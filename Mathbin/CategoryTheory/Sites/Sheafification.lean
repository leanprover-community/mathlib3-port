/-
Copyright (c) 2021 Adam Topaz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz

! This file was ported from Lean 3 source module category_theory.sites.sheafification
! leanprover-community/mathlib commit 4f4a1c875d0baa92ab5d92f3fb1bb258ad9f3e5b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Adjunction.FullyFaithful
import Mathbin.CategoryTheory.Sites.Plus
import Mathbin.CategoryTheory.Limits.ConcreteCategory
import Mathbin.CategoryTheory.ConcreteCategory.Elementwise

/-!

# Sheafification

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We construct the sheafification of a presheaf over a site `C` with values in `D` whenever
`D` is a concrete category for which the forgetful functor preserves the appropriate (co)limits
and reflects isomorphisms.

We generally follow the approach of https://stacks.math.columbia.edu/tag/00W1

-/


namespace CategoryTheory

open CategoryTheory.Limits Opposite

universe w v u

variable {C : Type u} [Category.{v} C] {J : GrothendieckTopology C}

variable {D : Type w} [Category.{max v u} D]

section

variable [ConcreteCategory.{max v u} D]

attribute [local instance] concrete_category.has_coe_to_sort concrete_category.has_coe_to_fun

#print CategoryTheory.Meq /-
/-- A concrete version of the multiequalizer, to be used below. -/
@[nolint has_nonempty_instance]
def Meq {X : C} (P : Cᵒᵖ ⥤ D) (S : J.cover X) :=
  { x : ∀ I : S.arrow, P.obj (op I.y) //
    ∀ I : S.Relation, P.map I.g₁.op (x I.fst) = P.map I.g₂.op (x I.snd) }
#align category_theory.meq CategoryTheory.Meq
-/

end

namespace Meq

variable [ConcreteCategory.{max v u} D]

attribute [local instance] concrete_category.has_coe_to_sort concrete_category.has_coe_to_fun

instance {X} (P : Cᵒᵖ ⥤ D) (S : J.cover X) :
    CoeFun (Meq P S) fun x => ∀ I : S.arrow, P.obj (op I.y) :=
  ⟨fun x => x.1⟩

/- warning: category_theory.meq.ext -> CategoryTheory.Meq.ext is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (y : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) x I) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) y I)) -> (Eq.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) x y)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (y : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J S I)))) x I) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J S I)))) y I)) -> (Eq.{max (succ u3) (succ u2)} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) x y)
Case conversion may be inaccurate. Consider using '#align category_theory.meq.ext CategoryTheory.Meq.extₓ'. -/
@[ext]
theorem ext {X} {P : Cᵒᵖ ⥤ D} {S : J.cover X} (x y : Meq P S) (h : ∀ I : S.arrow, x I = y I) :
    x = y :=
  Subtype.ext <| funext <| h
#align category_theory.meq.ext CategoryTheory.Meq.ext

/- warning: category_theory.meq.condition -> CategoryTheory.Meq.condition is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I)))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.y₁.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.y₁.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.y₁.{u2, u3} C _inst_1 X J S I)))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.y₁.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) x (CategoryTheory.Limits.MulticospanIndex.fstTo.{max u3 u2, max u2 u3, u1} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) I))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.y₂.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.y₂.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.y₂.{u2, u3} C _inst_1 X J S I)))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.y₂.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) x (CategoryTheory.Limits.MulticospanIndex.sndTo.{max u3 u2, max u2 u3, u1} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) I)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J S I)))) x (CategoryTheory.Limits.MulticospanIndex.fstTo.{max u3 u2, max u3 u2, u1} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J S I)))) x (CategoryTheory.Limits.MulticospanIndex.sndTo.{max u3 u2, max u3 u2, u1} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) I)))
Case conversion may be inaccurate. Consider using '#align category_theory.meq.condition CategoryTheory.Meq.conditionₓ'. -/
theorem condition {X} {P : Cᵒᵖ ⥤ D} {S : J.cover X} (x : Meq P S) (I : S.Relation) :
    P.map I.g₁.op (x ((S.index P).fstTo I)) = P.map I.g₂.op (x ((S.index P).sndTo I)) :=
  x.2 _
#align category_theory.meq.condition CategoryTheory.Meq.condition

/- warning: category_theory.meq.refine -> CategoryTheory.Meq.refine is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} {T : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X}, (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T) -> (Quiver.Hom.{succ (max u3 u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)))) S T) -> (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} {T : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X}, (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T) -> (Quiver.Hom.{max (succ u3) (succ u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) S T) -> (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S)
Case conversion may be inaccurate. Consider using '#align category_theory.meq.refine CategoryTheory.Meq.refineₓ'. -/
/-- Refine a term of `meq P T` with respect to a refinement `S ⟶ T` of covers. -/
def refine {X : C} {P : Cᵒᵖ ⥤ D} {S T : J.cover X} (x : Meq P T) (e : S ⟶ T) : Meq P S :=
  ⟨fun I => x ⟨I.y, I.f, (leOfHom e) _ I.hf⟩, fun I =>
    x.condition
      ⟨I.y₁, I.y₂, I.z, I.g₁, I.g₂, I.f₁, I.f₂, (leOfHom e) _ I.h₁, (leOfHom e) _ I.h₂, I.w⟩⟩
#align category_theory.meq.refine CategoryTheory.Meq.refine

/- warning: category_theory.meq.refine_apply -> CategoryTheory.Meq.refine_apply is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} {T : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T) (e : Quiver.Hom.{succ (max u3 u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)))) S T) (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (CategoryTheory.Meq.refine.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S T x e) I) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J T), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J T I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T) x (CategoryTheory.GrothendieckTopology.Cover.Arrow.mk.{u2, u3} C _inst_1 X J T (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I) (CategoryTheory.leOfHom.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X) S T e (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Arrow.hf.{u2, u3} C _inst_1 X J S I))))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} {T : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T) (e : Quiver.Hom.{max (succ u3) (succ u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) S T) (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.refine.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S T x e) I) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J T), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J T I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J T), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J T I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J T), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J T I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J T I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J T I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J T I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J T I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J T I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J T I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J T I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J T I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J T I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J T I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J T I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J T I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J T I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J T I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J T I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J T I)))) x (CategoryTheory.GrothendieckTopology.Cover.Arrow.mk.{u2, u3} C _inst_1 X J T (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I) (CategoryTheory.leOfHom.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X) S T e (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Arrow.hf.{u2, u3} C _inst_1 X J S I))))
Case conversion may be inaccurate. Consider using '#align category_theory.meq.refine_apply CategoryTheory.Meq.refine_applyₓ'. -/
@[simp]
theorem refine_apply {X : C} {P : Cᵒᵖ ⥤ D} {S T : J.cover X} (x : Meq P T) (e : S ⟶ T)
    (I : S.arrow) : x.refine e I = x ⟨I.y, I.f, (leOfHom e) _ I.hf⟩ :=
  rfl
#align category_theory.meq.refine_apply CategoryTheory.Meq.refine_apply

/- warning: category_theory.meq.pullback -> CategoryTheory.Meq.pullback is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] {Y : C} {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X}, (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) -> (forall (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X), CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y P (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] {Y : C} {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X}, (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) -> (forall (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X), CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y P (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S))
Case conversion may be inaccurate. Consider using '#align category_theory.meq.pullback CategoryTheory.Meq.pullbackₓ'. -/
/-- Pull back a term of `meq P S` with respect to a morphism `f : Y ⟶ X` in `C`. -/
def pullback {Y X : C} {P : Cᵒᵖ ⥤ D} {S : J.cover X} (x : Meq P S) (f : Y ⟶ X) :
    Meq P ((J.pullback f).obj S) :=
  ⟨fun I => x ⟨_, I.f ≫ f, I.hf⟩, fun I =>
    x.condition
      ⟨I.y₁, I.y₂, I.z, I.g₁, I.g₂, I.f₁ ≫ f, I.f₂ ≫ f, I.h₁, I.h₂, by simp [reassoc_of I.w]⟩⟩
#align category_theory.meq.pullback CategoryTheory.Meq.pullback

/- warning: category_theory.meq.pullback_apply -> CategoryTheory.Meq.pullback_apply is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] {Y : C} {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X) (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 Y J (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S)), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 Y J (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S) I)))) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y P (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S)) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y P (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S)) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 Y J (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S)), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 Y J (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S) I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y P (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S)) (CategoryTheory.Meq.pullback.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y X P S x f) I) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) x (CategoryTheory.GrothendieckTopology.Cover.Arrow.mk.{u2, u3} C _inst_1 X J S (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 Y J (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S) I) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 Y J (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S) I) Y X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 Y J (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S) I) f) (CategoryTheory.GrothendieckTopology.Cover.Arrow.hf.{u2, u3} C _inst_1 Y J (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S) I)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] {Y : C} {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X) (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S)), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I)))) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S)), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S)), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S)), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I)))) (CategoryTheory.Meq.pullback.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y X P S x f) I) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J S I)))) x (CategoryTheory.GrothendieckTopology.Cover.Arrow.mk.{u2, u3} C _inst_1 X J S (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I) Y X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I) f) (CategoryTheory.GrothendieckTopology.Cover.Arrow.hf.{u2, u3} C _inst_1 Y J (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) I)))
Case conversion may be inaccurate. Consider using '#align category_theory.meq.pullback_apply CategoryTheory.Meq.pullback_applyₓ'. -/
@[simp]
theorem pullback_apply {Y X : C} {P : Cᵒᵖ ⥤ D} {S : J.cover X} (x : Meq P S) (f : Y ⟶ X)
    (I : ((J.pullback f).obj S).arrow) : x.pullback f I = x ⟨_, I.f ≫ f, I.hf⟩ :=
  rfl
#align category_theory.meq.pullback_apply CategoryTheory.Meq.pullback_apply

/- warning: category_theory.meq.pullback_refine -> CategoryTheory.Meq.pullback_refine is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] {Y : C} {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} {T : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (h : Quiver.Hom.{succ (max u3 u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)))) S T) (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X) (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T), Eq.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y P (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S)) (CategoryTheory.Meq.refine.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y P (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S) (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) T) (CategoryTheory.Meq.pullback.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y X P T x f) (CategoryTheory.Functor.map.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S T h)) (CategoryTheory.Meq.pullback.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y X P S (CategoryTheory.Meq.refine.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S T x h) f)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] {Y : C} {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} {T : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (h : Quiver.Hom.{max (succ u3) (succ u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) S T) (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X) (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T), Eq.{max (succ u3) (succ u2)} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y P (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S)) (CategoryTheory.Meq.refine.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y P (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) T) (CategoryTheory.Meq.pullback.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y X P T x f) (Prefunctor.map.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S T h)) (CategoryTheory.Meq.pullback.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y X P S (CategoryTheory.Meq.refine.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S T x h) f)
Case conversion may be inaccurate. Consider using '#align category_theory.meq.pullback_refine CategoryTheory.Meq.pullback_refineₓ'. -/
@[simp]
theorem pullback_refine {Y X : C} {P : Cᵒᵖ ⥤ D} {S T : J.cover X} (h : S ⟶ T) (f : Y ⟶ X)
    (x : Meq P T) : (x.pullback f).refine ((J.pullback f).map h) = (refine x h).pullback _ :=
  rfl
#align category_theory.meq.pullback_refine CategoryTheory.Meq.pullback_refine

/- warning: category_theory.meq.mk -> CategoryTheory.Meq.mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) -> (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S)
Case conversion may be inaccurate. Consider using '#align category_theory.meq.mk CategoryTheory.Meq.mkₓ'. -/
/-- Make a term of `meq P S`. -/
def mk {X : C} {P : Cᵒᵖ ⥤ D} (S : J.cover X) (x : P.obj (op X)) : Meq P S :=
  ⟨fun I => P.map I.f.op x, fun I => by
    dsimp
    simp only [← comp_apply, ← P.map_comp, ← op_comp, I.w]⟩
#align category_theory.meq.mk CategoryTheory.Meq.mk

/- warning: category_theory.meq.mk_apply -> CategoryTheory.Meq.mk_apply is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (CategoryTheory.Meq.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S x) I) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S x) I) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x)
Case conversion may be inaccurate. Consider using '#align category_theory.meq.mk_apply CategoryTheory.Meq.mk_applyₓ'. -/
theorem mk_apply {X : C} {P : Cᵒᵖ ⥤ D} (S : J.cover X) (x : P.obj (op X)) (I : S.arrow) :
    mk S x I = P.map I.f.op x :=
  rfl
#align category_theory.meq.mk_apply CategoryTheory.Meq.mk_apply

variable [PreservesLimits (forget D)]

#print CategoryTheory.Meq.equiv /-
/-- The equivalence between the type associated to `multiequalizer (S.index P)` and `meq P S`. -/
noncomputable def equiv {X : C} (P : Cᵒᵖ ⥤ D) (S : J.cover X) [HasMultiequalizer (S.index P)] :
    (multiequalizer (S.index P) : D) ≃ Meq P S :=
  Limits.Concrete.multiequalizerEquiv _
#align category_theory.meq.equiv CategoryTheory.Meq.equiv
-/

/- warning: category_theory.meq.equiv_apply -> CategoryTheory.Meq.equiv_apply is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} [_inst_5 : CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] (x : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Limits.multiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (coeFn.{max 1 (max (succ (max u2 u3)) 1 (max (succ u3) (succ u2)) (succ (max u2 u3))) (max 1 (max (succ u3) (succ u2)) (succ (max u2 u3))) (succ (max u2 u3)), max (succ (max u2 u3)) 1 (max (succ u3) (succ u2)) (succ (max u2 u3))} (Equiv.{succ (max u2 u3), max 1 (max (succ u3) (succ u2)) (succ (max u2 u3))} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Limits.multiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S)) (fun (_x : Equiv.{succ (max u2 u3), max 1 (max (succ u3) (succ u2)) (succ (max u2 u3))} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Limits.multiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S)) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Limits.multiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) -> (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S)) (Equiv.hasCoeToFun.{succ (max u2 u3), max 1 (max (succ u3) (succ u2)) (succ (max u2 u3))} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Limits.multiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S)) (CategoryTheory.Meq.equiv.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 X P S _inst_5) x) I) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Limits.multiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5) (CategoryTheory.Limits.MulticospanIndex.left.{max u3 u2, max u2 u3, u1} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) I)) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Limits.multiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5) (CategoryTheory.Limits.MulticospanIndex.left.{max u3 u2, max u2 u3, u1} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) I)) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Limits.multiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Limits.MulticospanIndex.left.{max u3 u2, max u2 u3, u1} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) I))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Limits.multiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5) (CategoryTheory.Limits.MulticospanIndex.left.{max u3 u2, max u2 u3, u1} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) I)) (CategoryTheory.Limits.Multiequalizer.ι.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5 I) x)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} [_inst_5 : CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] (x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (CategoryTheory.Limits.multiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J S I)))) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (succ u3) (succ u2)} (Equiv.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (CategoryTheory.Limits.multiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S)) (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (CategoryTheory.Limits.multiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) (fun (_x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (CategoryTheory.Limits.multiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (CategoryTheory.Limits.multiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) => CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (CategoryTheory.Limits.multiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5)) (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S)) (CategoryTheory.Meq.equiv.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 X P S _inst_5) x) I) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (CategoryTheory.Limits.multiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5) (CategoryTheory.Limits.MulticospanIndex.left.{max u3 u2, max u3 u2, u1} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) I) (CategoryTheory.Limits.Multiequalizer.ι.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P) _inst_5 I) x)
Case conversion may be inaccurate. Consider using '#align category_theory.meq.equiv_apply CategoryTheory.Meq.equiv_applyₓ'. -/
@[simp]
theorem equiv_apply {X : C} {P : Cᵒᵖ ⥤ D} {S : J.cover X} [HasMultiequalizer (S.index P)]
    (x : multiequalizer (S.index P)) (I : S.arrow) :
    equiv P S x I = Multiequalizer.ι (S.index P) I x :=
  rfl
#align category_theory.meq.equiv_apply CategoryTheory.Meq.equiv_apply

#print CategoryTheory.Meq.equiv_symm_eq_apply /-
@[simp]
theorem equiv_symm_eq_apply {X : C} {P : Cᵒᵖ ⥤ D} {S : J.cover X} [HasMultiequalizer (S.index P)]
    (x : Meq P S) (I : S.arrow) : Multiequalizer.ι (S.index P) I ((Meq.equiv P S).symm x) = x I :=
  by
  let z := (meq.equiv P S).symm x
  rw [← equiv_apply]
  simp
#align category_theory.meq.equiv_symm_eq_apply CategoryTheory.Meq.equiv_symm_eq_apply
-/

end Meq

namespace GrothendieckTopology

namespace Plus

variable [ConcreteCategory.{max v u} D]

attribute [local instance] concrete_category.has_coe_to_sort concrete_category.has_coe_to_fun

variable [PreservesLimits (forget D)]

variable [∀ X : C, HasColimitsOfShape (J.cover X)ᵒᵖ D]

variable [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), HasMultiequalizer (S.index P)]

noncomputable section

/- warning: category_theory.grothendieck_topology.plus.mk -> CategoryTheory.GrothendieckTopology.Plus.mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X}, (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_6) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_5)) (Opposite.op.{succ u3} C X)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X}, (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) -> (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.mk CategoryTheory.GrothendieckTopology.Plus.mkₓ'. -/
/-- Make a term of `(J.plus_obj P).obj (op X)` from `x : meq P S`. -/
def mk {X : C} {P : Cᵒᵖ ⥤ D} {S : J.cover X} (x : Meq P S) : (J.plusObj P).obj (op X) :=
  colimit.ι (J.diagram P X) (op S) ((Meq.equiv P S).symm x)
#align category_theory.grothendieck_topology.plus.mk CategoryTheory.GrothendieckTopology.Plus.mk

/- warning: category_theory.grothendieck_topology.plus.res_mk_eq_mk_pullback -> CategoryTheory.GrothendieckTopology.Plus.res_mk_eq_mk_pullback is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {Y : C} {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C Y))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C Y))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C Y))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C Y)))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C Y))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C Y) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X f)) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P S x)) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) Y P (CategoryTheory.Functor.obj.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f) S) (CategoryTheory.Meq.pullback.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y X P S x f))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {Y : C} {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C Y))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C Y)) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C Y) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X f)) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P S x)) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) Y P (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J Y) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J Y)) (CategoryTheory.GrothendieckTopology.pullback.{u2, u3} C _inst_1 X Y J f)) S) (CategoryTheory.Meq.pullback.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 Y X P S x f))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.res_mk_eq_mk_pullback CategoryTheory.GrothendieckTopology.Plus.res_mk_eq_mk_pullbackₓ'. -/
theorem res_mk_eq_mk_pullback {Y X : C} {P : Cᵒᵖ ⥤ D} {S : J.cover X} (x : Meq P S) (f : Y ⟶ X) :
    (J.plusObj P).map f.op (mk x) = mk (x.pullback f) :=
  by
  dsimp [mk, plus_obj]
  simp only [← comp_apply, colimit.ι_pre, ι_colim_map_assoc]
  simp_rw [comp_apply]
  congr 1
  apply_fun meq.equiv P _
  erw [Equiv.apply_symm_apply]
  ext i
  simp only [diagram_pullback_app, meq.pullback_apply, meq.equiv_apply, ← comp_apply]
  erw [multiequalizer.lift_ι, meq.equiv_symm_eq_apply]
  cases i; rfl
#align category_theory.grothendieck_topology.plus.res_mk_eq_mk_pullback CategoryTheory.GrothendieckTopology.Plus.res_mk_eq_mk_pullback

/- warning: category_theory.grothendieck_topology.plus.to_plus_mk -> CategoryTheory.GrothendieckTopology.Plus.toPlus_mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (CategoryTheory.NatTrans.app.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (CategoryTheory.GrothendieckTopology.toPlus.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X)) x) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P S (CategoryTheory.Meq.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S x))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (CategoryTheory.NatTrans.app.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (CategoryTheory.GrothendieckTopology.toPlus.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X)) x) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P S (CategoryTheory.Meq.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S x))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.to_plus_mk CategoryTheory.GrothendieckTopology.Plus.toPlus_mkₓ'. -/
theorem toPlus_mk {X : C} {P : Cᵒᵖ ⥤ D} (S : J.cover X) (x : P.obj (op X)) :
    (J.toPlus P).app _ x = mk (Meq.mk S x) :=
  by
  dsimp [mk, to_plus]
  let e : S ⟶ ⊤ := hom_of_le (OrderTop.le_top _)
  rw [← colimit.w _ e.op]
  delta cover.to_multiequalizer
  simp only [comp_apply]
  congr 1
  dsimp [diagram]
  apply concrete.multiequalizer_ext
  intro i
  simpa only [← comp_apply, category.assoc, multiequalizer.lift_ι, category.comp_id,
    meq.equiv_symm_eq_apply]
#align category_theory.grothendieck_topology.plus.to_plus_mk CategoryTheory.GrothendieckTopology.Plus.toPlus_mk

/- warning: category_theory.grothendieck_topology.plus.to_plus_apply -> CategoryTheory.GrothendieckTopology.Plus.toPlus_apply is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.NatTrans.app.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (CategoryTheory.GrothendieckTopology.toPlus.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) x I)) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P S x))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.NatTrans.app.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (CategoryTheory.GrothendieckTopology.toPlus.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J S I)))) x I)) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P S x))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.to_plus_apply CategoryTheory.GrothendieckTopology.Plus.toPlus_applyₓ'. -/
theorem toPlus_apply {X : C} {P : Cᵒᵖ ⥤ D} (S : J.cover X) (x : Meq P S) (I : S.arrow) :
    (J.toPlus P).app _ (x I) = (J.plusObj P).map I.f.op (mk x) :=
  by
  dsimp only [to_plus, plus_obj]
  delta cover.to_multiequalizer
  dsimp [mk]
  simp only [← comp_apply, colimit.ι_pre, ι_colim_map_assoc]
  simp only [comp_apply]
  dsimp only [functor.op]
  let e : (J.pullback I.f).obj (unop (op S)) ⟶ ⊤ := hom_of_le (OrderTop.le_top _)
  rw [← colimit.w _ e.op]
  simp only [comp_apply]
  congr 1
  apply concrete.multiequalizer_ext
  intro i
  dsimp [diagram]
  simp only [← comp_apply, category.assoc, multiequalizer.lift_ι, category.comp_id,
    meq.equiv_symm_eq_apply]
  let RR : S.relation :=
    ⟨_, _, _, i.f, 𝟙 _, I.f, i.f ≫ I.f, I.hf, sieve.downward_closed _ I.hf _, by simp⟩
  cases I
  erw [x.condition RR]
  simpa [RR]
#align category_theory.grothendieck_topology.plus.to_plus_apply CategoryTheory.GrothendieckTopology.Plus.toPlus_apply

/- warning: category_theory.grothendieck_topology.plus.to_plus_eq_mk -> CategoryTheory.GrothendieckTopology.Plus.toPlus_eq_mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (x : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (CategoryTheory.NatTrans.app.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (CategoryTheory.GrothendieckTopology.toPlus.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X)) x) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P (Top.top.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (OrderTop.toHasTop.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.toHasLe.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.orderTop.{u2, u3} C _inst_1 X J))) (CategoryTheory.Meq.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P (Top.top.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (OrderTop.toHasTop.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.toHasLe.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.orderTop.{u2, u3} C _inst_1 X J))) x))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (CategoryTheory.NatTrans.app.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (CategoryTheory.GrothendieckTopology.toPlus.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X)) x) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P (Top.top.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (OrderTop.toTop.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.toLE.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.instOrderTopCoverToLEInstPreorderCover.{u2, u3} C _inst_1 X J))) (CategoryTheory.Meq.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P (Top.top.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (OrderTop.toTop.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.toLE.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)) (CategoryTheory.GrothendieckTopology.Cover.instOrderTopCoverToLEInstPreorderCover.{u2, u3} C _inst_1 X J))) x))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.to_plus_eq_mk CategoryTheory.GrothendieckTopology.Plus.toPlus_eq_mkₓ'. -/
theorem toPlus_eq_mk {X : C} {P : Cᵒᵖ ⥤ D} (x : P.obj (op X)) :
    (J.toPlus P).app _ x = mk (Meq.mk ⊤ x) :=
  by
  dsimp [mk, to_plus]
  delta cover.to_multiequalizer
  simp only [comp_apply]
  congr 1
  apply_fun meq.equiv P ⊤
  ext i
  simpa
#align category_theory.grothendieck_topology.plus.to_plus_eq_mk CategoryTheory.GrothendieckTopology.Plus.toPlus_eq_mk

variable [∀ X : C, PreservesColimitsOfShape (J.cover X)ᵒᵖ (forget D)]

/- warning: category_theory.grothendieck_topology.plus.exists_rep -> CategoryTheory.GrothendieckTopology.Plus.exists_rep is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (x : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))), Exists.{max 1 (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (fun (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => Exists.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (y : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))) x (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P S y)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))), Exists.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (fun (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => Exists.{max (succ u3) (succ u2)} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (fun (y : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) => Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) x (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P S y)))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.exists_rep CategoryTheory.GrothendieckTopology.Plus.exists_repₓ'. -/
theorem exists_rep {X : C} {P : Cᵒᵖ ⥤ D} (x : (J.plusObj P).obj (op X)) :
    ∃ (S : J.cover X)(y : Meq P S), x = mk y :=
  by
  obtain ⟨S, y, h⟩ := concrete.colimit_exists_rep (J.diagram P X) x
  use S.unop, meq.equiv _ _ y
  rw [← h]
  dsimp [mk]
  simp
#align category_theory.grothendieck_topology.plus.exists_rep CategoryTheory.GrothendieckTopology.Plus.exists_rep

/- warning: category_theory.grothendieck_topology.plus.eq_mk_iff_exists -> CategoryTheory.GrothendieckTopology.Plus.eq_mk_iff_exists is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] {X : C} {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} {T : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (y : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T), Iff (Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.mk._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.Plus.mk._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P S x) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P T y)) (Exists.{max 1 (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (fun (W : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => Exists.{succ (max u3 u2)} (Quiver.Hom.{succ (max u3 u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)))) W S) (fun (h1 : Quiver.Hom.{succ (max u3 u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)))) W S) => Exists.{succ (max u3 u2)} (Quiver.Hom.{succ (max u3 u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)))) W T) (fun (h2 : Quiver.Hom.{succ (max u3 u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X)))) W T) => Eq.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P W) (CategoryTheory.Meq.refine.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P W S x h1) (CategoryTheory.Meq.refine.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P W T y h2)))))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] {X : C} {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} {T : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X} (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P S) (y : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P T), Iff (Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P S x) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) X P T y)) (Exists.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (fun (W : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => Exists.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) W S) (fun (h1 : Quiver.Hom.{max (succ u3) (succ u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) W S) => Exists.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) W T) (fun (h2 : Quiver.Hom.{max (succ u3) (succ u2), max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X)))) W T) => Eq.{max (succ u3) (succ u2)} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P W) (CategoryTheory.Meq.refine.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P W S x h1) (CategoryTheory.Meq.refine.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P W T y h2)))))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.eq_mk_iff_exists CategoryTheory.GrothendieckTopology.Plus.eq_mk_iff_existsₓ'. -/
theorem eq_mk_iff_exists {X : C} {P : Cᵒᵖ ⥤ D} {S T : J.cover X} (x : Meq P S) (y : Meq P T) :
    mk x = mk y ↔ ∃ (W : J.cover X)(h1 : W ⟶ S)(h2 : W ⟶ T), x.refine h1 = y.refine h2 :=
  by
  constructor
  · intro h
    obtain ⟨W, h1, h2, hh⟩ := concrete.colimit_exists_of_rep_eq _ _ _ h
    use W.unop, h1.unop, h2.unop
    ext I
    apply_fun multiequalizer.ι (W.unop.index P) I  at hh
    convert hh
    all_goals
      dsimp [diagram]
      simp only [← comp_apply, multiequalizer.lift_ι, category.comp_id, meq.equiv_symm_eq_apply]
      cases I; rfl
  · rintro ⟨S, h1, h2, e⟩
    apply concrete.colimit_rep_eq_of_exists
    use op S, h1.op, h2.op
    apply concrete.multiequalizer_ext
    intro i
    apply_fun fun ee => ee i  at e
    convert e
    all_goals
      dsimp [diagram]
      simp only [← comp_apply, multiequalizer.lift_ι, meq.equiv_symm_eq_apply]
      cases i; rfl
#align category_theory.grothendieck_topology.plus.eq_mk_iff_exists CategoryTheory.GrothendieckTopology.Plus.eq_mk_iff_exists

/- warning: category_theory.grothendieck_topology.plus.sep -> CategoryTheory.GrothendieckTopology.Plus.sep is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] {X : C} (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))) (y : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) y)) -> (Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))) x y)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] {X : C} (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (y : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) y)) -> (Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) x y)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.sep CategoryTheory.GrothendieckTopology.Plus.sepₓ'. -/
/-- `P⁺` is always separated. -/
theorem sep {X : C} (P : Cᵒᵖ ⥤ D) (S : J.cover X) (x y : (J.plusObj P).obj (op X))
    (h : ∀ I : S.arrow, (J.plusObj P).map I.f.op x = (J.plusObj P).map I.f.op y) : x = y :=
  by
  -- First, we choose representatives for x and y.
  obtain ⟨Sx, x, rfl⟩ := exists_rep x
  obtain ⟨Sy, y, rfl⟩ := exists_rep y
  simp only [res_mk_eq_mk_pullback] at h
  -- Next, using our assumption,
  -- choose covers over which the pullbacks of these representatives become equal.
  choose W h1 h2 hh using fun I : S.arrow => (eq_mk_iff_exists _ _).mp (h I)
  -- To prove equality, it suffices to prove that there exists a cover over which
  -- the representatives become equal.
  rw [eq_mk_iff_exists]
  -- Construct the cover over which the representatives become equal by combining the various
  -- covers chosen above.
  let B : J.cover X := S.bind W
  use B
  -- Prove that this cover refines the two covers over which our representatives are defined
  -- and use these proofs.
  let ex : B ⟶ Sx :=
    hom_of_le
      (by
        rintro Y f ⟨Z, e1, e2, he2, he1, hee⟩
        rw [← hee]
        apply le_of_hom (h1 ⟨_, _, he2⟩)
        exact he1)
  let ey : B ⟶ Sy :=
    hom_of_le
      (by
        rintro Y f ⟨Z, e1, e2, he2, he1, hee⟩
        rw [← hee]
        apply le_of_hom (h2 ⟨_, _, he2⟩)
        exact he1)
  use ex, ey
  -- Now prove that indeed the representatives become equal over `B`.
  -- This will follow by using the fact that our representatives become
  -- equal over the chosen covers.
  ext1 I
  let IS : S.arrow := I.from_middle
  specialize hh IS
  let IW : (W IS).arrow := I.to_middle
  apply_fun fun e => e IW  at hh
  convert hh
  · let Rx : Sx.relation :=
      ⟨I.Y, I.Y, I.Y, 𝟙 _, 𝟙 _, I.f, I.to_middle_hom ≫ I.from_middle_hom, _, _, by
        simp [I.middle_spec]⟩
    have := x.condition Rx
    simpa using this
  · let Ry : Sy.relation :=
      ⟨I.Y, I.Y, I.Y, 𝟙 _, 𝟙 _, I.f, I.to_middle_hom ≫ I.from_middle_hom, _, _, by
        simp [I.middle_spec]⟩
    have := y.condition Ry
    simpa using this
#align category_theory.grothendieck_topology.plus.sep CategoryTheory.GrothendieckTopology.Plus.sep

/- warning: category_theory.grothendieck_topology.plus.inj_of_sep -> CategoryTheory.GrothendieckTopology.Plus.inj_of_sep is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) (y : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) y)) -> (Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) x y)) -> (forall (X : C), Function.Injective.{succ (max u2 u3), succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (CategoryTheory.NatTrans.app.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toPlus._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S)) P (CategoryTheory.GrothendieckTopology.toPlus._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_5 X))) (CategoryTheory.GrothendieckTopology.toPlus.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) (y : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) y)) -> (Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) x y)) -> (forall (X : C), Function.Injective.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, succ (max u3 u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X)) (CategoryTheory.NatTrans.app.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (CategoryTheory.GrothendieckTopology.toPlus.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.inj_of_sep CategoryTheory.GrothendieckTopology.Plus.inj_of_sepₓ'. -/
theorem inj_of_sep (P : Cᵒᵖ ⥤ D)
    (hsep :
      ∀ (X : C) (S : J.cover X) (x y : P.obj (op X)),
        (∀ I : S.arrow, P.map I.f.op x = P.map I.f.op y) → x = y)
    (X : C) : Function.Injective ((J.toPlus P).app (op X)) :=
  by
  intro x y h
  simp only [to_plus_eq_mk] at h
  rw [eq_mk_iff_exists] at h
  obtain ⟨W, h1, h2, hh⟩ := h
  apply hsep X W
  intro I
  apply_fun fun e => e I  at hh
  exact hh
#align category_theory.grothendieck_topology.plus.inj_of_sep CategoryTheory.GrothendieckTopology.Plus.inj_of_sep

/- warning: category_theory.grothendieck_topology.plus.meq_of_sep -> CategoryTheory.GrothendieckTopology.Plus.meqOfSep is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) (y : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) y)) -> (Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) x y)) -> (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (s : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_6) P (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_5)) S) (T : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (t : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) P (T I)), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_6) P (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_5)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3)), max (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_6) P (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_5)) S) (fun (x : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_6) P (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_5)) S) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_6) P (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_5)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Meq.hasCoeToFun.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_6) P (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_5)) S) s I) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_3.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_5) (CategoryTheory.GrothendieckTopology.Plus.meqOfSep._proof_4.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_6) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) P (T I) (t I))) -> (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P (CategoryTheory.GrothendieckTopology.Cover.bind.{u2, u3} C _inst_1 J X S T)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) (y : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) y)) -> (Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) x y)) -> (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (s : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) S) (T : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (t : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) P (T I)), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Subtype.val.{max (succ u3) (succ u2)} (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (fun (x : forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) => forall (I : CategoryTheory.GrothendieckTopology.Cover.Relation.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₁.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₁.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.fst.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I))) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I)) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Relation.Z.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.Y₂.{u2, u3} C _inst_1 X J S I) (CategoryTheory.GrothendieckTopology.Cover.Relation.g₂.{u2, u3} C _inst_1 X J S I))) (x (CategoryTheory.GrothendieckTopology.Cover.Relation.snd.{u2, u3} C _inst_1 X J S I)))) s I) (CategoryTheory.GrothendieckTopology.Plus.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (X : C) => _inst_5 X) (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) P (T I) (t I))) -> (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X P (CategoryTheory.GrothendieckTopology.Cover.bind.{u2, u3} C _inst_1 J X S T)))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.meq_of_sep CategoryTheory.GrothendieckTopology.Plus.meqOfSepₓ'. -/
/-- An auxiliary definition to be used in the proof of `exists_of_sep` below.
  Given a compatible family of local sections for `P⁺`, and representatives of said sections,
  construct a compatible family of local sections of `P` over the combination of the covers
  associated to the representatives.
  The separatedness condition is used to prove compatibility among these local sections of `P`. -/
def meqOfSep (P : Cᵒᵖ ⥤ D)
    (hsep :
      ∀ (X : C) (S : J.cover X) (x y : P.obj (op X)),
        (∀ I : S.arrow, P.map I.f.op x = P.map I.f.op y) → x = y)
    (X : C) (S : J.cover X) (s : Meq (J.plusObj P) S) (T : ∀ I : S.arrow, J.cover I.y)
    (t : ∀ I : S.arrow, Meq P (T I)) (ht : ∀ I : S.arrow, s I = mk (t I)) : Meq P (S.bind T)
    where
  val I := t I.fromMiddle I.toMiddle
  property := by
    intro II
    apply inj_of_sep P hsep
    rw [← comp_apply, ← comp_apply, (J.to_plus P).naturality, (J.to_plus P).naturality, comp_apply,
      comp_apply]
    erw [to_plus_apply (T II.fst.from_middle) (t II.fst.from_middle) II.fst.to_middle,
      to_plus_apply (T II.snd.from_middle) (t II.snd.from_middle) II.snd.to_middle, ← ht, ← ht, ←
      comp_apply, ← comp_apply, ← (J.plus_obj P).map_comp, ← (J.plus_obj P).map_comp]
    rw [← op_comp, ← op_comp]
    let IR : S.relation :=
      ⟨_, _, _, II.g₁ ≫ II.fst.to_middle_hom, II.g₂ ≫ II.snd.to_middle_hom, II.fst.from_middle_hom,
        II.snd.from_middle_hom, II.fst.from_middle_condition, II.snd.from_middle_condition, _⟩
    swap;
    · simp only [category.assoc, II.fst.middle_spec, II.snd.middle_spec]
      apply II.w
    exact s.condition IR
#align category_theory.grothendieck_topology.plus.meq_of_sep CategoryTheory.GrothendieckTopology.Plus.meqOfSep

/- warning: category_theory.grothendieck_topology.plus.exists_of_sep -> CategoryTheory.GrothendieckTopology.Plus.exists_of_sep is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) (y : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) y)) -> (Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) x y)) -> (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (s : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) S), Exists.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))) (fun (t : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (Opposite.op.{succ u3} C X))) => Eq.{max 1 (max (succ u3) (succ u2)) (succ (max u2 u3))} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) S) (CategoryTheory.Meq.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) S t) s))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) (y : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) y)) -> (Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) x y)) -> (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (s : CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) S), Exists.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) (fun (t : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X))) (Opposite.op.{succ u3} C X))) => Eq.{max (succ u3) (succ u2)} (CategoryTheory.Meq.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) S) (CategoryTheory.Meq.mk.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 X (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) S t) s))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.exists_of_sep CategoryTheory.GrothendieckTopology.Plus.exists_of_sepₓ'. -/
theorem exists_of_sep (P : Cᵒᵖ ⥤ D)
    (hsep :
      ∀ (X : C) (S : J.cover X) (x y : P.obj (op X)),
        (∀ I : S.arrow, P.map I.f.op x = P.map I.f.op y) → x = y)
    (X : C) (S : J.cover X) (s : Meq (J.plusObj P) S) :
    ∃ t : (J.plusObj P).obj (op X), Meq.mk S t = s :=
  by
  have inj : ∀ X : C, Function.Injective ((J.to_plus P).app (op X)) := inj_of_sep _ hsep
  -- Choose representatives for the given local sections.
  choose T t ht using fun I => exists_rep (s I)
  -- Construct a large cover over which we will define a representative that will
  -- provide the gluing of the given local sections.
  let B : J.cover X := S.bind T
  choose Z e1 e2 he2 he1 hee using fun I : B.arrow => I.hf
  -- Construct a compatible system of local sections over this large cover, using the chosen
  -- representatives of our local sections.
  -- The compatilibity here follows from the separatedness assumption.
  let w : meq P B := meq_of_sep P hsep X S s T t ht
  -- The associated gluing will be the candidate section.
  use mk w
  ext I
  erw [ht, res_mk_eq_mk_pullback]
  -- Use the separatedness of `P⁺` to prove that this is indeed a gluing of our
  -- original local sections.
  apply sep P (T I)
  intro II
  simp only [res_mk_eq_mk_pullback, eq_mk_iff_exists]
  -- It suffices to prove equality for representatives over a
  -- convenient sufficiently large cover...
  use (J.pullback II.f).obj (T I)
  let e0 : (J.pullback II.f).obj (T I) ⟶ (J.pullback II.f).obj ((J.pullback I.f).obj B) :=
    hom_of_le
      (by
        intro Y f hf
        apply sieve.le_pullback_bind _ _ _ I.hf
        · cases I
          exact hf)
  use e0, 𝟙 _
  ext IV
  dsimp only [meq.refine_apply, meq.pullback_apply, w]
  let IA : B.arrow := ⟨_, (IV.f ≫ II.f) ≫ I.f, _⟩
  swap
  · refine' ⟨I.Y, _, _, I.hf, _, rfl⟩
    apply sieve.downward_closed
    convert II.hf
    cases I
    rfl
  let IB : S.arrow := IA.from_middle
  let IC : (T IB).arrow := IA.to_middle
  let ID : (T I).arrow := ⟨IV.Y, IV.f ≫ II.f, sieve.downward_closed (T I) II.hf IV.f⟩
  change t IB IC = t I ID
  apply inj IV.Y
  erw [to_plus_apply (T I) (t I) ID, to_plus_apply (T IB) (t IB) IC, ← ht, ← ht]
  -- Conclude by constructing the relation showing equality...
  let IR : S.relation := ⟨_, _, IV.Y, IC.f, ID.f, IB.f, I.f, _, I.hf, IA.middle_spec⟩
  convert s.condition IR
  cases I; rfl
#align category_theory.grothendieck_topology.plus.exists_of_sep CategoryTheory.GrothendieckTopology.Plus.exists_of_sep

variable [ReflectsIsomorphisms (forget D)]

/- warning: category_theory.grothendieck_topology.plus.is_sheaf_of_sep -> CategoryTheory.GrothendieckTopology.Plus.isSheaf_of_sep is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) (y : coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (fun (f : Quiver.Hom.{succ (max u2 u3), u1} D (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, u1} D (CategoryTheory.Category.toCategoryStruct.{max u2 u3, u1} D _inst_2)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) => (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) -> (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I))))) (CategoryTheory.ConcreteCategory.hasCoeToFun.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3 (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X)) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)))) (CategoryTheory.Functor.map.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) y)) -> (Eq.{succ (max u2 u3)} (coeSort.{succ u1, succ (succ (max u2 u3))} D Type.{max u2 u3} (CategoryTheory.ConcreteCategory.hasCoeToSort.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3) (CategoryTheory.Functor.obj.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P (Opposite.op.{succ u3} C X))) x y)) -> (CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), (forall (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (x : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) (y : Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))), (forall (I : CategoryTheory.GrothendieckTopology.Cover.Arrow.{u2, u3} C _inst_1 X J S), Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)))) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) x) (Prefunctor.map.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I))) (Prefunctor.map.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I)) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.GrothendieckTopology.Cover.Arrow.Y.{u2, u3} C _inst_1 X J S I) X (CategoryTheory.GrothendieckTopology.Cover.Arrow.f.{u2, u3} C _inst_1 X J S I))) y)) -> (Eq.{max (succ u3) (succ u2)} (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), u1, succ (max u3 u2)} D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) Type.{max u3 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} (CategoryTheory.Category.toCategoryStruct.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, u1, succ (max u3 u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)) (Prefunctor.obj.{succ u2, max (succ u3) (succ u2), u3, u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) D (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, u1} D (CategoryTheory.Category.toCategoryStruct.{max u3 u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 P) (Opposite.op.{succ u3} C X))) x y)) -> (CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.is_sheaf_of_sep CategoryTheory.GrothendieckTopology.Plus.isSheaf_of_sepₓ'. -/
/-- If `P` is separated, then `P⁺` is a sheaf. -/
theorem isSheaf_of_sep (P : Cᵒᵖ ⥤ D)
    (hsep :
      ∀ (X : C) (S : J.cover X) (x y : P.obj (op X)),
        (∀ I : S.arrow, P.map I.f.op x = P.map I.f.op y) → x = y) :
    Presheaf.IsSheaf J (J.plusObj P) :=
  by
  rw [presheaf.is_sheaf_iff_multiequalizer]
  intro X S
  apply is_iso_of_reflects_iso _ (forget D)
  rw [is_iso_iff_bijective]
  constructor
  · intro x y h
    apply sep P S _ _
    intro I
    apply_fun meq.equiv _ _  at h
    apply_fun fun e => e I  at h
    convert h
    · erw [meq.equiv_apply, ← comp_apply, multiequalizer.lift_ι]
    · erw [meq.equiv_apply, ← comp_apply, multiequalizer.lift_ι]
  · rintro (x : (multiequalizer (S.index _) : D))
    obtain ⟨t, ht⟩ := exists_of_sep P hsep X S (meq.equiv _ _ x)
    use t
    apply_fun meq.equiv _ _
    swap
    · infer_instance
    rw [← ht]
    ext i
    dsimp
    rw [← comp_apply, multiequalizer.lift_ι]
    rfl
#align category_theory.grothendieck_topology.plus.is_sheaf_of_sep CategoryTheory.GrothendieckTopology.Plus.isSheaf_of_sep

variable (J)

/- warning: category_theory.grothendieck_topology.plus.is_sheaf_plus_plus -> CategoryTheory.GrothendieckTopology.Plus.isSheaf_plus_plus is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (fun (X : C) => _inst_5 X))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_6 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) (CategoryTheory.GrothendieckTopology.plusObj.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_6 P X S) P (fun (X : C) => _inst_5 X)) (fun (X : C) => _inst_5 X))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.plus.is_sheaf_plus_plus CategoryTheory.GrothendieckTopology.Plus.isSheaf_plus_plusₓ'. -/
/-- `P⁺⁺` is always a sheaf. -/
theorem isSheaf_plus_plus (P : Cᵒᵖ ⥤ D) : Presheaf.IsSheaf J (J.plusObj (J.plusObj P)) :=
  by
  apply is_sheaf_of_sep
  intro X S x y
  apply sep
#align category_theory.grothendieck_topology.plus.is_sheaf_plus_plus CategoryTheory.GrothendieckTopology.Plus.isSheaf_plus_plus

end Plus

variable (J)

variable [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), HasMultiequalizer (S.index P)]
  [∀ X : C, HasColimitsOfShape (J.cover X)ᵒᵖ D]

/- warning: category_theory.grothendieck_topology.sheafify -> CategoryTheory.GrothendieckTopology.sheafify is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2], (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) -> (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2], (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) -> (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafify CategoryTheory.GrothendieckTopology.sheafifyₓ'. -/
/-- The sheafification of a presheaf `P`.
*NOTE:* Additional hypotheses are needed to obtain a proof that this is a sheaf! -/
def sheafify (P : Cᵒᵖ ⥤ D) : Cᵒᵖ ⥤ D :=
  J.plusObj (J.plusObj P)
#align category_theory.grothendieck_topology.sheafify CategoryTheory.GrothendieckTopology.sheafify

/- warning: category_theory.grothendieck_topology.to_sheafify -> CategoryTheory.GrothendieckTopology.toSheafify is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) (CategoryTheory.GrothendieckTopology.toSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_4) P)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.to_sheafify CategoryTheory.GrothendieckTopology.toSheafifyₓ'. -/
/-- The canonical map from `P` to its sheafification. -/
def toSheafify (P : Cᵒᵖ ⥤ D) : P ⟶ J.sheafify P :=
  J.toPlus P ≫ J.plusMap (J.toPlus P)
#align category_theory.grothendieck_topology.to_sheafify CategoryTheory.GrothendieckTopology.toSheafify

/- warning: category_theory.grothendieck_topology.sheafify_map -> CategoryTheory.GrothendieckTopology.sheafifyMap is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2}, (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) -> (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_4) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_3.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_4.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_4) Q))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2}, (Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) -> (Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafify_map CategoryTheory.GrothendieckTopology.sheafifyMapₓ'. -/
/-- The canonical map on sheafifications induced by a morphism. -/
def sheafifyMap {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) : J.sheafify P ⟶ J.sheafify Q :=
  J.plusMap <| J.plusMap η
#align category_theory.grothendieck_topology.sheafify_map CategoryTheory.GrothendieckTopology.sheafifyMap

/- warning: category_theory.grothendieck_topology.sheafify_map_id -> CategoryTheory.GrothendieckTopology.sheafifyMap_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_3.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_4.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P)) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P P (CategoryTheory.CategoryStruct.id.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P)) (CategoryTheory.CategoryStruct.id.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P)) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P P (CategoryTheory.CategoryStruct.id.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P)) (CategoryTheory.CategoryStruct.id.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafify_map_id CategoryTheory.GrothendieckTopology.sheafifyMap_idₓ'. -/
@[simp]
theorem sheafifyMap_id (P : Cᵒᵖ ⥤ D) : J.sheafifyMap (𝟙 P) = 𝟙 (J.sheafify P) :=
  by
  dsimp [sheafify_map, sheafify]
  simp
#align category_theory.grothendieck_topology.sheafify_map_id CategoryTheory.GrothendieckTopology.sheafifyMap_id

/- warning: category_theory.grothendieck_topology.sheafify_map_comp -> CategoryTheory.GrothendieckTopology.sheafifyMap_comp is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {R : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (γ : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) Q R), Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_3.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_4.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) R)) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P R (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P Q R η γ)) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_3.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_4.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) Q) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_3.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_4.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) R) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q R γ))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {R : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (γ : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) Q R), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) R)) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P R (CategoryTheory.CategoryStruct.comp.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P Q R η γ)) (CategoryTheory.CategoryStruct.comp.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) R) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q R γ))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafify_map_comp CategoryTheory.GrothendieckTopology.sheafifyMap_compₓ'. -/
@[simp]
theorem sheafifyMap_comp {P Q R : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (γ : Q ⟶ R) :
    J.sheafifyMap (η ≫ γ) = J.sheafifyMap η ≫ J.sheafifyMap γ :=
  by
  dsimp [sheafify_map, sheafify]
  simp
#align category_theory.grothendieck_topology.sheafify_map_comp CategoryTheory.GrothendieckTopology.sheafifyMap_comp

/- warning: category_theory.grothendieck_topology.to_sheafify_naturality -> CategoryTheory.GrothendieckTopology.toSheafify_naturality is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q), Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) Q)) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P Q (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) Q) η (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q)) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) Q) (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{succ (max u3 u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q)) (CategoryTheory.CategoryStruct.comp.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P Q (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q) η (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q)) (CategoryTheory.CategoryStruct.comp.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q) (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.to_sheafify_naturality CategoryTheory.GrothendieckTopology.toSheafify_naturalityₓ'. -/
@[simp, reassoc.1]
theorem toSheafify_naturality {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :
    η ≫ J.toSheafify _ = J.toSheafify _ ≫ J.sheafifyMap η :=
  by
  dsimp [sheafify_map, sheafify, to_sheafify]
  simp
#align category_theory.grothendieck_topology.to_sheafify_naturality CategoryTheory.GrothendieckTopology.toSheafify_naturality

variable (D)

/- warning: category_theory.grothendieck_topology.sheafification -> CategoryTheory.GrothendieckTopology.sheafification is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2], CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2], CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, max (max (max u1 u3) u3 u2) u2} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafification CategoryTheory.GrothendieckTopology.sheafificationₓ'. -/
/-- The sheafification of a presheaf `P`, as a functor.
*NOTE:* Additional hypotheses are needed to obtain a proof that this is a sheaf! -/
def sheafification : (Cᵒᵖ ⥤ D) ⥤ Cᵒᵖ ⥤ D :=
  J.plusFunctor D ⋙ J.plusFunctor D
#align category_theory.grothendieck_topology.sheafification CategoryTheory.GrothendieckTopology.sheafification

/- warning: category_theory.grothendieck_topology.sheafification_obj -> CategoryTheory.GrothendieckTopology.sheafification_obj is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), Eq.{succ (max u2 (max u2 u3) u3 u1)} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X))) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafification_obj CategoryTheory.GrothendieckTopology.sheafification_objₓ'. -/
@[simp]
theorem sheafification_obj (P : Cᵒᵖ ⥤ D) : (J.sheafification D).obj P = J.sheafify P :=
  rfl
#align category_theory.grothendieck_topology.sheafification_obj CategoryTheory.GrothendieckTopology.sheafification_obj

/- warning: category_theory.grothendieck_topology.sheafification_map -> CategoryTheory.GrothendieckTopology.sheafification_map is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q), Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) P) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) Q)) (CategoryTheory.Functor.map.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) P Q η) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X))) P) (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X))) Q)) (Prefunctor.map.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X))) P Q η) (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafification_map CategoryTheory.GrothendieckTopology.sheafification_mapₓ'. -/
@[simp]
theorem sheafification_map {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :
    (J.sheafification D).map η = J.sheafifyMap η :=
  rfl
#align category_theory.grothendieck_topology.sheafification_map CategoryTheory.GrothendieckTopology.sheafification_map

/- warning: category_theory.grothendieck_topology.to_sheafification -> CategoryTheory.GrothendieckTopology.toSheafification is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2], Quiver.Hom.{succ (max (max u2 (max u2 u3) u3 u1) u2 u3), max (max u2 u3) u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.CategoryStruct.toQuiver.{max (max u2 (max u2 u3) u3 u1) u2 u3, max (max u2 u3) u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.Category.toCategoryStruct.{max (max u2 (max u2 u3) u3 u1) u2 u3, max (max u2 u3) u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)))) (CategoryTheory.Functor.id.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafification._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) (CategoryTheory.GrothendieckTopology.toSheafification._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_4))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2], Quiver.Hom.{max (max (succ u3) (succ u2)) (succ u1), max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.CategoryStruct.toQuiver.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.Category.toCategoryStruct.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)))) (CategoryTheory.Functor.id.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.to_sheafification CategoryTheory.GrothendieckTopology.toSheafificationₓ'. -/
/-- The canonical map from `P` to its sheafification, as a natural transformation.
*Note:* We only show this is a sheaf under additional hypotheses on `D`. -/
def toSheafification : 𝟭 _ ⟶ sheafification J D :=
  J.toPlusNatTrans D ≫ whiskerRight (J.toPlusNatTrans D) (J.plusFunctor D)
#align category_theory.grothendieck_topology.to_sheafification CategoryTheory.GrothendieckTopology.toSheafification

/- warning: category_theory.grothendieck_topology.to_sheafification_app -> CategoryTheory.GrothendieckTopology.toSheafification_app is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.id.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafification._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafification._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X))) P)) (CategoryTheory.NatTrans.app.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.id.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafification._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafification._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X))) (CategoryTheory.GrothendieckTopology.toSheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{succ (max u3 u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.id.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P) (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X))) P)) (CategoryTheory.NatTrans.app.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.id.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.GrothendieckTopology.sheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) (CategoryTheory.GrothendieckTopology.toSheafification.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.to_sheafification_app CategoryTheory.GrothendieckTopology.toSheafification_appₓ'. -/
@[simp]
theorem toSheafification_app (P : Cᵒᵖ ⥤ D) : (J.toSheafification D).app P = J.toSheafify P :=
  rfl
#align category_theory.grothendieck_topology.to_sheafification_app CategoryTheory.GrothendieckTopology.toSheafification_app

variable {D}

/- warning: category_theory.grothendieck_topology.is_iso_to_sheafify -> CategoryTheory.GrothendieckTopology.isIso_toSheafify is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2}, (CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J P) -> (CategoryTheory.IsIso.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2}, (CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J P) -> (CategoryTheory.IsIso.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.is_iso_to_sheafify CategoryTheory.GrothendieckTopology.isIso_toSheafifyₓ'. -/
theorem isIso_toSheafify {P : Cᵒᵖ ⥤ D} (hP : Presheaf.IsSheaf J P) : IsIso (J.toSheafify P) :=
  by
  dsimp [to_sheafify]
  haveI : is_iso (J.to_plus P) := by apply is_iso_to_plus_of_is_sheaf J P hP
  haveI : is_iso ((J.plus_functor D).map (J.to_plus P)) := by apply functor.map_is_iso
  exact @is_iso.comp_is_iso _ _ _ _ _ (J.to_plus P) ((J.plus_functor D).map (J.to_plus P)) _ _
#align category_theory.grothendieck_topology.is_iso_to_sheafify CategoryTheory.GrothendieckTopology.isIso_toSheafify

/- warning: category_theory.grothendieck_topology.iso_sheafify -> CategoryTheory.GrothendieckTopology.isoSheafify is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2}, (CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J P) -> (CategoryTheory.Iso.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.isoSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) (CategoryTheory.GrothendieckTopology.isoSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_4) P))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2}, (CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J P) -> (CategoryTheory.Iso.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.iso_sheafify CategoryTheory.GrothendieckTopology.isoSheafifyₓ'. -/
/-- If `P` is a sheaf, then `P` is isomorphic to `J.sheafify P`. -/
def isoSheafify {P : Cᵒᵖ ⥤ D} (hP : Presheaf.IsSheaf J P) : P ≅ J.sheafify P :=
  letI := is_iso_to_sheafify J hP
  as_iso (J.to_sheafify P)
#align category_theory.grothendieck_topology.iso_sheafify CategoryTheory.GrothendieckTopology.isoSheafify

/- warning: category_theory.grothendieck_topology.iso_sheafify_hom -> CategoryTheory.GrothendieckTopology.isoSheafify_hom is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (hP : CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J P), Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.isoSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.isoSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P)) (CategoryTheory.Iso.hom.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.isoSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.isoSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.isoSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P hP)) (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (hP : CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J P), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{succ (max u3 u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P)) (CategoryTheory.Iso.hom.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.isoSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P hP)) (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.iso_sheafify_hom CategoryTheory.GrothendieckTopology.isoSheafify_homₓ'. -/
@[simp]
theorem isoSheafify_hom {P : Cᵒᵖ ⥤ D} (hP : Presheaf.IsSheaf J P) :
    (J.isoSheafify hP).Hom = J.toSheafify P :=
  rfl
#align category_theory.grothendieck_topology.iso_sheafify_hom CategoryTheory.GrothendieckTopology.isoSheafify_hom

/- warning: category_theory.grothendieck_topology.sheafify_lift -> CategoryTheory.GrothendieckTopology.sheafifyLift is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2}, (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) -> (CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J Q) -> (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyLift._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_3) (CategoryTheory.GrothendieckTopology.sheafifyLift._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_4) P) Q)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2}, (Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) -> (CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J Q) -> (Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafify_lift CategoryTheory.GrothendieckTopology.sheafifyLiftₓ'. -/
/-- Given a sheaf `Q` and a morphism `P ⟶ Q`, construct a morphism from
`J.sheafifcation P` to `Q`. -/
def sheafifyLift {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (hQ : Presheaf.IsSheaf J Q) : J.sheafify P ⟶ Q :=
  J.plusLift (J.plusLift η hQ) hQ
#align category_theory.grothendieck_topology.sheafify_lift CategoryTheory.GrothendieckTopology.sheafifyLift

/- warning: category_theory.grothendieck_topology.to_sheafify_sheafify_lift -> CategoryTheory.GrothendieckTopology.toSheafify_sheafifyLift is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (hQ : CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J Q), Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) Q (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.sheafifyLift.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η hQ)) η
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (hQ : CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J Q), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{succ (max u3 u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (CategoryTheory.CategoryStruct.comp.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.sheafifyLift.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η hQ)) η
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.to_sheafify_sheafify_lift CategoryTheory.GrothendieckTopology.toSheafify_sheafifyLiftₓ'. -/
@[simp, reassoc.1]
theorem toSheafify_sheafifyLift {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (hQ : Presheaf.IsSheaf J Q) :
    J.toSheafify P ≫ sheafifyLift J η hQ = η :=
  by
  dsimp only [sheafify_lift, to_sheafify]
  simp
#align category_theory.grothendieck_topology.to_sheafify_sheafify_lift CategoryTheory.GrothendieckTopology.toSheafify_sheafifyLift

/- warning: category_theory.grothendieck_topology.sheafify_lift_unique -> CategoryTheory.GrothendieckTopology.sheafifyLift_unique is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (hQ : CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J Q) (γ : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q), (Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) Q (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) γ) η) -> (Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q) γ (CategoryTheory.GrothendieckTopology.sheafifyLift.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η hQ))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (hQ : CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J Q) (γ : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q), (Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{succ (max u3 u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (CategoryTheory.CategoryStruct.comp.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) γ) η) -> (Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q) γ (CategoryTheory.GrothendieckTopology.sheafifyLift.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η hQ))
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafify_lift_unique CategoryTheory.GrothendieckTopology.sheafifyLift_uniqueₓ'. -/
theorem sheafifyLift_unique {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (hQ : Presheaf.IsSheaf J Q)
    (γ : J.sheafify P ⟶ Q) : J.toSheafify P ≫ γ = η → γ = sheafifyLift J η hQ :=
  by
  intro h
  apply plus_lift_unique
  apply plus_lift_unique
  rw [← category.assoc, ← plus_map_to_plus]
  exact h
#align category_theory.grothendieck_topology.sheafify_lift_unique CategoryTheory.GrothendieckTopology.sheafifyLift_unique

/- warning: category_theory.grothendieck_topology.iso_sheafify_inv -> CategoryTheory.GrothendieckTopology.isoSheafify_inv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (hP : CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J P), Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.isoSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.isoSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) P) (CategoryTheory.Iso.inv.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.isoSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.isoSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.isoSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P hP)) (CategoryTheory.GrothendieckTopology.sheafifyLift.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P P (CategoryTheory.CategoryStruct.id.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P) hP)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (hP : CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J P), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{succ (max u3 u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) P) (CategoryTheory.Iso.inv.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.isoSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P hP)) (CategoryTheory.GrothendieckTopology.sheafifyLift.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P P (CategoryTheory.CategoryStruct.id.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P) hP)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.iso_sheafify_inv CategoryTheory.GrothendieckTopology.isoSheafify_invₓ'. -/
@[simp]
theorem isoSheafify_inv {P : Cᵒᵖ ⥤ D} (hP : Presheaf.IsSheaf J P) :
    (J.isoSheafify hP).inv = J.sheafifyLift (𝟙 _) hP :=
  by
  apply J.sheafify_lift_unique
  simp [iso.comp_inv_eq]
#align category_theory.grothendieck_topology.iso_sheafify_inv CategoryTheory.GrothendieckTopology.isoSheafify_inv

/- warning: category_theory.grothendieck_topology.sheafify_hom_ext -> CategoryTheory.GrothendieckTopology.sheafify_hom_ext is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q) (γ : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q), (CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J Q) -> (Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) Q (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) η) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.toSheafify._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.toSheafify._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) Q (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) γ)) -> (Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q) η γ)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q) (γ : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q), (CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J Q) -> (Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{succ (max u3 u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (CategoryTheory.CategoryStruct.comp.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) η) (CategoryTheory.CategoryStruct.comp.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q (CategoryTheory.GrothendieckTopology.toSheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) γ)) -> (Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) Q) η γ)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafify_hom_ext CategoryTheory.GrothendieckTopology.sheafify_hom_extₓ'. -/
theorem sheafify_hom_ext {P Q : Cᵒᵖ ⥤ D} (η γ : J.sheafify P ⟶ Q) (hQ : Presheaf.IsSheaf J Q)
    (h : J.toSheafify P ≫ η = J.toSheafify P ≫ γ) : η = γ :=
  by
  apply J.plus_hom_ext _ _ hQ
  apply J.plus_hom_ext _ _ hQ
  rw [← category.assoc, ← category.assoc, ← plus_map_to_plus]
  exact h
#align category_theory.grothendieck_topology.sheafify_hom_ext CategoryTheory.GrothendieckTopology.sheafify_hom_ext

/- warning: category_theory.grothendieck_topology.sheafify_map_sheafify_lift -> CategoryTheory.GrothendieckTopology.sheafifyMap_sheafifyLift is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {R : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (γ : Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) Q R) (hR : CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J R), Eq.{succ (max u2 u3)} (Quiver.Hom.{succ (max u2 u3), max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) R) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_3.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S)) (CategoryTheory.GrothendieckTopology.sheafifyMap._proof_4.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_4 X)) Q) R (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η) (CategoryTheory.GrothendieckTopology.sheafifyLift.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q R γ hR)) (CategoryTheory.GrothendieckTopology.sheafifyLift.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P R (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P Q R η γ) hR)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_4 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] {P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {Q : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} {R : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2} (η : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) P Q) (γ : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) Q R) (hR : CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J R), Eq.{max (succ u3) (succ u2)} (Quiver.Hom.{succ (max u3 u2), max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) R) (CategoryTheory.CategoryStruct.comp.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P) (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q) R (CategoryTheory.GrothendieckTopology.sheafifyMap.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P Q η) (CategoryTheory.GrothendieckTopology.sheafifyLift.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) Q R γ hR)) (CategoryTheory.GrothendieckTopology.sheafifyLift.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_3 P X S) (fun (X : C) => _inst_4 X) P R (CategoryTheory.CategoryStruct.comp.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2)) P Q R η γ) hR)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafify_map_sheafify_lift CategoryTheory.GrothendieckTopology.sheafifyMap_sheafifyLiftₓ'. -/
@[simp, reassoc.1]
theorem sheafifyMap_sheafifyLift {P Q R : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (γ : Q ⟶ R)
    (hR : Presheaf.IsSheaf J R) :
    J.sheafifyMap η ≫ J.sheafifyLift γ hR = J.sheafifyLift (η ≫ γ) hR :=
  by
  apply J.sheafify_lift_unique
  rw [← category.assoc, ← J.to_sheafify_naturality, category.assoc, to_sheafify_sheafify_lift]
#align category_theory.grothendieck_topology.sheafify_map_sheafify_lift CategoryTheory.GrothendieckTopology.sheafifyMap_sheafifyLift

end GrothendieckTopology

variable (J)

variable [ConcreteCategory.{max v u} D] [PreservesLimits (forget D)]
  [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), HasMultiequalizer (S.index P)]
  [∀ X : C, HasColimitsOfShape (J.cover X)ᵒᵖ D]
  [∀ X : C, PreservesColimitsOfShape (J.cover X)ᵒᵖ (forget D)] [ReflectsIsomorphisms (forget D)]

/- warning: category_theory.grothendieck_topology.sheafify_is_sheaf -> CategoryTheory.GrothendieckTopology.sheafify_isSheaf is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), CategoryTheory.Presheaf.IsSheaf.{u2, max u2 u3, u3, u1} C _inst_1 D _inst_2 J (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) P)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2), CategoryTheory.Presheaf.IsSheaf.{u2, max u3 u2, u3, u1} C _inst_1 D _inst_2 J (CategoryTheory.GrothendieckTopology.sheafify.{u1, u2, u3} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) P)
Case conversion may be inaccurate. Consider using '#align category_theory.grothendieck_topology.sheafify_is_sheaf CategoryTheory.GrothendieckTopology.sheafify_isSheafₓ'. -/
theorem GrothendieckTopology.sheafify_isSheaf (P : Cᵒᵖ ⥤ D) : Presheaf.IsSheaf J (J.sheafify P) :=
  GrothendieckTopology.Plus.isSheaf_plus_plus _ _
#align category_theory.grothendieck_topology.sheafify_is_sheaf CategoryTheory.GrothendieckTopology.sheafify_isSheaf

variable (D)

/- warning: category_theory.presheaf_to_Sheaf -> CategoryTheory.presheafToSheaf is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)], CategoryTheory.Functor.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u3 u1 u2 u3} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)], CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max (max u1 u3) u3 u2) u2, max (max (max u1 u3) u3 u2) u2} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.presheaf_to_Sheaf CategoryTheory.presheafToSheafₓ'. -/
/-- The sheafification functor, as a functor taking values in `Sheaf`. -/
@[simps]
def presheafToSheaf : (Cᵒᵖ ⥤ D) ⥤ Sheaf J D
    where
  obj P := ⟨J.sheafify P, J.sheafify_isSheaf P⟩
  map P Q η := ⟨J.sheafifyMap η⟩
  map_id' P := Sheaf.Hom.ext _ _ <| J.sheafifyMap_id _
  map_comp' P Q R f g := Sheaf.Hom.ext _ _ <| J.sheafifyMap_comp _ _
#align category_theory.presheaf_to_Sheaf CategoryTheory.presheafToSheaf

/- warning: category_theory.presheaf_to_Sheaf_preserves_zero_morphisms -> CategoryTheory.presheafToSheaf_preservesZeroMorphisms is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_9 : CategoryTheory.Preadditive.{max u2 u3, u1} D _inst_2], CategoryTheory.Functor.PreservesZeroMorphisms.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u3 u1 u2 u3} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Limits.CategoryTheory.Functor.hasZeroMorphisms.{u2, u3, max u2 u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u2 u3, u1} D _inst_2 _inst_9)) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.preadditive.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2 _inst_9)) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_9 : CategoryTheory.Preadditive.{max u3 u2, u1} D _inst_2], CategoryTheory.Functor.PreservesZeroMorphisms.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Limits.instHasZeroMorphismsFunctorCategory.{u2, u3, max u3 u2, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u3 u2, u1} D _inst_2 _inst_9)) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.instPreadditiveSheafInstCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2 _inst_9)) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8)
Case conversion may be inaccurate. Consider using '#align category_theory.presheaf_to_Sheaf_preserves_zero_morphisms CategoryTheory.presheafToSheaf_preservesZeroMorphismsₓ'. -/
instance presheafToSheaf_preservesZeroMorphisms [Preadditive D] :
    (presheafToSheaf J D).PreservesZeroMorphisms
    where map_zero' F G := by
    ext
    erw [colimit.ι_map, comp_zero, J.plus_map_zero, J.diagram_nat_trans_zero, zero_comp]
#align category_theory.presheaf_to_Sheaf_preserves_zero_morphisms CategoryTheory.presheafToSheaf_preservesZeroMorphisms

/- warning: category_theory.sheafification_adjunction -> CategoryTheory.sheafificationAdjunction is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)], CategoryTheory.Adjunction.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u3 u1 u2 u3} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (CategoryTheory.sheafificationAdjunction._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_5) (CategoryTheory.sheafificationAdjunction._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_6) (fun (X : C) => _inst_7 X) _inst_8) (CategoryTheory.sheafToPresheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)], CategoryTheory.Adjunction.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8) (CategoryTheory.sheafToPresheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.sheafification_adjunction CategoryTheory.sheafificationAdjunctionₓ'. -/
/-- The sheafification functor is left adjoint to the forgetful functor. -/
@[simps unit_app counit_app_val]
def sheafificationAdjunction : presheafToSheaf J D ⊣ sheafToPresheaf J D :=
  Adjunction.mkOfHomEquiv
    { homEquiv := fun P Q =>
        { toFun := fun e => J.toSheafify P ≫ e.val
          invFun := fun e => ⟨J.sheafifyLift e Q.2⟩
          left_inv := fun e => Sheaf.Hom.ext _ _ <| (J.sheafifyLift_unique _ _ _ rfl).symm
          right_inv := fun e => J.toSheafify_sheafifyLift _ _ }
      homEquiv_naturality_left_symm := by
        intro P Q R η γ; ext1; dsimp; symm
        apply J.sheafify_map_sheafify_lift
      homEquiv_naturality_right := fun P Q R η γ =>
        by
        dsimp
        rw [category.assoc] }
#align category_theory.sheafification_adjunction CategoryTheory.sheafificationAdjunction

/- warning: category_theory.Sheaf_to_presheaf_is_right_adjoint -> CategoryTheory.sheafToPresheafIsRightAdjoint is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)], CategoryTheory.IsRightAdjoint.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u3 u1 u2 u3} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafToPresheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)], CategoryTheory.IsRightAdjoint.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafToPresheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.Sheaf_to_presheaf_is_right_adjoint CategoryTheory.sheafToPresheafIsRightAdjointₓ'. -/
instance sheafToPresheafIsRightAdjoint : IsRightAdjoint (sheafToPresheaf J D) :=
  ⟨_, sheafificationAdjunction J D⟩
#align category_theory.Sheaf_to_presheaf_is_right_adjoint CategoryTheory.sheafToPresheafIsRightAdjoint

/- warning: category_theory.presheaf_mono_of_mono -> CategoryTheory.presheaf_mono_of_mono is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] {F : CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2} {G : CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2} (f : Quiver.Hom.{succ (max u2 u3), max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2))) F G) [_inst_9 : CategoryTheory.Mono.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) F G f], CategoryTheory.Mono.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.val.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2 F) (CategoryTheory.Sheaf.val.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2 G) (CategoryTheory.Sheaf.Hom.val.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2 F G f)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] {F : CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2} {G : CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2} (f : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2))) F G) [_inst_9 : CategoryTheory.Mono.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) F G f], CategoryTheory.Mono.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.val.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2 F) (CategoryTheory.Sheaf.val.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2 G) (CategoryTheory.Sheaf.Hom.val.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2 F G f)
Case conversion may be inaccurate. Consider using '#align category_theory.presheaf_mono_of_mono CategoryTheory.presheaf_mono_of_monoₓ'. -/
instance presheaf_mono_of_mono {F G : Sheaf J D} (f : F ⟶ G) [Mono f] : Mono f.1 :=
  (sheafToPresheaf J D).map_mono _
#align category_theory.presheaf_mono_of_mono CategoryTheory.presheaf_mono_of_mono

/- warning: category_theory.Sheaf.hom.mono_iff_presheaf_mono -> CategoryTheory.Sheaf.Hom.mono_iff_presheaf_mono is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] {F : CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2} {G : CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2} (f : Quiver.Hom.{succ (max u2 u3), max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2))) F G), Iff (CategoryTheory.Mono.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) F G f) (CategoryTheory.Mono.{max u2 u3, max u2 (max u2 u3) u3 u1} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.val.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2 F) (CategoryTheory.Sheaf.val.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2 G) (CategoryTheory.Sheaf.Hom.val.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2 F G f))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (D : Type.{u1}) [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] {F : CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2} {G : CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2} (f : Quiver.Hom.{max (succ u3) (succ u2), max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2))) F G), Iff (CategoryTheory.Mono.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) F G f) (CategoryTheory.Mono.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.val.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2 F) (CategoryTheory.Sheaf.val.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2 G) (CategoryTheory.Sheaf.Hom.val.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2 F G f))
Case conversion may be inaccurate. Consider using '#align category_theory.Sheaf.hom.mono_iff_presheaf_mono CategoryTheory.Sheaf.Hom.mono_iff_presheaf_monoₓ'. -/
theorem Sheaf.Hom.mono_iff_presheaf_mono {F G : Sheaf J D} (f : F ⟶ G) : Mono f ↔ Mono f.1 :=
  ⟨fun m => by
    skip
    infer_instance, fun m => by
    skip
    exact Sheaf.hom.mono_of_presheaf_mono J D f⟩
#align category_theory.Sheaf.hom.mono_iff_presheaf_mono CategoryTheory.Sheaf.Hom.mono_iff_presheaf_mono

variable {J D}

/- warning: category_theory.sheafification_iso -> CategoryTheory.sheafificationIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] (P : CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2), CategoryTheory.Iso.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) P (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u3 u1 u2 u3} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (CategoryTheory.sheafificationIso._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_5) (CategoryTheory.sheafificationIso._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 _inst_6) (fun (X : C) => _inst_7 X) _inst_8) (CategoryTheory.Sheaf.val.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2 P))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] (P : CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2), CategoryTheory.Iso.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) P (Prefunctor.obj.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2))) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8)) (CategoryTheory.Sheaf.val.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2 P))
Case conversion may be inaccurate. Consider using '#align category_theory.sheafification_iso CategoryTheory.sheafificationIsoₓ'. -/
/-- A sheaf `P` is isomorphic to its own sheafification. -/
@[simps]
def sheafificationIso (P : Sheaf J D) : P ≅ (presheafToSheaf J D).obj P.val
    where
  Hom := ⟨(J.isoSheafify P.2).Hom⟩
  inv := ⟨(J.isoSheafify P.2).inv⟩
  hom_inv_id' := by
    ext1
    apply (J.iso_sheafify P.2).hom_inv_id
  inv_hom_id' := by
    ext1
    apply (J.iso_sheafify P.2).inv_hom_id
#align category_theory.sheafification_iso CategoryTheory.sheafificationIso

/- warning: category_theory.is_iso_sheafification_adjunction_counit -> CategoryTheory.isIso_sheafificationAdjunction_counit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] (P : CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2), CategoryTheory.IsIso.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u3 u1 u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u3 u1 u2 u3, max u2 (max u2 u3) u3 u1, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafToPresheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (CategoryTheory.sheafificationAdjunction._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S)) (CategoryTheory.sheafificationAdjunction._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_6 X)) (fun (X : C) => _inst_7 X) _inst_8)) P) (CategoryTheory.Functor.obj.{max u2 u3, max u2 u3, max u3 u1 u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.id.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2)) P) (CategoryTheory.NatTrans.app.{max u2 u3, max u2 u3, max u3 u1 u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u3 u1 u2 u3, max u2 (max u2 u3) u3 u1, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafToPresheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (CategoryTheory.sheafificationAdjunction._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S)) (CategoryTheory.sheafificationAdjunction._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_6 X)) (fun (X : C) => _inst_7 X) _inst_8)) (CategoryTheory.Functor.id.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2)) (CategoryTheory.Adjunction.counit.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u3 u1 u2 u3} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (CategoryTheory.sheafificationAdjunction._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S)) (CategoryTheory.sheafificationAdjunction._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_6 X)) (fun (X : C) => _inst_7 X) _inst_8) (CategoryTheory.sheafToPresheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafificationAdjunction.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8)) P)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] (P : CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2), CategoryTheory.IsIso.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2))) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafToPresheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8))) P) (Prefunctor.obj.{succ (max u3 u2), succ (max u3 u2), max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2))) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2))) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.id.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2))) P) (CategoryTheory.NatTrans.app.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafToPresheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8)) (CategoryTheory.Functor.id.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2)) (CategoryTheory.Adjunction.counit.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8) (CategoryTheory.sheafToPresheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafificationAdjunction.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8)) P)
Case conversion may be inaccurate. Consider using '#align category_theory.is_iso_sheafification_adjunction_counit CategoryTheory.isIso_sheafificationAdjunction_counitₓ'. -/
instance isIso_sheafificationAdjunction_counit (P : Sheaf J D) :
    IsIso ((sheafificationAdjunction J D).counit.app P) :=
  isIso_of_fully_faithful (sheafToPresheaf J D) _
#align category_theory.is_iso_sheafification_adjunction_counit CategoryTheory.isIso_sheafificationAdjunction_counit

/- warning: category_theory.sheafification_reflective -> CategoryTheory.sheafification_reflective is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u2 u3, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u2 u3, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, u1} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (Opposite.{succ (max u3 u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.Cover.preorder.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u2 u3, max u2 u3, u1, succ (max u2 u3)} D _inst_2 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.forget.{u1, max u2 u3, max u2 u3} D _inst_2 _inst_3)], CategoryTheory.IsIso.{max (max u3 u1 u2 u3) u2 u3, max (max u2 u3) u3 u1 u2 u3} (CategoryTheory.Functor.{max u2 u3, max u2 u3, max u3 u1 u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2)) (CategoryTheory.Functor.category.{max u2 u3, max u2 u3, max u3 u1 u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2)) (CategoryTheory.Functor.comp.{max u2 u3, max u2 u3, max u2 u3, max u3 u1 u2 u3, max u2 (max u2 u3) u3 u1, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafToPresheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (CategoryTheory.sheafificationAdjunction._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S)) (CategoryTheory.sheafificationAdjunction._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_6 X)) (fun (X : C) => _inst_7 X) _inst_8)) (CategoryTheory.Functor.id.{max u2 u3, max u3 u1 u2 u3} (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2)) (CategoryTheory.Adjunction.counit.{max u2 u3, max u2 u3, max u2 (max u2 u3) u3 u1, max u3 u1 u2 u3} (CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.CategoryTheory.category.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (CategoryTheory.sheafificationAdjunction._proof_1.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S)) (CategoryTheory.sheafificationAdjunction._proof_2.{u3, u2, u1} C _inst_1 J D _inst_2 (fun (X : C) => _inst_6 X)) (fun (X : C) => _inst_7 X) _inst_8) (CategoryTheory.sheafToPresheaf.{u2, max u2 u3, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafificationAdjunction.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u2 u3, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {J : CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1} {D : Type.{u1}} [_inst_2 : CategoryTheory.Category.{max u2 u3, u1} D] [_inst_3 : CategoryTheory.ConcreteCategory.{max u2 u3, max u3 u2, u1} D _inst_2] [_inst_4 : CategoryTheory.Limits.PreservesLimits.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_5 : forall (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X), CategoryTheory.Limits.HasMultiequalizer.{max u3 u2, u1, max u3 u2} D _inst_2 (CategoryTheory.GrothendieckTopology.Cover.index.{u1, u2, u3} C _inst_1 X J D _inst_2 S P)] [_inst_6 : forall (X : C), CategoryTheory.Limits.HasColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, u1} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) D _inst_2] [_inst_7 : forall (X : C), CategoryTheory.Limits.PreservesColimitsOfShape.{max u3 u2, max u3 u2, max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (Opposite.{max (succ u3) (succ u2)} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X)) (CategoryTheory.Category.opposite.{max u3 u2, max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) (CategoryTheory.GrothendieckTopology.instPreorderCover.{u2, u3} C _inst_1 J X))) (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)] [_inst_8 : CategoryTheory.ReflectsIsomorphisms.{max u3 u2, max u3 u2, u1, max (succ u3) (succ u2)} D _inst_2 Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (CategoryTheory.forget.{u1, max u3 u2, max u3 u2} D _inst_2 _inst_3)], CategoryTheory.IsIso.{max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2)) (CategoryTheory.Functor.category.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2)) (CategoryTheory.Functor.comp.{max u3 u2, max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafToPresheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8)) (CategoryTheory.Functor.id.{max u3 u2, max (max u3 u2) u1} (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2)) (CategoryTheory.Adjunction.counit.{max u3 u2, max u3 u2, max (max u3 u2) u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Functor.category.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (CategoryTheory.Sheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.Sheaf.instCategorySheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.presheafToSheaf.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8) (CategoryTheory.sheafToPresheaf.{u2, max u3 u2, u3, u1} C _inst_1 J D _inst_2) (CategoryTheory.sheafificationAdjunction.{u1, u2, u3} C _inst_1 J D _inst_2 _inst_3 _inst_4 (fun (P : CategoryTheory.Functor.{u2, max u3 u2, u3, u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) D _inst_2) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover.{u2, u3} C _inst_1 J X) => _inst_5 P X S) (fun (X : C) => _inst_6 X) (fun (X : C) => _inst_7 X) _inst_8))
Case conversion may be inaccurate. Consider using '#align category_theory.sheafification_reflective CategoryTheory.sheafification_reflectiveₓ'. -/
instance sheafification_reflective : IsIso (sheafificationAdjunction J D).counit :=
  NatIso.isIso_of_isIso_app _
#align category_theory.sheafification_reflective CategoryTheory.sheafification_reflective

end CategoryTheory

