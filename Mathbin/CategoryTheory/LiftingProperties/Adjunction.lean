/-
Copyright (c) 2022 Joël Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joël Riou

! This file was ported from Lean 3 source module category_theory.lifting_properties.adjunction
! leanprover-community/mathlib commit 24855f4682aaf5f53513c918b421ba083d3cccd0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.LiftingProperties.Basic
import Mathbin.CategoryTheory.Adjunction.Basic

/-!

# Lifting properties and adjunction

In this file, we obtain `adjunction.has_lifting_property_iff`, which states
that when we have an adjunction `adj : G ⊣ F` between two functors `G : C ⥤ D`
and `F : D ⥤ C`, then a morphism of the form `G.map i` has the left lifting
property in `D` with respect to a morphism `p` if and only the morphism `i`
has the left lifting property in `C` with respect to `F.map p`.

-/


namespace CategoryTheory

open Category

variable {C D : Type _} [Category C] [Category D] {G : C ⥤ D} {F : D ⥤ C}

namespace CommSq

section

variable {A B : C} {X Y : D} {i : A ⟶ B} {p : X ⟶ Y} {u : G.obj A ⟶ X} {v : G.obj B ⟶ Y}
  (sq : CommSq u (G.map i) p v) (adj : G ⊣ F)

include sq

/- warning: category_theory.comm_sq.right_adjoint -> CategoryTheory.CommSq.right_adjoint is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] [_inst_2 : CategoryTheory.Category.{u4, u2} D] {G : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u4, u3, u2, u1} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A B} {p : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) X Y} {u : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X} {v : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y}, (CategoryTheory.CommSq.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y u (CategoryTheory.Functor.map.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A B i) p v) -> (forall (adj : CategoryTheory.Adjunction.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F), CategoryTheory.CommSq.{u1, u3} C _inst_1 A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) (fun (_x : Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) => (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) -> (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) (Equiv.hasCoeToFun.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj A X) u) i (CategoryTheory.Functor.map.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X Y p) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) (fun (_x : Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) => (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) -> (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) (Equiv.hasCoeToFun.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj B Y) v))
but is expected to have type
  forall {C : Type.{u4}} {D : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] [_inst_2 : CategoryTheory.Category.{u2, u1} D] {G : CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u2, u3, u1, u4} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) A B} {p : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) X Y} {u : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X} {v : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y}, (CategoryTheory.CommSq.{u1, u2} D _inst_2 (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y u (Prefunctor.map.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A B i) p v) -> (forall (adj : CategoryTheory.Adjunction.{u3, u2, u4, u1} C _inst_1 D _inst_2 G F), CategoryTheory.CommSq.{u4, u3} C _inst_1 A (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) X) B (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) Y) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X) (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) A (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) X))) (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X) (fun (_x : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X) => Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) A (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) X)) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X) (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) A (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) X))) (CategoryTheory.Adjunction.homEquiv.{u3, u2, u4, u1} C _inst_1 D _inst_2 G F adj A X) u) i (Prefunctor.map.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) X Y p) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y) (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) B (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) Y))) (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y) (fun (_x : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y) => Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) B (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) Y)) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y) (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) B (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) Y))) (CategoryTheory.Adjunction.homEquiv.{u3, u2, u4, u1} C _inst_1 D _inst_2 G F adj B Y) v))
Case conversion may be inaccurate. Consider using '#align category_theory.comm_sq.right_adjoint CategoryTheory.CommSq.right_adjointₓ'. -/
/-- When we have an adjunction `G ⊣ F`, any commutative square where the left
map is of the form `G.map i` and the right map is `p` has an "adjoint" commutative
square whose left map is `i` and whose right map is `F.map p`. -/
theorem right_adjoint : CommSq (adj.homEquiv _ _ u) i (F.map p) (adj.homEquiv _ _ v) :=
  ⟨by
    simp only [adjunction.hom_equiv_unit, assoc, ← F.map_comp, sq.w]
    rw [F.map_comp, adjunction.unit_naturality_assoc]⟩
#align category_theory.comm_sq.right_adjoint CategoryTheory.CommSq.right_adjoint

/- warning: category_theory.comm_sq.right_adjoint_lift_struct_equiv -> CategoryTheory.CommSq.rightAdjointLiftStructEquiv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] [_inst_2 : CategoryTheory.Category.{u4, u2} D] {G : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u4, u3, u2, u1} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A B} {p : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) X Y} {u : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X} {v : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y} (sq : CategoryTheory.CommSq.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y u (CategoryTheory.Functor.map.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A B i) p v) (adj : CategoryTheory.Adjunction.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F), Equiv.{succ u4, succ u3} (CategoryTheory.CommSq.LiftStruct.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) X Y u (CategoryTheory.Functor.map.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A B i) p v sq) (CategoryTheory.CommSq.LiftStruct.{u1, u3} C _inst_1 A B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X) (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) (fun (_x : Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) => (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) -> (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) (Equiv.hasCoeToFun.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj A X) u) i (CategoryTheory.Functor.map.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X Y p) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) (fun (_x : Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) => (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) -> (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) (Equiv.hasCoeToFun.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj B Y) v) (CategoryTheory.CommSq.right_adjoint.{u1, u2, u3, u4} C D _inst_1 _inst_2 G F A B X Y i p u v sq adj))
but is expected to have type
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] [_inst_2 : CategoryTheory.Category.{u4, u2} D] {G : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u4, u3, u2, u1} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A B} {p : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) X Y} {u : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X} {v : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y} (sq : CategoryTheory.CommSq.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y u (Prefunctor.map.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A B i) p v) (adj : CategoryTheory.Adjunction.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F), Equiv.{succ u4, succ u3} (CategoryTheory.CommSq.LiftStruct.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) X Y u (Prefunctor.map.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A B i) p v sq) (CategoryTheory.CommSq.LiftStruct.{u1, u3} C _inst_1 A B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X) (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y) (FunLike.coe.{max (succ u3) (succ u4), succ u4, succ u3} (Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X))) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X) (fun (_x : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X) => Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X)) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X))) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj A X) u) i (Prefunctor.map.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X Y p) (FunLike.coe.{max (succ u3) (succ u4), succ u4, succ u3} (Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y))) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y) (fun (_x : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y) => Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y)) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y))) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj B Y) v) (CategoryTheory.CommSq.right_adjoint.{u2, u4, u3, u1} C D _inst_1 _inst_2 G F A B X Y i p u v sq adj))
Case conversion may be inaccurate. Consider using '#align category_theory.comm_sq.right_adjoint_lift_struct_equiv CategoryTheory.CommSq.rightAdjointLiftStructEquivₓ'. -/
/-- The liftings of a commutative are in bijection with the liftings of its (right)
adjoint square. -/
def rightAdjointLiftStructEquiv : sq.LiftStruct ≃ (sq.rightAdjoint adj).LiftStruct
    where
  toFun l :=
    { l := adj.homEquiv _ _ l.l
      fac_left' := by rw [← adj.hom_equiv_naturality_left, l.fac_left]
      fac_right' := by rw [← adjunction.hom_equiv_naturality_right, l.fac_right] }
  invFun l :=
    { l := (adj.homEquiv _ _).symm l.l
      fac_left' := by
        rw [← adjunction.hom_equiv_naturality_left_symm, l.fac_left]
        apply (adj.hom_equiv _ _).left_inv
      fac_right' := by
        rw [← adjunction.hom_equiv_naturality_right_symm, l.fac_right]
        apply (adj.hom_equiv _ _).left_inv }
  left_inv := by tidy
  right_inv := by tidy
#align category_theory.comm_sq.right_adjoint_lift_struct_equiv CategoryTheory.CommSq.rightAdjointLiftStructEquiv

/- warning: category_theory.comm_sq.right_adjoint_has_lift_iff -> CategoryTheory.CommSq.right_adjoint_hasLift_iff is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] [_inst_2 : CategoryTheory.Category.{u4, u2} D] {G : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u4, u3, u2, u1} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A B} {p : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) X Y} {u : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X} {v : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y} (sq : CategoryTheory.CommSq.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y u (CategoryTheory.Functor.map.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A B i) p v) (adj : CategoryTheory.Adjunction.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F), Iff (CategoryTheory.CommSq.HasLift.{u1, u3} C _inst_1 A B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X) (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) (fun (_x : Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) => (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) -> (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) (Equiv.hasCoeToFun.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X))) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj A X) u) i (CategoryTheory.Functor.map.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X Y p) (coeFn.{max 1 (max (succ u4) (succ u3)) (succ u3) (succ u4), max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) (fun (_x : Equiv.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) => (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) -> (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) (Equiv.hasCoeToFun.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y))) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj B Y) v) (CategoryTheory.CommSq.right_adjoint.{u1, u2, u3, u4} C D _inst_1 _inst_2 G F A B X Y i p u v sq adj)) (CategoryTheory.CommSq.HasLift.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) X Y u (CategoryTheory.Functor.map.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A B i) p v sq)
but is expected to have type
  forall {C : Type.{u4}} {D : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u4} C] [_inst_2 : CategoryTheory.Category.{u2, u1} D] {G : CategoryTheory.Functor.{u3, u2, u4, u1} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u2, u3, u1, u4} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) A B} {p : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) X Y} {u : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X} {v : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y} (sq : CategoryTheory.CommSq.{u1, u2} D _inst_2 (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y u (Prefunctor.map.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A B i) p v) (adj : CategoryTheory.Adjunction.{u3, u2, u4, u1} C _inst_1 D _inst_2 G F), Iff (CategoryTheory.CommSq.HasLift.{u4, u3} C _inst_1 A B (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) X) (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) Y) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X) (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) A (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) X))) (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X) (fun (_x : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X) => Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) A (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) X)) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) X) (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) A (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) X))) (CategoryTheory.Adjunction.homEquiv.{u3, u2, u4, u1} C _inst_1 D _inst_2 G F adj A X) u) i (Prefunctor.map.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) X Y p) (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (Equiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y) (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) B (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) Y))) (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y) (fun (_x : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y) => Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) B (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) Y)) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) Y) (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) B (Prefunctor.obj.{succ u2, succ u3, u1, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} D _inst_2 C _inst_1 F) Y))) (CategoryTheory.Adjunction.homEquiv.{u3, u2, u4, u1} C _inst_1 D _inst_2 G F adj B Y) v) (CategoryTheory.CommSq.right_adjoint.{u1, u2, u3, u4} C D _inst_1 _inst_2 G F A B X Y i p u v sq adj)) (CategoryTheory.CommSq.HasLift.{u1, u2} D _inst_2 (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A) (Prefunctor.obj.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) B) X Y u (Prefunctor.map.{succ u3, succ u2, u4, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} D (CategoryTheory.Category.toCategoryStruct.{u2, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} C _inst_1 D _inst_2 G) A B i) p v sq)
Case conversion may be inaccurate. Consider using '#align category_theory.comm_sq.right_adjoint_has_lift_iff CategoryTheory.CommSq.right_adjoint_hasLift_iffₓ'. -/
/-- A square has a lifting if and only if its (right) adjoint square has a lifting. -/
theorem right_adjoint_hasLift_iff : HasLift (sq.rightAdjoint adj) ↔ HasLift sq :=
  by
  simp only [has_lift.iff]
  exact Equiv.nonempty_congr (sq.right_adjoint_lift_struct_equiv adj).symm
#align category_theory.comm_sq.right_adjoint_has_lift_iff CategoryTheory.CommSq.right_adjoint_hasLift_iff

instance [HasLift sq] : HasLift (sq.rightAdjoint adj) :=
  by
  rw [right_adjoint_has_lift_iff]
  infer_instance

end

section

variable {A B : C} {X Y : D} {i : A ⟶ B} {p : X ⟶ Y} {u : A ⟶ F.obj X} {v : B ⟶ F.obj Y}
  (sq : CommSq u i (F.map p) v) (adj : G ⊣ F)

include sq

/- warning: category_theory.comm_sq.left_adjoint -> CategoryTheory.CommSq.left_adjoint is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] [_inst_2 : CategoryTheory.Category.{u4, u2} D] {G : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u4, u3, u2, u1} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A B} {p : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) X Y} {u : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)} {v : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)}, (CategoryTheory.CommSq.{u1, u3} C _inst_1 A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y) u i (CategoryTheory.Functor.map.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X Y p) v) -> (forall (adj : CategoryTheory.Adjunction.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F), CategoryTheory.CommSq.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) (fun (_x : Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) => (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) -> (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) (Equiv.hasCoeToFun.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) (Equiv.symm.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj A X)) u) (CategoryTheory.Functor.map.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A B i) p (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) (fun (_x : Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) => (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) -> (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) (Equiv.hasCoeToFun.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) (Equiv.symm.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj B Y)) v))
but is expected to have type
  forall {C : Type.{u1}} {D : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Category.{u3, u4} D] {G : CategoryTheory.Functor.{u2, u3, u1, u4} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u3, u2, u4, u1} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A B} {p : Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) X Y} {u : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)} {v : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)}, (CategoryTheory.CommSq.{u1, u2} C _inst_1 A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y) u i (Prefunctor.map.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X Y p) v) -> (forall (adj : CategoryTheory.Adjunction.{u2, u3, u1, u4} C _inst_1 D _inst_2 G F), CategoryTheory.CommSq.{u4, u3} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A) X (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) B) Y (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Equiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A) X)) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) (fun (_x : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) => Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A) X) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A) X)) (Equiv.symm.{succ u3, succ u2} (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A) X) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) (CategoryTheory.Adjunction.homEquiv.{u2, u3, u1, u4} C _inst_1 D _inst_2 G F adj A X)) u) (Prefunctor.map.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A B i) p (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Equiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) B) Y)) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) (fun (_x : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) => Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) B) Y) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) B) Y)) (Equiv.symm.{succ u3, succ u2} (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) B) Y) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) (CategoryTheory.Adjunction.homEquiv.{u2, u3, u1, u4} C _inst_1 D _inst_2 G F adj B Y)) v))
Case conversion may be inaccurate. Consider using '#align category_theory.comm_sq.left_adjoint CategoryTheory.CommSq.left_adjointₓ'. -/
/-- When we have an adjunction `G ⊣ F`, any commutative square where the left
map is of the form `i` and the right map is `F.map p` has an "adjoint" commutative
square whose left map is `G.map i` and whose right map is `p`. -/
theorem left_adjoint : CommSq ((adj.homEquiv _ _).symm u) (G.map i) p ((adj.homEquiv _ _).symm v) :=
  ⟨by
    simp only [adjunction.hom_equiv_counit, assoc, ← G.map_comp_assoc, ← sq.w]
    rw [G.map_comp, assoc, adjunction.counit_naturality]⟩
#align category_theory.comm_sq.left_adjoint CategoryTheory.CommSq.left_adjoint

/- warning: category_theory.comm_sq.left_adjoint_lift_struct_equiv -> CategoryTheory.CommSq.leftAdjointLiftStructEquiv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] [_inst_2 : CategoryTheory.Category.{u4, u2} D] {G : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u4, u3, u2, u1} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A B} {p : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) X Y} {u : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)} {v : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)} (sq : CategoryTheory.CommSq.{u1, u3} C _inst_1 A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y) u i (CategoryTheory.Functor.map.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X Y p) v) (adj : CategoryTheory.Adjunction.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F), Equiv.{succ u3, succ u4} (CategoryTheory.CommSq.LiftStruct.{u1, u3} C _inst_1 A B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X) (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y) u i (CategoryTheory.Functor.map.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X Y p) v sq) (CategoryTheory.CommSq.LiftStruct.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) X Y (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) (fun (_x : Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) => (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) -> (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) (Equiv.hasCoeToFun.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) (Equiv.symm.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj A X)) u) (CategoryTheory.Functor.map.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A B i) p (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) (fun (_x : Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) => (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) -> (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) (Equiv.hasCoeToFun.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) (Equiv.symm.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj B Y)) v) (CategoryTheory.CommSq.left_adjoint.{u1, u2, u3, u4} C D _inst_1 _inst_2 G F A B X Y i p u v sq adj))
but is expected to have type
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] [_inst_2 : CategoryTheory.Category.{u4, u2} D] {G : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u4, u3, u2, u1} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A B} {p : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) X Y} {u : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X)} {v : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y)} (sq : CategoryTheory.CommSq.{u1, u3} C _inst_1 A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y) u i (Prefunctor.map.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X Y p) v) (adj : CategoryTheory.Adjunction.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F), Equiv.{succ u3, succ u4} (CategoryTheory.CommSq.LiftStruct.{u1, u3} C _inst_1 A B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X) (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y) u i (Prefunctor.map.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X Y p) v sq) (CategoryTheory.CommSq.LiftStruct.{u2, u4} D _inst_2 (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) X Y (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X)) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X)) (fun (_x : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X)) => Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X)) (Equiv.symm.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) X)) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj A X)) u) (Prefunctor.map.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) A B i) p (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y)) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y)) (fun (_x : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y)) => Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y)) (Equiv.symm.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} C _inst_1 D _inst_2 G) B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (Prefunctor.obj.{succ u4, succ u3, u2, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} D _inst_2 C _inst_1 F) Y)) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj B Y)) v) (CategoryTheory.CommSq.left_adjoint.{u1, u3, u4, u2} C D _inst_1 _inst_2 G F A B X Y i p u v sq adj))
Case conversion may be inaccurate. Consider using '#align category_theory.comm_sq.left_adjoint_lift_struct_equiv CategoryTheory.CommSq.leftAdjointLiftStructEquivₓ'. -/
/-- The liftings of a commutative are in bijection with the liftings of its (left)
adjoint square. -/
def leftAdjointLiftStructEquiv : sq.LiftStruct ≃ (sq.leftAdjoint adj).LiftStruct
    where
  toFun l :=
    { l := (adj.homEquiv _ _).symm l.l
      fac_left' := by rw [← adj.hom_equiv_naturality_left_symm, l.fac_left]
      fac_right' := by rw [← adj.hom_equiv_naturality_right_symm, l.fac_right] }
  invFun l :=
    { l := (adj.homEquiv _ _) l.l
      fac_left' := by
        rw [← adj.hom_equiv_naturality_left, l.fac_left]
        apply (adj.hom_equiv _ _).right_inv
      fac_right' := by
        rw [← adj.hom_equiv_naturality_right, l.fac_right]
        apply (adj.hom_equiv _ _).right_inv }
  left_inv := by tidy
  right_inv := by tidy
#align category_theory.comm_sq.left_adjoint_lift_struct_equiv CategoryTheory.CommSq.leftAdjointLiftStructEquiv

/- warning: category_theory.comm_sq.left_adjoint_has_lift_iff -> CategoryTheory.CommSq.left_adjoint_hasLift_iff is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] [_inst_2 : CategoryTheory.Category.{u4, u2} D] {G : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u4, u3, u2, u1} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A B} {p : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) X Y} {u : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)} {v : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)} (sq : CategoryTheory.CommSq.{u1, u3} C _inst_1 A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y) u i (CategoryTheory.Functor.map.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X Y p) v) (adj : CategoryTheory.Adjunction.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F), Iff (CategoryTheory.CommSq.HasLift.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) X Y (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) (fun (_x : Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) => (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) -> (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) (Equiv.hasCoeToFun.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X)) (Equiv.symm.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) X) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X)) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj A X)) u) (CategoryTheory.Functor.map.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A B i) p (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) (fun (_x : Equiv.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) => (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) -> (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) (Equiv.hasCoeToFun.{succ u3, succ u4} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y)) (Equiv.symm.{succ u4, succ u3} (Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) Y) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y)) (CategoryTheory.Adjunction.homEquiv.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F adj B Y)) v) (CategoryTheory.CommSq.left_adjoint.{u1, u2, u3, u4} C D _inst_1 _inst_2 G F A B X Y i p u v sq adj)) (CategoryTheory.CommSq.HasLift.{u1, u3} C _inst_1 A B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X) (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y) u i (CategoryTheory.Functor.map.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X Y p) v sq)
but is expected to have type
  forall {C : Type.{u1}} {D : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] [_inst_2 : CategoryTheory.Category.{u3, u4} D] {G : CategoryTheory.Functor.{u2, u3, u1, u4} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u3, u2, u4, u1} D _inst_2 C _inst_1} {A : C} {B : C} {X : D} {Y : D} {i : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A B} {p : Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) X Y} {u : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)} {v : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)} (sq : CategoryTheory.CommSq.{u1, u2} C _inst_1 A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y) u i (Prefunctor.map.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X Y p) v) (adj : CategoryTheory.Adjunction.{u2, u3, u1, u4} C _inst_1 D _inst_2 G F), Iff (CategoryTheory.CommSq.HasLift.{u4, u3} D _inst_2 (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) B) X Y (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Equiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A) X)) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) (fun (_x : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) => Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A) X) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A) X)) (Equiv.symm.{succ u3, succ u2} (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A) X) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) A (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X)) (CategoryTheory.Adjunction.homEquiv.{u2, u3, u1, u4} C _inst_1 D _inst_2 G F adj A X)) u) (Prefunctor.map.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) A B i) p (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Equiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) B) Y)) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) (fun (_x : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) => Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) B) Y) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u3} (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) B) Y)) (Equiv.symm.{succ u3, succ u2} (Quiver.Hom.{succ u3, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (Prefunctor.obj.{succ u2, succ u3, u1, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u2, u3, u1, u4} C _inst_1 D _inst_2 G) B) Y) (Quiver.Hom.{succ u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y)) (CategoryTheory.Adjunction.homEquiv.{u2, u3, u1, u4} C _inst_1 D _inst_2 G F adj B Y)) v) (CategoryTheory.CommSq.left_adjoint.{u1, u2, u3, u4} C D _inst_1 _inst_2 G F A B X Y i p u v sq adj)) (CategoryTheory.CommSq.HasLift.{u1, u2} C _inst_1 A B (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X) (Prefunctor.obj.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) Y) u i (Prefunctor.map.{succ u3, succ u2, u4, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} D (CategoryTheory.Category.toCategoryStruct.{u3, u4} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u4, u1} D _inst_2 C _inst_1 F) X Y p) v sq)
Case conversion may be inaccurate. Consider using '#align category_theory.comm_sq.left_adjoint_has_lift_iff CategoryTheory.CommSq.left_adjoint_hasLift_iffₓ'. -/
/-- A (left) adjoint square has a lifting if and only if the original square has a lifting. -/
theorem left_adjoint_hasLift_iff : HasLift (sq.leftAdjoint adj) ↔ HasLift sq :=
  by
  simp only [has_lift.iff]
  exact Equiv.nonempty_congr (sq.left_adjoint_lift_struct_equiv adj).symm
#align category_theory.comm_sq.left_adjoint_has_lift_iff CategoryTheory.CommSq.left_adjoint_hasLift_iff

instance [HasLift sq] : HasLift (sq.leftAdjoint adj) :=
  by
  rw [left_adjoint_has_lift_iff]
  infer_instance

end

end CommSq

namespace Adjunction

/- warning: category_theory.adjunction.has_lifting_property_iff -> CategoryTheory.Adjunction.hasLiftingProperty_iff is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} {D : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] [_inst_2 : CategoryTheory.Category.{u4, u2} D] {G : CategoryTheory.Functor.{u3, u4, u1, u2} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u4, u3, u2, u1} D _inst_2 C _inst_1}, (CategoryTheory.Adjunction.{u3, u4, u1, u2} C _inst_1 D _inst_2 G F) -> (forall {A : C} {B : C} {X : D} {Y : D} (i : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) A B) (p : Quiver.Hom.{succ u4, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} D (CategoryTheory.Category.toCategoryStruct.{u4, u2} D _inst_2)) X Y), Iff (CategoryTheory.HasLiftingProperty.{u2, u4} D _inst_2 (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A) (CategoryTheory.Functor.obj.{u3, u4, u1, u2} C _inst_1 D _inst_2 G B) X Y (CategoryTheory.Functor.map.{u3, u4, u1, u2} C _inst_1 D _inst_2 G A B i) p) (CategoryTheory.HasLiftingProperty.{u1, u3} C _inst_1 A B (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X) (CategoryTheory.Functor.obj.{u4, u3, u2, u1} D _inst_2 C _inst_1 F Y) i (CategoryTheory.Functor.map.{u4, u3, u2, u1} D _inst_2 C _inst_1 F X Y p)))
but is expected to have type
  forall {C : Type.{u2}} {D : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u4, u2} C] [_inst_2 : CategoryTheory.Category.{u3, u1} D] {G : CategoryTheory.Functor.{u4, u3, u2, u1} C _inst_1 D _inst_2} {F : CategoryTheory.Functor.{u3, u4, u1, u2} D _inst_2 C _inst_1}, (CategoryTheory.Adjunction.{u4, u3, u2, u1} C _inst_1 D _inst_2 G F) -> (forall {A : C} {B : C} {X : D} {Y : D} (i : Quiver.Hom.{succ u4, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) A B) (p : Quiver.Hom.{succ u3, u1} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) X Y), Iff (CategoryTheory.HasLiftingProperty.{u1, u3} D _inst_2 (Prefunctor.obj.{succ u4, succ u3, u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} C _inst_1 D _inst_2 G) A) (Prefunctor.obj.{succ u4, succ u3, u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} C _inst_1 D _inst_2 G) B) X Y (Prefunctor.map.{succ u4, succ u3, u2, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u4, u3, u2, u1} C _inst_1 D _inst_2 G) A B i) p) (CategoryTheory.HasLiftingProperty.{u2, u4} C _inst_1 A B (Prefunctor.obj.{succ u3, succ u4, u1, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} D _inst_2 C _inst_1 F) X) (Prefunctor.obj.{succ u3, succ u4, u1, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} D _inst_2 C _inst_1 F) Y) i (Prefunctor.map.{succ u3, succ u4, u1, u2} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} D (CategoryTheory.Category.toCategoryStruct.{u3, u1} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u2} C (CategoryTheory.Category.toCategoryStruct.{u4, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u1, u2} D _inst_2 C _inst_1 F) X Y p)))
Case conversion may be inaccurate. Consider using '#align category_theory.adjunction.has_lifting_property_iff CategoryTheory.Adjunction.hasLiftingProperty_iffₓ'. -/
theorem hasLiftingProperty_iff (adj : G ⊣ F) {A B : C} {X Y : D} (i : A ⟶ B) (p : X ⟶ Y) :
    HasLiftingProperty (G.map i) p ↔ HasLiftingProperty i (F.map p) :=
  by
  constructor <;> intro <;> constructor <;> intro f g sq
  · rw [← sq.left_adjoint_has_lift_iff adj]
    infer_instance
  · rw [← sq.right_adjoint_has_lift_iff adj]
    infer_instance
#align category_theory.adjunction.has_lifting_property_iff CategoryTheory.Adjunction.hasLiftingProperty_iff

end Adjunction

end CategoryTheory

