import Mathbin.CategoryTheory.Functor

/-!
# Unbundled functors, as a typeclass decorating the object-level function.
-/


namespace CategoryTheory

universe v v‚ÇÅ v‚ÇÇ v‚ÇÉ u u‚ÇÅ u‚ÇÇ u‚ÇÉ

variable{C : Type u‚ÇÅ}[category.{v‚ÇÅ} C]{D : Type u‚ÇÇ}[category.{v‚ÇÇ} D]

/-- A unbundled functor. -/
class functorial(F : C ‚Üí D) : Type max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ where 
  map : ‚àÄ {X Y : C}, (X ‚ü∂ Y) ‚Üí (F X ‚ü∂ F Y)
  map_id' : ‚àÄ (X : C), map (ùüô X) = ùüô (F X) :=  by 
  runTac 
    obviously 
  map_comp' : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map (f ‚â´ g) = map f ‚â´ map g :=  by 
  runTac 
    obviously

/--
If `F : C ‚Üí D` (just a function) has `[functorial F]`,
we can write `map F f : F X ‚ü∂ F Y` for the action of `F` on a morphism `f : X ‚ü∂ Y`.
-/
def map (F : C ‚Üí D) [functorial.{v‚ÇÅ, v‚ÇÇ} F] {X Y : C} (f : X ‚ü∂ Y) : F X ‚ü∂ F Y :=
  functorial.map.{v‚ÇÅ, v‚ÇÇ} f

@[simp]
theorem map_as_map {F : C ‚Üí D} [functorial.{v‚ÇÅ, v‚ÇÇ} F] {X Y : C} {f : X ‚ü∂ Y} : functorial.map.{v‚ÇÅ, v‚ÇÇ} f = map F f :=
  rfl

@[simp]
theorem functorial.map_id {F : C ‚Üí D} [functorial.{v‚ÇÅ, v‚ÇÇ} F] {X : C} : map F (ùüô X) = ùüô (F X) :=
  functorial.map_id' X

@[simp]
theorem functorial.map_comp {F : C ‚Üí D} [functorial.{v‚ÇÅ, v‚ÇÇ} F] {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} :
  map F (f ‚â´ g) = map F f ‚â´ map F g :=
  functorial.map_comp' f g

namespace Functor

/--
Bundle a functorial function as a functor.
-/
def of (F : C ‚Üí D) [I : functorial.{v‚ÇÅ, v‚ÇÇ} F] : C ‚•§ D :=
  { I with obj := F }

end Functor

instance  (F : C ‚•§ D) : functorial.{v‚ÇÅ, v‚ÇÇ} F.obj :=
  { F with  }

@[simp]
theorem map_functorial_obj (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) : map F.obj f = F.map f :=
  rfl

instance functorial_id : functorial.{v‚ÇÅ, v‚ÇÅ} (id : C ‚Üí C) :=
  { map := fun X Y f => f }

section 

variable{E : Type u‚ÇÉ}[category.{v‚ÇÉ} E]

/--
`G ‚àò F` is a functorial if both `F` and `G` are.
-/
def functorial_comp (F : C ‚Üí D) [functorial.{v‚ÇÅ, v‚ÇÇ} F] (G : D ‚Üí E) [functorial.{v‚ÇÇ, v‚ÇÉ} G] :
  functorial.{v‚ÇÅ, v‚ÇÉ} (G ‚àò F) :=
  { functor.of F ‚ãô functor.of G with  }

end 

end CategoryTheory

