/-
Copyright (c) 2020 David Wärn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Wärn

! This file was ported from Lean 3 source module category_theory.action
! leanprover-community/mathlib commit f2b757fc5c341d88741b9c4630b1e8ba973c5726
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Elements
import Mathbin.CategoryTheory.IsConnected
import Mathbin.CategoryTheory.SingleObj
import Mathbin.GroupTheory.GroupAction.Quotient
import Mathbin.GroupTheory.SemidirectProduct

/-!
# Actions as functors and as categories

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

From a multiplicative action M ↻ X, we can construct a functor from M to the category of
types, mapping the single object of M to X and an element `m : M` to map `X → X` given by
multiplication by `m`.
  This functor induces a category structure on X -- a special case of the category of elements.
A morphism `x ⟶ y` in this category is simply a scalar `m : M` such that `m • x = y`. In the case
where M is a group, this category is a groupoid -- the `action groupoid'.
-/


open MulAction SemidirectProduct

namespace CategoryTheory

universe u

variable (M : Type _) [Monoid M] (X : Type u) [MulAction M X]

#print CategoryTheory.actionAsFunctor /-
/-- A multiplicative action M ↻ X viewed as a functor mapping the single object of M to X
  and an element `m : M` to the map `X → X` given by multiplication by `m`. -/
@[simps]
def actionAsFunctor : SingleObj M ⥤ Type u
    where
  obj _ := X
  map _ _ := (· • ·)
  map_id' _ := funext <| MulAction.one_smul
  map_comp' _ _ _ f g := funext fun x => (smul_smul g f x).symm
#align category_theory.action_as_functor CategoryTheory.actionAsFunctor
-/

#print CategoryTheory.ActionCategory /-
/-- A multiplicative action M ↻ X induces a category strucure on X, where a morphism
 from x to y is a scalar taking x to y. Due to implementation details, the object type
 of this category is not equal to X, but is in bijection with X. -/
def ActionCategory :=
  (actionAsFunctor M X).Elements deriving Category
#align category_theory.action_category CategoryTheory.ActionCategory
-/

namespace ActionCategory

#print CategoryTheory.ActionCategory.π /-
/-- The projection from the action category to the monoid, mapping a morphism to its
  label. -/
def π : ActionCategory M X ⥤ SingleObj M :=
  CategoryOfElements.π _
#align category_theory.action_category.π CategoryTheory.ActionCategory.π
-/

/- warning: category_theory.action_category.π_map -> CategoryTheory.ActionCategory.π_map is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u2}) [_inst_1 : Monoid.{u2} M] (X : Type.{u1}) [_inst_2 : MulAction.{u2, u1} M X _inst_1] (p : CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (q : CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (f : Quiver.Hom.{succ u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2))) p q), Eq.{succ u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (CategoryTheory.Functor.obj.{u2, u2, u1, 0} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) (CategoryTheory.ActionCategory.π.{u1, u2} M _inst_1 X _inst_2) p) (CategoryTheory.Functor.obj.{u2, u2, u1, 0} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) (CategoryTheory.ActionCategory.π.{u1, u2} M _inst_1 X _inst_2) q)) (CategoryTheory.Functor.map.{u2, u2, u1, 0} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) (CategoryTheory.ActionCategory.π.{u1, u2} M _inst_1 X _inst_2) p q f) (Subtype.val.{succ u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) p) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) q)) (fun (f : Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) p) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) q)) => Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) q)) (CategoryTheory.Functor.map.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) p) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) q) f (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) p)) (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) q)) f)
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Monoid.{u1} M] (X : Type.{u2}) [_inst_2 : MulAction.{u1, u2} M X _inst_1] (p : CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (q : CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (f : Quiver.Hom.{succ u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2))) p q), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Prefunctor.obj.{succ u1, succ u1, u2, 0} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2))) (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, 0} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) (CategoryTheory.ActionCategory.π.{u2, u1} M _inst_1 X _inst_2)) p) (Prefunctor.obj.{succ u1, succ u1, u2, 0} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2))) (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, 0} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) (CategoryTheory.ActionCategory.π.{u2, u1} M _inst_1 X _inst_2)) q)) (Prefunctor.map.{succ u1, succ u1, u2, 0} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2))) (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, 0} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) (CategoryTheory.ActionCategory.π.{u2, u1} M _inst_1 X _inst_2)) p q f) (Subtype.val.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) p) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) q)) (fun (f : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) p) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) q)) => Eq.{succ u2} (Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) q)) (Prefunctor.map.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) p) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) q) f (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) p)) (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) q)) f)
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.π_map CategoryTheory.ActionCategory.π_mapₓ'. -/
@[simp]
theorem π_map (p q : ActionCategory M X) (f : p ⟶ q) : (π M X).map f = f.val :=
  rfl
#align category_theory.action_category.π_map CategoryTheory.ActionCategory.π_map

/- warning: category_theory.action_category.π_obj -> CategoryTheory.ActionCategory.π_obj is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u2}) [_inst_1 : Monoid.{u2} M] (X : Type.{u1}) [_inst_2 : MulAction.{u2, u1} M X _inst_1] (p : CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2), Eq.{1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Functor.obj.{u2, u2, u1, 0} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) (CategoryTheory.ActionCategory.π.{u1, u2} M _inst_1 X _inst_2) p) (CategoryTheory.SingleObj.star.{u2} M)
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Monoid.{u1} M] (X : Type.{u2}) [_inst_2 : MulAction.{u1, u2} M X _inst_1] (p : CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2), Eq.{1} (CategoryTheory.SingleObj.{u1} M) (Prefunctor.obj.{succ u1, succ u1, u2, 0} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2))) (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, 0} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) (CategoryTheory.ActionCategory.π.{u2, u1} M _inst_1 X _inst_2)) p) (CategoryTheory.SingleObj.star.{u1} M)
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.π_obj CategoryTheory.ActionCategory.π_objₓ'. -/
@[simp]
theorem π_obj (p : ActionCategory M X) : (π M X).obj p = SingleObj.star M :=
  Unit.ext
#align category_theory.action_category.π_obj CategoryTheory.ActionCategory.π_obj

variable {M X}

#print CategoryTheory.ActionCategory.back /-
/-- The canonical map `action_category M X → X`. It is given by `λ x, x.snd`, but
  has a more explicit type. -/
protected def back : ActionCategory M X → X := fun x => x.snd
#align category_theory.action_category.back CategoryTheory.ActionCategory.back
-/

instance : CoeTC X (ActionCategory M X) :=
  ⟨fun x => ⟨(), x⟩⟩

/- warning: category_theory.action_category.coe_back -> CategoryTheory.ActionCategory.coe_back is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] {X : Type.{u1}} [_inst_2 : MulAction.{u2, u1} M X _inst_1] (x : X), Eq.{succ u1} X (CategoryTheory.ActionCategory.back.{u1, u2} M _inst_1 X _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} M _inst_1 X _inst_2))) x)) x
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {X : Type.{u2}} [_inst_2 : MulAction.{u1, u2} M X _inst_1] (x : X), Eq.{succ u2} X (CategoryTheory.ActionCategory.back.{u2, u1} M _inst_1 X _inst_2 (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) x
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.coe_back CategoryTheory.ActionCategory.coe_backₓ'. -/
@[simp]
theorem coe_back (x : X) : (↑x : ActionCategory M X).back = x :=
  rfl
#align category_theory.action_category.coe_back CategoryTheory.ActionCategory.coe_back

/- warning: category_theory.action_category.back_coe -> CategoryTheory.ActionCategory.back_coe is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] {X : Type.{u1}} [_inst_2 : MulAction.{u2, u1} M X _inst_1] (x : CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2), Eq.{succ u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} M _inst_1 X _inst_2))) (CategoryTheory.ActionCategory.back.{u1, u2} M _inst_1 X _inst_2 x)) x
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {X : Type.{u2}} [_inst_2 : MulAction.{u1, u2} M X _inst_1] (x : CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2), Eq.{succ u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit (CategoryTheory.ActionCategory.back.{u2, u1} M _inst_1 X _inst_2 x)) x
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.back_coe CategoryTheory.ActionCategory.back_coeₓ'. -/
@[simp]
theorem back_coe (x : ActionCategory M X) : ↑x.back = x := by ext <;> rfl
#align category_theory.action_category.back_coe CategoryTheory.ActionCategory.back_coe

variable (M X)

#print CategoryTheory.ActionCategory.objEquiv /-
/-- An object of the action category given by M ↻ X corresponds to an element of X. -/
def objEquiv : X ≃ ActionCategory M X where
  toFun := coe
  invFun x := x.back
  left_inv := coe_back
  right_inv := back_coe
#align category_theory.action_category.obj_equiv CategoryTheory.ActionCategory.objEquiv
-/

/- warning: category_theory.action_category.hom_as_subtype -> CategoryTheory.ActionCategory.hom_as_subtype is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u2}) [_inst_1 : Monoid.{u2} M] (X : Type.{u1}) [_inst_2 : MulAction.{u2, u1} M X _inst_1] (p : CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (q : CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2), Eq.{succ (succ u2)} Type.{u2} (Quiver.Hom.{succ u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2))) p q) (Subtype.{succ u2} M (fun (m : M) => Eq.{succ u1} X (SMul.smul.{u2, u1} M X (MulAction.toHasSmul.{u2, u1} M X _inst_1 _inst_2) m (CategoryTheory.ActionCategory.back.{u1, u2} M _inst_1 X _inst_2 p)) (CategoryTheory.ActionCategory.back.{u1, u2} M _inst_1 X _inst_2 q)))
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Monoid.{u1} M] (X : Type.{u2}) [_inst_2 : MulAction.{u1, u2} M X _inst_1] (p : CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (q : CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2), Eq.{succ (succ u1)} Type.{u1} (Quiver.Hom.{succ u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2))) p q) (Subtype.{succ u1} M (fun (m : M) => Eq.{succ u2} X (HSMul.hSMul.{u1, u2, u2} M X X (instHSMul.{u1, u2} M X (MulAction.toSMul.{u1, u2} M X _inst_1 _inst_2)) m (CategoryTheory.ActionCategory.back.{u2, u1} M _inst_1 X _inst_2 p)) (CategoryTheory.ActionCategory.back.{u2, u1} M _inst_1 X _inst_2 q)))
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.hom_as_subtype CategoryTheory.ActionCategory.hom_as_subtypeₓ'. -/
theorem hom_as_subtype (p q : ActionCategory M X) : (p ⟶ q) = { m : M // m • p.back = q.back } :=
  rfl
#align category_theory.action_category.hom_as_subtype CategoryTheory.ActionCategory.hom_as_subtype

instance [Inhabited X] : Inhabited (ActionCategory M X) :=
  ⟨show X from default⟩

instance [Nonempty X] : Nonempty (ActionCategory M X) :=
  Nonempty.map (objEquiv M X) inferInstance

variable {X} (x : X)

/- warning: category_theory.action_category.stabilizer_iso_End -> CategoryTheory.ActionCategory.stabilizerIsoEnd is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u2}) [_inst_1 : Monoid.{u2} M] {X : Type.{u1}} [_inst_2 : MulAction.{u2, u1} M X _inst_1] (x : X), MulEquiv.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)) (CategoryTheory.End.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} M _inst_1 X _inst_2))) x)) (Submonoid.mul.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)) (Submonoid.mul.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x))
but is expected to have type
  forall (M : Type.{u2}) [_inst_1 : Monoid.{u2} M] {X : Type.{u1}} [_inst_2 : MulAction.{u2, u1} M X _inst_1] (x : X), MulEquiv.{u2, u2} (Subtype.{succ u2} M (fun (x_1 : M) => Membership.mem.{u2, u2} M (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u1, u2} M _inst_1 X _inst_2)) (Sigma.mk.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => Prefunctor.obj.{succ u2, succ u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)) (CategoryTheory.End.mul.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u1, u2} M _inst_1 X _inst_2)) (Sigma.mk.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => Prefunctor.obj.{succ u2, succ u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2)) c) Unit.unit x))
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.stabilizer_iso_End CategoryTheory.ActionCategory.stabilizerIsoEndₓ'. -/
/-- The stabilizer of a point is isomorphic to the endomorphism monoid at the
  corresponding point. In fact they are definitionally equivalent. -/
def stabilizerIsoEnd : Stabilizer.submonoid M x ≃* End (↑x : ActionCategory M X) :=
  MulEquiv.refl _
#align category_theory.action_category.stabilizer_iso_End CategoryTheory.ActionCategory.stabilizerIsoEnd

/- warning: category_theory.action_category.stabilizer_iso_End_apply -> CategoryTheory.ActionCategory.stabilizerIsoEnd_apply is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u2}) [_inst_1 : Monoid.{u2} M] {X : Type.{u1}} [_inst_2 : MulAction.{u2, u1} M X _inst_1] (x : X) (f : coeSort.{succ u2, succ (succ u2)} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)), Eq.{succ u2} (CategoryTheory.End.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} M _inst_1 X _inst_2))) x)) (MulEquiv.toFun.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)) (CategoryTheory.End.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} M _inst_1 X _inst_2))) x)) (Submonoid.mul.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)) (Submonoid.mul.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)) (CategoryTheory.ActionCategory.stabilizerIsoEnd.{u1, u2} M _inst_1 X _inst_2 x) f) f
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Monoid.{u1} M] {X : Type.{u2}} [_inst_2 : MulAction.{u1, u2} M X _inst_1] (x : X) (f : Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) => CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) f) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x)) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x))) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (fun (a : Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) => CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x)) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x))) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x)) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x))) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (MulEquivClass.toEquivLike.{u1, u1, u1} (MulEquiv.{u1, u1} (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x)) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x))) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x)) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x)) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)))))) (CategoryTheory.ActionCategory.stabilizerIsoEnd.{u2, u1} M _inst_1 X _inst_2 x) f) f
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.stabilizer_iso_End_apply CategoryTheory.ActionCategory.stabilizerIsoEnd_applyₓ'. -/
@[simp]
theorem stabilizerIsoEnd_apply (f : Stabilizer.submonoid M x) :
    (stabilizerIsoEnd M x).toFun f = f :=
  rfl
#align category_theory.action_category.stabilizer_iso_End_apply CategoryTheory.ActionCategory.stabilizerIsoEnd_apply

/- warning: category_theory.action_category.stabilizer_iso_End_symm_apply -> CategoryTheory.ActionCategory.stabilizerIsoEnd_symm_apply is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u2}) [_inst_1 : Monoid.{u2} M] {X : Type.{u1}} [_inst_2 : MulAction.{u2, u1} M X _inst_1] (x : X) (f : CategoryTheory.End.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} M _inst_1 X _inst_2))) x)), Eq.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)) (MulEquiv.invFun.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submonoid.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) M (Submonoid.setLike.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1))) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)) (CategoryTheory.End.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} M _inst_1 X _inst_2))) x)) (Submonoid.mul.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)) (Submonoid.mul.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1) (MulAction.Stabilizer.submonoid.{u2, u1} M X _inst_1 _inst_2 x)) (CategoryTheory.ActionCategory.stabilizerIsoEnd.{u1, u2} M _inst_1 X _inst_2 x) f) f
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Monoid.{u1} M] {X : Type.{u2}} [_inst_2 : MulAction.{u1, u2} M X _inst_1] (x : X) (f : CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) => Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) f) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (fun (a : CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) => Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (MulEquivClass.toEquivLike.{u1, u1, u1} (MulEquiv.{u1, u1} (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x)) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x)))))) (MulEquiv.symm.{u1, u1} (Subtype.{succ u1} M (fun (x_1 : M) => Membership.mem.{u1, u1} M (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) M (Submonoid.instSetLikeSubmonoid.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) x_1 (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x))) (CategoryTheory.End.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (Submonoid.mul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1) (MulAction.Stabilizer.submonoid.{u1, u2} M X _inst_1 _inst_2 x)) (CategoryTheory.End.mul.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) Unit.unit x)) (CategoryTheory.ActionCategory.stabilizerIsoEnd.{u2, u1} M _inst_1 X _inst_2 x)) f) f
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.stabilizer_iso_End_symm_apply CategoryTheory.ActionCategory.stabilizerIsoEnd_symm_applyₓ'. -/
@[simp]
theorem stabilizerIsoEnd_symm_apply (f : End _) : (stabilizerIsoEnd M x).invFun f = f :=
  rfl
#align category_theory.action_category.stabilizer_iso_End_symm_apply CategoryTheory.ActionCategory.stabilizerIsoEnd_symm_apply

variable {M X}

/- warning: category_theory.action_category.id_val -> CategoryTheory.ActionCategory.id_val is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] {X : Type.{u1}} [_inst_2 : MulAction.{u2, u1} M X _inst_1] (x : CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2), Eq.{succ u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) (Subtype.val.{succ u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) (fun (f : Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) => Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) (CategoryTheory.Functor.map.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) f (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) (CategoryTheory.CategoryStruct.id.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2)) x)) (OfNat.ofNat.{u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) 1 (OfNat.mk.{u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) 1 (One.one.{u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) (MulOneClass.toHasOne.{u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) (Monoid.toMulOneClass.{u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) _inst_1)))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {X : Type.{u2}} [_inst_2 : MulAction.{u1, u2} M X _inst_1] (x : CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) (Subtype.val.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) (fun (f : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) => Eq.{succ u2} (Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) (Prefunctor.map.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) f (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) (CategoryTheory.CategoryStruct.id.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) x)) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) 1 (One.toOfNat1.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) (Monoid.toOne.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) _inst_1)))
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.id_val CategoryTheory.ActionCategory.id_valₓ'. -/
@[simp]
protected theorem id_val (x : ActionCategory M X) : Subtype.val (𝟙 x) = 1 :=
  rfl
#align category_theory.action_category.id_val CategoryTheory.ActionCategory.id_val

/- warning: category_theory.action_category.comp_val -> CategoryTheory.ActionCategory.comp_val is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] {X : Type.{u1}} [_inst_2 : MulAction.{u2, u1} M X _inst_1] {x : CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2} {y : CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2} {z : CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2} (f : Quiver.Hom.{succ u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2))) x y) (g : Quiver.Hom.{succ u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2))) y z), Eq.{succ u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (Subtype.val.{succ u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (fun (f : Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) => Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (CategoryTheory.Functor.map.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z) f (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (CategoryTheory.CategoryStruct.comp.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} M _inst_1 X _inst_2) (CategoryTheory.ActionCategory.category.{u2, u1} M _inst_1 X _inst_2)) x y z f g)) (HMul.hMul.{u2, u2, u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (instHMul.{u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (MulOneClass.toHasMul.{u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (Monoid.toMulOneClass.{u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) _inst_1))) (Subtype.val.{succ u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) y) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (fun (f : Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) y) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) => Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) (CategoryTheory.Functor.map.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) y) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z) f (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) y)) (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) z)) g) (Subtype.val.{succ u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) y)) (fun (f : Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) y)) => Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) y)) (CategoryTheory.Functor.map.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) y) f (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) x)) (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} M) (fun (c : CategoryTheory.SingleObj.{u2} M) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} M) (CategoryTheory.SingleObj.category.{u2} M _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} M _inst_1 X _inst_2) c) y)) f))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {X : Type.{u2}} [_inst_2 : MulAction.{u1, u2} M X _inst_1] {x : CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2} {y : CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2} {z : CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2} (f : Quiver.Hom.{succ u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2))) x y) (g : Quiver.Hom.{succ u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2))) y z), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) (Subtype.val.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) (fun (f : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) => Eq.{succ u2} (Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) (Prefunctor.map.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z) f (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) (CategoryTheory.CategoryStruct.comp.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (CategoryTheory.ActionCategory.{u2, u1} M _inst_1 X _inst_2) (CategoryTheory.instCategoryActionCategory.{u2, u1} M _inst_1 X _inst_2)) x y z f g)) (HMul.hMul.{u1, u1, u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y)) (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) (instHMul.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) (MulOneClass.toMul.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) (Monoid.toMulOneClass.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) _inst_1))) (Subtype.val.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) (fun (f : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) => Eq.{succ u2} (Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) (Prefunctor.map.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z) f (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y)) (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) z)) g) (Subtype.val.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y)) (fun (f : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y)) => Eq.{succ u2} (Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y)) (Prefunctor.map.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y) f (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) x)) (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} M) (fun (c : CategoryTheory.SingleObj.{u1} M) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} M) (CategoryTheory.SingleObj.category.{u1} M _inst_1) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} M _inst_1 X _inst_2)) c) y)) f))
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.comp_val CategoryTheory.ActionCategory.comp_valₓ'. -/
@[simp]
protected theorem comp_val {x y z : ActionCategory M X} (f : x ⟶ y) (g : y ⟶ z) :
    (f ≫ g).val = g.val * f.val :=
  rfl
#align category_theory.action_category.comp_val CategoryTheory.ActionCategory.comp_val

instance [IsPretransitive M X] [Nonempty X] : IsConnected (ActionCategory M X) :=
  zigzag_isConnected fun x y =>
    Relation.ReflTransGen.single <|
      Or.inl <| nonempty_subtype.mpr (show _ from exists_smul_eq M x.back y.back)

section Group

variable {G : Type _} [Group G] [MulAction G X]

noncomputable instance : Groupoid (ActionCategory G X) :=
  CategoryTheory.groupoidOfElements _

#print CategoryTheory.ActionCategory.endMulEquivSubgroup /-
/-- Any subgroup of `G` is a vertex group in its action groupoid. -/
def endMulEquivSubgroup (H : Subgroup G) : End (objEquiv G (G ⧸ H) ↑(1 : G)) ≃* H :=
  MulEquiv.trans (stabilizerIsoEnd G ((1 : G) : G ⧸ H)).symm
    (MulEquiv.subgroupCongr <| stabilizer_quotient H)
#align category_theory.action_category.End_mul_equiv_subgroup CategoryTheory.ActionCategory.endMulEquivSubgroup
-/

/- warning: category_theory.action_category.hom_of_pair -> CategoryTheory.ActionCategory.homOfPair is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {G : Type.{u2}} [_inst_3 : Group.{u2} G] [_inst_4 : MulAction.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))] (t : X) (g : G), Quiver.Hom.{succ u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.category.{u2, u1} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) (SMul.smul.{u2, u1} G X (MulAction.toHasSmul.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4) (Inv.inv.{u2} G (DivInvMonoid.toHasInv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) g) t)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) t)
but is expected to have type
  forall {X : Type.{u1}} {G : Type.{u2}} [_inst_3 : Group.{u2} G] [_inst_4 : MulAction.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))] (t : X) (g : G), Quiver.Hom.{succ u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.instCategoryActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) (Sigma.mk.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => Prefunctor.obj.{succ u2, succ u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4)) c) Unit.unit (HSMul.hSMul.{u2, u1, u1} G X X (instHSMul.{u2, u1} G X (MulAction.toSMul.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4)) (Inv.inv.{u2} G (InvOneClass.toInv.{u2} G (DivInvOneMonoid.toInvOneClass.{u2} G (DivisionMonoid.toDivInvOneMonoid.{u2} G (Group.toDivisionMonoid.{u2} G _inst_3)))) g) t)) (Sigma.mk.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => Prefunctor.obj.{succ u2, succ u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4)) c) Unit.unit t)
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.hom_of_pair CategoryTheory.ActionCategory.homOfPairₓ'. -/
/-- A target vertex `t` and a scalar `g` determine a morphism in the action groupoid. -/
def homOfPair (t : X) (g : G) : ↑(g⁻¹ • t) ⟶ (t : ActionCategory G X) :=
  Subtype.mk g (smul_inv_smul g t)
#align category_theory.action_category.hom_of_pair CategoryTheory.ActionCategory.homOfPair

/- warning: category_theory.action_category.hom_of_pair.val -> CategoryTheory.ActionCategory.homOfPair.val is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {G : Type.{u2}} [_inst_3 : Group.{u2} G] [_inst_4 : MulAction.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))] (t : X) (g : G), Eq.{succ u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) (SMul.smul.{u2, u1} G X (MulAction.toHasSmul.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4) (Inv.inv.{u2} G (DivInvMonoid.toHasInv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) g) t))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) t))) (Subtype.val.{succ u2} (Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) (SMul.smul.{u2, u1} G X (MulAction.toHasSmul.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4) (Inv.inv.{u2} G (DivInvMonoid.toHasInv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) g) t))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) t))) (fun (f : Quiver.Hom.{succ u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) (SMul.smul.{u2, u1} G X (MulAction.toHasSmul.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4) (Inv.inv.{u2} G (DivInvMonoid.toHasInv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) g) t))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) t))) => Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) t))) (CategoryTheory.Functor.map.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) (SMul.smul.{u2, u1} G X (MulAction.toHasSmul.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4) (Inv.inv.{u2} G (DivInvMonoid.toHasInv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) g) t))) (Sigma.fst.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) t)) f (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) (SMul.smul.{u2, u1} G X (MulAction.toHasSmul.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4) (Inv.inv.{u2} G (DivInvMonoid.toHasInv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) g) t)))) (Sigma.snd.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => CategoryTheory.Functor.obj.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) c) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) t))) (CategoryTheory.ActionCategory.homOfPair.{u1, u2} X G _inst_3 _inst_4 t g)) g
but is expected to have type
  forall {X : Type.{u2}} {G : Type.{u1}} [_inst_3 : Group.{u1} G] [_inst_4 : MulAction.{u1, u2} G X (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))] (t : X) (g : G), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit (HSMul.hSMul.{u1, u2, u2} G X X (instHSMul.{u1, u2} G X (MulAction.toSMul.{u1, u2} G X (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_3)))) g) t))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit t))) (Subtype.val.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit (HSMul.hSMul.{u1, u2, u2} G X X (instHSMul.{u1, u2} G X (MulAction.toSMul.{u1, u2} G X (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_3)))) g) t))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit t))) (fun (f : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit (HSMul.hSMul.{u1, u2, u2} G X X (instHSMul.{u1, u2} G X (MulAction.toSMul.{u1, u2} G X (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_3)))) g) t))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit t))) => Eq.{succ u2} (Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit t))) (Prefunctor.map.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit (HSMul.hSMul.{u1, u2, u2} G X X (instHSMul.{u1, u2} G X (MulAction.toSMul.{u1, u2} G X (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_3)))) g) t))) (Sigma.fst.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit t)) f (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit (HSMul.hSMul.{u1, u2, u2} G X X (instHSMul.{u1, u2} G X (MulAction.toSMul.{u1, u2} G X (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) _inst_4)) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_3)))) g) t)))) (Sigma.snd.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) (Sigma.mk.{0, u2} (CategoryTheory.SingleObj.{u1} G) (fun (c : CategoryTheory.SingleObj.{u1} G) => Prefunctor.obj.{succ u1, succ u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, 0, succ u2} (CategoryTheory.SingleObj.{u1} G) (CategoryTheory.SingleObj.category.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3))) Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.actionAsFunctor.{u2, u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_3)) X _inst_4)) c) Unit.unit t))) (CategoryTheory.ActionCategory.homOfPair.{u2, u1} X G _inst_3 _inst_4 t g)) g
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.hom_of_pair.val CategoryTheory.ActionCategory.homOfPair.valₓ'. -/
@[simp]
theorem homOfPair.val (t : X) (g : G) : (homOfPair t g).val = g :=
  rfl
#align category_theory.action_category.hom_of_pair.val CategoryTheory.ActionCategory.homOfPair.val

/- warning: category_theory.action_category.cases -> CategoryTheory.ActionCategory.cases is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {G : Type.{u2}} [_inst_3 : Group.{u2} G] [_inst_4 : MulAction.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))] {P : forall {{a : CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4}} {{b : CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4}}, (Quiver.Hom.{succ u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.category.{u2, u1} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) a b) -> Sort.{u3}}, (forall (t : X) (g : G), P ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) (SMul.smul.{u2, u1} G X (MulAction.toHasSmul.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4) (Inv.inv.{u2} G (DivInvMonoid.toHasInv.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) g) t)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (HasLiftT.mk.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CoeTCₓ.coe.{succ u1, succ u1} X (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.hasCoeT.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) t) (CategoryTheory.ActionCategory.homOfPair.{u1, u2} X G _inst_3 _inst_4 t g)) -> (forall {{a : CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4}} {{b : CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4}} (f : Quiver.Hom.{succ u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.ActionCategory.category.{u2, u1} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) a b), P a b f)
but is expected to have type
  forall {X : Type.{u1}} {G : Type.{u2}} [_inst_3 : Group.{u2} G] [_inst_4 : MulAction.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))] {P : forall {{a : CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4}} {{b : CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4}}, (Quiver.Hom.{succ u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.instCategoryActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) a b) -> Sort.{u3}}, (forall (t : X) (g : G), P (Sigma.mk.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => Prefunctor.obj.{succ u2, succ u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4)) c) Unit.unit (HSMul.hSMul.{u2, u1, u1} G X X (instHSMul.{u2, u1} G X (MulAction.toSMul.{u2, u1} G X (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) _inst_4)) (Inv.inv.{u2} G (InvOneClass.toInv.{u2} G (DivInvOneMonoid.toInvOneClass.{u2} G (DivisionMonoid.toDivInvOneMonoid.{u2} G (Group.toDivisionMonoid.{u2} G _inst_3)))) g) t)) (Sigma.mk.{0, u1} (CategoryTheory.SingleObj.{u2} G) (fun (c : CategoryTheory.SingleObj.{u2} G) => Prefunctor.obj.{succ u2, succ u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.CategoryStruct.toQuiver.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.Category.toCategoryStruct.{u2, 0} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, 0, succ u1} (CategoryTheory.SingleObj.{u2} G) (CategoryTheory.SingleObj.category.{u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3))) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.actionAsFunctor.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4)) c) Unit.unit t) (CategoryTheory.ActionCategory.homOfPair.{u1, u2} X G _inst_3 _inst_4 t g)) -> (forall {{a : CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4}} {{b : CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4}} (f : Quiver.Hom.{succ u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.Category.toCategoryStruct.{u2, u1} (CategoryTheory.ActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4) (CategoryTheory.instCategoryActionCategory.{u1, u2} G (DivInvMonoid.toMonoid.{u2} G (Group.toDivInvMonoid.{u2} G _inst_3)) X _inst_4))) a b), P a b f)
Case conversion may be inaccurate. Consider using '#align category_theory.action_category.cases CategoryTheory.ActionCategory.casesₓ'. -/
/-- Any morphism in the action groupoid is given by some pair. -/
protected def cases {P : ∀ ⦃a b : ActionCategory G X⦄, (a ⟶ b) → Sort _}
    (hyp : ∀ t g, P (homOfPair t g)) ⦃a b⦄ (f : a ⟶ b) : P f :=
  by
  refine' cast _ (hyp b.back f.val)
  rcases a with ⟨⟨⟩, a : X⟩
  rcases b with ⟨⟨⟩, b : X⟩
  rcases f with ⟨g : G, h : g • a = b⟩
  cases inv_smul_eq_iff.mpr h.symm
  rfl
#align category_theory.action_category.cases CategoryTheory.ActionCategory.cases

variable {H : Type _} [Group H]

#print CategoryTheory.ActionCategory.curry /-
/-- Given `G` acting on `X`, a functor from the corresponding action groupoid to a group `H`
    can be curried to a group homomorphism `G →* (X → H) ⋊ G`. -/
@[simps]
def curry (F : ActionCategory G X ⥤ SingleObj H) : G →* (X → H) ⋊[mulAutArrow] G :=
  have F_map_eq : ∀ {a b} {f : a ⟶ b}, F.map f = (F.map (homOfPair b.back f.val) : H) :=
    ActionCategory.cases fun _ _ => rfl
  { toFun := fun g => ⟨fun b => F.map (homOfPair b g), g⟩
    map_one' := by
      congr
      funext
      exact F_map_eq.symm.trans (F.map_id b)
    map_mul' := by
      intro g h
      congr ; funext
      exact F_map_eq.symm.trans (F.map_comp (hom_of_pair (g⁻¹ • b) h) (hom_of_pair b g)) }
#align category_theory.action_category.curry CategoryTheory.ActionCategory.curry
-/

#print CategoryTheory.ActionCategory.uncurry /-
/-- Given `G` acting on `X`, a group homomorphism `φ : G →* (X → H) ⋊ G` can be uncurried to
    a functor from the action groupoid to `H`, provided that `φ g = (_, g)` for all `g`. -/
@[simps]
def uncurry (F : G →* (X → H) ⋊[mulAutArrow] G) (sane : ∀ g, (F g).right = g) :
    ActionCategory G X ⥤ SingleObj H where
  obj _ := ()
  map a b f := (F f.val).left b.back
  map_id' := by
    intro x
    rw [action_category.id_val, F.map_one]
    rfl
  map_comp' := by
    intro x y z f g; revert y z g
    refine' action_category.cases _
    simp [single_obj.comp_as_mul, sane]
#align category_theory.action_category.uncurry CategoryTheory.ActionCategory.uncurry
-/

end Group

end ActionCategory

end CategoryTheory

