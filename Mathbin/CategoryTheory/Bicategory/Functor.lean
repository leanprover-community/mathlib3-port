/-
Copyright (c) 2022 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno

! This file was ported from Lean 3 source module category_theory.bicategory.functor
! leanprover-community/mathlib commit ee05e9ce1322178f0c12004eb93c00d2c8c00ed2
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Bicategory.Basic

/-!
# Oplax functors and pseudofunctors

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

An oplax functor `F` between bicategories `B` and `C` consists of
* a function between objects `F.obj : B ⟶ C`,
* a family of functions between 1-morphisms `F.map : (a ⟶ b) → (F.obj a ⟶ F.obj b)`,
* a family of functions between 2-morphisms `F.map₂ : (f ⟶ g) → (F.map f ⟶ F.map g)`,
* a family of 2-morphisms `F.map_id a : F.map (𝟙 a) ⟶ 𝟙 (F.obj a)`,
* a family of 2-morphisms `F.map_comp f g : F.map (f ≫ g) ⟶ F.map f ≫ F.map g`, and
* certain consistency conditions on them.

A pseudofunctor is an oplax functor whose `map_id` and `map_comp` are isomorphisms. We provide
several constructors for pseudofunctors:
* `pseudofunctor.mk` : the default constructor, which requires `map₂_whisker_left` and
  `map₂_whisker_right` instead of naturality of `map_comp`.
* `pseudofunctor.mk_of_oplax` : construct a pseudofunctor from an oplax functor whose
  `map_id` and `map_comp` are isomorphisms. This constructor uses `iso` to describe isomorphisms.
* `pseudofunctor.mk_of_oplax'` : similar to `mk_of_oplax`, but uses `is_iso` to describe
  isomorphisms.

The additional constructors are useful when constructing a pseudofunctor where the construction
of the oplax functor associated with it is already done. For example, the composition of
pseudofunctors can be defined by using the composition of oplax functors as follows:
```lean
def pseudofunctor.comp (F : pseudofunctor B C) (G : pseudofunctor C D) : pseudofunctor B D :=
mk_of_oplax ((F : oplax_functor B C).comp G)
{ map_id_iso := λ a, (G.map_functor _ _).map_iso (F.map_id a) ≪≫ G.map_id (F.obj a),
  map_comp_iso := λ a b c f g,
    (G.map_functor _ _).map_iso (F.map_comp f g) ≪≫ G.map_comp (F.map f) (F.map g) }
```
although the composition of pseudofunctors in this file is defined by using the default constructor
because `obviously` is smart enough. Similarly, the composition is also defined by using
`mk_of_oplax'` after giving appropriate instances for `is_iso`. The former constructor
`mk_of_oplax` requires isomorphisms as data type `iso`, and so it is useful if you don't want
to forget the definitions of the inverses. On the other hand, the latter constructor
`mk_of_oplax'` is useful if you want to use propositional type class `is_iso`.

## Main definitions

* `category_theory.oplax_functor B C` : an oplax functor between bicategories `B` and `C`
* `category_theory.oplax_functor.comp F G` : the composition of oplax functors
* `category_theory.pseudofunctor B C` : a pseudofunctor between bicategories `B` and `C`
* `category_theory.pseudofunctor.comp F G` : the composition of pseudofunctors

## Future work

There are two types of functors between bicategories, called lax and oplax functors, depending on
the directions of `map_id` and `map_comp`. We may need both in mathlib in the future, but for
now we only define oplax functors.
-/


namespace CategoryTheory

open Category Bicategory

open Bicategory

universe w₁ w₂ w₃ v₁ v₂ v₃ u₁ u₂ u₃

section

variable {B : Type u₁} [Quiver.{v₁ + 1} B] [∀ a b : B, Quiver.{w₁ + 1} (a ⟶ b)]

variable {C : Type u₂} [Quiver.{v₂ + 1} C] [∀ a b : C, Quiver.{w₂ + 1} (a ⟶ b)]

variable {D : Type u₃} [Quiver.{v₃ + 1} D] [∀ a b : D, Quiver.{w₃ + 1} (a ⟶ b)]

#print CategoryTheory.PrelaxFunctor /-
/-- A prelax functor between bicategories consists of functions between objects,
1-morphisms, and 2-morphisms. This structure will be extended to define `oplax_functor`.
-/
structure PrelaxFunctor (B : Type u₁) [Quiver.{v₁ + 1} B] [∀ a b : B, Quiver.{w₁ + 1} (a ⟶ b)]
  (C : Type u₂) [Quiver.{v₂ + 1} C] [∀ a b : C, Quiver.{w₂ + 1} (a ⟶ b)] extends
  Prefunctor B C where
  zipWith {a b : B} {f g : a ⟶ b} : (f ⟶ g) → (map f ⟶ map g)
#align category_theory.prelax_functor CategoryTheory.PrelaxFunctor
-/

/-- The prefunctor between the underlying quivers. -/
add_decl_doc prelax_functor.to_prefunctor

namespace PrelaxFunctor

#print CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor /-
instance hasCoeToPrefunctor : Coe (PrelaxFunctor B C) (Prefunctor B C) :=
  ⟨toPrefunctor⟩
#align category_theory.prelax_functor.has_coe_to_prefunctor CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor
-/

variable (F : PrelaxFunctor B C)

/- warning: category_theory.prelax_functor.to_prefunctor_eq_coe clashes with [anonymous] -> [anonymous]
warning: category_theory.prelax_functor.to_prefunctor_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : Quiver.{succ v₁, u₁} B] [_inst_2 : forall (a : B) (b : B), Quiver.{succ w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B _inst_1 a b)] {C : Type.{u₂}} [_inst_3 : Quiver.{succ v₂, u₂} C] [_inst_4 : forall (a : C) (b : C), Quiver.{succ w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C _inst_3 a b)] (F : CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)), Eq.{max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CategoryTheory.PrelaxFunctor.toPrefunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b) F) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} a b] => self.0) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b))))) F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.prelax_functor.to_prefunctor_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : F.toPrefunctor = F :=
  rfl
#align category_theory.prelax_functor.to_prefunctor_eq_coe [anonymous]

/- warning: category_theory.prelax_functor.to_prefunctor_obj clashes with [anonymous] -> [anonymous]
warning: category_theory.prelax_functor.to_prefunctor_obj -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : Quiver.{succ v₁, u₁} B] [_inst_2 : forall (a : B) (b : B), Quiver.{succ w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B _inst_1 a b)] {C : Type.{u₂}} [_inst_3 : Quiver.{succ v₂, u₂} C] [_inst_4 : forall (a : C) (b : C), Quiver.{succ w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C _inst_3 a b)] (F : CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)), Eq.{max (succ u₁) (succ u₂)} (B -> C) (Prefunctor.obj.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} a b] => self.0) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b))))) F)) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b) F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.prelax_functor.to_prefunctor_obj [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : (F : Prefunctor B C).obj = F.obj :=
  rfl
#align category_theory.prelax_functor.to_prefunctor_obj [anonymous]

/- warning: category_theory.prelax_functor.to_prefunctor_map clashes with [anonymous] -> [anonymous]
warning: category_theory.prelax_functor.to_prefunctor_map -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : Quiver.{succ v₁, u₁} B] [_inst_2 : forall (a : B) (b : B), Quiver.{succ w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B _inst_1 a b)] {C : Type.{u₂}} [_inst_3 : Quiver.{succ v₂, u₂} C] [_inst_4 : forall (a : C) (b : C), Quiver.{succ w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C _inst_3 a b)] (F : CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)), Eq.{max (succ u₁) (succ v₁) (succ v₂)} (forall {X : B} {Y : B}, (Quiver.Hom.{succ v₁, u₁} B _inst_1 X Y) -> (Quiver.Hom.{succ v₂, u₂} C _inst_3 (Prefunctor.obj.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} a b] => self.0) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b))))) F) X) (Prefunctor.obj.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} a b] => self.0) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b))))) F) Y))) (Prefunctor.map.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} a b] => self.0) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (max (succ u₁) (succ v₁) (succ v₂)) (succ u₁) (succ u₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b)) (Prefunctor.{succ v₁, succ v₂, u₁, u₂} B _inst_1 C _inst_3) (CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b))))) F)) (CategoryTheory.PrelaxFunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 (fun (a : B) (b : B) => _inst_2 a b) C _inst_3 (fun (a : C) (b : C) => _inst_4 a b) F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.prelax_functor.to_prefunctor_map [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : @Prefunctor.map B _ C _ F = @map _ _ _ _ _ _ F :=
  rfl
#align category_theory.prelax_functor.to_prefunctor_map [anonymous]

#print CategoryTheory.PrelaxFunctor.id /-
/-- The identity prelax functor. -/
@[simps]
def id (B : Type u₁) [Quiver.{v₁ + 1} B] [∀ a b : B, Quiver.{w₁ + 1} (a ⟶ b)] : PrelaxFunctor B B :=
  { Prefunctor.id B with zipWith := fun a b f g η => η }
#align category_theory.prelax_functor.id CategoryTheory.PrelaxFunctor.id
-/

instance : Inhabited (PrelaxFunctor B B) :=
  ⟨PrelaxFunctor.id B⟩

#print CategoryTheory.PrelaxFunctor.comp /-
/-- Composition of prelax functors. -/
@[simps]
def comp (F : PrelaxFunctor B C) (G : PrelaxFunctor C D) : PrelaxFunctor B D :=
  { (F : Prefunctor B C).comp ↑G with zipWith := fun a b f g η => G.zipWith (F.zipWith η) }
#align category_theory.prelax_functor.comp CategoryTheory.PrelaxFunctor.comp
-/

end PrelaxFunctor

end

section

variable {B : Type u₁} [Bicategory.{w₁, v₁} B] {C : Type u₂} [Bicategory.{w₂, v₂} C]

variable {D : Type u₃} [Bicategory.{w₃, v₃} D]

/- warning: category_theory.oplax_functor.map₂_associator_aux clashes with [anonymous] -> [anonymous]
warning: category_theory.oplax_functor.map₂_associator_aux -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (obj : B -> C) (map : forall {X : B} {Y : B}, (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) X Y) -> (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj X) (obj Y))), (forall {a : B} {b : B} {f : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b} {g : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b}, (Quiver.Hom.{succ w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) f g) -> (Quiver.Hom.{succ w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj a) (obj b)) (CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj a) (obj b)) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj a) (obj b)) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 (obj a) (obj b)))) (map a b f) (map a b g))) -> (forall {a : B} {b : B} {c : B} (f : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (g : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) b c), Quiver.Hom.{succ w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj a) (obj c)) (CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj a) (obj c)) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj a) (obj c)) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 (obj a) (obj c)))) (map a c (CategoryTheory.CategoryStruct.comp.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1) a b c f g)) (CategoryTheory.CategoryStruct.comp.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2) (obj a) (obj b) (obj c) (map a b f) (map b c g))) -> (forall {a : B} {b : B} {c : B} {d : B}, (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) -> (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) b c) -> (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) c d) -> Prop)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.oplax_functor.map₂_associator_aux [anonymous]ₓ'. -/
/-
We use this auxiliary definition instead of writing it directly in the definition
of oplax functors because doing so will cause a timeout.
-/
/-- This auxiliary definition states that oplax functors preserve the associators
modulo some adjustments of domains and codomains of 2-morphisms.
-/
@[simp]
def [anonymous] (obj : B → C) (map : ∀ {X Y : B}, (X ⟶ Y) → (obj X ⟶ obj Y))
    (map₂ : ∀ {a b : B} {f g : a ⟶ b}, (f ⟶ g) → (map f ⟶ map g))
    (map_comp : ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c), map (f ≫ g) ⟶ map f ≫ map g) {a b c d : B}
    (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) : Prop :=
  map₂ (α_ f g h).Hom ≫ map_comp f (g ≫ h) ≫ map f ◁ map_comp g h =
    map_comp (f ≫ g) h ≫ map_comp f g ▷ map h ≫ (α_ (map f) (map g) (map h)).Hom
#align category_theory.oplax_functor.map₂_associator_aux [anonymous]

#print CategoryTheory.OplaxFunctor /-
/-- An oplax functor `F` between bicategories `B` and `C` consists of a function between objects
`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map₂`.

Unlike functors between categories, `F.map` do not need to strictly commute with the composition,
and do not need to strictly preserve the identity. Instead, there are specified 2-morphisms
`F.map (𝟙 a) ⟶ 𝟙 (F.obj a)` and `F.map (f ≫ g) ⟶ F.map f ≫ F.map g`.

`F.map₂` strictly commute with compositions and preserve the identity. They also preserve the
associator, the left unitor, and the right unitor modulo some adjustments of domains and codomains
of 2-morphisms.
-/
structure OplaxFunctor (B : Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂)
  [Bicategory.{w₂, v₂} C] extends PrelaxFunctor B C where
  map_id (a : B) : map (𝟙 a) ⟶ 𝟙 (obj a)
  map_comp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : map (f ≫ g) ⟶ map f ≫ map g
  mapComp_naturality_left :
    ∀ {a b c : B} {f f' : a ⟶ b} (η : f ⟶ f') (g : b ⟶ c),
      map₂ (η ▷ g) ≫ map_comp f' g = map_comp f g ≫ map₂ η ▷ map g := by
    obviously
  mapComp_naturality_right :
    ∀ {a b c : B} (f : a ⟶ b) {g g' : b ⟶ c} (η : g ⟶ g'),
      map₂ (f ◁ η) ≫ map_comp f g' = map_comp f g ≫ map f ◁ map₂ η := by
    obviously
  map₂_id : ∀ {a b : B} (f : a ⟶ b), map₂ (𝟙 f) = 𝟙 (map f) := by obviously
  map₂_comp :
    ∀ {a b : B} {f g h : a ⟶ b} (η : f ⟶ g) (θ : g ⟶ h), map₂ (η ≫ θ) = map₂ η ≫ map₂ θ := by
    obviously
  map₂_associator :
    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d),
      [anonymous] obj (fun _ _ => map) (fun a b f g => map₂) (fun a b c => map_comp) f g h := by
    obviously
  map₂_leftUnitor :
    ∀ {a b : B} (f : a ⟶ b),
      map₂ (λ_ f).Hom = map_comp (𝟙 a) f ≫ map_id a ▷ map f ≫ (λ_ (map f)).Hom := by
    obviously
  map₂_rightUnitor :
    ∀ {a b : B} (f : a ⟶ b),
      map₂ (ρ_ f).Hom = map_comp f (𝟙 b) ≫ map f ◁ map_id b ≫ (ρ_ (map f)).Hom := by
    obviously
#align category_theory.oplax_functor CategoryTheory.OplaxFunctor
-/

namespace OplaxFunctor

restate_axiom map_comp_naturality_left'

restate_axiom map_comp_naturality_right'

restate_axiom map₂_id'

restate_axiom map₂_comp'

restate_axiom map₂_associator'

restate_axiom map₂_left_unitor'

restate_axiom map₂_right_unitor'

attribute [simp] map_comp_naturality_left map_comp_naturality_right map₂_id map₂_associator

attribute [reassoc]
  map_comp_naturality_left map_comp_naturality_right map₂_comp map₂_associator map₂_left_unitor map₂_right_unitor

attribute [simp] map₂_comp map₂_left_unitor map₂_right_unitor

section

/-- The prelax functor between the underlying quivers. -/
add_decl_doc oplax_functor.to_prelax_functor

#print CategoryTheory.OplaxFunctor.hasCoeToPrelax /-
instance hasCoeToPrelax : Coe (OplaxFunctor B C) (PrelaxFunctor B C) :=
  ⟨toPrelaxFunctor⟩
#align category_theory.oplax_functor.has_coe_to_prelax CategoryTheory.OplaxFunctor.hasCoeToPrelax
-/

variable (F : OplaxFunctor B C)

/- warning: category_theory.oplax_functor.to_prelax_eq_coe clashes with [anonymous] -> [anonymous]
warning: category_theory.oplax_functor.to_prelax_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (F : CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2), Eq.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 F) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.OplaxFunctor.hasCoeToPrelax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.oplax_functor.to_prelax_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : F.toPrelaxFunctor = F :=
  rfl
#align category_theory.oplax_functor.to_prelax_eq_coe [anonymous]

/- warning: category_theory.oplax_functor.to_prelax_functor_obj clashes with [anonymous] -> [anonymous]
warning: category_theory.oplax_functor.to_prelax_functor_obj -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (F : CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2), Eq.{max (succ u₁) (succ u₂)} (B -> C) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.OplaxFunctor.hasCoeToPrelax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F)) (CategoryTheory.OplaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.oplax_functor.to_prelax_functor_obj [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : (F : PrelaxFunctor B C).obj = F.obj :=
  rfl
#align category_theory.oplax_functor.to_prelax_functor_obj [anonymous]

@[simp]
theorem to_prelaxFunctor_map : @PrelaxFunctor.map B _ _ C _ _ F = @map _ _ _ _ F :=
  rfl
#align category_theory.oplax_functor.to_prelax_functor_map CategoryTheory.OplaxFunctor.to_prelaxFunctor_map

/- warning: category_theory.oplax_functor.to_prelax_functor_map₂ clashes with [anonymous] -> [anonymous]
warning: category_theory.oplax_functor.to_prelax_functor_map₂ -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (F : CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2), Eq.{max (succ u₁) (succ v₁) (succ w₁) (succ w₂)} (forall {a : B} {b : B} {f : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b} {g : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b}, (Quiver.Hom.{succ w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) ((fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) a b) f g) -> (Quiver.Hom.{succ w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.OplaxFunctor.hasCoeToPrelax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.OplaxFunctor.hasCoeToPrelax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) b)) ((fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.OplaxFunctor.hasCoeToPrelax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.OplaxFunctor.hasCoeToPrelax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) b)) (CategoryTheory.PrelaxFunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.OplaxFunctor.hasCoeToPrelax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a b f) (CategoryTheory.PrelaxFunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.OplaxFunctor.hasCoeToPrelax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a b g))) (CategoryTheory.PrelaxFunctor.map₂.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.OplaxFunctor.hasCoeToPrelax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F)) (CategoryTheory.OplaxFunctor.map₂.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.oplax_functor.to_prelax_functor_map₂ [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : @PrelaxFunctor.map₂ B _ _ C _ _ F = @map₂ _ _ _ _ F :=
  rfl
#align category_theory.oplax_functor.to_prelax_functor_map₂ [anonymous]

/- warning: category_theory.oplax_functor.map_functor -> CategoryTheory.OplaxFunctor.mapFunctor is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (a : B) (b : B), CategoryTheory.Functor.{u1, u2, u3, u4} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b) (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F b)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F b))
but is expected to have type
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (a : B) (b : B), CategoryTheory.Functor.{u1, u2, u3, u4} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b) (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) b)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) b))
Case conversion may be inaccurate. Consider using '#align category_theory.oplax_functor.map_functor CategoryTheory.OplaxFunctor.mapFunctorₓ'. -/
/-- Function between 1-morphisms as a functor. -/
@[simps]
def mapFunctor (a b : B) : (a ⟶ b) ⥤ (F.obj a ⟶ F.obj b)
    where
  obj f := F.map f
  map f g η := F.zipWith η
#align category_theory.oplax_functor.map_functor CategoryTheory.OplaxFunctor.mapFunctor

#print CategoryTheory.OplaxFunctor.id /-
/-- The identity oplax functor. -/
@[simps]
def id (B : Type u₁) [Bicategory.{w₁, v₁} B] : OplaxFunctor B B :=
  { PrelaxFunctor.id B with
    map_id := fun a => 𝟙 (𝟙 a)
    map_comp := fun a b c f g => 𝟙 (f ≫ g) }
#align category_theory.oplax_functor.id CategoryTheory.OplaxFunctor.id
-/

instance : Inhabited (OplaxFunctor B B) :=
  ⟨id B⟩

#print CategoryTheory.OplaxFunctor.comp /-
/-- Composition of oplax functors. -/
@[simps]
def comp (F : OplaxFunctor B C) (G : OplaxFunctor C D) : OplaxFunctor B D :=
  {
    (F : PrelaxFunctor B C).comp
      ↑G with
    map_id := fun a => (G.mapFunctor _ _).map (F.map_id a) ≫ G.map_id (F.obj a)
    map_comp := fun a b c f g =>
      (G.mapFunctor _ _).map (F.map_comp f g) ≫ G.map_comp (F.map f) (F.map g)
    mapComp_naturality_left := fun a b c f f' η g =>
      by
      dsimp
      rw [← map₂_comp_assoc, map_comp_naturality_left, map₂_comp_assoc, map_comp_naturality_left,
        assoc]
    mapComp_naturality_right := fun a b c f g g' η =>
      by
      dsimp
      rw [← map₂_comp_assoc, map_comp_naturality_right, map₂_comp_assoc, map_comp_naturality_right,
        assoc]
    map₂_associator := fun a b c d f g h => by
      dsimp
      simp only [map₂_associator, ← map₂_comp_assoc, ← map_comp_naturality_right_assoc,
        whisker_left_comp, assoc]
      simp only [map₂_associator, map₂_comp, map_comp_naturality_left_assoc, comp_whisker_right,
        assoc]
    map₂_leftUnitor := fun a b f => by
      dsimp
      simp only [map₂_left_unitor, map₂_comp, map_comp_naturality_left_assoc, comp_whisker_right,
        assoc]
    map₂_rightUnitor := fun a b f => by
      dsimp
      simp only [map₂_right_unitor, map₂_comp, map_comp_naturality_right_assoc, whisker_left_comp,
        assoc] }
#align category_theory.oplax_functor.comp CategoryTheory.OplaxFunctor.comp
-/

#print CategoryTheory.OplaxFunctor.PseudoCore /-
/-- A structure on an oplax functor that promotes an oplax functor to a pseudofunctor.
See `pseudofunctor.mk_of_oplax`.
-/
@[nolint has_nonempty_instance]
structure PseudoCore (F : OplaxFunctor B C) where
  mapIdIso (a : B) : F.map (𝟙 a) ≅ 𝟙 (F.obj a)
  mapCompIso {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : F.map (f ≫ g) ≅ F.map f ≫ F.map g
  mapIdIso_hom' : ∀ {a : B}, (map_id_iso a).Hom = F.map_id a := by obviously
  mapCompIso_hom' :
    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c), (map_comp_iso f g).Hom = F.map_comp f g := by obviously
#align category_theory.oplax_functor.pseudo_core CategoryTheory.OplaxFunctor.PseudoCore
-/

restate_axiom pseudo_core.map_id_iso_hom'

restate_axiom pseudo_core.map_comp_iso_hom'

attribute [simp] pseudo_core.map_id_iso_hom pseudo_core.map_comp_iso_hom

end

end OplaxFunctor

/- warning: category_theory.pseudofunctor.map₂_associator_aux clashes with [anonymous] -> [anonymous]
warning: category_theory.pseudofunctor.map₂_associator_aux -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (obj : B -> C) (map : forall {X : B} {Y : B}, (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) X Y) -> (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj X) (obj Y))), (forall {a : B} {b : B} {f : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b} {g : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b}, (Quiver.Hom.{succ w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) f g) -> (Quiver.Hom.{succ w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj a) (obj b)) (CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj a) (obj b)) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj a) (obj b)) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 (obj a) (obj b)))) (map a b f) (map a b g))) -> (forall {a : B} {b : B} {c : B} (f : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (g : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) b c), CategoryTheory.Iso.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (obj a) (obj c)) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 (obj a) (obj c)) (map a c (CategoryTheory.CategoryStruct.comp.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1) a b c f g)) (CategoryTheory.CategoryStruct.comp.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2) (obj a) (obj b) (obj c) (map a b f) (map b c g))) -> (forall {a : B} {b : B} {c : B} {d : B}, (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) -> (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) b c) -> (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) c d) -> Prop)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.map₂_associator_aux [anonymous]ₓ'. -/
/-
We use this auxiliary definition instead of writing it directly in the definition
of pseudofunctors because doing so will cause a timeout.
-/
/-- This auxiliary definition states that pseudofunctors preserve the associators
modulo some adjustments of domains and codomains of 2-morphisms.
-/
@[simp]
def [anonymous] (obj : B → C) (map : ∀ {X Y : B}, (X ⟶ Y) → (obj X ⟶ obj Y))
    (map₂ : ∀ {a b : B} {f g : a ⟶ b}, (f ⟶ g) → (map f ⟶ map g))
    (map_comp : ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c), map (f ≫ g) ≅ map f ≫ map g) {a b c d : B}
    (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) : Prop :=
  map₂ (α_ f g h).Hom =
    (map_comp (f ≫ g) h).Hom ≫
      (map_comp f g).Hom ▷ map h ≫
        (α_ (map f) (map g) (map h)).Hom ≫ map f ◁ (map_comp g h).inv ≫ (map_comp f (g ≫ h)).inv
#align category_theory.pseudofunctor.map₂_associator_aux [anonymous]

#print CategoryTheory.Pseudofunctor /-
/-- A pseudofunctor `F` between bicategories `B` and `C` consists of a function between objects
`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map₂`.

Unlike functors between categories, `F.map` do not need to strictly commute with the compositions,
and do not need to strictly preserve the identity. Instead, there are specified 2-isomorphisms
`F.map (𝟙 a) ≅ 𝟙 (F.obj a)` and `F.map (f ≫ g) ≅ F.map f ≫ F.map g`.

`F.map₂` strictly commute with compositions and preserve the identity. They also preserve the
associator, the left unitor, and the right unitor modulo some adjustments of domains and codomains
of 2-morphisms.
-/
structure Pseudofunctor (B : Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂)
  [Bicategory.{w₂, v₂} C] extends PrelaxFunctor B C where
  map_id (a : B) : map (𝟙 a) ≅ 𝟙 (obj a)
  map_comp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : map (f ≫ g) ≅ map f ≫ map g
  map₂_id : ∀ {a b : B} (f : a ⟶ b), map₂ (𝟙 f) = 𝟙 (map f) := by obviously
  map₂_comp :
    ∀ {a b : B} {f g h : a ⟶ b} (η : f ⟶ g) (θ : g ⟶ h), map₂ (η ≫ θ) = map₂ η ≫ map₂ θ := by
    obviously
  map₂_whisker_left' :
    ∀ {a b c : B} (f : a ⟶ b) {g h : b ⟶ c} (η : g ⟶ h),
      map₂ (f ◁ η) = (map_comp f g).Hom ≫ map f ◁ map₂ η ≫ (map_comp f h).inv := by
    obviously
  map₂_whisker_right' :
    ∀ {a b c : B} {f g : a ⟶ b} (η : f ⟶ g) (h : b ⟶ c),
      map₂ (η ▷ h) = (map_comp f h).Hom ≫ map₂ η ▷ map h ≫ (map_comp g h).inv := by
    obviously
  map₂_associator :
    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d),
      [anonymous] obj (fun a b => map) (fun a b f g => map₂) (fun a b c => map_comp) f g h := by
    obviously
  map₂_leftUnitor :
    ∀ {a b : B} (f : a ⟶ b),
      map₂ (λ_ f).Hom = (map_comp (𝟙 a) f).Hom ≫ (map_id a).Hom ▷ map f ≫ (λ_ (map f)).Hom := by
    obviously
  map₂_rightUnitor :
    ∀ {a b : B} (f : a ⟶ b),
      map₂ (ρ_ f).Hom = (map_comp f (𝟙 b)).Hom ≫ map f ◁ (map_id b).Hom ≫ (ρ_ (map f)).Hom := by
    obviously
#align category_theory.pseudofunctor CategoryTheory.Pseudofunctor
-/

namespace Pseudofunctor

restate_axiom map₂_id'

restate_axiom map₂_comp'

restate_axiom map₂_whisker_left'

restate_axiom map₂_whisker_right'

restate_axiom map₂_associator'

restate_axiom map₂_left_unitor'

restate_axiom map₂_right_unitor'

attribute [reassoc]
  map₂_comp map₂_whisker_left map₂_whisker_right map₂_associator map₂_left_unitor map₂_right_unitor

attribute [simp]
  map₂_id map₂_comp map₂_whisker_left map₂_whisker_right map₂_associator map₂_left_unitor map₂_right_unitor

section

open Iso

/-- The prelax functor between the underlying quivers. -/
add_decl_doc pseudofunctor.to_prelax_functor

#print CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor /-
instance hasCoeToPrelaxFunctor : Coe (Pseudofunctor B C) (PrelaxFunctor B C) :=
  ⟨toPrelaxFunctor⟩
#align category_theory.pseudofunctor.has_coe_to_prelax_functor CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor
-/

variable (F : Pseudofunctor B C)

/- warning: category_theory.pseudofunctor.to_prelax_functor_eq_coe clashes with [anonymous] -> [anonymous]
warning: category_theory.pseudofunctor.to_prelax_functor_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (F : CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2), Eq.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 F) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.to_prelax_functor_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : F.toPrelaxFunctor = F :=
  rfl
#align category_theory.pseudofunctor.to_prelax_functor_eq_coe [anonymous]

/- warning: category_theory.pseudofunctor.to_prelax_functor_obj clashes with [anonymous] -> [anonymous]
warning: category_theory.pseudofunctor.to_prelax_functor_obj -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (F : CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2), Eq.{max (succ u₁) (succ u₂)} (B -> C) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F)) (CategoryTheory.Pseudofunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.to_prelax_functor_obj [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : (F : PrelaxFunctor B C).obj = F.obj :=
  rfl
#align category_theory.pseudofunctor.to_prelax_functor_obj [anonymous]

/- warning: category_theory.pseudofunctor.to_prelax_functor_map clashes with [anonymous] -> [anonymous]
warning: category_theory.pseudofunctor.to_prelax_functor_map -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (F : CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2), Eq.{max (succ u₁) (succ v₁) (succ v₂)} (forall {X : B} {Y : B}, (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) X Y) -> (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) X) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) Y))) (CategoryTheory.PrelaxFunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F)) (CategoryTheory.Pseudofunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.to_prelax_functor_map [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : @PrelaxFunctor.map B _ _ C _ _ F = @map _ _ _ _ F :=
  rfl
#align category_theory.pseudofunctor.to_prelax_functor_map [anonymous]

/- warning: category_theory.pseudofunctor.to_prelax_functor_map₂ clashes with [anonymous] -> [anonymous]
warning: category_theory.pseudofunctor.to_prelax_functor_map₂ -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (F : CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2), Eq.{max (succ u₁) (succ v₁) (succ w₁) (succ w₂)} (forall {a : B} {b : B} {f : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b} {g : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b}, (Quiver.Hom.{succ w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) ((fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) a b) f g) -> (Quiver.Hom.{succ w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) b)) ((fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.PrelaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) b)) (CategoryTheory.PrelaxFunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a b f) (CategoryTheory.PrelaxFunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a b g))) (CategoryTheory.PrelaxFunctor.map₂.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.PrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b)))) (CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F)) (CategoryTheory.Pseudofunctor.map₂.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.to_prelax_functor_map₂ [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : @PrelaxFunctor.map₂ B _ _ C _ _ F = @map₂ _ _ _ _ F :=
  rfl
#align category_theory.pseudofunctor.to_prelax_functor_map₂ [anonymous]

#print CategoryTheory.Pseudofunctor.toOplax /-
/-- The oplax functor associated with a pseudofunctor. -/
def toOplax : OplaxFunctor B C :=
  { (F : PrelaxFunctor B C) with
    map_id := fun a => (F.map_id a).Hom
    map_comp := fun a b c f g => (F.map_comp f g).Hom }
#align category_theory.pseudofunctor.to_oplax CategoryTheory.Pseudofunctor.toOplax
-/

#print CategoryTheory.Pseudofunctor.hasCoeToOplax /-
instance hasCoeToOplax : Coe (Pseudofunctor B C) (OplaxFunctor B C) :=
  ⟨toOplax⟩
#align category_theory.pseudofunctor.has_coe_to_oplax CategoryTheory.Pseudofunctor.hasCoeToOplax
-/

/- warning: category_theory.pseudofunctor.to_oplax_eq_coe clashes with [anonymous] -> [anonymous]
warning: category_theory.pseudofunctor.to_oplax_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (F : CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2), Eq.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.toOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 F) ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.to_oplax_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : F.toOplax = F :=
  rfl
#align category_theory.pseudofunctor.to_oplax_eq_coe [anonymous]

/- warning: category_theory.pseudofunctor.to_oplax_obj -> CategoryTheory.Pseudofunctor.to_oplax_obj is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2), Eq.{max (succ u5) (succ u6)} (B -> C) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F)) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)
but is expected to have type
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2), Eq.{max (succ u5) (succ u6)} (B -> C) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)))) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)))
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.to_oplax_obj CategoryTheory.Pseudofunctor.to_oplax_objₓ'. -/
@[simp]
theorem to_oplax_obj : (F : OplaxFunctor B C).obj = F.obj :=
  rfl
#align category_theory.pseudofunctor.to_oplax_obj CategoryTheory.Pseudofunctor.to_oplax_obj

/- warning: category_theory.pseudofunctor.to_oplax_map clashes with [anonymous] -> [anonymous]
warning: category_theory.pseudofunctor.to_oplax_map -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (F : CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2), Eq.{max (succ u₁) (succ v₁) (succ v₂)} (forall {X : B} {Y : B}, (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) X Y) -> (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) X) (CategoryTheory.OplaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) Y))) (CategoryTheory.OplaxFunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F)) (CategoryTheory.Pseudofunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.to_oplax_map [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : @OplaxFunctor.map B _ C _ F = @map _ _ _ _ F :=
  rfl
#align category_theory.pseudofunctor.to_oplax_map [anonymous]

/- warning: category_theory.pseudofunctor.to_oplax_map₂ clashes with [anonymous] -> [anonymous]
warning: category_theory.pseudofunctor.to_oplax_map₂ -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u₁}} [_inst_1 : CategoryTheory.Bicategory.{w₁, v₁, u₁} B] {C : Type.{u₂}} [_inst_2 : CategoryTheory.Bicategory.{w₂, v₂, u₂} C] (F : CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2), Eq.{max (succ u₁) (succ v₁) (succ w₁) (succ w₂)} (forall {a : B} {b : B} {f : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b} {g : Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b}, (Quiver.Hom.{succ w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) ((fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{w₁, v₁} (Quiver.Hom.{succ v₁, u₁} B (CategoryTheory.CategoryStruct.toQuiver.{v₁, u₁} B (CategoryTheory.Bicategory.toCategoryStruct.{w₁, v₁, u₁} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{w₁, v₁, u₁} B _inst_1 a b))) a b) f g) -> (Quiver.Hom.{succ w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) b)) ((fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{w₂, v₂} (Quiver.Hom.{succ v₂, u₂} C (CategoryTheory.CategoryStruct.toQuiver.{v₂, u₂} C (CategoryTheory.Bicategory.toCategoryStruct.{w₂, v₂, u₂} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{w₂, v₂, u₂} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) b)) (CategoryTheory.OplaxFunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a b f) (CategoryTheory.OplaxFunctor.map.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F) a b g))) (CategoryTheory.OplaxFunctor.map₂.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) (b : Sort.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)}) [self : HasLiftT.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} a b] => self.0) (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (coeBase.{max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂), max (succ u₁) (succ u₂) (succ v₁) (succ v₂) (succ w₁) (succ w₂)} (CategoryTheory.Pseudofunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2)))) F)) (CategoryTheory.Pseudofunctor.map₂.{w₁, w₂, v₁, v₂, u₁, u₂} B _inst_1 C _inst_2 F)
but is expected to have type
  forall {B : Type.{u}} {_inst_1 : Type.{v}}, (Nat -> B -> _inst_1) -> Nat -> (List.{u} B) -> (List.{v} _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.to_oplax_map₂ [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : @OplaxFunctor.map₂ B _ C _ F = @map₂ _ _ _ _ F :=
  rfl
#align category_theory.pseudofunctor.to_oplax_map₂ [anonymous]

/- warning: category_theory.pseudofunctor.to_oplax_map_id -> CategoryTheory.Pseudofunctor.to_oplax_mapId is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (a : B), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a)) (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a)) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a)))) (CategoryTheory.OplaxFunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a a (CategoryTheory.CategoryStruct.id.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a)) (CategoryTheory.CategoryStruct.id.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a))) (CategoryTheory.OplaxFunctor.mapId.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.Iso.hom.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a)) (CategoryTheory.Pseudofunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a a (CategoryTheory.CategoryStruct.id.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a)) (CategoryTheory.CategoryStruct.id.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a)) (CategoryTheory.Pseudofunctor.mapId.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a))
but is expected to have type
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (a : B), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a)) (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a)) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a)))) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a a (CategoryTheory.CategoryStruct.id.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a)) (CategoryTheory.CategoryStruct.id.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a))) (CategoryTheory.OplaxFunctor.mapId.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F) a) (CategoryTheory.Iso.hom.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a)) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a a (CategoryTheory.CategoryStruct.id.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a)) (CategoryTheory.CategoryStruct.id.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a)) (CategoryTheory.Pseudofunctor.mapId.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a))
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.to_oplax_map_id CategoryTheory.Pseudofunctor.to_oplax_mapIdₓ'. -/
@[simp]
theorem to_oplax_mapId (a : B) : (F : OplaxFunctor B C).map_id a = (F.map_id a).Hom :=
  rfl
#align category_theory.pseudofunctor.to_oplax_map_id CategoryTheory.Pseudofunctor.to_oplax_mapId

/- warning: category_theory.pseudofunctor.to_oplax_map_comp -> CategoryTheory.Pseudofunctor.to_oplax_mapComp is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) {a : B} {b : B} {c : B} (f : Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (g : Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) b c), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) c)) (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) c)) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) c)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) c)))) (CategoryTheory.OplaxFunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a c (CategoryTheory.CategoryStruct.comp.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a b c f g)) (CategoryTheory.CategoryStruct.comp.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) b) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) c) (CategoryTheory.OplaxFunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a b f) (CategoryTheory.OplaxFunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) b c g))) (CategoryTheory.OplaxFunctor.mapComp.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 ((fun (a : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) (b : Sort.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} a b] => self.0) (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (HasLiftT.mk.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CoeTCₓ.coe.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (coeBase.{max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2), max (succ u5) (succ u6) (succ u3) (succ u4) (succ u1) (succ u2)} (CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (CategoryTheory.Pseudofunctor.hasCoeToOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2)))) F) a b c f g) (CategoryTheory.Iso.hom.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F c)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F c)) (CategoryTheory.Pseudofunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a c (CategoryTheory.CategoryStruct.comp.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a b c f g)) (CategoryTheory.CategoryStruct.comp.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F b) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F c) (CategoryTheory.Pseudofunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a b f) (CategoryTheory.Pseudofunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F b c g)) (CategoryTheory.Pseudofunctor.mapComp.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a b c f g))
but is expected to have type
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) {a : B} {b : B} {c : B} (f : Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (g : Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) b c), Eq.{succ u2} (Quiver.Hom.{succ u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) c)) (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) c)) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) c)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) c)))) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a c (CategoryTheory.CategoryStruct.comp.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a b c f g)) (CategoryTheory.CategoryStruct.comp.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) b) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) c) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) a b f) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F))) b c g))) (CategoryTheory.OplaxFunctor.mapComp.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 (CategoryTheory.Pseudofunctor.toOplax.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F) a b c f g) (CategoryTheory.Iso.hom.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) c)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) c)) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a c (CategoryTheory.CategoryStruct.comp.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a b c f g)) (CategoryTheory.CategoryStruct.comp.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) b) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) c) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a b f) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) b c g)) (CategoryTheory.Pseudofunctor.mapComp.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a b c f g))
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.to_oplax_map_comp CategoryTheory.Pseudofunctor.to_oplax_mapCompₓ'. -/
@[simp]
theorem to_oplax_mapComp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) :
    (F : OplaxFunctor B C).map_comp f g = (F.map_comp f g).Hom :=
  rfl
#align category_theory.pseudofunctor.to_oplax_map_comp CategoryTheory.Pseudofunctor.to_oplax_mapComp

/- warning: category_theory.pseudofunctor.map_functor -> CategoryTheory.Pseudofunctor.mapFunctor is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (a : B) (b : B), CategoryTheory.Functor.{u1, u2, u3, u4} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b) (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F b)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.Pseudofunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F b))
but is expected to have type
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) (a : B) (b : B), CategoryTheory.Functor.{u1, u2, u3, u4} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b) (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) b)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.Pseudofunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) b))
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.map_functor CategoryTheory.Pseudofunctor.mapFunctorₓ'. -/
/-- Function on 1-morphisms as a functor. -/
@[simps]
def mapFunctor (a b : B) : (a ⟶ b) ⥤ (F.obj a ⟶ F.obj b) :=
  (F : OplaxFunctor B C).mapFunctor a b
#align category_theory.pseudofunctor.map_functor CategoryTheory.Pseudofunctor.mapFunctor

#print CategoryTheory.Pseudofunctor.id /-
/-- The identity pseudofunctor. -/
@[simps]
def id (B : Type u₁) [Bicategory.{w₁, v₁} B] : Pseudofunctor B B :=
  { PrelaxFunctor.id B with
    map_id := fun a => Iso.refl (𝟙 a)
    map_comp := fun a b c f g => Iso.refl (f ≫ g) }
#align category_theory.pseudofunctor.id CategoryTheory.Pseudofunctor.id
-/

instance : Inhabited (Pseudofunctor B B) :=
  ⟨id B⟩

#print CategoryTheory.Pseudofunctor.comp /-
/-- Composition of pseudofunctors. -/
@[simps]
def comp (F : Pseudofunctor B C) (G : Pseudofunctor C D) : Pseudofunctor B D :=
  {
    (F : PrelaxFunctor B C).comp
      ↑G with
    map_id := fun a => (G.mapFunctor _ _).mapIso (F.map_id a) ≪≫ G.map_id (F.obj a)
    map_comp := fun a b c f g =>
      (G.mapFunctor _ _).mapIso (F.map_comp f g) ≪≫ G.map_comp (F.map f) (F.map g) }
#align category_theory.pseudofunctor.comp CategoryTheory.Pseudofunctor.comp
-/

#print CategoryTheory.Pseudofunctor.mkOfOplax /-
/-- Construct a pseudofunctor from an oplax functor whose `map_id` and `map_comp` are isomorphisms.
-/
@[simps]
def mkOfOplax (F : OplaxFunctor B C) (F' : F.PseudoCore) : Pseudofunctor B C :=
  { (F : PrelaxFunctor B C) with
    map_id := F'.mapIdIso
    map_comp := fun _ _ _ => F'.mapCompIso
    map₂_whisker_left' := fun a b c f g h η => by
      dsimp
      rw [F'.map_comp_iso_hom f g, ← F.map_comp_naturality_right_assoc, ← F'.map_comp_iso_hom f h,
        hom_inv_id, comp_id]
    map₂_whisker_right' := fun a b c f g η h => by
      dsimp
      rw [F'.map_comp_iso_hom f h, ← F.map_comp_naturality_left_assoc, ← F'.map_comp_iso_hom g h,
        hom_inv_id, comp_id]
    map₂_associator := fun a b c d f g h => by
      dsimp
      rw [F'.map_comp_iso_hom (f ≫ g) h, F'.map_comp_iso_hom f g, ← F.map₂_associator_assoc, ←
        F'.map_comp_iso_hom f (g ≫ h), ← F'.map_comp_iso_hom g h, hom_inv_whisker_left_assoc,
        hom_inv_id, comp_id] }
#align category_theory.pseudofunctor.mk_of_oplax CategoryTheory.Pseudofunctor.mkOfOplax
-/

/- warning: category_theory.pseudofunctor.mk_of_oplax' -> CategoryTheory.Pseudofunctor.mkOfOplax' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) [_inst_4 : forall (a : B), CategoryTheory.IsIso.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a)) (CategoryTheory.OplaxFunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a a (CategoryTheory.CategoryStruct.id.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a)) (CategoryTheory.CategoryStruct.id.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a)) (CategoryTheory.OplaxFunctor.mapId.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a)] [_inst_5 : forall {a : B} {b : B} {c : B} (f : Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (g : Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) b c), CategoryTheory.IsIso.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F c)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F c)) (CategoryTheory.OplaxFunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a c (CategoryTheory.CategoryStruct.comp.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a b c f g)) (CategoryTheory.CategoryStruct.comp.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F b) (CategoryTheory.OplaxFunctor.obj.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F c) (CategoryTheory.OplaxFunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a b f) (CategoryTheory.OplaxFunctor.map.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F b c g)) (CategoryTheory.OplaxFunctor.mapComp.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a b c f g)], CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2
but is expected to have type
  forall {B : Type.{u5}} [_inst_1 : CategoryTheory.Bicategory.{u1, u3, u5} B] {C : Type.{u6}} [_inst_2 : CategoryTheory.Bicategory.{u2, u4, u6} C] (F : CategoryTheory.OplaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2) [_inst_4 : forall (a : B), CategoryTheory.IsIso.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a)) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a a (CategoryTheory.CategoryStruct.id.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a)) (CategoryTheory.CategoryStruct.id.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a)) (CategoryTheory.OplaxFunctor.mapId.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a)] [_inst_5 : forall {a : B} {b : B} {c : B} (f : Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (g : Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) b c), CategoryTheory.IsIso.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) c)) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) c)) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a c (CategoryTheory.CategoryStruct.comp.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1) a b c f g)) (CategoryTheory.CategoryStruct.comp.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) b) (Prefunctor.obj.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) c) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) a b f) (Prefunctor.map.{succ u3, succ u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (CategoryTheory.PrelaxFunctor.toPrefunctor.{u1, u2, u3, u4, u5, u6} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) (fun (a : B) (b : B) => CategoryTheory.CategoryStruct.toQuiver.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Category.toCategoryStruct.{u1, u3} (Quiver.Hom.{succ u3, u5} B (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} B (CategoryTheory.Bicategory.toCategoryStruct.{u1, u3, u5} B _inst_1)) a b) (CategoryTheory.Bicategory.homCategory.{u1, u3, u5} B _inst_1 a b))) C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) (fun (a : C) (b : C) => CategoryTheory.CategoryStruct.toQuiver.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Category.toCategoryStruct.{u2, u4} (Quiver.Hom.{succ u4, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} C (CategoryTheory.Bicategory.toCategoryStruct.{u2, u4, u6} C _inst_2)) a b) (CategoryTheory.Bicategory.homCategory.{u2, u4, u6} C _inst_2 a b))) (CategoryTheory.OplaxFunctor.toPrelaxFunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F)) b c g)) (CategoryTheory.OplaxFunctor.mapComp.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2 F a b c f g)], CategoryTheory.Pseudofunctor.{u1, u2, u3, u4, u5, u6} B _inst_1 C _inst_2
Case conversion may be inaccurate. Consider using '#align category_theory.pseudofunctor.mk_of_oplax' CategoryTheory.Pseudofunctor.mkOfOplax'ₓ'. -/
/-- Construct a pseudofunctor from an oplax functor whose `map_id` and `map_comp` are isomorphisms.
-/
@[simps]
noncomputable def mkOfOplax' (F : OplaxFunctor B C) [∀ a, IsIso (F.map_id a)]
    [∀ {a b c} (f : a ⟶ b) (g : b ⟶ c), IsIso (F.map_comp f g)] : Pseudofunctor B C :=
  { (F : PrelaxFunctor B C) with
    map_id := fun a => asIso (F.map_id a)
    map_comp := fun a b c f g => asIso (F.map_comp f g)
    map₂_whisker_left' := fun a b c f g h η => by
      dsimp
      rw [← assoc, is_iso.eq_comp_inv, F.map_comp_naturality_right]
    map₂_whisker_right' := fun a b c f g η h => by
      dsimp
      rw [← assoc, is_iso.eq_comp_inv, F.map_comp_naturality_left]
    map₂_associator := fun a b c d f g h => by
      dsimp
      simp only [← assoc]
      rw [is_iso.eq_comp_inv, ← inv_whisker_left, is_iso.eq_comp_inv]
      simp only [assoc, F.map₂_associator] }
#align category_theory.pseudofunctor.mk_of_oplax' CategoryTheory.Pseudofunctor.mkOfOplax'

end

end Pseudofunctor

end

end CategoryTheory

