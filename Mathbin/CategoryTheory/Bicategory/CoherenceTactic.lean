/-
Copyright (c) 2022 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno

! This file was ported from Lean 3 source module category_theory.bicategory.coherence_tactic
! leanprover-community/mathlib commit 7e5137f579de09a059a5ce98f364a04e221aabf0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Bicategory.Coherence

/-!
# A `coherence` tactic for bicategories, and `‚äó‚â´` (composition up to associators)

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We provide a `coherence` tactic,
which proves that any two 2-morphisms (with the same source and target)
in a bicategory which are built out of associators and unitors
are equal.

We also provide `f ‚äó‚â´ g`, the `bicategorical_comp` operation,
which automatically inserts associators and unitors as needed
to make the target of `f` match the source of `g`.

This file mainly deals with the type class setup for the coherence tactic. The actual front end
tactic is given in `category_theory/monooidal/coherence.lean` at the same time as the coherence
tactic for monoidal categories.
-/


noncomputable section

universe w v u

open CategoryTheory

open CategoryTheory.FreeBicategory

open scoped Bicategory

variable {B : Type u} [Bicategory.{w, v} B] {a b c d e : B}

namespace CategoryTheory.Bicategory

#print Mathlib.Tactic.BicategoryCoherence.LiftHom /-
/-- A typeclass carrying a choice of lift of a 1-morphism from `B` to `free_bicategory B`. -/
class Mathlib.Tactic.BicategoryCoherence.LiftHom {a b : B} (f : a ‚ü∂ b) where
  lift : of.obj a ‚ü∂ of.obj b
#align category_theory.bicategory.lift_hom Mathlib.Tactic.BicategoryCoherence.LiftHom
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHomId /-
instance Mathlib.Tactic.BicategoryCoherence.liftHomId :
    Mathlib.Tactic.BicategoryCoherence.LiftHom (ùüô a) where lift := ùüô (of.obj a)
#align category_theory.bicategory.lift_hom_id Mathlib.Tactic.BicategoryCoherence.liftHomId
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHomComp /-
instance Mathlib.Tactic.BicategoryCoherence.liftHomComp (f : a ‚ü∂ b) (g : b ‚ü∂ c)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] [Mathlib.Tactic.BicategoryCoherence.LiftHom g] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom (f ‚â´ g)
    where lift :=
    Mathlib.Tactic.BicategoryCoherence.LiftHom.lift f ‚â´
      Mathlib.Tactic.BicategoryCoherence.LiftHom.lift g
#align category_theory.bicategory.lift_hom_comp Mathlib.Tactic.BicategoryCoherence.liftHomComp
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHomOf /-
instance (priority := 100) Mathlib.Tactic.BicategoryCoherence.liftHomOf (f : a ‚ü∂ b) :
    Mathlib.Tactic.BicategoryCoherence.LiftHom f where lift := of.map f
#align category_theory.bicategory.lift_hom_of Mathlib.Tactic.BicategoryCoherence.liftHomOf
-/

#print Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ /-
/-- A typeclass carrying a choice of lift of a 2-morphism from `B` to `free_bicategory B`. -/
class Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ {f g : a ‚ü∂ b}
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] [Mathlib.Tactic.BicategoryCoherence.LiftHom g]
    (Œ∑ : f ‚ü∂ g) where
  lift :
    Mathlib.Tactic.BicategoryCoherence.LiftHom.lift f ‚ü∂
      Mathlib.Tactic.BicategoryCoherence.LiftHom.lift g
#align category_theory.bicategory.lift_hom‚ÇÇ Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇId /-
instance Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇId (f : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ (ùüô f) where lift := ùüô _
#align category_theory.bicategory.lift_hom‚ÇÇ_id Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇId
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇLeftUnitorHom /-
instance Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇLeftUnitorHom (f : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ (Œª_ f).Hom
    where lift := (Œª_ (Mathlib.Tactic.BicategoryCoherence.LiftHom.lift f)).Hom
#align category_theory.bicategory.lift_hom‚ÇÇ_left_unitor_hom Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇLeftUnitorHom
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇLeftUnitorInv /-
instance Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇLeftUnitorInv (f : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ (Œª_ f).inv
    where lift := (Œª_ (Mathlib.Tactic.BicategoryCoherence.LiftHom.lift f)).inv
#align category_theory.bicategory.lift_hom‚ÇÇ_left_unitor_inv Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇLeftUnitorInv
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇRightUnitorHom /-
instance Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇRightUnitorHom (f : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ (œÅ_ f).Hom
    where lift := (œÅ_ (Mathlib.Tactic.BicategoryCoherence.LiftHom.lift f)).Hom
#align category_theory.bicategory.lift_hom‚ÇÇ_right_unitor_hom Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇRightUnitorHom
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇRightUnitorInv /-
instance Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇRightUnitorInv (f : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ (œÅ_ f).inv
    where lift := (œÅ_ (Mathlib.Tactic.BicategoryCoherence.LiftHom.lift f)).inv
#align category_theory.bicategory.lift_hom‚ÇÇ_right_unitor_inv Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇRightUnitorInv
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇAssociatorHom /-
instance Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇAssociatorHom (f : a ‚ü∂ b) (g : b ‚ü∂ c)
    (h : c ‚ü∂ d) [Mathlib.Tactic.BicategoryCoherence.LiftHom f]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] [Mathlib.Tactic.BicategoryCoherence.LiftHom h] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ (Œ±_ f g h).Hom
    where lift :=
    (Œ±_ (Mathlib.Tactic.BicategoryCoherence.LiftHom.lift f)
        (Mathlib.Tactic.BicategoryCoherence.LiftHom.lift g)
        (Mathlib.Tactic.BicategoryCoherence.LiftHom.lift h)).Hom
#align category_theory.bicategory.lift_hom‚ÇÇ_associator_hom Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇAssociatorHom
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇAssociatorInv /-
instance Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇAssociatorInv (f : a ‚ü∂ b) (g : b ‚ü∂ c)
    (h : c ‚ü∂ d) [Mathlib.Tactic.BicategoryCoherence.LiftHom f]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] [Mathlib.Tactic.BicategoryCoherence.LiftHom h] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ (Œ±_ f g h).inv
    where lift :=
    (Œ±_ (Mathlib.Tactic.BicategoryCoherence.LiftHom.lift f)
        (Mathlib.Tactic.BicategoryCoherence.LiftHom.lift g)
        (Mathlib.Tactic.BicategoryCoherence.LiftHom.lift h)).inv
#align category_theory.bicategory.lift_hom‚ÇÇ_associator_inv Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇAssociatorInv
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇComp /-
instance Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇComp {f g h : a ‚ü∂ b}
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] [Mathlib.Tactic.BicategoryCoherence.LiftHom g]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom h] (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ Œ∑]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ Œ∏] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ (Œ∑ ‚â´ Œ∏)
    where lift :=
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ.lift Œ∑ ‚â´
      Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ.lift Œ∏
#align category_theory.bicategory.lift_hom‚ÇÇ_comp Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇComp
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇWhiskerLeft /-
instance Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇWhiskerLeft (f : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] {g h : b ‚ü∂ c} (Œ∑ : g ‚ü∂ h)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] [Mathlib.Tactic.BicategoryCoherence.LiftHom h]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ Œ∑] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ (f ‚óÅ Œ∑)
    where lift :=
    Mathlib.Tactic.BicategoryCoherence.LiftHom.lift f ‚óÅ
      Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ.lift Œ∑
#align category_theory.bicategory.lift_hom‚ÇÇ_whisker_left Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇWhiskerLeft
-/

#print Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇWhiskerRight /-
instance Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇWhiskerRight {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] [Mathlib.Tactic.BicategoryCoherence.LiftHom g]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ Œ∑] {h : b ‚ü∂ c}
    [Mathlib.Tactic.BicategoryCoherence.LiftHom h] :
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ (Œ∑ ‚ñ∑ h)
    where lift :=
    Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ.lift Œ∑ ‚ñ∑
      Mathlib.Tactic.BicategoryCoherence.LiftHom.lift h
#align category_theory.bicategory.lift_hom‚ÇÇ_whisker_right Mathlib.Tactic.BicategoryCoherence.liftHom‚ÇÇWhiskerRight
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence /-
/- ./././Mathport/Syntax/Translate/Command.lean:393:30: infer kinds are unsupported in Lean 4: #[`Hom] [] -/
/-- A typeclass carrying a choice of bicategorical structural isomorphism between two objects.
Used by the `‚äó‚â´` bicategorical composition operator, and the `coherence` tactic.
-/
class Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence (f g : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] where
  Hom : f ‚ü∂ g
  [IsIso : IsIso hom]
#align category_theory.bicategory.bicategorical_coherence Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence
-/

attribute [instance] bicategorical_coherence.is_iso

namespace BicategoricalCoherence

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.refl /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.refl (f : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence f f :=
  ‚ü®ùüô _‚ü©
#align category_theory.bicategory.bicategorical_coherence.refl Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.refl
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.whiskerLeft /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.whiskerLeft (f : a ‚ü∂ b)
    (g h : b ‚ü∂ c) [Mathlib.Tactic.BicategoryCoherence.LiftHom f]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] [Mathlib.Tactic.BicategoryCoherence.LiftHom h]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence g h] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence (f ‚â´ g) (f ‚â´ h) :=
  ‚ü®f ‚óÅ Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom g h‚ü©
#align category_theory.bicategory.bicategorical_coherence.whisker_left Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.whiskerLeft
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.whiskerRight /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.whiskerRight (f g : a ‚ü∂ b)
    (h : b ‚ü∂ c) [Mathlib.Tactic.BicategoryCoherence.LiftHom f]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] [Mathlib.Tactic.BicategoryCoherence.LiftHom h]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence f g] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence (f ‚â´ h) (g ‚â´ h) :=
  ‚ü®Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom f g ‚ñ∑ h‚ü©
#align category_theory.bicategory.bicategorical_coherence.whisker_right Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.whiskerRight
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.tensorRight /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.tensorRight (f : a ‚ü∂ b)
    (g : b ‚ü∂ b) [Mathlib.Tactic.BicategoryCoherence.LiftHom f]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence (ùüô b) g] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence f (f ‚â´ g) :=
  ‚ü®(œÅ_ f).inv ‚â´ f ‚óÅ Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom (ùüô b) g‚ü©
#align category_theory.bicategory.bicategorical_coherence.tensor_right Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.tensorRight
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.tensorRight' /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.tensorRight' (f : a ‚ü∂ b)
    (g : b ‚ü∂ b) [Mathlib.Tactic.BicategoryCoherence.LiftHom f]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence g (ùüô b)] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence (f ‚â´ g) f :=
  ‚ü®f ‚óÅ Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom g (ùüô b) ‚â´ (œÅ_ f).Hom‚ü©
#align category_theory.bicategory.bicategorical_coherence.tensor_right' Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.tensorRight'
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.left /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.left (f g : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] [Mathlib.Tactic.BicategoryCoherence.LiftHom g]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence f g] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence (ùüô a ‚â´ f) g :=
  ‚ü®(Œª_ f).Hom ‚â´ Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom f g‚ü©
#align category_theory.bicategory.bicategorical_coherence.left Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.left
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.left' /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.left' (f g : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] [Mathlib.Tactic.BicategoryCoherence.LiftHom g]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence f g] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence f (ùüô a ‚â´ g) :=
  ‚ü®Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom f g ‚â´ (Œª_ g).inv‚ü©
#align category_theory.bicategory.bicategorical_coherence.left' Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.left'
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.right /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.right (f g : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] [Mathlib.Tactic.BicategoryCoherence.LiftHom g]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence f g] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence (f ‚â´ ùüô b) g :=
  ‚ü®(œÅ_ f).Hom ‚â´ Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom f g‚ü©
#align category_theory.bicategory.bicategorical_coherence.right Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.right
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.right' /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.right' (f g : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] [Mathlib.Tactic.BicategoryCoherence.LiftHom g]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence f g] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence f (g ‚â´ ùüô b) :=
  ‚ü®Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom f g ‚â´ (œÅ_ g).inv‚ü©
#align category_theory.bicategory.bicategorical_coherence.right' Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.right'
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.assoc /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.assoc (f : a ‚ü∂ b) (g : b ‚ü∂ c)
    (h : c ‚ü∂ d) (i : a ‚ü∂ d) [Mathlib.Tactic.BicategoryCoherence.LiftHom f]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] [Mathlib.Tactic.BicategoryCoherence.LiftHom h]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom i]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence (f ‚â´ g ‚â´ h) i] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence ((f ‚â´ g) ‚â´ h) i :=
  ‚ü®(Œ±_ f g h).Hom ‚â´ Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom (f ‚â´ g ‚â´ h) i‚ü©
#align category_theory.bicategory.bicategorical_coherence.assoc Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.assoc
-/

#print Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.assoc' /-
@[simps]
instance Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.assoc' (f : a ‚ü∂ b) (g : b ‚ü∂ c)
    (h : c ‚ü∂ d) (i : a ‚ü∂ d) [Mathlib.Tactic.BicategoryCoherence.LiftHom f]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] [Mathlib.Tactic.BicategoryCoherence.LiftHom h]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom i]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence i (f ‚â´ g ‚â´ h)] :
    Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence i ((f ‚â´ g) ‚â´ h) :=
  ‚ü®Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom i (f ‚â´ g ‚â´ h) ‚â´ (Œ±_ f g h).inv‚ü©
#align category_theory.bicategory.bicategorical_coherence.assoc' Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.assoc'
-/

end BicategoricalCoherence

#print Mathlib.Tactic.BicategoryCoherence.bicategoricalIso /-
/-- Construct an isomorphism between two objects in a bicategorical category
out of unitors and associators. -/
def Mathlib.Tactic.BicategoryCoherence.bicategoricalIso (f g : a ‚ü∂ b)
    [Mathlib.Tactic.BicategoryCoherence.LiftHom f] [Mathlib.Tactic.BicategoryCoherence.LiftHom g]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence f g] : f ‚âÖ g :=
  asIso (Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom f g)
#align category_theory.bicategory.bicategorical_iso Mathlib.Tactic.BicategoryCoherence.bicategoricalIso
-/

#print Mathlib.Tactic.BicategoryCoherence.bicategoricalComp /-
/-- Compose two morphisms in a bicategorical category,
inserting unitors and associators between as necessary. -/
def Mathlib.Tactic.BicategoryCoherence.bicategoricalComp {f g h i : a ‚ü∂ b}
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] [Mathlib.Tactic.BicategoryCoherence.LiftHom h]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence g h] (Œ∑ : f ‚ü∂ g) (Œ∏ : h ‚ü∂ i) :
    f ‚ü∂ i :=
  Œ∑ ‚â´ Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom g h ‚â´ Œ∏
#align category_theory.bicategory.bicategorical_comp Mathlib.Tactic.BicategoryCoherence.bicategoricalComp
-/

scoped[Bicategory] infixr:80 " ‚äó‚â´ " => Mathlib.Tactic.BicategoryCoherence.bicategoricalComp

#print Mathlib.Tactic.BicategoryCoherence.bicategoricalIsoComp /-
-- type as \ot \gg
/-- Compose two isomorphisms in a bicategorical category,
inserting unitors and associators between as necessary. -/
def Mathlib.Tactic.BicategoryCoherence.bicategoricalIsoComp {f g h i : a ‚ü∂ b}
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] [Mathlib.Tactic.BicategoryCoherence.LiftHom h]
    [Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence g h] (Œ∑ : f ‚âÖ g) (Œ∏ : h ‚âÖ i) :
    f ‚âÖ i :=
  Œ∑ ‚â™‚â´ asIso (Mathlib.Tactic.BicategoryCoherence.BicategoricalCoherence.hom g h) ‚â™‚â´ Œ∏
#align category_theory.bicategory.bicategorical_iso_comp Mathlib.Tactic.BicategoryCoherence.bicategoricalIsoComp
-/

scoped[Bicategory] infixr:80 " ‚â™‚äó‚â´ " => Mathlib.Tactic.BicategoryCoherence.bicategoricalIsoComp

-- type as \ot \gg
example {f' : a ‚ü∂ d} {f : a ‚ü∂ b} {g : b ‚ü∂ c} {h : c ‚ü∂ d} {h' : a ‚ü∂ d} (Œ∑ : f' ‚ü∂ f ‚â´ g ‚â´ h)
    (Œ∏ : (f ‚â´ g) ‚â´ h ‚ü∂ h') : f' ‚ü∂ h' :=
  Œ∑ ‚äó‚â´ Œ∏

-- To automatically insert unitors/associators at the beginning or end,
-- you can use `Œ∑ ‚äó‚â´ ùüô _`
example {f' : a ‚ü∂ d} {f : a ‚ü∂ b} {g : b ‚ü∂ c} {h : c ‚ü∂ d} (Œ∑ : f' ‚ü∂ (f ‚â´ g) ‚â´ h) : f' ‚ü∂ f ‚â´ g ‚â´ h :=
  Œ∑ ‚äó‚â´ ùüô _

#print Mathlib.Tactic.BicategoryCoherence.bicategoricalComp_refl /-
@[simp]
theorem Mathlib.Tactic.BicategoryCoherence.bicategoricalComp_refl {f g h : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g)
    (Œ∏ : g ‚ü∂ h) : Œ∑ ‚äó‚â´ Œ∏ = Œ∑ ‚â´ Œ∏ := by dsimp [bicategorical_comp]; simp
#align category_theory.bicategory.bicategorical_comp_refl Mathlib.Tactic.BicategoryCoherence.bicategoricalComp_refl
-/

end CategoryTheory.Bicategory

open CategoryTheory.Bicategory

namespace Tactic

/- ./././Mathport/Syntax/Translate/Tactic/Mathlib/Core.lean:38:34: unsupported: setup_tactic_parser -/
/- ./././Mathport/Syntax/Translate/Expr.lean:336:4: warning: unsupported (TODO): `[tacs] -/
-- PLEASE REPORT THIS TO MATHPORT DEVS, THIS SHOULD NOT HAPPEN.
-- failed to format: unknown constant 'term.pseudo.antiquot'
/-- Coherence tactic for bicategories. -/ unsafe
  def
    bicategorical_coherence
    : tactic Unit
    :=
      focus1
        do
          let o ‚Üê get_options
            set_options <| o `class.instance_max_depth 128
            try sorry
            let q( $ ( lhs ) = $ ( rhs ) ) ‚Üê target
            to_expr
                `
                  `(
                    ( FreeBicategory.lift ( Prefunctor.id _ ) ) . zipWith
                        ( Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ.lift $ ( lhs ) )
                      =
                      ( FreeBicategory.lift ( Prefunctor.id _ ) ) . zipWith
                        ( Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ.lift $ ( rhs ) )
                    )
              >>=
              tactic.change
            congr
#align tactic.bicategorical_coherence tactic.bicategorical_coherence

namespace Bicategory

/- ./././Mathport/Syntax/Translate/Expr.lean:336:4: warning: unsupported (TODO): `[tacs] -/
/-- Simp lemmas for rewriting a 2-morphism into a normal form. -/
unsafe def whisker_simps : tactic Unit :=
  sorry
#align tactic.bicategory.whisker_simps tactic.bicategory.whisker_simps

namespace Coherence

#print Mathlib.Tactic.BicategoryCoherence.assoc_liftHom‚ÇÇ /-
-- We have unused typeclass arguments here.
-- They are intentional, to ensure that `simp only [assoc_lift_hom‚ÇÇ]` only left associates
-- bicategorical structural morphisms.
/-- Auxiliary simp lemma for the `coherence` tactic:
this move brackets to the left in order to expose a maximal prefix
built out of unitors and associators.
-/
@[nolint unused_arguments]
theorem assoc_liftHom‚ÇÇ {f g h i : a ‚ü∂ b} [Mathlib.Tactic.BicategoryCoherence.LiftHom f]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom g] [Mathlib.Tactic.BicategoryCoherence.LiftHom h]
    (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h) (Œπ : h ‚ü∂ i) [Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ Œ∑]
    [Mathlib.Tactic.BicategoryCoherence.LiftHom‚ÇÇ Œ∏] : Œ∑ ‚â´ Œ∏ ‚â´ Œπ = (Œ∑ ‚â´ Œ∏) ‚â´ Œπ :=
  (Category.assoc _ _ _).symm
#align tactic.bicategory.coherence.assoc_lift_hom‚ÇÇ Mathlib.Tactic.BicategoryCoherence.assoc_liftHom‚ÇÇ
-/

end Coherence

end Bicategory

end Tactic

