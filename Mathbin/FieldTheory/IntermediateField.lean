/-
Copyright (c) 2020 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen

! This file was ported from Lean 3 source module field_theory.intermediate_field
! leanprover-community/mathlib commit 61db041ab8e4aaf8cb5c7dc10a7d4ff261997536
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.FieldTheory.Minpoly.Field
import Mathbin.FieldTheory.Subfield
import Mathbin.FieldTheory.Tower

/-!
# Intermediate fields

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Let `L / K` be a field extension, given as an instance `algebra K L`.
This file defines the type of fields in between `K` and `L`, `intermediate_field K L`.
An `intermediate_field K L` is a subfield of `L` which contains (the image of) `K`,
i.e. it is a `subfield L` and a `subalgebra K L`.

## Main definitions

* `intermediate_field K L` : the type of intermediate fields between `K` and `L`.
* `subalgebra.to_intermediate_field`: turns a subalgebra closed under `⁻¹`
  into an intermediate field
* `subfield.to_intermediate_field`: turns a subfield containing the image of `K`
  into an intermediate field
* `intermediate_field.map`: map an intermediate field along an `alg_hom`
* `intermediate_field.restrict_scalars`: restrict the scalars of an intermediate field to a smaller
  field in a tower of fields.

## Implementation notes

Intermediate fields are defined with a structure extending `subfield` and `subalgebra`.
A `subalgebra` is closed under all operations except `⁻¹`,

## Tags
intermediate field, field extension
-/


open FiniteDimensional Polynomial

open BigOperators Polynomial

variable (K L L' : Type _) [Field K] [Field L] [Field L'] [Algebra K L] [Algebra K L']

#print IntermediateField /-
/-- `S : intermediate_field K L` is a subset of `L` such that there is a field
tower `L / S / K`. -/
structure IntermediateField extends Subalgebra K L where
  neg_mem' : ∀ x ∈ carrier, -x ∈ carrier
  inv_mem' : ∀ x ∈ carrier, x⁻¹ ∈ carrier
#align intermediate_field IntermediateField
-/

/-- Reinterpret an `intermediate_field` as a `subalgebra`. -/
add_decl_doc IntermediateField.toSubalgebra

variable {K L L'} (S : IntermediateField K L)

namespace IntermediateField

#print IntermediateField.toSubfield /-
/-- Reinterpret an `intermediate_field` as a `subfield`. -/
def toSubfield : Subfield L :=
  { S.toSubalgebra, S with }
#align intermediate_field.to_subfield IntermediateField.toSubfield
-/

instance : SetLike (IntermediateField K L) L :=
  ⟨fun S => S.toSubalgebra.carrier, by
    rintro ⟨⟨⟩⟩ ⟨⟨⟩⟩ ⟨h⟩
    congr ⟩

instance : SubfieldClass (IntermediateField K L) L
    where
  add_mem s _ _ := s.add_mem'
  zero_mem s := s.zero_mem'
  neg_mem := neg_mem'
  mul_mem s _ _ := s.mul_mem'
  one_mem s := s.one_mem'
  inv_mem := inv_mem'

/- warning: intermediate_field.mem_carrier -> IntermediateField.mem_carrier is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {s : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {x : L}, Iff (Membership.Mem.{u2, u2} L (Set.{u2} L) (Set.hasMem.{u2} L) x (Subalgebra.carrier.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 s))) (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x s)
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] {s : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4} {x : L}, Iff (Membership.mem.{u1, u1} L (Set.{u1} L) (Set.instMembershipSet.{u1} L) x (Subsemigroup.carrier.{u1} L (MulOneClass.toMul.{u1} L (MulZeroOneClass.toMulOneClass.{u1} L (NonAssocSemiring.toMulZeroOneClass.{u1} L (Semiring.toNonAssocSemiring.{u1} L (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))))))) (Submonoid.toSubsemigroup.{u1} L (MulZeroOneClass.toMulOneClass.{u1} L (NonAssocSemiring.toMulZeroOneClass.{u1} L (Semiring.toNonAssocSemiring.{u1} L (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))))) (Subsemiring.toSubmonoid.{u1} L (Semiring.toNonAssocSemiring.{u1} L (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))) (Subalgebra.toSubsemiring.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 s)))))) (Membership.mem.{u1, u1} L (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)) x s)
Case conversion may be inaccurate. Consider using '#align intermediate_field.mem_carrier IntermediateField.mem_carrierₓ'. -/
@[simp]
theorem mem_carrier {s : IntermediateField K L} {x : L} : x ∈ s.carrier ↔ x ∈ s :=
  Iff.rfl
#align intermediate_field.mem_carrier IntermediateField.mem_carrier

/- warning: intermediate_field.ext -> IntermediateField.ext is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {T : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, (forall (x : L), Iff (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x T)) -> (Eq.{succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S T)
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] {S : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4} {T : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4}, (forall (x : L), Iff (Membership.mem.{u1, u1} L (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)) x S) (Membership.mem.{u1, u1} L (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)) x T)) -> (Eq.{succ u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) S T)
Case conversion may be inaccurate. Consider using '#align intermediate_field.ext IntermediateField.extₓ'. -/
/-- Two intermediate fields are equal if they have the same elements. -/
@[ext]
theorem ext {S T : IntermediateField K L} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=
  SetLike.ext h
#align intermediate_field.ext IntermediateField.ext

/- warning: intermediate_field.coe_to_subalgebra -> IntermediateField.coe_toSubalgebra is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} (Set.{u2} L) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (Set.{u2} L) (HasLiftT.mk.{succ u2, succ u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (Set.{u2} L) (CoeTCₓ.coe.{succ u2, succ u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (Set.{u2} L) (SetLike.Set.hasCoeT.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)))) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (HasLiftT.mk.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (CoeTCₓ.coe.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (SetLike.Set.hasCoeT.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} (Set.{u2} L) (SetLike.coe.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) L (Subalgebra.instSetLikeSubalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_to_subalgebra IntermediateField.coe_toSubalgebraₓ'. -/
@[simp]
theorem coe_toSubalgebra : (S.toSubalgebra : Set L) = S :=
  rfl
#align intermediate_field.coe_to_subalgebra IntermediateField.coe_toSubalgebra

/- warning: intermediate_field.coe_to_subfield -> IntermediateField.coe_toSubfield is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} (Set.{u2} L) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Subfield.{u2} L _inst_2) (Set.{u2} L) (HasLiftT.mk.{succ u2, succ u2} (Subfield.{u2} L _inst_2) (Set.{u2} L) (CoeTCₓ.coe.{succ u2, succ u2} (Subfield.{u2} L _inst_2) (Set.{u2} L) (SetLike.Set.hasCoeT.{u2, u2} (Subfield.{u2} L _inst_2) L (Subfield.setLike.{u2} L _inst_2)))) (IntermediateField.toSubfield.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (HasLiftT.mk.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (CoeTCₓ.coe.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (SetLike.Set.hasCoeT.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} (Set.{u2} L) (SetLike.coe.{u2, u2} (Subfield.{u2} L _inst_2) L (Subfield.instSetLikeSubfield.{u2} L _inst_2) (IntermediateField.toSubfield.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_to_subfield IntermediateField.coe_toSubfieldₓ'. -/
@[simp]
theorem coe_toSubfield : (S.toSubfield : Set L) = S :=
  rfl
#align intermediate_field.coe_to_subfield IntermediateField.coe_toSubfield

@[simp]
theorem mem_mk (s : Set L) (hK : ∀ x, algebraMap K L x ∈ s) (ho hm hz ha hn hi) (x : L) :
    x ∈ IntermediateField.mk (Subalgebra.mk s ho hm hz ha hK) hn hi ↔ x ∈ s :=
  Iff.rfl
#align intermediate_field.mem_mk IntermediateField.mem_mkₓ

/- warning: intermediate_field.mem_to_subalgebra -> IntermediateField.mem_toSubalgebra is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (s : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (x : L), Iff (Membership.Mem.{u2, u2} L (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (SetLike.hasMem.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)) x (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 s)) (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x s)
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] (s : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (x : L), Iff (Membership.mem.{u1, u1} L (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) L (Subalgebra.instSetLikeSubalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4)) x (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 s)) (Membership.mem.{u1, u1} L (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)) x s)
Case conversion may be inaccurate. Consider using '#align intermediate_field.mem_to_subalgebra IntermediateField.mem_toSubalgebraₓ'. -/
@[simp]
theorem mem_toSubalgebra (s : IntermediateField K L) (x : L) : x ∈ s.toSubalgebra ↔ x ∈ s :=
  Iff.rfl
#align intermediate_field.mem_to_subalgebra IntermediateField.mem_toSubalgebra

/- warning: intermediate_field.mem_to_subfield -> IntermediateField.mem_toSubfield is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (s : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (x : L), Iff (Membership.Mem.{u2, u2} L (Subfield.{u2} L _inst_2) (SetLike.hasMem.{u2, u2} (Subfield.{u2} L _inst_2) L (Subfield.setLike.{u2} L _inst_2)) x (IntermediateField.toSubfield.{u1, u2} K L _inst_1 _inst_2 _inst_4 s)) (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x s)
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] (s : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (x : L), Iff (Membership.mem.{u1, u1} L (Subfield.{u1} L _inst_2) (SetLike.instMembership.{u1, u1} (Subfield.{u1} L _inst_2) L (Subfield.instSetLikeSubfield.{u1} L _inst_2)) x (IntermediateField.toSubfield.{u2, u1} K L _inst_1 _inst_2 _inst_4 s)) (Membership.mem.{u1, u1} L (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)) x s)
Case conversion may be inaccurate. Consider using '#align intermediate_field.mem_to_subfield IntermediateField.mem_toSubfieldₓ'. -/
@[simp]
theorem mem_toSubfield (s : IntermediateField K L) (x : L) : x ∈ s.toSubfield ↔ x ∈ s :=
  Iff.rfl
#align intermediate_field.mem_to_subfield IntermediateField.mem_toSubfield

/- warning: intermediate_field.copy -> IntermediateField.copy is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (s : Set.{u2} L), (Eq.{succ u2} (Set.{u2} L) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (HasLiftT.mk.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (CoeTCₓ.coe.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (SetLike.Set.hasCoeT.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) S)) -> (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (s : Set.{u2} L), (Eq.{succ u2} (Set.{u2} L) s (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) -> (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align intermediate_field.copy IntermediateField.copyₓ'. -/
/-- Copy of an intermediate field with a new `carrier` equal to the old one. Useful to fix
definitional equalities. -/
protected def copy (S : IntermediateField K L) (s : Set L) (hs : s = ↑S) : IntermediateField K L
    where
  toSubalgebra := S.toSubalgebra.copy s (hs : s = S.toSubalgebra.carrier)
  neg_mem' :=
    have hs' : (S.toSubalgebra.copy s hs).carrier = S.toSubalgebra.carrier := hs
    hs'.symm ▸ S.neg_mem'
  inv_mem' :=
    have hs' : (S.toSubalgebra.copy s hs).carrier = S.toSubalgebra.carrier := hs
    hs'.symm ▸ S.inv_mem'
#align intermediate_field.copy IntermediateField.copy

/- warning: intermediate_field.coe_copy -> IntermediateField.coe_copy is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (s : Set.{u2} L) (hs : Eq.{succ u2} (Set.{u2} L) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (HasLiftT.mk.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (CoeTCₓ.coe.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (SetLike.Set.hasCoeT.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) S)), Eq.{succ u2} (Set.{u2} L) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (HasLiftT.mk.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (CoeTCₓ.coe.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (SetLike.Set.hasCoeT.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) (IntermediateField.copy.{u1, u2} K L _inst_1 _inst_2 _inst_4 S s hs)) s
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] (S : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (s : Set.{u1} L) (hs : Eq.{succ u1} (Set.{u1} L) s (SetLike.coe.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) S)), Eq.{succ u1} (Set.{u1} L) (SetLike.coe.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (IntermediateField.copy.{u2, u1} K L _inst_1 _inst_2 _inst_4 S s hs)) s
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_copy IntermediateField.coe_copyₓ'. -/
@[simp]
theorem coe_copy (S : IntermediateField K L) (s : Set L) (hs : s = ↑S) :
    (S.copy s hs : Set L) = s :=
  rfl
#align intermediate_field.coe_copy IntermediateField.coe_copy

/- warning: intermediate_field.copy_eq -> IntermediateField.copy_eq is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (s : Set.{u2} L) (hs : Eq.{succ u2} (Set.{u2} L) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (HasLiftT.mk.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (CoeTCₓ.coe.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (SetLike.Set.hasCoeT.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) S)), Eq.{succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.copy.{u1, u2} K L _inst_1 _inst_2 _inst_4 S s hs) S
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] (S : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (s : Set.{u1} L) (hs : Eq.{succ u1} (Set.{u1} L) s (SetLike.coe.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) S)), Eq.{succ u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (IntermediateField.copy.{u2, u1} K L _inst_1 _inst_2 _inst_4 S s hs) S
Case conversion may be inaccurate. Consider using '#align intermediate_field.copy_eq IntermediateField.copy_eqₓ'. -/
theorem copy_eq (S : IntermediateField K L) (s : Set L) (hs : s = ↑S) : S.copy s hs = S :=
  SetLike.coe_injective hs
#align intermediate_field.copy_eq IntermediateField.copy_eq

section InheritedLemmas

/-! ### Lemmas inherited from more general structures

The declarations in this section derive from the fact that an `intermediate_field` is also a
subalgebra or subfield. Their use should be replaceable with the corresponding lemma from a
subobject class.
-/


/- warning: intermediate_field.algebra_map_mem -> IntermediateField.algebraMap_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (x : K), Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (fun (_x : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) => K -> L) (RingHom.hasCoeToFun.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (algebraMap.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) x) S
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (x : K), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : K) => L) x) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : K) => L) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))))) (algebraMap.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) x) S
Case conversion may be inaccurate. Consider using '#align intermediate_field.algebra_map_mem IntermediateField.algebraMap_memₓ'. -/
/-- An intermediate field contains the image of the smaller field. -/
theorem algebraMap_mem (x : K) : algebraMap K L x ∈ S :=
  S.algebraMap_mem' x
#align intermediate_field.algebra_map_mem IntermediateField.algebraMap_mem

/- warning: intermediate_field.smul_mem -> IntermediateField.smul_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {y : L}, (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) y S) -> (forall {x : K}, Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (SMul.smul.{u1, u2} K L (SMulZeroClass.toHasSmul.{u1, u2} K L (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} K L (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K L (Semiring.toMonoidWithZero.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (Module.toMulActionWithZero.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) (Algebra.toModule.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4))))) x y) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {y : L}, (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) y S) -> (forall {x : K}, Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HSMul.hSMul.{u1, u2, u2} K L L (instHSMul.{u1, u2} K L (Algebra.toSMul.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4)) x y) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.smul_mem IntermediateField.smul_memₓ'. -/
/-- An intermediate field is closed under scalar multiplication. -/
theorem smul_mem {y : L} : y ∈ S → ∀ {x : K}, x • y ∈ S :=
  S.toSubalgebra.smul_mem
#align intermediate_field.smul_mem IntermediateField.smul_mem

/- warning: intermediate_field.one_mem -> IntermediateField.one_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (OfNat.ofNat.{u2} L 1 (OfNat.mk.{u2} L 1 (One.one.{u2} L (AddMonoidWithOne.toOne.{u2} L (AddGroupWithOne.toAddMonoidWithOne.{u2} L (AddCommGroupWithOne.toAddGroupWithOne.{u2} L (Ring.toAddCommGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) S
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (OfNat.ofNat.{u2} L 1 (One.toOfNat1.{u2} L (Semiring.toOne.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) S
Case conversion may be inaccurate. Consider using '#align intermediate_field.one_mem IntermediateField.one_memₓ'. -/
/-- An intermediate field contains the ring's 1. -/
protected theorem one_mem : (1 : L) ∈ S :=
  one_mem S
#align intermediate_field.one_mem IntermediateField.one_mem

/- warning: intermediate_field.zero_mem -> IntermediateField.zero_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (OfNat.ofNat.{u2} L 0 (OfNat.mk.{u2} L 0 (Zero.zero.{u2} L (MulZeroClass.toHasZero.{u2} L (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))))))) S
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (OfNat.ofNat.{u2} L 0 (Zero.toOfNat0.{u2} L (CommMonoidWithZero.toZero.{u2} L (CommGroupWithZero.toCommMonoidWithZero.{u2} L (Semifield.toCommGroupWithZero.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) S
Case conversion may be inaccurate. Consider using '#align intermediate_field.zero_mem IntermediateField.zero_memₓ'. -/
/-- An intermediate field contains the ring's 0. -/
protected theorem zero_mem : (0 : L) ∈ S :=
  zero_mem S
#align intermediate_field.zero_mem IntermediateField.zero_mem

/- warning: intermediate_field.mul_mem -> IntermediateField.mul_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L} {y : L}, (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) y S) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HMul.hMul.{u2, u2, u2} L L L (instHMul.{u2} L (Distrib.toHasMul.{u2} L (Ring.toDistrib.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) x y) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L} {y : L}, (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) y S) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HMul.hMul.{u2, u2, u2} L L L (instHMul.{u2} L (NonUnitalNonAssocRing.toMul.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) x y) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.mul_mem IntermediateField.mul_memₓ'. -/
/-- An intermediate field is closed under multiplication. -/
protected theorem mul_mem {x y : L} : x ∈ S → y ∈ S → x * y ∈ S :=
  mul_mem
#align intermediate_field.mul_mem IntermediateField.mul_mem

/- warning: intermediate_field.add_mem -> IntermediateField.add_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L} {y : L}, (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) y S) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HAdd.hAdd.{u2, u2, u2} L L L (instHAdd.{u2} L (Distrib.toHasAdd.{u2} L (Ring.toDistrib.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) x y) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L} {y : L}, (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) y S) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HAdd.hAdd.{u2, u2, u2} L L L (instHAdd.{u2} L (Distrib.toAdd.{u2} L (NonUnitalNonAssocSemiring.toDistrib.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))))) x y) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.add_mem IntermediateField.add_memₓ'. -/
/-- An intermediate field is closed under addition. -/
protected theorem add_mem {x y : L} : x ∈ S → y ∈ S → x + y ∈ S :=
  add_mem
#align intermediate_field.add_mem IntermediateField.add_mem

/- warning: intermediate_field.sub_mem -> IntermediateField.sub_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L} {y : L}, (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) y S) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HSub.hSub.{u2, u2, u2} L L L (instHSub.{u2} L (SubNegMonoid.toHasSub.{u2} L (AddGroup.toSubNegMonoid.{u2} L (AddGroupWithOne.toAddGroup.{u2} L (AddCommGroupWithOne.toAddGroupWithOne.{u2} L (Ring.toAddCommGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))))) x y) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L} {y : L}, (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) y S) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HSub.hSub.{u2, u2, u2} L L L (instHSub.{u2} L (Ring.toSub.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) x y) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.sub_mem IntermediateField.sub_memₓ'. -/
/-- An intermediate field is closed under subtraction -/
protected theorem sub_mem {x y : L} : x ∈ S → y ∈ S → x - y ∈ S :=
  sub_mem
#align intermediate_field.sub_mem IntermediateField.sub_mem

/- warning: intermediate_field.neg_mem -> IntermediateField.neg_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L}, (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Neg.neg.{u2} L (SubNegMonoid.toHasNeg.{u2} L (AddGroup.toSubNegMonoid.{u2} L (AddGroupWithOne.toAddGroup.{u2} L (AddCommGroupWithOne.toAddGroupWithOne.{u2} L (Ring.toAddCommGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))) x) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L}, (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Neg.neg.{u2} L (Ring.toNeg.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) x) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.neg_mem IntermediateField.neg_memₓ'. -/
/-- An intermediate field is closed under negation. -/
protected theorem neg_mem {x : L} : x ∈ S → -x ∈ S :=
  neg_mem
#align intermediate_field.neg_mem IntermediateField.neg_mem

/- warning: intermediate_field.inv_mem -> IntermediateField.inv_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L}, (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Inv.inv.{u2} L (DivInvMonoid.toHasInv.{u2} L (DivisionRing.toDivInvMonoid.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) x) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L}, (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Inv.inv.{u2} L (Field.toInv.{u2} L _inst_2) x) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.inv_mem IntermediateField.inv_memₓ'. -/
/-- An intermediate field is closed under inverses. -/
protected theorem inv_mem {x : L} : x ∈ S → x⁻¹ ∈ S :=
  inv_mem
#align intermediate_field.inv_mem IntermediateField.inv_mem

/- warning: intermediate_field.div_mem -> IntermediateField.div_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L} {y : L}, (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) y S) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HDiv.hDiv.{u2, u2, u2} L L L (instHDiv.{u2} L (DivInvMonoid.toHasDiv.{u2} L (DivisionRing.toDivInvMonoid.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) x y) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L} {y : L}, (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) y S) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HDiv.hDiv.{u2, u2, u2} L L L (instHDiv.{u2} L (Field.toDiv.{u2} L _inst_2)) x y) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.div_mem IntermediateField.div_memₓ'. -/
/-- An intermediate field is closed under division. -/
protected theorem div_mem {x y : L} : x ∈ S → y ∈ S → x / y ∈ S :=
  div_mem
#align intermediate_field.div_mem IntermediateField.div_mem

/- warning: intermediate_field.list_prod_mem -> IntermediateField.list_prod_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {l : List.{u2} L}, (forall (x : L), (Membership.Mem.{u2, u2} L (List.{u2} L) (List.hasMem.{u2} L) x l) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (List.prod.{u2} L (Distrib.toHasMul.{u2} L (Ring.toDistrib.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (AddMonoidWithOne.toOne.{u2} L (AddGroupWithOne.toAddMonoidWithOne.{u2} L (AddCommGroupWithOne.toAddGroupWithOne.{u2} L (Ring.toAddCommGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) l) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {l : List.{u2} L}, (forall (x : L), (Membership.mem.{u2, u2} L (List.{u2} L) (List.instMembershipList.{u2} L) x l) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (List.prod.{u2} L (NonUnitalNonAssocRing.toMul.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (Semiring.toOne.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) l) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.list_prod_mem IntermediateField.list_prod_memₓ'. -/
/-- Product of a list of elements in an intermediate_field is in the intermediate_field. -/
protected theorem list_prod_mem {l : List L} : (∀ x ∈ l, x ∈ S) → l.Prod ∈ S :=
  list_prod_mem
#align intermediate_field.list_prod_mem IntermediateField.list_prod_mem

/- warning: intermediate_field.list_sum_mem -> IntermediateField.list_sum_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {l : List.{u2} L}, (forall (x : L), (Membership.Mem.{u2, u2} L (List.{u2} L) (List.hasMem.{u2} L) x l) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (List.sum.{u2} L (Distrib.toHasAdd.{u2} L (Ring.toDistrib.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (MulZeroClass.toHasZero.{u2} L (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))) l) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {l : List.{u2} L}, (forall (x : L), (Membership.mem.{u2, u2} L (List.{u2} L) (List.instMembershipList.{u2} L) x l) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (List.sum.{u2} L (Distrib.toAdd.{u2} L (NonUnitalNonAssocSemiring.toDistrib.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))) (CommMonoidWithZero.toZero.{u2} L (CommGroupWithZero.toCommMonoidWithZero.{u2} L (Semifield.toCommGroupWithZero.{u2} L (Field.toSemifield.{u2} L _inst_2)))) l) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.list_sum_mem IntermediateField.list_sum_memₓ'. -/
/-- Sum of a list of elements in an intermediate field is in the intermediate_field. -/
protected theorem list_sum_mem {l : List L} : (∀ x ∈ l, x ∈ S) → l.Sum ∈ S :=
  list_sum_mem
#align intermediate_field.list_sum_mem IntermediateField.list_sum_mem

/- warning: intermediate_field.multiset_prod_mem -> IntermediateField.multiset_prod_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (m : Multiset.{u2} L), (forall (a : L), (Membership.Mem.{u2, u2} L (Multiset.{u2} L) (Multiset.hasMem.{u2} L) a m) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) a S)) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Multiset.prod.{u2} L (CommRing.toCommMonoid.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))) m) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (m : Multiset.{u2} L), (forall (a : L), (Membership.mem.{u2, u2} L (Multiset.{u2} L) (Multiset.instMembershipMultiset.{u2} L) a m) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) a S)) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Multiset.prod.{u2} L (CommRing.toCommMonoid.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))) m) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.multiset_prod_mem IntermediateField.multiset_prod_memₓ'. -/
/-- Product of a multiset of elements in an intermediate field is in the intermediate_field. -/
protected theorem multiset_prod_mem (m : Multiset L) : (∀ a ∈ m, a ∈ S) → m.Prod ∈ S :=
  multiset_prod_mem m
#align intermediate_field.multiset_prod_mem IntermediateField.multiset_prod_mem

/- warning: intermediate_field.multiset_sum_mem -> IntermediateField.multiset_sum_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (m : Multiset.{u2} L), (forall (a : L), (Membership.Mem.{u2, u2} L (Multiset.{u2} L) (Multiset.hasMem.{u2} L) a m) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) a S)) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Multiset.sum.{u2} L (AddCommGroup.toAddCommMonoid.{u2} L (NonUnitalNonAssocRing.toAddCommGroup.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) m) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (m : Multiset.{u2} L), (forall (a : L), (Membership.mem.{u2, u2} L (Multiset.{u2} L) (Multiset.instMembershipMultiset.{u2} L) a m) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) a S)) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Multiset.sum.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) m) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.multiset_sum_mem IntermediateField.multiset_sum_memₓ'. -/
/-- Sum of a multiset of elements in a `intermediate_field` is in the `intermediate_field`. -/
protected theorem multiset_sum_mem (m : Multiset L) : (∀ a ∈ m, a ∈ S) → m.Sum ∈ S :=
  multiset_sum_mem m
#align intermediate_field.multiset_sum_mem IntermediateField.multiset_sum_mem

/- warning: intermediate_field.prod_mem -> IntermediateField.prod_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {ι : Type.{u3}} {t : Finset.{u3} ι} {f : ι -> L}, (forall (c : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) c t) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (f c) S)) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Finset.prod.{u2, u3} L ι (CommRing.toCommMonoid.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))) t (fun (i : ι) => f i)) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {ι : Type.{u3}} {t : Finset.{u3} ι} {f : ι -> L}, (forall (c : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) c t) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (f c) S)) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Finset.prod.{u2, u3} L ι (CommRing.toCommMonoid.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))) t (fun (i : ι) => f i)) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.prod_mem IntermediateField.prod_memₓ'. -/
/-- Product of elements of an intermediate field indexed by a `finset` is in the intermediate_field.
-/
protected theorem prod_mem {ι : Type _} {t : Finset ι} {f : ι → L} (h : ∀ c ∈ t, f c ∈ S) :
    (∏ i in t, f i) ∈ S :=
  prod_mem h
#align intermediate_field.prod_mem IntermediateField.prod_mem

/- warning: intermediate_field.sum_mem -> IntermediateField.sum_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {ι : Type.{u3}} {t : Finset.{u3} ι} {f : ι -> L}, (forall (c : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) c t) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (f c) S)) -> (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Finset.sum.{u2, u3} L ι (AddCommGroup.toAddCommMonoid.{u2} L (NonUnitalNonAssocRing.toAddCommGroup.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) t (fun (i : ι) => f i)) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {ι : Type.{u3}} {t : Finset.{u3} ι} {f : ι -> L}, (forall (c : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) c t) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (f c) S)) -> (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Finset.sum.{u2, u3} L ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) t (fun (i : ι) => f i)) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.sum_mem IntermediateField.sum_memₓ'. -/
/-- Sum of elements in a `intermediate_field` indexed by a `finset` is in the `intermediate_field`.
-/
protected theorem sum_mem {ι : Type _} {t : Finset ι} {f : ι → L} (h : ∀ c ∈ t, f c ∈ S) :
    (∑ i in t, f i) ∈ S :=
  sum_mem h
#align intermediate_field.sum_mem IntermediateField.sum_mem

/- warning: intermediate_field.pow_mem -> IntermediateField.pow_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L}, (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (forall (n : Int), Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HPow.hPow.{u2, 0, u2} L Int L (instHPow.{u2, 0} L Int (DivInvMonoid.Pow.{u2} L (DivisionRing.toDivInvMonoid.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) x n) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L}, (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (forall (n : Int), Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HPow.hPow.{u2, 0, u2} L Int L (instHPow.{u2, 0} L Int (DivInvMonoid.Pow.{u2} L (DivisionRing.toDivInvMonoid.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) x n) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.pow_mem IntermediateField.pow_memₓ'. -/
protected theorem pow_mem {x : L} (hx : x ∈ S) (n : ℤ) : x ^ n ∈ S :=
  zpow_mem hx n
#align intermediate_field.pow_mem IntermediateField.pow_mem

/- warning: intermediate_field.zsmul_mem -> IntermediateField.zsmul_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L}, (Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (forall (n : Int), Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (SMul.smul.{0, u2} Int L (SubNegMonoid.SMulInt.{u2} L (AddGroup.toSubNegMonoid.{u2} L (AddGroupWithOne.toAddGroup.{u2} L (AddCommGroupWithOne.toAddGroupWithOne.{u2} L (Ring.toAddCommGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))) n x) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {x : L}, (Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S) -> (forall (n : Int), Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (HSMul.hSMul.{0, u2, u2} Int L L (instHSMul.{0, u2} Int L (SubNegMonoid.SMulInt.{u2} L (AddGroup.toSubNegMonoid.{u2} L (AddGroupWithOne.toAddGroup.{u2} L (Ring.toAddGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))) n x) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.zsmul_mem IntermediateField.zsmul_memₓ'. -/
protected theorem zsmul_mem {x : L} (hx : x ∈ S) (n : ℤ) : n • x ∈ S :=
  zsmul_mem hx n
#align intermediate_field.zsmul_mem IntermediateField.zsmul_mem

/- warning: intermediate_field.coe_int_mem -> IntermediateField.coe_int_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (n : Int), Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int L (HasLiftT.mk.{1, succ u2} Int L (CoeTCₓ.coe.{1, succ u2} Int L (Int.castCoe.{u2} L (AddGroupWithOne.toHasIntCast.{u2} L (AddCommGroupWithOne.toAddGroupWithOne.{u2} L (Ring.toAddCommGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))))) n) S
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (n : Int), Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Int.cast.{u2} L (Ring.toIntCast.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) n) S
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_int_mem IntermediateField.coe_int_memₓ'. -/
protected theorem coe_int_mem (n : ℤ) : (n : L) ∈ S :=
  coe_int_mem S n
#align intermediate_field.coe_int_mem IntermediateField.coe_int_mem

/- warning: intermediate_field.coe_add -> IntermediateField.coe_add is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_add IntermediateField.coe_addₓ'. -/
protected theorem coe_add (x y : S) : (↑(x + y) : L) = ↑x + ↑y :=
  rfl
#align intermediate_field.coe_add IntermediateField.coe_add

/- warning: intermediate_field.coe_neg -> IntermediateField.coe_neg is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (x : coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S), Eq.{succ u2} L ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) (Neg.neg.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (AddSubgroupClass.neg.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (AddGroup.toSubNegMonoid.{u2} L (AddGroupWithOne.toAddGroup.{u2} L (AddCommGroupWithOne.toAddGroupWithOne.{u2} L (Ring.toAddCommGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubringClass.addSubgroupClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) (SubfieldClass.to_subringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L _inst_2 (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.subfieldClass.{u1, u2} K L _inst_1 _inst_2 _inst_4))) S) x)) (Neg.neg.{u2} L (SubNegMonoid.toHasNeg.{u2} L (AddGroup.toSubNegMonoid.{u2} L (AddGroupWithOne.toAddGroup.{u2} L (AddCommGroupWithOne.toAddGroupWithOne.{u2} L (Ring.toAddCommGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) x))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (x : Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)), Eq.{succ u2} L (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) (Neg.neg.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (AddSubgroupClass.neg.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (AddGroup.toSubNegMonoid.{u2} L (AddGroupWithOne.toAddGroup.{u2} L (Ring.toAddGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubringClass.addSubgroupClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) (SubfieldClass.toSubringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L _inst_2 (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.instSubfieldClassIntermediateFieldInstSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4))) S) x)) (Neg.neg.{u2} L (Ring.toNeg.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) x))
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_neg IntermediateField.coe_negₓ'. -/
protected theorem coe_neg (x : S) : (↑(-x) : L) = -↑x :=
  rfl
#align intermediate_field.coe_neg IntermediateField.coe_neg

/- warning: intermediate_field.coe_mul -> IntermediateField.coe_mul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_mul IntermediateField.coe_mulₓ'. -/
protected theorem coe_mul (x y : S) : (↑(x * y) : L) = ↑x * ↑y :=
  rfl
#align intermediate_field.coe_mul IntermediateField.coe_mul

/- warning: intermediate_field.coe_inv -> IntermediateField.coe_inv is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (x : coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S), Eq.{succ u2} L ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) (Inv.inv.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (SubgroupClass.inv.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (DivisionRing.toDivInvMonoid.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubfieldClass.toSubgroupClass.{u2, u2} L _inst_2 (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.subfieldClass.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) x)) (Inv.inv.{u2} L (DivInvMonoid.toHasInv.{u2} L (DivisionRing.toDivInvMonoid.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) x))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (x : Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)), Eq.{succ u2} L (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) (Inv.inv.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (SubgroupClass.inv.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (DivisionRing.toDivInvMonoid.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubfieldClass.toSubgroupClass.{u2, u2} L _inst_2 (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.instSubfieldClassIntermediateFieldInstSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) x)) (Inv.inv.{u2} L (Field.toInv.{u2} L _inst_2) (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) x))
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_inv IntermediateField.coe_invₓ'. -/
protected theorem coe_inv (x : S) : (↑x⁻¹ : L) = (↑x)⁻¹ :=
  rfl
#align intermediate_field.coe_inv IntermediateField.coe_inv

/- warning: intermediate_field.coe_zero -> IntermediateField.coe_zero is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} L ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) (OfNat.ofNat.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) 0 (OfNat.mk.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) 0 (Zero.zero.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (ZeroMemClass.zero.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddMonoidWithOne.toAddMonoid.{u2} L (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} L (NonAssocSemiring.toAddCommMonoidWithOne.{u2} L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (AddSubmonoidClass.to_zeroMemClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (AddMonoid.toAddZeroClass.{u2} L (AddMonoidWithOne.toAddMonoid.{u2} L (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} L (NonAssocSemiring.toAddCommMonoidWithOne.{u2} L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))))) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubsemiringClass.to_addSubmonoidClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubringClass.to_subsemiringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubfieldClass.to_subringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L _inst_2 (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.subfieldClass.{u1, u2} K L _inst_1 _inst_2 _inst_4))))) S))))) (OfNat.ofNat.{u2} L 0 (OfNat.mk.{u2} L 0 (Zero.zero.{u2} L (MulZeroClass.toHasZero.{u2} L (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} L (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) (OfNat.ofNat.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) 0 (Zero.toOfNat0.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (ZeroMemClass.zero.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (CommMonoidWithZero.toZero.{u2} L (CommGroupWithZero.toCommMonoidWithZero.{u2} L (Semifield.toCommGroupWithZero.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (AddSubmonoidClass.toZeroMemClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (AddMonoid.toAddZeroClass.{u2} L (AddMonoidWithOne.toAddMonoid.{u2} L (AddGroupWithOne.toAddMonoidWithOne.{u2} L (Ring.toAddGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubsemiringClass.toAddSubmonoidClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubringClass.toSubsemiringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubfieldClass.toSubringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L _inst_2 (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.instSubfieldClassIntermediateFieldInstSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4))))) S)))) (OfNat.ofNat.{u2} L 0 (Zero.toOfNat0.{u2} L (CommMonoidWithZero.toZero.{u2} L (CommGroupWithZero.toCommMonoidWithZero.{u2} L (Semifield.toCommGroupWithZero.{u2} L (Field.toSemifield.{u2} L _inst_2))))))
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_zero IntermediateField.coe_zeroₓ'. -/
protected theorem coe_zero : ((0 : S) : L) = 0 :=
  rfl
#align intermediate_field.coe_zero IntermediateField.coe_zero

/- warning: intermediate_field.coe_one -> IntermediateField.coe_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} L ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) (OfNat.ofNat.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) 1 (OfNat.mk.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) 1 (One.one.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (OneMemClass.one.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (AddMonoidWithOne.toOne.{u2} L (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} L (NonAssocSemiring.toAddCommMonoidWithOne.{u2} L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))) (AddSubmonoidWithOneClass.to_oneMemClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} L (NonAssocSemiring.toAddCommMonoidWithOne.{u2} L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubsemiringClass.addSubmonoidWithOneClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubringClass.to_subsemiringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubfieldClass.to_subringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L _inst_2 (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.subfieldClass.{u1, u2} K L _inst_1 _inst_2 _inst_4))))) S))))) (OfNat.ofNat.{u2} L 1 (OfNat.mk.{u2} L 1 (One.one.{u2} L (AddMonoidWithOne.toOne.{u2} L (AddGroupWithOne.toAddMonoidWithOne.{u2} L (AddCommGroupWithOne.toAddGroupWithOne.{u2} L (Ring.toAddCommGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} L (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) (OfNat.ofNat.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) 1 (One.toOfNat1.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (Submonoid.one.{u2} L (MulZeroOneClass.toMulOneClass.{u2} L (NonAssocSemiring.toMulZeroOneClass.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) (Subsemiring.toSubmonoid.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Subalgebra.toSubsemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S))))))) (OfNat.ofNat.{u2} L 1 (One.toOfNat1.{u2} L (Semiring.toOne.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))))
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_one IntermediateField.coe_oneₓ'. -/
protected theorem coe_one : ((1 : S) : L) = 1 :=
  rfl
#align intermediate_field.coe_one IntermediateField.coe_one

/- warning: intermediate_field.coe_pow -> IntermediateField.coe_pow is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (x : coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (n : Nat), Eq.{succ u2} L ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) (HPow.hPow.{u2, 0, u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) Nat (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (instHPow.{u2, 0} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) Nat (SubmonoidClass.nPow.{u2, u2} L (Ring.toMonoid.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubsemiringClass.to_submonoidClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubringClass.to_subsemiringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubfieldClass.to_subringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L _inst_2 (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.subfieldClass.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) S)) x n)) (HPow.hPow.{u2, 0, u2} L Nat L (instHPow.{u2, 0} L Nat (Monoid.Pow.{u2} L (Ring.toMonoid.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) x) n)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (x : Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (n : Nat), Eq.{succ u2} L (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) (HPow.hPow.{u2, 0, u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) Nat (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (instHPow.{u2, 0} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) Nat (SubmonoidClass.nPow.{u2, u2} L (MonoidWithZero.toMonoid.{u2} L (Semiring.toMonoidWithZero.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubsemiringClass.toSubmonoidClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubringClass.toSubsemiringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubfieldClass.toSubringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L _inst_2 (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.instSubfieldClassIntermediateFieldInstSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) S)) x n)) (HPow.hPow.{u2, 0, u2} L Nat L (instHPow.{u2, 0} L Nat (Monoid.Pow.{u2} L (MonoidWithZero.toMonoid.{u2} L (Semiring.toMonoidWithZero.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))))) (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) x) n)
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_pow IntermediateField.coe_powₓ'. -/
protected theorem coe_pow (x : S) (n : ℕ) : (↑(x ^ n) : L) = ↑x ^ n :=
  SubmonoidClass.coe_pow x n
#align intermediate_field.coe_pow IntermediateField.coe_pow

end InheritedLemmas

/- warning: intermediate_field.coe_nat_mem -> IntermediateField.coe_nat_mem is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (n : Nat), Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat L (HasLiftT.mk.{1, succ u2} Nat L (CoeTCₓ.coe.{1, succ u2} Nat L (Nat.castCoe.{u2} L (AddMonoidWithOne.toNatCast.{u2} L (AddGroupWithOne.toAddMonoidWithOne.{u2} L (AddCommGroupWithOne.toAddGroupWithOne.{u2} L (Ring.toAddCommGroupWithOne.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) n) S
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (n : Nat), Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) (Nat.cast.{u2} L (Semiring.toNatCast.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) n) S
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_nat_mem IntermediateField.coe_nat_memₓ'. -/
theorem coe_nat_mem (n : ℕ) : (n : L) ∈ S := by simpa using coe_int_mem S n
#align intermediate_field.coe_nat_mem IntermediateField.coe_nat_mem

end IntermediateField

/- warning: subalgebra.to_intermediate_field -> Subalgebra.toIntermediateField is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4), (forall (x : L), (Membership.Mem.{u2, u2} L (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (SetLike.hasMem.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)) x S) -> (Membership.Mem.{u2, u2} L (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (SetLike.hasMem.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)) (Inv.inv.{u2} L (DivInvMonoid.toHasInv.{u2} L (DivisionRing.toDivInvMonoid.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) x) S)) -> (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4), (forall (x : L), (Membership.mem.{u2, u2} L (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (SetLike.instMembership.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) L (Subalgebra.instSetLikeSubalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4)) x S) -> (Membership.mem.{u2, u2} L (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (SetLike.instMembership.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) L (Subalgebra.instSetLikeSubalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4)) (Inv.inv.{u2} L (Field.toInv.{u2} L _inst_2) x) S)) -> (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align subalgebra.to_intermediate_field Subalgebra.toIntermediateFieldₓ'. -/
/-- Turn a subalgebra closed under inverses into an intermediate field -/
def Subalgebra.toIntermediateField (S : Subalgebra K L) (inv_mem : ∀ x ∈ S, x⁻¹ ∈ S) :
    IntermediateField K L :=
  { S with
    neg_mem' := fun x => S.neg_mem
    inv_mem' := inv_mem }
#align subalgebra.to_intermediate_field Subalgebra.toIntermediateField

/- warning: to_subalgebra_to_intermediate_field -> toSubalgebra_toIntermediateField is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (inv_mem : forall (x : L), (Membership.Mem.{u2, u2} L (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (SetLike.hasMem.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)) x S) -> (Membership.Mem.{u2, u2} L (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (SetLike.hasMem.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)) (Inv.inv.{u2} L (DivInvMonoid.toHasInv.{u2} L (DivisionRing.toDivInvMonoid.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) x) S)), Eq.{succ u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 (Subalgebra.toIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S inv_mem)) S
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] (S : Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (inv_mem : forall (x : L), (Membership.mem.{u1, u1} L (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) L (Subalgebra.instSetLikeSubalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4)) x S) -> (Membership.mem.{u1, u1} L (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) L (Subalgebra.instSetLikeSubalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4)) (Inv.inv.{u1} L (Field.toInv.{u1} L _inst_2) x) S)), Eq.{succ u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 (Subalgebra.toIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4 S inv_mem)) S
Case conversion may be inaccurate. Consider using '#align to_subalgebra_to_intermediate_field toSubalgebra_toIntermediateFieldₓ'. -/
@[simp]
theorem toSubalgebra_toIntermediateField (S : Subalgebra K L) (inv_mem : ∀ x ∈ S, x⁻¹ ∈ S) :
    (S.toIntermediateField inv_mem).toSubalgebra = S :=
  by
  ext
  rfl
#align to_subalgebra_to_intermediate_field toSubalgebra_toIntermediateField

/- warning: to_intermediate_field_to_subalgebra -> toIntermediateField_toSubalgebra is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Subalgebra.toIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) (fun (x : L) => IntermediateField.inv_mem.{u1, u2} K L _inst_1 _inst_2 _inst_4 S x)) S
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] (S : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4), Eq.{succ u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (Subalgebra.toIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4 (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 S) (fun (x : L) => IntermediateField.inv_mem.{u2, u1} K L _inst_1 _inst_2 _inst_4 S x)) S
Case conversion may be inaccurate. Consider using '#align to_intermediate_field_to_subalgebra toIntermediateField_toSubalgebraₓ'. -/
@[simp]
theorem toIntermediateField_toSubalgebra (S : IntermediateField K L) :
    (S.toSubalgebra.toIntermediateField fun x => S.inv_mem) = S :=
  by
  ext
  rfl
#align to_intermediate_field_to_subalgebra toIntermediateField_toSubalgebra

/- warning: subalgebra.to_intermediate_field' -> Subalgebra.toIntermediateField' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4), (IsField.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)) S) (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4 S)) -> (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4), (IsField.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (SetLike.instMembership.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) L (Subalgebra.instSetLikeSubalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4)) x S)) (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 S)) -> (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align subalgebra.to_intermediate_field' Subalgebra.toIntermediateField'ₓ'. -/
/-- Turn a subalgebra satisfying `is_field` into an intermediate_field -/
def Subalgebra.toIntermediateField' (S : Subalgebra K L) (hS : IsField S) : IntermediateField K L :=
  S.toIntermediateField fun x hx => by
    by_cases hx0 : x = 0
    · rw [hx0, inv_zero]
      exact S.zero_mem
    letI hS' := hS.to_field
    obtain ⟨y, hy⟩ := hS.mul_inv_cancel (show (⟨x, hx⟩ : S) ≠ 0 from Subtype.ne_of_val_ne hx0)
    rw [Subtype.ext_iff, S.coe_mul, S.coe_one, Subtype.coe_mk, mul_eq_one_iff_inv_eq₀ hx0] at hy
    exact hy.symm ▸ y.2
#align subalgebra.to_intermediate_field' Subalgebra.toIntermediateField'

/- warning: to_subalgebra_to_intermediate_field' -> toSubalgebra_toIntermediateField' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (hS : IsField.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)) S) (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4 S)), Eq.{succ u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 (Subalgebra.toIntermediateField'.{u1, u2} K L _inst_1 _inst_2 _inst_4 S hS)) S
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] (S : Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (hS : IsField.{u1} (Subtype.{succ u1} L (fun (x : L) => Membership.mem.{u1, u1} L (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) L (Subalgebra.instSetLikeSubalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4)) x S)) (Subalgebra.toSemiring.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4 S)), Eq.{succ u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 (Subalgebra.toIntermediateField'.{u2, u1} K L _inst_1 _inst_2 _inst_4 S hS)) S
Case conversion may be inaccurate. Consider using '#align to_subalgebra_to_intermediate_field' toSubalgebra_toIntermediateField'ₓ'. -/
@[simp]
theorem toSubalgebra_toIntermediateField' (S : Subalgebra K L) (hS : IsField S) :
    (S.toIntermediateField' hS).toSubalgebra = S :=
  by
  ext
  rfl
#align to_subalgebra_to_intermediate_field' toSubalgebra_toIntermediateField'

/- warning: to_intermediate_field'_to_subalgebra -> toIntermediateField'_toSubalgebra is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Subalgebra.toIntermediateField'.{u1, u2} K L _inst_1 _inst_2 _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) (Field.toIsField.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (SubfieldClass.toField.{u2, u2} L _inst_2 (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.subfieldClass.{u1, u2} K L _inst_1 _inst_2 _inst_4) S))) S
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] (S : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4), Eq.{succ u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (Subalgebra.toIntermediateField'.{u2, u1} K L _inst_1 _inst_2 _inst_4 (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 S) (Field.toIsField.{u1} (Subtype.{succ u1} L (fun (x : L) => Membership.mem.{u1, u1} L (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)) x S)) (SubfieldClass.toField.{u1, u1} L _inst_2 (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (IntermediateField.instSubfieldClassIntermediateFieldInstSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) S))) S
Case conversion may be inaccurate. Consider using '#align to_intermediate_field'_to_subalgebra toIntermediateField'_toSubalgebraₓ'. -/
@[simp]
theorem toIntermediateField'_toSubalgebra (S : IntermediateField K L) :
    S.toSubalgebra.toIntermediateField' (Field.toIsField S) = S :=
  by
  ext
  rfl
#align to_intermediate_field'_to_subalgebra toIntermediateField'_toSubalgebra

/- warning: subfield.to_intermediate_field -> Subfield.toIntermediateField is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : Subfield.{u2} L _inst_2), (forall (x : K), Membership.Mem.{u2, u2} L (Subfield.{u2} L _inst_2) (SetLike.hasMem.{u2, u2} (Subfield.{u2} L _inst_2) L (Subfield.setLike.{u2} L _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (fun (_x : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) => K -> L) (RingHom.hasCoeToFun.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (algebraMap.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) x) S) -> (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : Subfield.{u2} L _inst_2), (forall (x : K), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : K) => L) x) (Subfield.{u2} L _inst_2) (SetLike.instMembership.{u2, u2} (Subfield.{u2} L _inst_2) L (Subfield.instSetLikeSubfield.{u2} L _inst_2)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : K) => L) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))))) (algebraMap.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) x) S) -> (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align subfield.to_intermediate_field Subfield.toIntermediateFieldₓ'. -/
/-- Turn a subfield of `L` containing the image of `K` into an intermediate field -/
def Subfield.toIntermediateField (S : Subfield L) (algebra_map_mem : ∀ x, algebraMap K L x ∈ S) :
    IntermediateField K L :=
  { S with algebraMap_mem' := algebra_map_mem }
#align subfield.to_intermediate_field Subfield.toIntermediateField

namespace IntermediateField

/- warning: intermediate_field.to_field -> IntermediateField.toField is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Field.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Field.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))
Case conversion may be inaccurate. Consider using '#align intermediate_field.to_field IntermediateField.toFieldₓ'. -/
/-- An intermediate field inherits a field structure -/
instance toField : Field S :=
  S.toSubfield.toField
#align intermediate_field.to_field IntermediateField.toField

/- warning: intermediate_field.coe_sum -> IntermediateField.coe_sum is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_sum IntermediateField.coe_sumₓ'. -/
@[simp, norm_cast]
theorem coe_sum {ι : Type _} [Fintype ι] (f : ι → S) : (↑(∑ i, f i) : L) = ∑ i, (f i : L) := by
  classical
    induction' Finset.univ using Finset.induction_on with i s hi H
    · simp
    · rw [Finset.sum_insert hi, AddMemClass.coe_add, H, Finset.sum_insert hi]
#align intermediate_field.coe_sum IntermediateField.coe_sum

/- warning: intermediate_field.coe_prod -> IntermediateField.coe_prod is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {ι : Type.{u3}} [_inst_6 : Fintype.{u3} ι] (f : ι -> (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S)), Eq.{succ u2} L ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) (Finset.prod.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) ι (CommRing.toCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (EuclideanDomain.toCommRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Field.toEuclideanDomain.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)))) (Finset.univ.{u3} ι _inst_6) (fun (i : ι) => f i))) (Finset.prod.{u2, u3} L ι (CommRing.toCommMonoid.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))) (Finset.univ.{u3} ι _inst_6) (fun (i : ι) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) (f i)))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {ι : Type.{u3}} [_inst_6 : Fintype.{u3} ι] (f : ι -> (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))), Eq.{succ u2} L (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) (Finset.prod.{u2, u3} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) ι (Submonoid.toCommMonoid.{u2} L (CommRing.toCommMonoid.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))) (Subsemiring.toSubmonoid.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (Subalgebra.toSubsemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)))) (Finset.univ.{u3} ι _inst_6) (fun (i : ι) => f i))) (Finset.prod.{u2, u3} L ι (CommRing.toCommMonoid.{u2} L (EuclideanDomain.toCommRing.{u2} L (Field.toEuclideanDomain.{u2} L _inst_2))) (Finset.univ.{u3} ι _inst_6) (fun (i : ι) => Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) (f i)))
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_prod IntermediateField.coe_prodₓ'. -/
@[simp, norm_cast]
theorem coe_prod {ι : Type _} [Fintype ι] (f : ι → S) : (↑(∏ i, f i) : L) = ∏ i, (f i : L) := by
  classical
    induction' Finset.univ using Finset.induction_on with i s hi H
    · simp
    · rw [Finset.prod_insert hi, MulMemClass.coe_mul, H, Finset.prod_insert hi]
#align intermediate_field.coe_prod IntermediateField.coe_prod

/-! `intermediate_field`s inherit structure from their `subalgebra` coercions. -/


/- warning: intermediate_field.module' -> IntermediateField.module' is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.module' IntermediateField.module'ₓ'. -/
instance module' {R} [Semiring R] [SMul R K] [Module R L] [IsScalarTower R K L] : Module R S :=
  S.toSubalgebra.module'
#align intermediate_field.module' IntermediateField.module'

/- warning: intermediate_field.module -> IntermediateField.module is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Module.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)))))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Module.{u1, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (Ring.toNonAssocRing.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (DivisionRing.toRing.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (Field.toDivisionRing.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)))))))
Case conversion may be inaccurate. Consider using '#align intermediate_field.module IntermediateField.moduleₓ'. -/
instance module : Module K S :=
  S.toSubalgebra.Module
#align intermediate_field.module IntermediateField.module

/- warning: intermediate_field.is_scalar_tower -> IntermediateField.isScalarTower is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.is_scalar_tower IntermediateField.isScalarTowerₓ'. -/
instance isScalarTower {R} [Semiring R] [SMul R K] [Module R L] [IsScalarTower R K L] :
    IsScalarTower R K S :=
  S.toSubalgebra.IsScalarTower
#align intermediate_field.is_scalar_tower IntermediateField.isScalarTower

/- warning: intermediate_field.coe_smul -> IntermediateField.coe_smul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_smul IntermediateField.coe_smulₓ'. -/
@[simp]
theorem coe_smul {R} [Semiring R] [SMul R K] [Module R L] [IsScalarTower R K L] (r : R) (x : S) :
    ↑(r • x) = (r • x : L) :=
  rfl
#align intermediate_field.coe_smul IntermediateField.coe_smul

/- warning: intermediate_field.algebra' -> IntermediateField.algebra' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {K' : Type.{u3}} [_inst_6 : CommSemiring.{u3} K'] [_inst_7 : SMul.{u3, u1} K' K] [_inst_8 : Algebra.{u3, u2} K' L _inst_6 (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] [_inst_9 : IsScalarTower.{u3, u1, u2} K' K L _inst_7 (SMulZeroClass.toHasSmul.{u1, u2} K L (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} K L (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K L (Semiring.toMonoidWithZero.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (Module.toMulActionWithZero.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) (Algebra.toModule.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4))))) (SMulZeroClass.toHasSmul.{u3, u2} K' L (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (SMulWithZero.toSmulZeroClass.{u3, u2} K' L (MulZeroClass.toHasZero.{u3} K' (MulZeroOneClass.toMulZeroClass.{u3} K' (MonoidWithZero.toMulZeroOneClass.{u3} K' (Semiring.toMonoidWithZero.{u3} K' (CommSemiring.toSemiring.{u3} K' _inst_6))))) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (MulActionWithZero.toSMulWithZero.{u3, u2} K' L (Semiring.toMonoidWithZero.{u3} K' (CommSemiring.toSemiring.{u3} K' _inst_6)) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (Module.toMulActionWithZero.{u3, u2} K' L (CommSemiring.toSemiring.{u3} K' _inst_6) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) (Algebra.toModule.{u3, u2} K' L _inst_6 (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_8)))))], Algebra.{u3, u2} K' (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) _inst_6 (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {K' : Type.{u3}} [_inst_6 : CommSemiring.{u3} K'] [_inst_7 : SMul.{u3, u1} K' K] [_inst_8 : Algebra.{u3, u2} K' L _inst_6 (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] [_inst_9 : IsScalarTower.{u3, u1, u2} K' K L _inst_7 (Algebra.toSMul.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (Algebra.toSMul.{u3, u2} K' L _inst_6 (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_8)], Algebra.{u3, u2} K' (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) _inst_6 (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S))
Case conversion may be inaccurate. Consider using '#align intermediate_field.algebra' IntermediateField.algebra'ₓ'. -/
instance algebra' {K'} [CommSemiring K'] [SMul K' K] [Algebra K' L] [IsScalarTower K' K L] :
    Algebra K' S :=
  S.toSubalgebra.algebra'
#align intermediate_field.algebra' IntermediateField.algebra'

/- warning: intermediate_field.algebra -> IntermediateField.algebra is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Algebra.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Algebra.{u1, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S))
Case conversion may be inaccurate. Consider using '#align intermediate_field.algebra IntermediateField.algebraₓ'. -/
instance algebra : Algebra K S :=
  S.toSubalgebra.Algebra
#align intermediate_field.algebra IntermediateField.algebra

/- warning: intermediate_field.to_algebra -> IntermediateField.toAlgebra is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {R : Type.{u3}} [_inst_6 : Semiring.{u3} R] [_inst_7 : Algebra.{u2, u3} L R (Semifield.toCommSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)) _inst_6], Algebra.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) R (SubsemiringClass.toCommSemiring.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S L (Semifield.toCommSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.toAlgebra._proof_1.{u1, u2} K L _inst_1 _inst_2 _inst_4)) _inst_6
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) {R : Type.{u3}} [_inst_6 : Semiring.{u3} R] [_inst_7 : Algebra.{u2, u3} L R (Semifield.toCommSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)) _inst_6], Algebra.{u2, u3} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) R (Subalgebra.toCommSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Semifield.toCommSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) _inst_6
Case conversion may be inaccurate. Consider using '#align intermediate_field.to_algebra IntermediateField.toAlgebraₓ'. -/
instance toAlgebra {R : Type _} [Semiring R] [Algebra L R] : Algebra S R :=
  S.toSubalgebra.toAlgebra
#align intermediate_field.to_algebra IntermediateField.toAlgebra

/- warning: intermediate_field.is_scalar_tower_bot -> IntermediateField.isScalarTower_bot is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.is_scalar_tower_bot IntermediateField.isScalarTower_botₓ'. -/
instance isScalarTower_bot {R : Type _} [Semiring R] [Algebra L R] : IsScalarTower S L R :=
  IsScalarTower.subalgebra _ _ _ S.toSubalgebra
#align intermediate_field.is_scalar_tower_bot IntermediateField.isScalarTower_bot

/- warning: intermediate_field.is_scalar_tower_mid -> IntermediateField.isScalarTower_mid is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.is_scalar_tower_mid IntermediateField.isScalarTower_midₓ'. -/
instance isScalarTower_mid {R : Type _} [Semiring R] [Algebra L R] [Algebra K R]
    [IsScalarTower K L R] : IsScalarTower K S R :=
  IsScalarTower.subalgebra' _ _ _ S.toSubalgebra
#align intermediate_field.is_scalar_tower_mid IntermediateField.isScalarTower_mid

/- warning: intermediate_field.is_scalar_tower_mid' -> IntermediateField.isScalarTower_mid' is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.is_scalar_tower_mid' IntermediateField.isScalarTower_mid'ₓ'. -/
/-- Specialize `is_scalar_tower_mid` to the common case where the top field is `L` -/
instance isScalarTower_mid' : IsScalarTower K S L :=
  S.isScalarTower_mid
#align intermediate_field.is_scalar_tower_mid' IntermediateField.isScalarTower_mid'

#print IntermediateField.map /-
/-- If `f : L →+* L'` fixes `K`, `S.map f` is the intermediate field between `L'` and `K`
such that `x ∈ S ↔ f x ∈ S.map f`. -/
def map (f : L →ₐ[K] L') (S : IntermediateField K L) : IntermediateField K L' :=
  {
    S.toSubalgebra.map
      f with
    inv_mem' := by
      rintro _ ⟨x, hx, rfl⟩
      exact ⟨x⁻¹, S.inv_mem hx, map_inv₀ f x⟩
    neg_mem' := fun x hx => (S.toSubalgebra.map f).neg_mem hx }
#align intermediate_field.map IntermediateField.map
-/

/- warning: intermediate_field.coe_map -> IntermediateField.coe_map is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_map IntermediateField.coe_mapₓ'. -/
@[simp]
theorem coe_map (f : L →ₐ[K] L') : (S.map f : Set L') = f '' S :=
  rfl
#align intermediate_field.coe_map IntermediateField.coe_map

/- warning: intermediate_field.map_map -> IntermediateField.map_map is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L₁ : Type.{u2}} {L₂ : Type.{u3}} {L₃ : Type.{u4}} [_inst_6 : Field.{u1} K] [_inst_7 : Field.{u2} L₁] [_inst_8 : Algebra.{u1, u2} K L₁ (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_6)) (Ring.toSemiring.{u2} L₁ (DivisionRing.toRing.{u2} L₁ (Field.toDivisionRing.{u2} L₁ _inst_7)))] [_inst_9 : Field.{u3} L₂] [_inst_10 : Algebra.{u1, u3} K L₂ (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_6)) (Ring.toSemiring.{u3} L₂ (DivisionRing.toRing.{u3} L₂ (Field.toDivisionRing.{u3} L₂ _inst_9)))] [_inst_11 : Field.{u4} L₃] [_inst_12 : Algebra.{u1, u4} K L₃ (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_6)) (Ring.toSemiring.{u4} L₃ (DivisionRing.toRing.{u4} L₃ (Field.toDivisionRing.{u4} L₃ _inst_11)))] (E : IntermediateField.{u1, u2} K L₁ _inst_6 _inst_7 _inst_8) (f : AlgHom.{u1, u2, u3} K L₁ L₂ (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_6)) (Ring.toSemiring.{u2} L₁ (DivisionRing.toRing.{u2} L₁ (Field.toDivisionRing.{u2} L₁ _inst_7))) (Ring.toSemiring.{u3} L₂ (DivisionRing.toRing.{u3} L₂ (Field.toDivisionRing.{u3} L₂ _inst_9))) _inst_8 _inst_10) (g : AlgHom.{u1, u3, u4} K L₂ L₃ (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_6)) (Ring.toSemiring.{u3} L₂ (DivisionRing.toRing.{u3} L₂ (Field.toDivisionRing.{u3} L₂ _inst_9))) (Ring.toSemiring.{u4} L₃ (DivisionRing.toRing.{u4} L₃ (Field.toDivisionRing.{u4} L₃ _inst_11))) _inst_10 _inst_12), Eq.{succ u4} (IntermediateField.{u1, u4} K L₃ _inst_6 _inst_11 _inst_12) (IntermediateField.map.{u1, u3, u4} K L₂ L₃ _inst_6 _inst_9 _inst_11 _inst_10 _inst_12 g (IntermediateField.map.{u1, u2, u3} K L₁ L₂ _inst_6 _inst_7 _inst_9 _inst_8 _inst_10 f E)) (IntermediateField.map.{u1, u2, u4} K L₁ L₃ _inst_6 _inst_7 _inst_11 _inst_8 _inst_12 (AlgHom.comp.{u1, u2, u3, u4} K L₁ L₂ L₃ (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_6)) (Ring.toSemiring.{u2} L₁ (DivisionRing.toRing.{u2} L₁ (Field.toDivisionRing.{u2} L₁ _inst_7))) (Ring.toSemiring.{u3} L₂ (DivisionRing.toRing.{u3} L₂ (Field.toDivisionRing.{u3} L₂ _inst_9))) (Ring.toSemiring.{u4} L₃ (DivisionRing.toRing.{u4} L₃ (Field.toDivisionRing.{u4} L₃ _inst_11))) _inst_8 _inst_10 _inst_12 g f) E)
but is expected to have type
  forall {K : Type.{u4}} {L₁ : Type.{u3}} {L₂ : Type.{u2}} {L₃ : Type.{u1}} [_inst_6 : Field.{u4} K] [_inst_7 : Field.{u3} L₁] [_inst_8 : Algebra.{u4, u3} K L₁ (Semifield.toCommSemiring.{u4} K (Field.toSemifield.{u4} K _inst_6)) (DivisionSemiring.toSemiring.{u3} L₁ (Semifield.toDivisionSemiring.{u3} L₁ (Field.toSemifield.{u3} L₁ _inst_7)))] [_inst_9 : Field.{u2} L₂] [_inst_10 : Algebra.{u4, u2} K L₂ (Semifield.toCommSemiring.{u4} K (Field.toSemifield.{u4} K _inst_6)) (DivisionSemiring.toSemiring.{u2} L₂ (Semifield.toDivisionSemiring.{u2} L₂ (Field.toSemifield.{u2} L₂ _inst_9)))] [_inst_11 : Field.{u1} L₃] [_inst_12 : Algebra.{u4, u1} K L₃ (Semifield.toCommSemiring.{u4} K (Field.toSemifield.{u4} K _inst_6)) (DivisionSemiring.toSemiring.{u1} L₃ (Semifield.toDivisionSemiring.{u1} L₃ (Field.toSemifield.{u1} L₃ _inst_11)))] (E : IntermediateField.{u4, u3} K L₁ _inst_6 _inst_7 _inst_8) (f : AlgHom.{u4, u3, u2} K L₁ L₂ (Semifield.toCommSemiring.{u4} K (Field.toSemifield.{u4} K _inst_6)) (DivisionSemiring.toSemiring.{u3} L₁ (Semifield.toDivisionSemiring.{u3} L₁ (Field.toSemifield.{u3} L₁ _inst_7))) (DivisionSemiring.toSemiring.{u2} L₂ (Semifield.toDivisionSemiring.{u2} L₂ (Field.toSemifield.{u2} L₂ _inst_9))) _inst_8 _inst_10) (g : AlgHom.{u4, u2, u1} K L₂ L₃ (Semifield.toCommSemiring.{u4} K (Field.toSemifield.{u4} K _inst_6)) (DivisionSemiring.toSemiring.{u2} L₂ (Semifield.toDivisionSemiring.{u2} L₂ (Field.toSemifield.{u2} L₂ _inst_9))) (DivisionSemiring.toSemiring.{u1} L₃ (Semifield.toDivisionSemiring.{u1} L₃ (Field.toSemifield.{u1} L₃ _inst_11))) _inst_10 _inst_12), Eq.{succ u1} (IntermediateField.{u4, u1} K L₃ _inst_6 _inst_11 _inst_12) (IntermediateField.map.{u4, u2, u1} K L₂ L₃ _inst_6 _inst_9 _inst_11 _inst_10 _inst_12 g (IntermediateField.map.{u4, u3, u2} K L₁ L₂ _inst_6 _inst_7 _inst_9 _inst_8 _inst_10 f E)) (IntermediateField.map.{u4, u3, u1} K L₁ L₃ _inst_6 _inst_7 _inst_11 _inst_8 _inst_12 (AlgHom.comp.{u4, u3, u2, u1} K L₁ L₂ L₃ (Semifield.toCommSemiring.{u4} K (Field.toSemifield.{u4} K _inst_6)) (DivisionSemiring.toSemiring.{u3} L₁ (Semifield.toDivisionSemiring.{u3} L₁ (Field.toSemifield.{u3} L₁ _inst_7))) (DivisionSemiring.toSemiring.{u2} L₂ (Semifield.toDivisionSemiring.{u2} L₂ (Field.toSemifield.{u2} L₂ _inst_9))) (DivisionSemiring.toSemiring.{u1} L₃ (Semifield.toDivisionSemiring.{u1} L₃ (Field.toSemifield.{u1} L₃ _inst_11))) _inst_8 _inst_10 _inst_12 g f) E)
Case conversion may be inaccurate. Consider using '#align intermediate_field.map_map IntermediateField.map_mapₓ'. -/
theorem map_map {K L₁ L₂ L₃ : Type _} [Field K] [Field L₁] [Algebra K L₁] [Field L₂] [Algebra K L₂]
    [Field L₃] [Algebra K L₃] (E : IntermediateField K L₁) (f : L₁ →ₐ[K] L₂) (g : L₂ →ₐ[K] L₃) :
    (E.map f).map g = E.map (g.comp f) :=
  SetLike.coe_injective <| Set.image_image _ _ _
#align intermediate_field.map_map IntermediateField.map_map

/- warning: intermediate_field.intermediate_field_map -> IntermediateField.intermediateFieldMap is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} {L' : Type.{u3}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_3 : Field.{u3} L'] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] [_inst_5 : Algebra.{u1, u3} K L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3)))] (e : AlgEquiv.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))) _inst_4 _inst_5) (E : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), AlgEquiv.{u1, u2, u3} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (coeSort.{succ u3, succ (succ u3)} (IntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (IntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5) L' (IntermediateField.setLike.{u1, u3} K L' _inst_1 _inst_3 _inst_5)) (IntermediateField.map.{u1, u2, u3} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AlgEquiv.toAlgHom.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))) _inst_4 _inst_5 e) E)) (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 E)))) (Ring.toSemiring.{u3} (coeSort.{succ u3, succ (succ u3)} (IntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (IntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5) L' (IntermediateField.setLike.{u1, u3} K L' _inst_1 _inst_3 _inst_5)) (IntermediateField.map.{u1, u2, u3} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AlgEquiv.toAlgHom.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))) _inst_4 _inst_5 e) E)) (DivisionRing.toRing.{u3} (coeSort.{succ u3, succ (succ u3)} (IntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (IntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5) L' (IntermediateField.setLike.{u1, u3} K L' _inst_1 _inst_3 _inst_5)) (IntermediateField.map.{u1, u2, u3} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AlgEquiv.toAlgHom.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))) _inst_4 _inst_5 e) E)) (Field.toDivisionRing.{u3} (coeSort.{succ u3, succ (succ u3)} (IntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (IntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5) L' (IntermediateField.setLike.{u1, u3} K L' _inst_1 _inst_3 _inst_5)) (IntermediateField.map.{u1, u2, u3} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AlgEquiv.toAlgHom.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))) _inst_4 _inst_5 e) E)) (IntermediateField.toField.{u1, u3} K L' _inst_1 _inst_3 _inst_5 (IntermediateField.map.{u1, u2, u3} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AlgEquiv.toAlgHom.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))) _inst_4 _inst_5 e) E))))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 E) (IntermediateField.algebra.{u1, u3} K L' _inst_1 _inst_3 _inst_5 (IntermediateField.map.{u1, u2, u3} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AlgEquiv.toAlgHom.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))) _inst_4 _inst_5 e) E))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} {L' : Type.{u3}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_3 : Field.{u3} L'] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] [_inst_5 : Algebra.{u1, u3} K L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u3} L' (Semifield.toDivisionSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3)))] (e : AlgEquiv.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) (DivisionSemiring.toSemiring.{u3} L' (Semifield.toDivisionSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3))) _inst_4 _inst_5) (E : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), AlgEquiv.{u1, u2, u3} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x E)) (Subtype.{succ u3} L' (fun (x : L') => Membership.mem.{u3, u3} L' (IntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5) (SetLike.instMembership.{u3, u3} (IntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5) L' (IntermediateField.instSetLikeIntermediateField.{u1, u3} K L' _inst_1 _inst_3 _inst_5)) x (IntermediateField.map.{u1, u2, u3} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AlgEquiv.toAlgHom.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) (DivisionSemiring.toSemiring.{u3} L' (Semifield.toDivisionSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3))) _inst_4 _inst_5 e) E))) (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 E)) (Subalgebra.toSemiring.{u1, u3} K L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u3} L' (Semifield.toDivisionSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3))) _inst_5 (IntermediateField.toSubalgebra.{u1, u3} K L' _inst_1 _inst_3 _inst_5 (IntermediateField.map.{u1, u2, u3} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AlgEquiv.toAlgHom.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) (DivisionSemiring.toSemiring.{u3} L' (Semifield.toDivisionSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3))) _inst_4 _inst_5 e) E))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 E) (IntermediateField.algebra.{u1, u3} K L' _inst_1 _inst_3 _inst_5 (IntermediateField.map.{u1, u2, u3} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (AlgEquiv.toAlgHom.{u1, u2, u3} K L L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) (DivisionSemiring.toSemiring.{u3} L' (Semifield.toDivisionSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3))) _inst_4 _inst_5 e) E))
Case conversion may be inaccurate. Consider using '#align intermediate_field.intermediate_field_map IntermediateField.intermediateFieldMapₓ'. -/
/-- Given an equivalence `e : L ≃ₐ[K] L'` of `K`-field extensions and an intermediate
field `E` of `L/K`, `intermediate_field_equiv_map e E` is the induced equivalence
between `E` and `E.map e` -/
def intermediateFieldMap (e : L ≃ₐ[K] L') (E : IntermediateField K L) : E ≃ₐ[K] E.map e.toAlgHom :=
  e.subalgebraMap E.toSubalgebra
#align intermediate_field.intermediate_field_map IntermediateField.intermediateFieldMap

/- warning: intermediate_field.intermediate_field_map_apply_coe -> IntermediateField.intermediateFieldMap_apply_coe is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.intermediate_field_map_apply_coe IntermediateField.intermediateFieldMap_apply_coeₓ'. -/
/- We manually add these two simp lemmas because `@[simps]` before `intermediate_field_map`
  led to a timeout. -/
@[simp]
theorem intermediateFieldMap_apply_coe (e : L ≃ₐ[K] L') (E : IntermediateField K L) (a : E) :
    ↑(intermediateFieldMap e E a) = e a :=
  rfl
#align intermediate_field.intermediate_field_map_apply_coe IntermediateField.intermediateFieldMap_apply_coe

/- warning: intermediate_field.intermediate_field_map_symm_apply_coe -> IntermediateField.intermediateFieldMap_symm_apply_coe is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.intermediate_field_map_symm_apply_coe IntermediateField.intermediateFieldMap_symm_apply_coeₓ'. -/
@[simp]
theorem intermediateFieldMap_symm_apply_coe (e : L ≃ₐ[K] L') (E : IntermediateField K L)
    (a : E.map e.toAlgHom) : ↑((intermediateFieldMap e E).symm a) = e.symm a :=
  rfl
#align intermediate_field.intermediate_field_map_symm_apply_coe IntermediateField.intermediateFieldMap_symm_apply_coe

end IntermediateField

namespace AlgHom

variable (f : L →ₐ[K] L')

#print AlgHom.fieldRange /-
/-- The range of an algebra homomorphism, as an intermediate field. -/
@[simps toSubalgebra]
def fieldRange : IntermediateField K L' :=
  { f.range, (f : L →+* L').fieldRange with }
#align alg_hom.field_range AlgHom.fieldRange
-/

/- warning: alg_hom.coe_field_range -> AlgHom.coe_fieldRange is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align alg_hom.coe_field_range AlgHom.coe_fieldRangeₓ'. -/
@[simp]
theorem coe_fieldRange : ↑f.fieldRange = Set.range f :=
  rfl
#align alg_hom.coe_field_range AlgHom.coe_fieldRange

/- warning: alg_hom.field_range_to_subfield -> AlgHom.fieldRange_toSubfield is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align alg_hom.field_range_to_subfield AlgHom.fieldRange_toSubfieldₓ'. -/
@[simp]
theorem fieldRange_toSubfield : f.fieldRange.toSubfield = (f : L →+* L').fieldRange :=
  rfl
#align alg_hom.field_range_to_subfield AlgHom.fieldRange_toSubfield

variable {f}

/- warning: alg_hom.mem_field_range -> AlgHom.mem_fieldRange is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align alg_hom.mem_field_range AlgHom.mem_fieldRangeₓ'. -/
@[simp]
theorem mem_fieldRange {y : L'} : y ∈ f.fieldRange ↔ ∃ x, f x = y :=
  Iff.rfl
#align alg_hom.mem_field_range AlgHom.mem_fieldRange

end AlgHom

namespace IntermediateField

/- warning: intermediate_field.val -> IntermediateField.val is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), AlgHom.{u1, u2, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)))) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) _inst_4
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), AlgHom.{u1, u2, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) _inst_4
Case conversion may be inaccurate. Consider using '#align intermediate_field.val IntermediateField.valₓ'. -/
/-- The embedding from an intermediate field of `L / K` to `L`. -/
def val : S →ₐ[K] L :=
  S.toSubalgebra.val
#align intermediate_field.val IntermediateField.val

/- warning: intermediate_field.coe_val -> IntermediateField.coe_val is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_val IntermediateField.coe_valₓ'. -/
@[simp]
theorem coe_val : ⇑S.val = coe :=
  rfl
#align intermediate_field.coe_val IntermediateField.coe_val

/- warning: intermediate_field.val_mk -> IntermediateField.val_mk is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.val_mk IntermediateField.val_mkₓ'. -/
@[simp]
theorem val_mk {x : L} (hx : x ∈ S) : S.val ⟨x, hx⟩ = x :=
  rfl
#align intermediate_field.val_mk IntermediateField.val_mk

/- warning: intermediate_field.range_val -> IntermediateField.range_val is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (AlgHom.range.{u1, u2, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4 (IntermediateField.val.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (AlgHom.range.{u1, u2, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.val.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.range_val IntermediateField.range_valₓ'. -/
theorem range_val : S.val.range = S.toSubalgebra :=
  S.toSubalgebra.range_val
#align intermediate_field.range_val IntermediateField.range_val

/- warning: intermediate_field.field_range_val -> IntermediateField.fieldRange_val is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (AlgHom.fieldRange.{u1, u2, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L _inst_1 (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) _inst_2 (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) _inst_4 (IntermediateField.val.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) S
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Eq.{succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (AlgHom.fieldRange.{u1, u2, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) L _inst_1 (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) _inst_2 (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) _inst_4 (IntermediateField.val.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) S
Case conversion may be inaccurate. Consider using '#align intermediate_field.field_range_val IntermediateField.fieldRange_valₓ'. -/
@[simp]
theorem fieldRange_val : S.val.fieldRange = S :=
  SetLike.ext' Subtype.range_val
#align intermediate_field.field_range_val IntermediateField.fieldRange_val

/- warning: intermediate_field.alg_hom.inhabited -> IntermediateField.AlgHom.inhabited is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Inhabited.{succ u2} (AlgHom.{u1, u2, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)))) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) _inst_4)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), Inhabited.{succ u2} (AlgHom.{u1, u2, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) _inst_4)
Case conversion may be inaccurate. Consider using '#align intermediate_field.alg_hom.inhabited IntermediateField.AlgHom.inhabitedₓ'. -/
instance AlgHom.inhabited : Inhabited (S →ₐ[K] L) :=
  ⟨S.val⟩
#align intermediate_field.alg_hom.inhabited IntermediateField.AlgHom.inhabited

/- warning: intermediate_field.aeval_coe -> IntermediateField.aeval_coe is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.aeval_coe IntermediateField.aeval_coeₓ'. -/
theorem aeval_coe {R : Type _} [CommRing R] [Algebra R K] [Algebra R L] [IsScalarTower R K L]
    (x : S) (P : R[X]) : aeval (x : L) P = aeval x P :=
  by
  refine' Polynomial.induction_on' P (fun f g hf hg => _) fun n r => _
  · rw [aeval_add, aeval_add, AddMemClass.coe_add, hf, hg]
  · simp only [MulMemClass.coe_mul, aeval_monomial, SubmonoidClass.coe_pow, mul_eq_mul_right_iff]
    left
    rfl
#align intermediate_field.aeval_coe IntermediateField.aeval_coe

/- warning: intermediate_field.coe_is_integral_iff -> IntermediateField.coe_isIntegral_iff is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_is_integral_iff IntermediateField.coe_isIntegral_iffₓ'. -/
theorem coe_isIntegral_iff {R : Type _} [CommRing R] [Algebra R K] [Algebra R L]
    [IsScalarTower R K L] {x : S} : IsIntegral R (x : L) ↔ IsIntegral R x :=
  by
  refine' ⟨fun h => _, fun h => _⟩
  · obtain ⟨P, hPmo, hProot⟩ := h
    refine' ⟨P, hPmo, (injective_iff_map_eq_zero _).1 (algebraMap (↥S) L).Injective _ _⟩
    letI : IsScalarTower R S L := IsScalarTower.of_algebraMap_eq (congr_fun rfl)
    rwa [eval₂_eq_eval_map, ← eval₂_at_apply, eval₂_eq_eval_map, Polynomial.map_map, ←
      IsScalarTower.algebraMap_eq, ← eval₂_eq_eval_map]
  · obtain ⟨P, hPmo, hProot⟩ := h
    refine' ⟨P, hPmo, _⟩
    rw [← aeval_def, aeval_coe, aeval_def, hProot, ZeroMemClass.coe_zero]
#align intermediate_field.coe_is_integral_iff IntermediateField.coe_isIntegral_iff

/- warning: intermediate_field.inclusion -> IntermediateField.inclusion is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {E : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {F : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, (LE.le.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Preorder.toHasLe.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.partialOrder.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) E F) -> (AlgHom.{u1, u2, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 E)))) (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 E) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 F))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] {E : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {F : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, (LE.le.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Preorder.toLE.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instPartialOrder.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) E F) -> (AlgHom.{u1, u2, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x E)) (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x F)) (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 E)) (Subalgebra.toSemiring.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 E) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 F))
Case conversion may be inaccurate. Consider using '#align intermediate_field.inclusion IntermediateField.inclusionₓ'. -/
/-- The map `E → F` when `E` is an intermediate field contained in the intermediate field `F`.

This is the intermediate field version of `subalgebra.inclusion`. -/
def inclusion {E F : IntermediateField K L} (hEF : E ≤ F) : E →ₐ[K] F :=
  Subalgebra.inclusion hEF
#align intermediate_field.inclusion IntermediateField.inclusion

/- warning: intermediate_field.inclusion_injective -> IntermediateField.inclusion_injective is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.inclusion_injective IntermediateField.inclusion_injectiveₓ'. -/
theorem inclusion_injective {E F : IntermediateField K L} (hEF : E ≤ F) :
    Function.Injective (inclusion hEF) :=
  Subalgebra.inclusion_injective hEF
#align intermediate_field.inclusion_injective IntermediateField.inclusion_injective

/- warning: intermediate_field.inclusion_self -> IntermediateField.inclusion_self is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {E : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, Eq.{succ u2} (AlgHom.{u1, u2, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 E)))) (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 E)))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 E) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 E)) (IntermediateField.inclusion.{u1, u2} K L _inst_1 _inst_2 _inst_4 E E (le_refl.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.partialOrder.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4))) E)) (AlgHom.id.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) E) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 E)))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 E))
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] {E : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4}, Eq.{succ u1} (AlgHom.{u2, u1, u1} K (Subtype.{succ u1} L (fun (x : L) => Membership.mem.{u1, u1} L (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)) x E)) (Subtype.{succ u1} L (fun (x : L) => Membership.mem.{u1, u1} L (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)) x E)) (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (Subalgebra.toSemiring.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 E)) (Subalgebra.toSemiring.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 E)) (IntermediateField.algebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 E) (IntermediateField.algebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 E)) (IntermediateField.inclusion.{u2, u1} K L _inst_1 _inst_2 _inst_4 E E (le_refl.{u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instPartialOrder.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4))) E)) (AlgHom.id.{u2, u1} K (Subtype.{succ u1} L (fun (x : L) => Membership.mem.{u1, u1} L (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)) x E)) (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (Subalgebra.toSemiring.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4 (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 E)) (IntermediateField.algebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 E))
Case conversion may be inaccurate. Consider using '#align intermediate_field.inclusion_self IntermediateField.inclusion_selfₓ'. -/
@[simp]
theorem inclusion_self {E : IntermediateField K L} : inclusion (le_refl E) = AlgHom.id K E :=
  Subalgebra.inclusion_self
#align intermediate_field.inclusion_self IntermediateField.inclusion_self

/- warning: intermediate_field.inclusion_inclusion -> IntermediateField.inclusion_inclusion is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.inclusion_inclusion IntermediateField.inclusion_inclusionₓ'. -/
@[simp]
theorem inclusion_inclusion {E F G : IntermediateField K L} (hEF : E ≤ F) (hFG : F ≤ G) (x : E) :
    inclusion hFG (inclusion hEF x) = inclusion (le_trans hEF hFG) x :=
  Subalgebra.inclusion_inclusion hEF hFG x
#align intermediate_field.inclusion_inclusion IntermediateField.inclusion_inclusion

/- warning: intermediate_field.coe_inclusion -> IntermediateField.coe_inclusion is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_inclusion IntermediateField.coe_inclusionₓ'. -/
@[simp]
theorem coe_inclusion {E F : IntermediateField K L} (hEF : E ≤ F) (e : E) :
    (inclusion hEF e : L) = e :=
  rfl
#align intermediate_field.coe_inclusion IntermediateField.coe_inclusion

variable {S}

/- warning: intermediate_field.to_subalgebra_injective -> IntermediateField.toSubalgebra_injective is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {S' : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, (Eq.{succ u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S')) -> (Eq.{succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S S')
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] {S : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4} {S' : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4}, (Eq.{succ u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 S) (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 S')) -> (Eq.{succ u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) S S')
Case conversion may be inaccurate. Consider using '#align intermediate_field.to_subalgebra_injective IntermediateField.toSubalgebra_injectiveₓ'. -/
theorem toSubalgebra_injective {S S' : IntermediateField K L}
    (h : S.toSubalgebra = S'.toSubalgebra) : S = S' :=
  by
  ext
  rw [← mem_to_subalgebra, ← mem_to_subalgebra, h]
#align intermediate_field.to_subalgebra_injective IntermediateField.toSubalgebra_injective

variable (S)

/- warning: intermediate_field.set_range_subset -> IntermediateField.set_range_subset is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), HasSubset.Subset.{u2} (Set.{u2} L) (Set.hasSubset.{u2} L) (Set.range.{u2, succ u1} L K (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (fun (_x : RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) => K -> L) (RingHom.hasCoeToFun.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (algebraMap.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (HasLiftT.mk.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (CoeTCₓ.coe.{succ u2, succ u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Set.{u2} L) (SetLike.Set.hasCoeT.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), HasSubset.Subset.{u2} (Set.{u2} L) (Set.instHasSubsetSet.{u2} L) (Set.range.{u2, succ u1} L K (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : K) => L) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))))) K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (RingHom.instRingHomClassRingHom.{u1, u2} K L (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))))) (algebraMap.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4))) (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.set_range_subset IntermediateField.set_range_subsetₓ'. -/
theorem set_range_subset : Set.range (algebraMap K L) ⊆ S :=
  S.toSubalgebra.range_subset
#align intermediate_field.set_range_subset IntermediateField.set_range_subset

/- warning: intermediate_field.field_range_le -> IntermediateField.fieldRange_le is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), LE.le.{u2} (Subfield.{u2} L _inst_2) (Preorder.toHasLe.{u2} (Subfield.{u2} L _inst_2) (PartialOrder.toPreorder.{u2} (Subfield.{u2} L _inst_2) (SetLike.partialOrder.{u2, u2} (Subfield.{u2} L _inst_2) L (Subfield.setLike.{u2} L _inst_2)))) (RingHom.fieldRange.{u1, u2} K L _inst_1 _inst_2 (algebraMap.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)) (IntermediateField.toSubfield.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4), LE.le.{u2} (Subfield.{u2} L _inst_2) (Preorder.toLE.{u2} (Subfield.{u2} L _inst_2) (PartialOrder.toPreorder.{u2} (Subfield.{u2} L _inst_2) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Subfield.{u2} L _inst_2) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Subfield.{u2} L _inst_2) (Subfield.instCompleteLatticeSubfield.{u2} L _inst_2))))) (RingHom.fieldRange.{u1, u2} K L _inst_1 _inst_2 (algebraMap.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4)) (IntermediateField.toSubfield.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)
Case conversion may be inaccurate. Consider using '#align intermediate_field.field_range_le IntermediateField.fieldRange_leₓ'. -/
theorem fieldRange_le : (algebraMap K L).fieldRange ≤ S.toSubfield := fun x hx =>
  S.toSubalgebra.range_subset (by rwa [Set.mem_range, ← RingHom.mem_fieldRange])
#align intermediate_field.field_range_le IntermediateField.fieldRange_le

/- warning: intermediate_field.to_subalgebra_le_to_subalgebra -> IntermediateField.toSubalgebra_le_toSubalgebra is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {S' : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, Iff (LE.le.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)))) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S')) (LE.le.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Preorder.toHasLe.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.partialOrder.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) S S')
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] {S : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4} {S' : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4}, Iff (LE.le.{u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4))))) (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 S) (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 S')) (LE.le.{u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (Preorder.toLE.{u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instPartialOrder.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)))) S S')
Case conversion may be inaccurate. Consider using '#align intermediate_field.to_subalgebra_le_to_subalgebra IntermediateField.toSubalgebra_le_toSubalgebraₓ'. -/
@[simp]
theorem toSubalgebra_le_toSubalgebra {S S' : IntermediateField K L} :
    S.toSubalgebra ≤ S'.toSubalgebra ↔ S ≤ S' :=
  Iff.rfl
#align intermediate_field.to_subalgebra_le_to_subalgebra IntermediateField.toSubalgebra_le_toSubalgebra

/- warning: intermediate_field.to_subalgebra_lt_to_subalgebra -> IntermediateField.toSubalgebra_lt_toSubalgebra is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {S' : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, Iff (LT.lt.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (Preorder.toHasLt.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)))) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S')) (LT.lt.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Preorder.toHasLt.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.partialOrder.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) S S')
but is expected to have type
  forall {K : Type.{u2}} {L : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Field.{u1} L] [_inst_4 : Algebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2)))] {S : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4} {S' : IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4}, Iff (LT.lt.{u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (Preorder.toLT.{u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Subalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} K L (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u1} L (Semifield.toDivisionSemiring.{u1} L (Field.toSemifield.{u1} L _inst_2))) _inst_4))))) (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 S) (IntermediateField.toSubalgebra.{u2, u1} K L _inst_1 _inst_2 _inst_4 S')) (LT.lt.{u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (Preorder.toLT.{u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) (SetLike.instPartialOrder.{u1, u1} (IntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u2, u1} K L _inst_1 _inst_2 _inst_4)))) S S')
Case conversion may be inaccurate. Consider using '#align intermediate_field.to_subalgebra_lt_to_subalgebra IntermediateField.toSubalgebra_lt_toSubalgebraₓ'. -/
@[simp]
theorem toSubalgebra_lt_toSubalgebra {S S' : IntermediateField K L} :
    S.toSubalgebra < S'.toSubalgebra ↔ S < S' :=
  Iff.rfl
#align intermediate_field.to_subalgebra_lt_to_subalgebra IntermediateField.toSubalgebra_lt_toSubalgebra

variable {S}

section Tower

/- warning: intermediate_field.lift -> IntermediateField.lift is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {F : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, (IntermediateField.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) _inst_1 (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 F) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)) -> (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] {F : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, (IntermediateField.{u1, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x F)) _inst_1 (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 F) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)) -> (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align intermediate_field.lift IntermediateField.liftₓ'. -/
/-- Lift an intermediate_field of an intermediate_field -/
def lift {F : IntermediateField K L} (E : IntermediateField K F) : IntermediateField K L :=
  E.map (val F)
#align intermediate_field.lift IntermediateField.lift

/- warning: intermediate_field.has_lift -> IntermediateField.hasLift is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {F : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, HasLiftT.{succ u2, succ u2} (IntermediateField.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) _inst_1 (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 F) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] {F : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4}, CoeOut.{succ u2, succ u2} (IntermediateField.{u1, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x F)) _inst_1 (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 F) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align intermediate_field.has_lift IntermediateField.hasLiftₓ'. -/
instance hasLift {F : IntermediateField K L} :
    HasLiftT (IntermediateField K F) (IntermediateField K L) :=
  ⟨lift⟩
#align intermediate_field.has_lift IntermediateField.hasLift

section RestrictScalars

variable (K) [Algebra L' L] [IsScalarTower K L' L]

#print IntermediateField.restrictScalars /-
/-- Given a tower `L / ↥E / L' / K` of field extensions, where `E` is an `L'`-intermediate field of
`L`, reinterpret `E` as a `K`-intermediate field of `L`. -/
def restrictScalars (E : IntermediateField L' L) : IntermediateField K L :=
  { E.toSubfield, E.toSubalgebra.restrictScalars K with carrier := E.carrier }
#align intermediate_field.restrict_scalars IntermediateField.restrictScalars
-/

/- warning: intermediate_field.coe_restrict_scalars -> IntermediateField.coe_restrictScalars is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.coe_restrict_scalars IntermediateField.coe_restrictScalarsₓ'. -/
@[simp]
theorem coe_restrictScalars {E : IntermediateField L' L} :
    (restrictScalars K E : Set L) = (E : Set L) :=
  rfl
#align intermediate_field.coe_restrict_scalars IntermediateField.coe_restrictScalars

#print IntermediateField.restrictScalars_toSubalgebra /-
@[simp]
theorem restrictScalars_toSubalgebra {E : IntermediateField L' L} :
    (E.restrictScalars K).toSubalgebra = E.toSubalgebra.restrictScalars K :=
  SetLike.coe_injective rfl
#align intermediate_field.restrict_scalars_to_subalgebra IntermediateField.restrictScalars_toSubalgebra
-/

#print IntermediateField.restrictScalars_toSubfield /-
@[simp]
theorem restrictScalars_toSubfield {E : IntermediateField L' L} :
    (E.restrictScalars K).toSubfield = E.toSubfield :=
  SetLike.coe_injective rfl
#align intermediate_field.restrict_scalars_to_subfield IntermediateField.restrictScalars_toSubfield
-/

/- warning: intermediate_field.mem_restrict_scalars -> IntermediateField.mem_restrictScalars is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.mem_restrict_scalars IntermediateField.mem_restrictScalarsₓ'. -/
@[simp]
theorem mem_restrictScalars {E : IntermediateField L' L} {x : L} :
    x ∈ restrictScalars K E ↔ x ∈ E :=
  Iff.rfl
#align intermediate_field.mem_restrict_scalars IntermediateField.mem_restrictScalars

/- warning: intermediate_field.restrict_scalars_injective -> IntermediateField.restrictScalars_injective is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) {L : Type.{u2}} {L' : Type.{u3}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_3 : Field.{u3} L'] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] [_inst_5 : Algebra.{u1, u3} K L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3)))] [_inst_6 : Algebra.{u3, u2} L' L (Semifield.toCommSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] [_inst_7 : IsScalarTower.{u1, u3, u2} K L' L (SMulZeroClass.toHasSmul.{u1, u3} K L' (AddZeroClass.toHasZero.{u3} L' (AddMonoid.toAddZeroClass.{u3} L' (AddCommMonoid.toAddMonoid.{u3} L' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} L' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} L' (Semiring.toNonAssocSemiring.{u3} L' (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))))))))) (SMulWithZero.toSmulZeroClass.{u1, u3} K L' (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (AddZeroClass.toHasZero.{u3} L' (AddMonoid.toAddZeroClass.{u3} L' (AddCommMonoid.toAddMonoid.{u3} L' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} L' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} L' (Semiring.toNonAssocSemiring.{u3} L' (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))))))))) (MulActionWithZero.toSMulWithZero.{u1, u3} K L' (Semiring.toMonoidWithZero.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (AddZeroClass.toHasZero.{u3} L' (AddMonoid.toAddZeroClass.{u3} L' (AddCommMonoid.toAddMonoid.{u3} L' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} L' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} L' (Semiring.toNonAssocSemiring.{u3} L' (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))))))))) (Module.toMulActionWithZero.{u1, u3} K L' (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} L' (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} L' (Semiring.toNonAssocSemiring.{u3} L' (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3)))))) (Algebra.toModule.{u1, u3} K L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u3} L' (DivisionRing.toRing.{u3} L' (Field.toDivisionRing.{u3} L' _inst_3))) _inst_5))))) (SMulZeroClass.toHasSmul.{u3, u2} L' L (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (SMulWithZero.toSmulZeroClass.{u3, u2} L' L (MulZeroClass.toHasZero.{u3} L' (MulZeroOneClass.toMulZeroClass.{u3} L' (MonoidWithZero.toMulZeroOneClass.{u3} L' (Semiring.toMonoidWithZero.{u3} L' (CommSemiring.toSemiring.{u3} L' (Semifield.toCommSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3))))))) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (MulActionWithZero.toSMulWithZero.{u3, u2} L' L (Semiring.toMonoidWithZero.{u3} L' (CommSemiring.toSemiring.{u3} L' (Semifield.toCommSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3)))) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (Module.toMulActionWithZero.{u3, u2} L' L (CommSemiring.toSemiring.{u3} L' (Semifield.toCommSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) (Algebra.toModule.{u3, u2} L' L (Semifield.toCommSemiring.{u3} L' (Field.toSemifield.{u3} L' _inst_3)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_6))))) (SMulZeroClass.toHasSmul.{u1, u2} K L (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} K L (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K L (Semiring.toMonoidWithZero.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (AddZeroClass.toHasZero.{u2} L (AddMonoid.toAddZeroClass.{u2} L (AddCommMonoid.toAddMonoid.{u2} L (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))))))) (Module.toMulActionWithZero.{u1, u2} K L (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} L (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} L (Semiring.toNonAssocSemiring.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))))) (Algebra.toModule.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)))))], Function.Injective.{succ u2, succ u2} (IntermediateField.{u3, u2} L' L _inst_3 _inst_2 _inst_6) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.restrictScalars.{u1, u2, u3} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)
but is expected to have type
  forall (K : Type.{u1}) {L : Type.{u3}} {L' : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u3} L] [_inst_3 : Field.{u2} L'] [_inst_4 : Algebra.{u1, u3} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u3} L (Semifield.toDivisionSemiring.{u3} L (Field.toSemifield.{u3} L _inst_2)))] [_inst_5 : Algebra.{u1, u2} K L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L' (Semifield.toDivisionSemiring.{u2} L' (Field.toSemifield.{u2} L' _inst_3)))] [_inst_6 : Algebra.{u2, u3} L' L (Semifield.toCommSemiring.{u2} L' (Field.toSemifield.{u2} L' _inst_3)) (DivisionSemiring.toSemiring.{u3} L (Semifield.toDivisionSemiring.{u3} L (Field.toSemifield.{u3} L _inst_2)))] [_inst_7 : IsScalarTower.{u1, u2, u3} K L' L (Algebra.toSMul.{u1, u2} K L' (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L' (Semifield.toDivisionSemiring.{u2} L' (Field.toSemifield.{u2} L' _inst_3))) _inst_5) (Algebra.toSMul.{u2, u3} L' L (Semifield.toCommSemiring.{u2} L' (Field.toSemifield.{u2} L' _inst_3)) (DivisionSemiring.toSemiring.{u3} L (Semifield.toDivisionSemiring.{u3} L (Field.toSemifield.{u3} L _inst_2))) _inst_6) (Algebra.toSMul.{u1, u3} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u3} L (Semifield.toDivisionSemiring.{u3} L (Field.toSemifield.{u3} L _inst_2))) _inst_4)], Function.Injective.{succ u3, succ u3} (IntermediateField.{u2, u3} L' L _inst_3 _inst_2 _inst_6) (IntermediateField.{u1, u3} K L _inst_1 _inst_2 _inst_4) (IntermediateField.restrictScalars.{u1, u3, u2} K L L' _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align intermediate_field.restrict_scalars_injective IntermediateField.restrictScalars_injectiveₓ'. -/
theorem restrictScalars_injective :
    Function.Injective (restrictScalars K : IntermediateField L' L → IntermediateField K L) :=
  fun U V H => ext fun x => by rw [← mem_restrict_scalars K, H, mem_restrict_scalars]
#align intermediate_field.restrict_scalars_injective IntermediateField.restrictScalars_injective

end RestrictScalars

/-- This was formerly an instance called `lift2_alg`, but an instance above already provides it. -/
example {F : IntermediateField K L} {E : IntermediateField F L} : Algebra K E := by infer_instance

end Tower

section FiniteDimensional

variable (F E : IntermediateField K L)

/- warning: intermediate_field.finite_dimensional_left -> IntermediateField.finiteDimensional_left is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (F : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) [_inst_6 : FiniteDimensional.{u1, u2} K L (Field.toDivisionRing.{u1} K _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (Algebra.toModule.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)], FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (Field.toDivisionRing.{u1} K _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)))))) (IntermediateField.module.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (F : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) [_inst_6 : FiniteDimensional.{u1, u2} K L (Field.toDivisionRing.{u1} K _inst_1) (Ring.toAddCommGroup.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Algebra.toModule.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4)], FiniteDimensional.{u1, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x F)) (Field.toDivisionRing.{u1} K _inst_1) (Ring.toAddCommGroup.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x F)) (DivisionRing.toRing.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x F)) (Field.toDivisionRing.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x F)) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)))) (IntermediateField.module.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)
Case conversion may be inaccurate. Consider using '#align intermediate_field.finite_dimensional_left IntermediateField.finiteDimensional_leftₓ'. -/
instance finiteDimensional_left [FiniteDimensional K L] : FiniteDimensional K F :=
  left K F L
#align intermediate_field.finite_dimensional_left IntermediateField.finiteDimensional_left

/- warning: intermediate_field.finite_dimensional_right -> IntermediateField.finiteDimensional_right is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] (F : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) [_inst_6 : FiniteDimensional.{u1, u2} K L (Field.toDivisionRing.{u1} K _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (Algebra.toModule.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)], FiniteDimensional.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) L (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)) (NonUnitalNonAssocRing.toAddCommGroup.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))))) (Algebra.toModule.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) F) L (SubsemiringClass.toCommSemiring.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) F L (Semifield.toCommSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubringClass.to_subsemiringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SubfieldClass.to_subringClass.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L _inst_2 (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4) (IntermediateField.subfieldClass.{u1, u2} K L _inst_1 _inst_2 _inst_4)))) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (IntermediateField.toAlgebra.{u1, u2, u2} K L _inst_1 _inst_2 _inst_4 F L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Algebra.id.{u2} L (Semifield.toCommSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] (F : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) [_inst_6 : FiniteDimensional.{u1, u2} K L (Field.toDivisionRing.{u1} K _inst_1) (Ring.toAddCommGroup.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Algebra.toModule.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4)], FiniteDimensional.{u2, u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x F)) L (Field.toDivisionRing.{u2} (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x F)) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 F)) (Ring.toAddCommGroup.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) (Subalgebra.moduleLeft.{u1, u2, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4 L (AddCommGroup.toAddCommMonoid.{u2} L (Ring.toAddCommGroup.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))) (Semiring.toModule.{u2} L (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))) (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 F))
Case conversion may be inaccurate. Consider using '#align intermediate_field.finite_dimensional_right IntermediateField.finiteDimensional_rightₓ'. -/
instance finiteDimensional_right [FiniteDimensional K L] : FiniteDimensional F L :=
  right K F L
#align intermediate_field.finite_dimensional_right IntermediateField.finiteDimensional_right

#print IntermediateField.rank_eq_rank_subalgebra /-
@[simp]
theorem rank_eq_rank_subalgebra : Module.rank K F.toSubalgebra = Module.rank K F :=
  rfl
#align intermediate_field.rank_eq_rank_subalgebra IntermediateField.rank_eq_rank_subalgebra
-/

/- warning: intermediate_field.finrank_eq_finrank_subalgebra -> IntermediateField.finrank_eq_finrank_subalgebra is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.finrank_eq_finrank_subalgebra IntermediateField.finrank_eq_finrank_subalgebraₓ'. -/
@[simp]
theorem finrank_eq_finrank_subalgebra : finrank K F.toSubalgebra = finrank K F :=
  rfl
#align intermediate_field.finrank_eq_finrank_subalgebra IntermediateField.finrank_eq_finrank_subalgebra

variable {F} {E}

#print IntermediateField.toSubalgebra_eq_iff /-
@[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E :=
  by
  rw [SetLike.ext_iff, SetLike.ext'_iff, Set.ext_iff]
  rfl
#align intermediate_field.to_subalgebra_eq_iff IntermediateField.toSubalgebra_eq_iff
-/

/- warning: intermediate_field.eq_of_le_of_finrank_le -> IntermediateField.eq_of_le_of_finrank_le is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.eq_of_le_of_finrank_le IntermediateField.eq_of_le_of_finrank_leₓ'. -/
theorem eq_of_le_of_finrank_le [FiniteDimensional K L] (h_le : F ≤ E)
    (h_finrank : finrank K E ≤ finrank K F) : F = E :=
  toSubalgebra_injective <|
    Subalgebra.toSubmodule.Injective <| eq_of_le_of_finrank_le h_le h_finrank
#align intermediate_field.eq_of_le_of_finrank_le IntermediateField.eq_of_le_of_finrank_le

/- warning: intermediate_field.eq_of_le_of_finrank_eq -> IntermediateField.eq_of_le_of_finrank_eq is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.eq_of_le_of_finrank_eq IntermediateField.eq_of_le_of_finrank_eqₓ'. -/
theorem eq_of_le_of_finrank_eq [FiniteDimensional K L] (h_le : F ≤ E)
    (h_finrank : finrank K F = finrank K E) : F = E :=
  eq_of_le_of_finrank_le h_le h_finrank.ge
#align intermediate_field.eq_of_le_of_finrank_eq IntermediateField.eq_of_le_of_finrank_eq

/- warning: intermediate_field.eq_of_le_of_finrank_le' -> IntermediateField.eq_of_le_of_finrank_le' is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.eq_of_le_of_finrank_le' IntermediateField.eq_of_le_of_finrank_le'ₓ'. -/
theorem eq_of_le_of_finrank_le' [FiniteDimensional K L] (h_le : F ≤ E)
    (h_finrank : finrank F L ≤ finrank E L) : F = E :=
  by
  apply eq_of_le_of_finrank_le h_le
  have h1 := finrank_mul_finrank K F L
  have h2 := finrank_mul_finrank K E L
  have h3 : 0 < finrank E L := finrank_pos
  nlinarith
#align intermediate_field.eq_of_le_of_finrank_le' IntermediateField.eq_of_le_of_finrank_le'

/- warning: intermediate_field.eq_of_le_of_finrank_eq' -> IntermediateField.eq_of_le_of_finrank_eq' is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align intermediate_field.eq_of_le_of_finrank_eq' IntermediateField.eq_of_le_of_finrank_eq'ₓ'. -/
theorem eq_of_le_of_finrank_eq' [FiniteDimensional K L] (h_le : F ≤ E)
    (h_finrank : finrank F L = finrank E L) : F = E :=
  eq_of_le_of_finrank_le' h_le h_finrank.le
#align intermediate_field.eq_of_le_of_finrank_eq' IntermediateField.eq_of_le_of_finrank_eq'

end FiniteDimensional

/- warning: intermediate_field.is_algebraic_iff -> IntermediateField.isAlgebraic_iff is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {x : coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S}, Iff (IsAlgebraic.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) x) (IsAlgebraic.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) x))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] {S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {x : Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)}, Iff (IsAlgebraic.{u1, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Subalgebra.toRing.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) x) (IsAlgebraic.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4 (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) x))
Case conversion may be inaccurate. Consider using '#align intermediate_field.is_algebraic_iff IntermediateField.isAlgebraic_iffₓ'. -/
theorem isAlgebraic_iff {x : S} : IsAlgebraic K x ↔ IsAlgebraic K (x : L) :=
  (isAlgebraic_algebraMap_iff (algebraMap S L).Injective).symm
#align intermediate_field.is_algebraic_iff IntermediateField.isAlgebraic_iff

/- warning: intermediate_field.is_integral_iff -> IntermediateField.isIntegral_iff is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {x : coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S}, Iff (IsIntegral.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) x) (IsIntegral.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) x))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] {S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} {x : Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)}, Iff (IsIntegral.{u1, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Subalgebra.toRing.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) x) (IsIntegral.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4 (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) x))
Case conversion may be inaccurate. Consider using '#align intermediate_field.is_integral_iff IntermediateField.isIntegral_iffₓ'. -/
theorem isIntegral_iff {x : S} : IsIntegral K x ↔ IsIntegral K (x : L) := by
  rw [← isAlgebraic_iff_isIntegral, is_algebraic_iff, isAlgebraic_iff_isIntegral]
#align intermediate_field.is_integral_iff IntermediateField.isIntegral_iff

/- warning: intermediate_field.minpoly_eq -> IntermediateField.minpoly_eq is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))] {S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} (x : coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S), Eq.{succ u1} (Polynomial.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) (minpoly.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (Field.toDivisionRing.{u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) (IntermediateField.toField.{u1, u2} K L _inst_1 _inst_2 _inst_4 S))) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) x) (minpoly.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) S) L (coeSubtype.{succ u2} L (fun (x : L) => Membership.Mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.hasMem.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S))))) x))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))] {S : IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4} (x : Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)), Eq.{succ u1} (Polynomial.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1))))) (minpoly.{u1, u2} K (Subtype.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)) x S)) (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (Subalgebra.toRing.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4 (IntermediateField.toSubalgebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S)) (IntermediateField.algebra.{u1, u2} K L _inst_1 _inst_2 _inst_4 S) x) (minpoly.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4 (Subtype.val.{succ u2} L (fun (x : L) => Membership.mem.{u2, u2} L (Set.{u2} L) (Set.instMembershipSet.{u2} L) x (SetLike.coe.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) S)) x))
Case conversion may be inaccurate. Consider using '#align intermediate_field.minpoly_eq IntermediateField.minpoly_eqₓ'. -/
theorem minpoly_eq (x : S) : minpoly K x = minpoly K (x : L) :=
  by
  by_cases hx : IsIntegral K x
  · exact minpoly.eq_of_algebraMap_eq (algebraMap S L).Injective hx rfl
  · exact (minpoly.eq_zero hx).trans (minpoly.eq_zero (mt is_integral_iff.mpr hx)).symm
#align intermediate_field.minpoly_eq IntermediateField.minpoly_eq

end IntermediateField

/- warning: subalgebra_equiv_intermediate_field -> subalgebraEquivIntermediateField is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)))], (Algebra.IsAlgebraic.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4) -> (OrderIso.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4) L (Subalgebra.setLike.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2))) _inst_4)))) (Preorder.toHasLe.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.partialOrder.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.setLike.{u1, u2} K L _inst_1 _inst_2 _inst_4)))))
but is expected to have type
  forall {K : Type.{u1}} {L : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : Field.{u2} L] [_inst_4 : Algebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2)))], (Algebra.IsAlgebraic.{u1, u2} K L (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K _inst_1)) (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L _inst_2)) _inst_4) -> (OrderIso.{u2, u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Subalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} K L (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u2} L (Semifield.toDivisionSemiring.{u2} L (Field.toSemifield.{u2} L _inst_2))) _inst_4))))) (Preorder.toLE.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) (SetLike.instPartialOrder.{u2, u2} (IntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4) L (IntermediateField.instSetLikeIntermediateField.{u1, u2} K L _inst_1 _inst_2 _inst_4)))))
Case conversion may be inaccurate. Consider using '#align subalgebra_equiv_intermediate_field subalgebraEquivIntermediateFieldₓ'. -/
/-- If `L/K` is algebraic, the `K`-subalgebras of `L` are all fields.  -/
def subalgebraEquivIntermediateField (alg : Algebra.IsAlgebraic K L) :
    Subalgebra K L ≃o IntermediateField K L
    where
  toFun S := S.toIntermediateField fun x hx => S.inv_mem_of_algebraic (alg (⟨x, hx⟩ : S))
  invFun S := S.toSubalgebra
  left_inv S := toSubalgebra_toIntermediateField _ _
  right_inv := toIntermediateField_toSubalgebra
  map_rel_iff' S S' := Iff.rfl
#align subalgebra_equiv_intermediate_field subalgebraEquivIntermediateField

/- warning: mem_subalgebra_equiv_intermediate_field -> mem_subalgebraEquivIntermediateField is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align mem_subalgebra_equiv_intermediate_field mem_subalgebraEquivIntermediateFieldₓ'. -/
@[simp]
theorem mem_subalgebraEquivIntermediateField (alg : Algebra.IsAlgebraic K L) {S : Subalgebra K L}
    {x : L} : x ∈ subalgebraEquivIntermediateField alg S ↔ x ∈ S :=
  Iff.rfl
#align mem_subalgebra_equiv_intermediate_field mem_subalgebraEquivIntermediateField

/- warning: mem_subalgebra_equiv_intermediate_field_symm -> mem_subalgebraEquivIntermediateField_symm is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align mem_subalgebra_equiv_intermediate_field_symm mem_subalgebraEquivIntermediateField_symmₓ'. -/
@[simp]
theorem mem_subalgebraEquivIntermediateField_symm (alg : Algebra.IsAlgebraic K L)
    {S : IntermediateField K L} {x : L} :
    x ∈ (subalgebraEquivIntermediateField alg).symm S ↔ x ∈ S :=
  Iff.rfl
#align mem_subalgebra_equiv_intermediate_field_symm mem_subalgebraEquivIntermediateField_symm

