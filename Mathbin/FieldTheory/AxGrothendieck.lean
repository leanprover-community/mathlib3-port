/-
Copyright (c) 2023 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes

! This file was ported from Lean 3 source module field_theory.ax_grothendieck
! leanprover-community/mathlib commit 4e529b03dd62b7b7d13806c3fb974d9d4848910e
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.MvPolynomial.Basic
import Mathbin.RingTheory.Algebraic
import Mathbin.Data.Fintype.Card

/-!
# Ax-Grothendieck for algebraic extensions of `zmod p`

This file proves that if `R` is an algebraic extension of a finite field,
then any injective polynomial map `R^n -> R^n` is also surjective.

This proof is required for the true Ax-Grothendieck theorem, which proves the same result
for any algebraically closed field of characteristic zero.

## TODO

The proof of the theorem for characteristic zero is not in mathlib, but it is at
https://github.com/Jlh18/ModelTheoryInLean8
-/


noncomputable section

open MvPolynomial Finset Function

/- warning: ax_grothendieck_of_locally_finite -> ax_grothendieck_of_locally_finite is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {K : Type.{u2}} {R : Type.{u3}} [_inst_1 : Field.{u2} K] [_inst_2 : Finite.{succ u2} K] [_inst_3 : CommRing.{u3} R] [_inst_4 : Finite.{succ u1} ι] [_inst_5 : Algebra.{u2, u3} K R (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_3))], (Algebra.IsAlgebraic.{u2, u3} K R (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_1)) (CommRing.toRing.{u3} R _inst_3) _inst_5) -> (forall (ps : ι -> (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3))), (Function.Injective.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (ι -> R) (ι -> R) (fun (v : ι -> R) (i : ι) => coeFn.{max (succ (max u1 u3)) (succ u3), max (succ (max u1 u3)) (succ u3)} (RingHom.{max u1 u3, u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (MvPolynomial.commSemiring.{u3, u1} R ι (CommRing.toCommSemiring.{u3} R _inst_3)))) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_3)))) (fun (_x : RingHom.{max u1 u3, u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (MvPolynomial.commSemiring.{u3, u1} R ι (CommRing.toCommSemiring.{u3} R _inst_3)))) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_3)))) => (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) -> R) (RingHom.hasCoeToFun.{max u1 u3, u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (MvPolynomial.commSemiring.{u3, u1} R ι (CommRing.toCommSemiring.{u3} R _inst_3)))) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_3)))) (MvPolynomial.eval.{u3, u1} R ι (CommRing.toCommSemiring.{u3} R _inst_3) v) (ps i))) -> (Function.Surjective.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (ι -> R) (ι -> R) (fun (v : ι -> R) (i : ι) => coeFn.{max (succ (max u1 u3)) (succ u3), max (succ (max u1 u3)) (succ u3)} (RingHom.{max u1 u3, u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (MvPolynomial.commSemiring.{u3, u1} R ι (CommRing.toCommSemiring.{u3} R _inst_3)))) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_3)))) (fun (_x : RingHom.{max u1 u3, u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (MvPolynomial.commSemiring.{u3, u1} R ι (CommRing.toCommSemiring.{u3} R _inst_3)))) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_3)))) => (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) -> R) (RingHom.hasCoeToFun.{max u1 u3, u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u1, u3} ι R (CommRing.toCommSemiring.{u3} R _inst_3)) (MvPolynomial.commSemiring.{u3, u1} R ι (CommRing.toCommSemiring.{u3} R _inst_3)))) (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_3)))) (MvPolynomial.eval.{u3, u1} R ι (CommRing.toCommSemiring.{u3} R _inst_3) v) (ps i))))
but is expected to have type
  forall {ι : Type.{u3}} {K : Type.{u2}} {R : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : Finite.{succ u2} K] [_inst_3 : CommRing.{u1} R] [_inst_4 : Finite.{succ u3} ι] [_inst_5 : Algebra.{u2, u1} K R (Semifield.toCommSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)) (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))], (Algebra.IsAlgebraic.{u2, u1} K R (EuclideanDomain.toCommRing.{u2} K (Field.toEuclideanDomain.{u2} K _inst_1)) (CommRing.toRing.{u1} R _inst_3) _inst_5) -> (forall (ps : ι -> (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3))), (Function.Injective.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (ι -> R) (forall (i : ι), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) => R) (ps i)) (fun (v : ι -> R) (i : ι) => FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), succ u1} (RingHom.{max u1 u3, u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)))) (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (fun (_x : MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) => R) _x) (MulHomClass.toFunLike.{max u3 u1, max u3 u1, u1} (RingHom.{max u1 u3, u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)))) (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (NonUnitalNonAssocSemiring.toMul.{max u3 u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u1, max u3 u1, u1} (RingHom.{max u1 u3, u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)))) (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u1, max u3 u1, u1} (RingHom.{max u1 u3, u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)))) (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))) (RingHom.instRingHomClassRingHom.{max u3 u1, u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))))))) (MvPolynomial.eval.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3) v) (ps i))) -> (Function.Surjective.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (ι -> R) (forall (i : ι), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) => R) (ps i)) (fun (v : ι -> R) (i : ι) => FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), succ u1} (RingHom.{max u1 u3, u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)))) (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (fun (_x : MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) => R) _x) (MulHomClass.toFunLike.{max u3 u1, max u3 u1, u1} (RingHom.{max u1 u3, u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)))) (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (NonUnitalNonAssocSemiring.toMul.{max u3 u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u1, max u3 u1, u1} (RingHom.{max u1 u3, u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)))) (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u1, max u3 u1, u1} (RingHom.{max u1 u3, u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3)))) (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))) (RingHom.instRingHomClassRingHom.{max u3 u1, u1} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) R (Semiring.toNonAssocSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (CommSemiring.toSemiring.{max u1 u3} (MvPolynomial.{u3, u1} ι R (CommRing.toCommSemiring.{u1} R _inst_3)) (MvPolynomial.commSemiring.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3)))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))))))) (MvPolynomial.eval.{u1, u3} R ι (CommRing.toCommSemiring.{u1} R _inst_3) v) (ps i))))
Case conversion may be inaccurate. Consider using '#align ax_grothendieck_of_locally_finite ax_grothendieck_of_locally_finiteₓ'. -/
/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/
theorem ax_grothendieck_of_locally_finite {ι K R : Type _} [Field K] [Finite K] [CommRing R]
    [Finite ι] [Algebra K R] (alg : Algebra.IsAlgebraic K R) (ps : ι → MvPolynomial ι R)
    (hinj : Injective fun v i => eval v (ps i)) : Surjective fun v i => eval v (ps i) :=
  by
  have is_int : ∀ x : R, IsIntegral K x := fun x => isAlgebraic_iff_isIntegral.1 (alg x)
  classical
    intro v
    cases nonempty_fintype ι
    /- `s` is the set of all coefficients of the polynomial, as well as all of
      the coordinates of `v`, the point I am trying to find the preimage of. -/
    let s : Finset R :=
      (Finset.biUnion (univ : Finset ι) fun i => (ps i).support.image fun x => coeff x (ps i)) ∪
        (univ : Finset ι).image v
    have hv : ∀ i, v i ∈ Algebra.adjoin K (s : Set R) := fun j =>
      Algebra.subset_adjoin (mem_union_right _ (mem_image.2 ⟨j, mem_univ _, rfl⟩))
    have hs₁ :
      ∀ (i : ι) (k : ι →₀ ℕ), k ∈ (ps i).support → coeff k (ps i) ∈ Algebra.adjoin K (s : Set R) :=
      fun i k hk =>
      Algebra.subset_adjoin (mem_union_left _ (mem_bUnion.2 ⟨i, mem_univ _, mem_image_of_mem _ hk⟩))
    have hs : ∀ i, MvPolynomial.eval v (ps i) ∈ Algebra.adjoin K (s : Set R) := fun i =>
      eval_mem (hs₁ _) hv
    letI := isNoetherian_adjoin_finset s fun x _ => is_int x
    letI := Module.IsNoetherian.finite K (Algebra.adjoin K (s : Set R))
    letI : Finite (Algebra.adjoin K (s : Set R)) :=
      FiniteDimensional.finite_of_finite K (Algebra.adjoin K (s : Set R))
    -- The restriction of the polynomial map, `ps`, to the subalgebra generated by `s`
    let res : (ι → Algebra.adjoin K (s : Set R)) → ι → Algebra.adjoin K (s : Set R) := fun x i =>
      ⟨eval (fun j : ι => (x j : R)) (ps i), eval_mem (hs₁ _) fun i => (x i).2⟩
    have hres_inj : injective res := by
      intro x y hxy
      ext i
      simp only [res, Subtype.ext_iff, funext_iff] at hxy
      exact congr_fun (hinj (funext hxy)) i
    have hres_surj : surjective res := Finite.injective_iff_surjective.1 hres_inj
    cases' hres_surj fun i => ⟨v i, hv i⟩ with w hw
    use fun i => w i
    simpa only [res, Subtype.ext_iff, funext_iff] using hw
#align ax_grothendieck_of_locally_finite ax_grothendieck_of_locally_finite

