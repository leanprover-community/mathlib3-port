/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Yury Kudryashov

! This file was ported from Lean 3 source module field_theory.perfect_closure
! leanprover-community/mathlib commit c085f3044fe585c575e322bfab45b3633c48d820
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.CharP.Basic
import Mathbin.Algebra.Hom.Iterate
import Mathbin.Algebra.Ring.Equiv

/-!
# The perfect closure of a field

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
-/


universe u v

open Function

section Defs

variable (R : Type u) [CommSemiring R] (p : ℕ) [Fact p.Prime] [CharP R p]

#print PerfectRing /-
/-- A perfect ring is a ring of characteristic p that has p-th root. -/
class PerfectRing : Type u where
  pthRoot' : R → R
  frobenius_pthRoot' : ∀ x, frobenius R p (pth_root' x) = x
  pth_root_frobenius' : ∀ x, pth_root' (frobenius R p x) = x
#align perfect_ring PerfectRing
-/

/- warning: frobenius_equiv -> frobeniusEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_4 : PerfectRing.{u1} R _inst_1 p _inst_2 _inst_3], RingEquiv.{u1, u1} R R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_4 : PerfectRing.{u1} R _inst_1 p _inst_2 _inst_3], RingEquiv.{u1, u1} R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align frobenius_equiv frobeniusEquivₓ'. -/
/-- Frobenius automorphism of a perfect ring. -/
def frobeniusEquiv [PerfectRing R p] : R ≃+* R :=
  { frobenius R p with
    invFun := PerfectRing.pthRoot' p
    left_inv := PerfectRing.pth_root_frobenius'
    right_inv := PerfectRing.frobenius_pthRoot' }
#align frobenius_equiv frobeniusEquiv

#print pthRoot /-
/-- `p`-th root of an element in a `perfect_ring` as a `ring_hom`. -/
def pthRoot [PerfectRing R p] : R →+* R :=
  (frobeniusEquiv R p).symm
#align pth_root pthRoot
-/

end Defs

section

variable {R : Type u} [CommSemiring R] {S : Type v} [CommSemiring S] (f : R →* S) (g : R →+* S)
  {p : ℕ} [Fact p.Prime] [CharP R p] [PerfectRing R p] [CharP S p] [PerfectRing S p]

#print coe_frobeniusEquiv /-
@[simp]
theorem coe_frobeniusEquiv : ⇑(frobeniusEquiv R p) = frobenius R p :=
  rfl
#align coe_frobenius_equiv coe_frobeniusEquiv
-/

#print coe_frobeniusEquiv_symm /-
@[simp]
theorem coe_frobeniusEquiv_symm : ⇑(frobeniusEquiv R p).symm = pthRoot R p :=
  rfl
#align coe_frobenius_equiv_symm coe_frobeniusEquiv_symm
-/

/- warning: frobenius_pth_root -> frobenius_pthRoot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] (x : R), Eq.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x)) x
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) a) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x)) x
Case conversion may be inaccurate. Consider using '#align frobenius_pth_root frobenius_pthRootₓ'. -/
@[simp]
theorem frobenius_pthRoot (x : R) : frobenius R p (pthRoot R p x) = x :=
  (frobeniusEquiv R p).apply_symm_apply x
#align frobenius_pth_root frobenius_pthRoot

/- warning: pth_root_pow_p -> pthRoot_pow_p is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] (x : R), Eq.{succ u1} R (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x) p) x
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) (HPow.hPow.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) (instHPow.{u1, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) Nat (Monoid.Pow.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) (MonoidWithZero.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) _inst_1))))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x) p) x
Case conversion may be inaccurate. Consider using '#align pth_root_pow_p pthRoot_pow_pₓ'. -/
@[simp]
theorem pthRoot_pow_p (x : R) : pthRoot R p x ^ p = x :=
  frobenius_pthRoot x
#align pth_root_pow_p pthRoot_pow_p

/- warning: pth_root_frobenius -> pthRoot_frobenius is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] (x : R), Eq.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4) x)) x
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) a) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4) x)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4) x)) x
Case conversion may be inaccurate. Consider using '#align pth_root_frobenius pthRoot_frobeniusₓ'. -/
@[simp]
theorem pthRoot_frobenius (x : R) : pthRoot R p (frobenius R p x) = x :=
  (frobeniusEquiv R p).symm_apply_apply x
#align pth_root_frobenius pthRoot_frobenius

/- warning: pth_root_pow_p' -> pthRoot_pow_p' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] (x : R), Eq.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x p)) x
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x p)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x p)) x
Case conversion may be inaccurate. Consider using '#align pth_root_pow_p' pthRoot_pow_p'ₓ'. -/
@[simp]
theorem pthRoot_pow_p' (x : R) : pthRoot R p (x ^ p) = x :=
  pthRoot_frobenius x
#align pth_root_pow_p' pthRoot_pow_p'

/- warning: left_inverse_pth_root_frobenius -> leftInverse_pthRoot_frobenius is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4], Function.LeftInverse.{succ u1, succ u1} R R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4], Function.LeftInverse.{succ u1, succ u1} R R (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align left_inverse_pth_root_frobenius leftInverse_pthRoot_frobeniusₓ'. -/
theorem leftInverse_pthRoot_frobenius : LeftInverse (pthRoot R p) (frobenius R p) :=
  pthRoot_frobenius
#align left_inverse_pth_root_frobenius leftInverse_pthRoot_frobenius

/- warning: right_inverse_pth_root_frobenius -> rightInverse_pthRoot_frobenius is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4], Function.RightInverse.{succ u1, succ u1} R R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4], Function.RightInverse.{succ u1, succ u1} R R (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align right_inverse_pth_root_frobenius rightInverse_pthRoot_frobeniusₓ'. -/
theorem rightInverse_pthRoot_frobenius : Function.RightInverse (pthRoot R p) (frobenius R p) :=
  frobenius_pthRoot
#align right_inverse_pth_root_frobenius rightInverse_pthRoot_frobenius

/- warning: commute_frobenius_pth_root -> commute_frobenius_pthRoot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4], Function.Commute.{u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4], Function.Commute.{u1} R (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5))
Case conversion may be inaccurate. Consider using '#align commute_frobenius_pth_root commute_frobenius_pthRootₓ'. -/
theorem commute_frobenius_pthRoot : Function.Commute (frobenius R p) (pthRoot R p) := fun x =>
  (frobenius_pthRoot x).trans (pthRoot_frobenius x).symm
#align commute_frobenius_pth_root commute_frobenius_pthRoot

/- warning: eq_pth_root_iff -> eq_pthRoot_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] {x : R} {y : R}, Iff (Eq.{succ u1} R x (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) y)) (Eq.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4) x) y)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] {x : R} {y : R}, Iff (Eq.{succ u1} R x (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) y)) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4) x) y)
Case conversion may be inaccurate. Consider using '#align eq_pth_root_iff eq_pthRoot_iffₓ'. -/
theorem eq_pthRoot_iff {x y : R} : x = pthRoot R p y ↔ frobenius R p x = y :=
  (frobeniusEquiv R p).toEquiv.eq_symm_apply
#align eq_pth_root_iff eq_pthRoot_iff

/- warning: pth_root_eq_iff -> pthRoot_eq_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] {x : R} {y : R}, Iff (Eq.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x) y) (Eq.{succ u1} R x (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4) y))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] {x : R} {y : R}, Iff (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x) y) (Eq.{succ u1} R x (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (frobenius.{u1} R _inst_1 p _inst_3 _inst_4) y))
Case conversion may be inaccurate. Consider using '#align pth_root_eq_iff pthRoot_eq_iffₓ'. -/
theorem pthRoot_eq_iff {x y : R} : pthRoot R p x = y ↔ x = frobenius R p y :=
  (frobeniusEquiv R p).toEquiv.symm_apply_eq
#align pth_root_eq_iff pthRoot_eq_iff

/- warning: monoid_hom.map_pth_root -> MonoidHom.map_pthRoot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] (f : MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] [_inst_6 : CharP.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) p] [_inst_7 : PerfectRing.{u2} S _inst_2 p _inst_3 _inst_6] (x : R), Eq.{succ u2} S (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) (fun (_x : MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) => R -> S) (MonoidHom.hasCoeToFun.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) f (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x)) (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) => S -> S) (RingHom.hasCoeToFun.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (pthRoot.{u2} S _inst_2 p _inst_3 _inst_6 _inst_7) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) (fun (_x : MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) => R -> S) (MonoidHom.hasCoeToFun.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) f x))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] (f : MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] [_inst_6 : CharP.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) p] [_inst_7 : PerfectRing.{u2} S _inst_2 p _inst_3 _inst_6] (x : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) a) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R S (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulOneClass.toMul.{u2} S (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (MonoidHom.monoidHomClass.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))))) f (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x)) (FunLike.coe.{succ u2, succ u2, succ u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => S) _x) (MulHomClass.toFunLike.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) (pthRoot.{u2} S _inst_2 p _inst_3 _inst_6 _inst_7) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R S (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulOneClass.toMul.{u2} S (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (MonoidHom.monoidHomClass.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))))) f x))
Case conversion may be inaccurate. Consider using '#align monoid_hom.map_pth_root MonoidHom.map_pthRootₓ'. -/
theorem MonoidHom.map_pthRoot (x : R) : f (pthRoot R p x) = pthRoot S p (f x) :=
  eq_pthRoot_iff.2 <| by rw [← f.map_frobenius, frobenius_pthRoot]
#align monoid_hom.map_pth_root MonoidHom.map_pthRoot

/- warning: monoid_hom.map_iterate_pth_root -> MonoidHom.map_iterate_pthRoot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] (f : MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] [_inst_6 : CharP.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) p] [_inst_7 : PerfectRing.{u2} S _inst_2 p _inst_3 _inst_6] (x : R) (n : Nat), Eq.{succ u2} S (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) (fun (_x : MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) => R -> S) (MonoidHom.hasCoeToFun.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) f (Nat.iterate.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5)) n x)) (Nat.iterate.{succ u2} S (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) => S -> S) (RingHom.hasCoeToFun.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (pthRoot.{u2} S _inst_2 p _inst_3 _inst_6 _inst_7)) n (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) (fun (_x : MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) => R -> S) (MonoidHom.hasCoeToFun.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) f x))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] (f : MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] [_inst_6 : CharP.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) p] [_inst_7 : PerfectRing.{u2} S _inst_2 p _inst_3 _inst_6] (x : R) (n : Nat), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Nat.iterate.{succ u1} R (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) a) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5)) n x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R S (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulOneClass.toMul.{u2} S (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (MonoidHom.monoidHomClass.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))))) f (Nat.iterate.{succ u1} R (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5)) n x)) (Nat.iterate.{succ u2} S (FunLike.coe.{succ u2, succ u2, succ u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => S) _x) (MulHomClass.toFunLike.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) (pthRoot.{u2} S _inst_2 p _inst_3 _inst_6 _inst_7)) n (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R S (MulOneClass.toMul.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulOneClass.toMul.{u2} S (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))) R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (MonoidHom.monoidHomClass.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))))))) f x))
Case conversion may be inaccurate. Consider using '#align monoid_hom.map_iterate_pth_root MonoidHom.map_iterate_pthRootₓ'. -/
theorem MonoidHom.map_iterate_pthRoot (x : R) (n : ℕ) :
    f ((pthRoot R p^[n]) x) = (pthRoot S p^[n]) (f x) :=
  Semiconj.iterate_right f.map_pthRoot n x
#align monoid_hom.map_iterate_pth_root MonoidHom.map_iterate_pthRoot

/- warning: ring_hom.map_pth_root -> RingHom.map_pthRoot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] (g : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] [_inst_6 : CharP.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) p] [_inst_7 : PerfectRing.{u2} S _inst_2 p _inst_3 _inst_6] (x : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) g (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x)) (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) => S -> S) (RingHom.hasCoeToFun.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (pthRoot.{u2} S _inst_2 p _inst_3 _inst_6 _inst_7) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) g x))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] (g : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] [_inst_6 : CharP.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) p] [_inst_7 : PerfectRing.{u2} S _inst_2 p _inst_3 _inst_6] (x : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) a) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) g (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5) x)) (FunLike.coe.{succ u2, succ u2, succ u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => S) _x) (MulHomClass.toFunLike.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) (pthRoot.{u2} S _inst_2 p _inst_3 _inst_6 _inst_7) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) g x))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_pth_root RingHom.map_pthRootₓ'. -/
theorem RingHom.map_pthRoot (x : R) : g (pthRoot R p x) = pthRoot S p (g x) :=
  g.toMonoidHom.map_pthRoot x
#align ring_hom.map_pth_root RingHom.map_pthRoot

/- warning: ring_hom.map_iterate_pth_root -> RingHom.map_iterate_pthRoot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] (g : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] [_inst_6 : CharP.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) p] [_inst_7 : PerfectRing.{u2} S _inst_2 p _inst_3 _inst_6] (x : R) (n : Nat), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) g (Nat.iterate.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5)) n x)) (Nat.iterate.{succ u2} S (coeFn.{succ u2, succ u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) => S -> S) (RingHom.hasCoeToFun.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (pthRoot.{u2} S _inst_2 p _inst_3 _inst_6 _inst_7)) n (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) g x))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_2 : CommSemiring.{u2} S] (g : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) {p : Nat} [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) p] [_inst_5 : PerfectRing.{u1} R _inst_1 p _inst_3 _inst_4] [_inst_6 : CharP.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) p] [_inst_7 : PerfectRing.{u2} S _inst_2 p _inst_3 _inst_6] (x : R) (n : Nat), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Nat.iterate.{succ u1} R (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) a) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5)) n x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) g (Nat.iterate.{succ u1} R (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (pthRoot.{u1} R _inst_1 p _inst_3 _inst_4 _inst_5)) n x)) (Nat.iterate.{succ u2} S (FunLike.coe.{succ u2, succ u2, succ u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : S) => S) _x) (MulHomClass.toFunLike.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{u2, u2, u2} (RingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u2} S S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) (pthRoot.{u2} S _inst_2 p _inst_3 _inst_6 _inst_7)) n (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2)))))) g x))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_iterate_pth_root RingHom.map_iterate_pthRootₓ'. -/
theorem RingHom.map_iterate_pthRoot (x : R) (n : ℕ) :
    g ((pthRoot R p^[n]) x) = (pthRoot S p^[n]) (g x) :=
  g.toMonoidHom.map_iterate_pthRoot x n
#align ring_hom.map_iterate_pth_root RingHom.map_iterate_pthRoot

variable (p)

#print injective_pow_p /-
theorem injective_pow_p {x y : R} (hxy : x ^ p = y ^ p) : x = y :=
  leftInverse_pthRoot_frobenius.Injective hxy
#align injective_pow_p injective_pow_p
-/

end

section

variable (K : Type u) [CommRing K] (p : ℕ) [Fact p.Prime] [CharP K p]

/- warning: perfect_closure.r -> PerfectClosure.R is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p], (Prod.{0, u1} Nat K) -> (Prod.{0, u1} Nat K) -> Prop
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p], (Prod.{0, u1} Nat K) -> (Prod.{0, u1} Nat K) -> Prop
Case conversion may be inaccurate. Consider using '#align perfect_closure.r PerfectClosure.Rₓ'. -/
/-- `perfect_closure K p` is the quotient by this relation. -/
@[mk_iff]
inductive PerfectClosure.R : ℕ × K → ℕ × K → Prop
  | intro : ∀ n x, PerfectClosure.R (n, x) (n + 1, frobenius K p x)
#align perfect_closure.r PerfectClosure.R

/- warning: perfect_closure -> PerfectClosure is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p], Type.{u1}
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p], Type.{u1}
Case conversion may be inaccurate. Consider using '#align perfect_closure PerfectClosureₓ'. -/
/-- The perfect closure is the smallest extension that makes frobenius surjective. -/
def PerfectClosure : Type u :=
  Quot (PerfectClosure.R K p)
#align perfect_closure PerfectClosure

end

namespace PerfectClosure

variable (K : Type u)

section Ring

variable [CommRing K] (p : ℕ) [Fact p.Prime] [CharP K p]

/- warning: perfect_closure.mk -> PerfectClosure.mk is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p], (Prod.{0, u1} Nat K) -> (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3)
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p], (Prod.{0, u1} Nat K) -> (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align perfect_closure.mk PerfectClosure.mkₓ'. -/
/-- Constructor for `perfect_closure`. -/
def mk (x : ℕ × K) : PerfectClosure K p :=
  Quot.mk (R K p) x
#align perfect_closure.mk PerfectClosure.mk

/- warning: perfect_closure.quot_mk_eq_mk -> PerfectClosure.quot_mk_eq_mk is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : Prod.{0, u1} Nat K), Eq.{succ u1} (Quot.{succ u1} (Prod.{0, u1} Nat K) (PerfectClosure.R.{u1} K _inst_1 p _inst_2 _inst_3)) (Quot.mk.{succ u1} (Prod.{0, u1} Nat K) (PerfectClosure.R.{u1} K _inst_1 p _inst_2 _inst_3) x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x)
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : Prod.{0, u1} Nat K), Eq.{succ u1} (Quot.{succ u1} (Prod.{0, u1} Nat K) (PerfectClosure.R.{u1} K _inst_1 p _inst_2 _inst_3)) (Quot.mk.{succ u1} (Prod.{0, u1} Nat K) (PerfectClosure.R.{u1} K _inst_1 p _inst_2 _inst_3) x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x)
Case conversion may be inaccurate. Consider using '#align perfect_closure.quot_mk_eq_mk PerfectClosure.quot_mk_eq_mkₓ'. -/
@[simp]
theorem quot_mk_eq_mk (x : ℕ × K) : (Quot.mk (R K p) x : PerfectClosure K p) = mk K p x :=
  rfl
#align perfect_closure.quot_mk_eq_mk PerfectClosure.quot_mk_eq_mk

variable {K p}

/- warning: perfect_closure.lift_on -> PerfectClosure.liftOn is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : CommRing.{u1} K] {p : Nat} [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] {L : Type.{u2}}, (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) -> (forall (f : (Prod.{0, u1} Nat K) -> L), (forall (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), (PerfectClosure.R.{u1} K _inst_1 p _inst_2 _inst_3 x y) -> (Eq.{succ u2} L (f x) (f y))) -> L)
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : CommRing.{u1} K] {p : Nat} [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] {L : Type.{u2}}, (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) -> (forall (f : (Prod.{0, u1} Nat K) -> L), (forall (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), (PerfectClosure.R.{u1} K _inst_1 p _inst_2 _inst_3 x y) -> (Eq.{succ u2} L (f x) (f y))) -> L)
Case conversion may be inaccurate. Consider using '#align perfect_closure.lift_on PerfectClosure.liftOnₓ'. -/
/-- Lift a function `ℕ × K → L` to a function on `perfect_closure K p`. -/
@[elab_as_elim]
def liftOn {L : Type _} (x : PerfectClosure K p) (f : ℕ × K → L)
    (hf : ∀ x y, R K p x y → f x = f y) : L :=
  Quot.liftOn x f hf
#align perfect_closure.lift_on PerfectClosure.liftOn

/- warning: perfect_closure.lift_on_mk -> PerfectClosure.liftOn_mk is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : CommRing.{u1} K] {p : Nat} [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] {L : Type.{u2}} (f : (Prod.{0, u1} Nat K) -> L) (hf : forall (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), (PerfectClosure.R.{u1} K _inst_1 p _inst_2 _inst_3 x y) -> (Eq.{succ u2} L (f x) (f y))) (x : Prod.{0, u1} Nat K), Eq.{succ u2} L (PerfectClosure.liftOn.{u1, u2} K _inst_1 p _inst_2 _inst_3 L (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x) f hf) (f x)
but is expected to have type
  forall {K : Type.{u2}} [_inst_1 : CommRing.{u2} K] {p : Nat} [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u2} K (AddGroupWithOne.toAddMonoidWithOne.{u2} K (Ring.toAddGroupWithOne.{u2} K (CommRing.toRing.{u2} K _inst_1))) p] {L : Type.{u1}} (f : (Prod.{0, u2} Nat K) -> L) (hf : forall (x : Prod.{0, u2} Nat K) (y : Prod.{0, u2} Nat K), (PerfectClosure.R.{u2} K _inst_1 p _inst_2 _inst_3 x y) -> (Eq.{succ u1} L (f x) (f y))) (x : Prod.{0, u2} Nat K), Eq.{succ u1} L (PerfectClosure.liftOn.{u2, u1} K _inst_1 p _inst_2 _inst_3 L (PerfectClosure.mk.{u2} K _inst_1 p _inst_2 _inst_3 x) f hf) (f x)
Case conversion may be inaccurate. Consider using '#align perfect_closure.lift_on_mk PerfectClosure.liftOn_mkₓ'. -/
@[simp]
theorem liftOn_mk {L : Sort _} (f : ℕ × K → L) (hf : ∀ x y, R K p x y → f x = f y) (x : ℕ × K) :
    (mk K p x).liftOn f hf = f x :=
  rfl
#align perfect_closure.lift_on_mk PerfectClosure.liftOn_mk

/- warning: perfect_closure.induction_on -> PerfectClosure.induction_on is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : CommRing.{u1} K] {p : Nat} [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) {q : (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) -> Prop}, (forall (x : Prod.{0, u1} Nat K), q (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x)) -> (q x)
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : CommRing.{u1} K] {p : Nat} [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) {q : (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) -> Prop}, (forall (x : Prod.{0, u1} Nat K), q (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x)) -> (q x)
Case conversion may be inaccurate. Consider using '#align perfect_closure.induction_on PerfectClosure.induction_onₓ'. -/
@[elab_as_elim]
theorem induction_on (x : PerfectClosure K p) {q : PerfectClosure K p → Prop}
    (h : ∀ x, q (mk K p x)) : q x :=
  Quot.inductionOn x h
#align perfect_closure.induction_on PerfectClosure.induction_on

variable (K p)

private theorem mul_aux_left (x1 x2 y : ℕ × K) (H : R K p x1 x2) :
    mk K p (x1.1 + y.1, (frobenius K p^[y.1]) x1.2 * (frobenius K p^[x1.1]) y.2) =
      mk K p (x2.1 + y.1, (frobenius K p^[y.1]) x2.2 * (frobenius K p^[x2.1]) y.2) :=
  match x1, x2, H with
  | _, _, r.intro n x =>
    Quot.sound <| by
      rw [← iterate_succ_apply, iterate_succ', iterate_succ', ← frobenius_mul, Nat.succ_add] <;>
        apply r.intro
#align perfect_closure.mul_aux_left perfect_closure.mul_aux_left

private theorem mul_aux_right (x y1 y2 : ℕ × K) (H : R K p y1 y2) :
    mk K p (x.1 + y1.1, (frobenius K p^[y1.1]) x.2 * (frobenius K p^[x.1]) y1.2) =
      mk K p (x.1 + y2.1, (frobenius K p^[y2.1]) x.2 * (frobenius K p^[x.1]) y2.2) :=
  match y1, y2, H with
  | _, _, r.intro n y =>
    Quot.sound <| by
      rw [← iterate_succ_apply, iterate_succ', iterate_succ', ← frobenius_mul] <;> apply r.intro
#align perfect_closure.mul_aux_right perfect_closure.mul_aux_right

instance : Mul (PerfectClosure K p) :=
  ⟨Quot.lift
      (fun x : ℕ × K =>
        Quot.lift
          (fun y : ℕ × K =>
            mk K p (x.1 + y.1, (frobenius K p^[y.1]) x.2 * (frobenius K p^[x.1]) y.2))
          (mul_aux_right K p x))
      fun x1 x2 (H : R K p x1 x2) =>
      funext fun e => Quot.inductionOn e fun y => mul_aux_left K p x1 x2 y H⟩

/- warning: perfect_closure.mk_mul_mk -> PerfectClosure.mk_mul_mk is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (HMul.hMul.{u1, u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (instHMul.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.hasMul.{u1} K _inst_1 p _inst_2 _inst_3)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 y)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (Prod.fst.{0, u1} Nat K x) (Prod.fst.{0, u1} Nat K y)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (CommRing.toRing.{u1} K _inst_1)))) (Nat.iterate.{succ u1} K (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (fun (_x : RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) => K -> K) (RingHom.hasCoeToFun.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (Prod.fst.{0, u1} Nat K y) (Prod.snd.{0, u1} Nat K x)) (Nat.iterate.{succ u1} K (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (fun (_x : RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) => K -> K) (RingHom.hasCoeToFun.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (Prod.fst.{0, u1} Nat K x) (Prod.snd.{0, u1} Nat K y)))))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (HMul.hMul.{u1, u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (instHMul.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.instMulPerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 y)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (Prod.fst.{0, u1} Nat K x) (Prod.fst.{0, u1} Nat K y)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))))) (Nat.iterate.{succ u1} K (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => K) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (Prod.fst.{0, u1} Nat K y) (Prod.snd.{0, u1} Nat K x)) (Nat.iterate.{succ u1} K (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => K) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (Prod.fst.{0, u1} Nat K x) (Prod.snd.{0, u1} Nat K y)))))
Case conversion may be inaccurate. Consider using '#align perfect_closure.mk_mul_mk PerfectClosure.mk_mul_mkₓ'. -/
@[simp]
theorem mk_mul_mk (x y : ℕ × K) :
    mk K p x * mk K p y =
      mk K p (x.1 + y.1, (frobenius K p^[y.1]) x.2 * (frobenius K p^[x.1]) y.2) :=
  rfl
#align perfect_closure.mk_mul_mk PerfectClosure.mk_mul_mk

instance : CommMonoid (PerfectClosure K p) :=
  {
    (inferInstance :
      Mul
        (PerfectClosure K
          p)) with
    mul_assoc := fun e f g =>
      Quot.inductionOn e fun ⟨m, x⟩ =>
        Quot.inductionOn f fun ⟨n, y⟩ =>
          Quot.inductionOn g fun ⟨s, z⟩ =>
            congr_arg (Quot.mk _) <| by
              simp only [add_assoc, mul_assoc, RingHom.iterate_map_mul, ← iterate_add_apply,
                add_comm, add_left_comm]
    one := mk K p (0, 1)
    one_mul := fun e =>
      Quot.inductionOn e fun ⟨n, x⟩ =>
        congr_arg (Quot.mk _) <| by
          simp only [RingHom.iterate_map_one, iterate_zero_apply, one_mul, zero_add]
    mul_one := fun e =>
      Quot.inductionOn e fun ⟨n, x⟩ =>
        congr_arg (Quot.mk _) <| by
          simp only [RingHom.iterate_map_one, iterate_zero_apply, mul_one, add_zero]
    mul_comm := fun e f =>
      Quot.inductionOn e fun ⟨m, x⟩ =>
        Quot.inductionOn f fun ⟨n, y⟩ =>
          congr_arg (Quot.mk _) <| by simp only [add_comm, mul_comm] }

/- warning: perfect_closure.one_def -> PerfectClosure.one_def is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p], Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (OfNat.ofNat.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 1 (OfNat.mk.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 1 (One.one.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (MulOneClass.toHasOne.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Monoid.toMulOneClass.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommMonoid.toMonoid.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commMonoid.{u1} K _inst_1 p _inst_2 _inst_3))))))) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))))))))))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p], Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (OfNat.ofNat.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 1 (One.toOfNat1.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Monoid.toOne.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommMonoid.toMonoid.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.instCommMonoidPerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3))))) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align perfect_closure.one_def PerfectClosure.one_defₓ'. -/
theorem one_def : (1 : PerfectClosure K p) = mk K p (0, 1) :=
  rfl
#align perfect_closure.one_def PerfectClosure.one_def

instance : Inhabited (PerfectClosure K p) :=
  ⟨1⟩

private theorem add_aux_left (x1 x2 y : ℕ × K) (H : R K p x1 x2) :
    mk K p (x1.1 + y.1, (frobenius K p^[y.1]) x1.2 + (frobenius K p^[x1.1]) y.2) =
      mk K p (x2.1 + y.1, (frobenius K p^[y.1]) x2.2 + (frobenius K p^[x2.1]) y.2) :=
  match x1, x2, H with
  | _, _, r.intro n x =>
    Quot.sound <| by
      rw [← iterate_succ_apply, iterate_succ', iterate_succ', ← frobenius_add, Nat.succ_add] <;>
        apply r.intro
#align perfect_closure.add_aux_left perfect_closure.add_aux_left

private theorem add_aux_right (x y1 y2 : ℕ × K) (H : R K p y1 y2) :
    mk K p (x.1 + y1.1, (frobenius K p^[y1.1]) x.2 + (frobenius K p^[x.1]) y1.2) =
      mk K p (x.1 + y2.1, (frobenius K p^[y2.1]) x.2 + (frobenius K p^[x.1]) y2.2) :=
  match y1, y2, H with
  | _, _, r.intro n y =>
    Quot.sound <| by
      rw [← iterate_succ_apply, iterate_succ', iterate_succ', ← frobenius_add] <;> apply r.intro
#align perfect_closure.add_aux_right perfect_closure.add_aux_right

instance : Add (PerfectClosure K p) :=
  ⟨Quot.lift
      (fun x : ℕ × K =>
        Quot.lift
          (fun y : ℕ × K =>
            mk K p (x.1 + y.1, (frobenius K p^[y.1]) x.2 + (frobenius K p^[x.1]) y.2))
          (add_aux_right K p x))
      fun x1 x2 (H : R K p x1 x2) =>
      funext fun e => Quot.inductionOn e fun y => add_aux_left K p x1 x2 y H⟩

/- warning: perfect_closure.mk_add_mk -> PerfectClosure.mk_add_mk is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (HAdd.hAdd.{u1, u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (instHAdd.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.hasAdd.{u1} K _inst_1 p _inst_2 _inst_3)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 y)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (Prod.fst.{0, u1} Nat K x) (Prod.fst.{0, u1} Nat K y)) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (CommRing.toRing.{u1} K _inst_1)))) (Nat.iterate.{succ u1} K (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (fun (_x : RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) => K -> K) (RingHom.hasCoeToFun.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (Prod.fst.{0, u1} Nat K y) (Prod.snd.{0, u1} Nat K x)) (Nat.iterate.{succ u1} K (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (fun (_x : RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) => K -> K) (RingHom.hasCoeToFun.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (Prod.fst.{0, u1} Nat K x) (Prod.snd.{0, u1} Nat K y)))))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (HAdd.hAdd.{u1, u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (instHAdd.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.instAddPerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 y)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (Prod.fst.{0, u1} Nat K x) (Prod.fst.{0, u1} Nat K y)) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))))))) (Nat.iterate.{succ u1} K (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => K) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (Prod.fst.{0, u1} Nat K y) (Prod.snd.{0, u1} Nat K x)) (Nat.iterate.{succ u1} K (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => K) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (Prod.fst.{0, u1} Nat K x) (Prod.snd.{0, u1} Nat K y)))))
Case conversion may be inaccurate. Consider using '#align perfect_closure.mk_add_mk PerfectClosure.mk_add_mkₓ'. -/
@[simp]
theorem mk_add_mk (x y : ℕ × K) :
    mk K p x + mk K p y =
      mk K p (x.1 + y.1, (frobenius K p^[y.1]) x.2 + (frobenius K p^[x.1]) y.2) :=
  rfl
#align perfect_closure.mk_add_mk PerfectClosure.mk_add_mk

instance : Neg (PerfectClosure K p) :=
  ⟨Quot.lift (fun x : ℕ × K => mk K p (x.1, -x.2)) fun x y (H : R K p x y) =>
      match x, y, H with
      | _, _, r.intro n x => Quot.sound <| by rw [← frobenius_neg] <;> apply r.intro⟩

/- warning: perfect_closure.neg_mk -> PerfectClosure.neg_mk is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : Prod.{0, u1} Nat K), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Neg.neg.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.hasNeg.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (Prod.fst.{0, u1} Nat K x) (Neg.neg.{u1} K (SubNegMonoid.toHasNeg.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))))) (Prod.snd.{0, u1} Nat K x))))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : Prod.{0, u1} Nat K), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Neg.neg.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.instNegPerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (Prod.fst.{0, u1} Nat K x) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (CommRing.toRing.{u1} K _inst_1)) (Prod.snd.{0, u1} Nat K x))))
Case conversion may be inaccurate. Consider using '#align perfect_closure.neg_mk PerfectClosure.neg_mkₓ'. -/
@[simp]
theorem neg_mk (x : ℕ × K) : -mk K p x = mk K p (x.1, -x.2) :=
  rfl
#align perfect_closure.neg_mk PerfectClosure.neg_mk

instance : Zero (PerfectClosure K p) :=
  ⟨mk K p (0, 0)⟩

/- warning: perfect_closure.zero_def -> PerfectClosure.zero_def is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p], Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (OfNat.ofNat.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 0 (OfNat.mk.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 0 (Zero.zero.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.hasZero.{u1} K _inst_1 p _inst_2 _inst_3)))) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))))))))))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p], Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (OfNat.ofNat.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 0 (Zero.toOfNat0.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.instZeroPerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3))) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommSemiring.toCommMonoidWithZero.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align perfect_closure.zero_def PerfectClosure.zero_defₓ'. -/
theorem zero_def : (0 : PerfectClosure K p) = mk K p (0, 0) :=
  rfl
#align perfect_closure.zero_def PerfectClosure.zero_def

/- warning: perfect_closure.mk_zero_zero -> PerfectClosure.mk_zero_zero is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p], Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))))))))))) (OfNat.ofNat.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 0 (OfNat.mk.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 0 (Zero.zero.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.hasZero.{u1} K _inst_1 p _inst_2 _inst_3))))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p], Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommSemiring.toCommMonoidWithZero.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (OfNat.ofNat.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 0 (Zero.toOfNat0.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.instZeroPerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align perfect_closure.mk_zero_zero PerfectClosure.mk_zero_zeroₓ'. -/
@[simp]
theorem mk_zero_zero : mk K p (0, 0) = 0 :=
  rfl
#align perfect_closure.mk_zero_zero PerfectClosure.mk_zero_zero

/- warning: perfect_closure.mk_zero -> PerfectClosure.mk_zero is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (n : Nat), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K n (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))))))))))) (OfNat.ofNat.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 0 (OfNat.mk.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 0 (Zero.zero.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.hasZero.{u1} K _inst_1 p _inst_2 _inst_3))))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (n : Nat), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K n (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommSemiring.toCommMonoidWithZero.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (OfNat.ofNat.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) 0 (Zero.toOfNat0.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.instZeroPerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align perfect_closure.mk_zero PerfectClosure.mk_zeroₓ'. -/
theorem mk_zero (n : ℕ) : mk K p (n, 0) = 0 := by
  induction' n with n ih <;> [rfl, rw [← ih]] <;> symm <;> apply Quot.sound <;>
      have := r.intro n (0 : K) <;>
    rwa [frobenius_zero K p] at this
#align perfect_closure.mk_zero PerfectClosure.mk_zero

/- warning: perfect_closure.r.sound -> PerfectClosure.R.sound is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (m : Nat) (n : Nat) (x : K) (y : K), (Eq.{succ u1} K (Nat.iterate.{succ u1} K (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (fun (_x : RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) => K -> K) (RingHom.hasCoeToFun.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) m x) y) -> (Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K n x)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m n) y)))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (m : Nat) (n : Nat) (x : K) (y : K), (Eq.{succ u1} K (Nat.iterate.{succ u1} K (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => K) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) m x) y) -> (Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K n x)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m n) y)))
Case conversion may be inaccurate. Consider using '#align perfect_closure.r.sound PerfectClosure.R.soundₓ'. -/
theorem R.sound (m n : ℕ) (x y : K) (H : (frobenius K p^[m]) x = y) :
    mk K p (n, x) = mk K p (m + n, y) := by
  subst H <;> induction' m with m ih <;> [simp only [zero_add, iterate_zero_apply],
        rw [ih, Nat.succ_add, iterate_succ']] <;>
      apply Quot.sound <;>
    apply r.intro
#align perfect_closure.r.sound PerfectClosure.R.sound

instance : AddCommGroup (PerfectClosure K p) :=
  { (inferInstance : Add (PerfectClosure K p)),
    (inferInstance :
      Neg
        (PerfectClosure K
          p)) with
    add_assoc := fun e f g =>
      Quot.inductionOn e fun ⟨m, x⟩ =>
        Quot.inductionOn f fun ⟨n, y⟩ =>
          Quot.inductionOn g fun ⟨s, z⟩ =>
            congr_arg (Quot.mk _) <| by
              simp only [RingHom.iterate_map_add, ← iterate_add_apply, add_assoc, add_comm s _]
    zero := 0
    zero_add := fun e =>
      Quot.inductionOn e fun ⟨n, x⟩ =>
        congr_arg (Quot.mk _) <| by
          simp only [RingHom.iterate_map_zero, iterate_zero_apply, zero_add]
    add_zero := fun e =>
      Quot.inductionOn e fun ⟨n, x⟩ =>
        congr_arg (Quot.mk _) <| by
          simp only [RingHom.iterate_map_zero, iterate_zero_apply, add_zero]
    sub_eq_add_neg := fun a b => rfl
    add_left_neg := fun e =>
      Quot.inductionOn e fun ⟨n, x⟩ => by
        simp only [quot_mk_eq_mk, neg_mk, mk_add_mk, RingHom.iterate_map_neg, add_left_neg, mk_zero]
    add_comm := fun e f =>
      Quot.inductionOn e fun ⟨m, x⟩ =>
        Quot.inductionOn f fun ⟨n, y⟩ => congr_arg (Quot.mk _) <| by simp only [add_comm] }

instance : CommRing (PerfectClosure K p) :=
  { PerfectClosure.addCommGroup K p, AddMonoidWithOne.unary,
    (inferInstance :
      CommMonoid
        (PerfectClosure K
          p)) with
    left_distrib := fun e f g =>
      Quot.inductionOn e fun ⟨m, x⟩ =>
        Quot.inductionOn f fun ⟨n, y⟩ =>
          Quot.inductionOn g fun ⟨s, z⟩ =>
            show Quot.mk _ _ = Quot.mk _ _ by
              simp only [add_assoc, add_comm, add_left_comm] <;> apply r.sound <;>
                simp only [RingHom.iterate_map_mul, RingHom.iterate_map_add, ← iterate_add_apply,
                  mul_add, add_comm, add_left_comm]
    right_distrib := fun e f g =>
      Quot.inductionOn e fun ⟨m, x⟩ =>
        Quot.inductionOn f fun ⟨n, y⟩ =>
          Quot.inductionOn g fun ⟨s, z⟩ =>
            show Quot.mk _ _ = Quot.mk _ _ by
              simp only [add_assoc, add_comm _ s, add_left_comm _ s] <;> apply r.sound <;>
                simp only [RingHom.iterate_map_mul, RingHom.iterate_map_add, ← iterate_add_apply,
                  add_mul, add_comm, add_left_comm] }

/- warning: perfect_closure.eq_iff' -> PerfectClosure.eq_iff' is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), Iff (Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 y)) (Exists.{1} Nat (fun (z : Nat) => Eq.{succ u1} K (Nat.iterate.{succ u1} K (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (fun (_x : RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) => K -> K) (RingHom.hasCoeToFun.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (Prod.fst.{0, u1} Nat K y) z) (Prod.snd.{0, u1} Nat K x)) (Nat.iterate.{succ u1} K (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (fun (_x : RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) => K -> K) (RingHom.hasCoeToFun.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (Prod.fst.{0, u1} Nat K x) z) (Prod.snd.{0, u1} Nat K y))))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), Iff (Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 y)) (Exists.{1} Nat (fun (z : Nat) => Eq.{succ u1} K (Nat.iterate.{succ u1} K (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => K) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (Prod.fst.{0, u1} Nat K y) z) (Prod.snd.{0, u1} Nat K x)) (Nat.iterate.{succ u1} K (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => K) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_2 _inst_3)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (Prod.fst.{0, u1} Nat K x) z) (Prod.snd.{0, u1} Nat K y))))
Case conversion may be inaccurate. Consider using '#align perfect_closure.eq_iff' PerfectClosure.eq_iff'ₓ'. -/
theorem eq_iff' (x y : ℕ × K) :
    mk K p x = mk K p y ↔ ∃ z, (frobenius K p^[y.1 + z]) x.2 = (frobenius K p^[x.1 + z]) y.2 :=
  by
  constructor
  · intro H
    replace H := Quot.exact _ H
    induction H
    case rel x y H => cases' H with n x; exact ⟨0, rfl⟩
    case refl H => exact ⟨0, rfl⟩
    case symm x y H ih => cases' ih with w ih; exact ⟨w, ih.symm⟩
    case trans x y z H1 H2 ih1 ih2 =>
      cases' ih1 with z1 ih1
      cases' ih2 with z2 ih2
      exists z2 + (y.1 + z1)
      rw [← add_assoc, iterate_add_apply, ih1]
      rw [← iterate_add_apply, add_comm, iterate_add_apply, ih2]
      rw [← iterate_add_apply]
      simp only [add_comm, add_left_comm]
  intro H
  cases' x with m x
  cases' y with n y
  cases' H with z H; dsimp only at H
  rw [r.sound K p (n + z) m x _ rfl, r.sound K p (m + z) n y _ rfl, H]
  rw [add_assoc, add_comm, add_comm z]
#align perfect_closure.eq_iff' PerfectClosure.eq_iff'

/- warning: perfect_closure.nat_cast -> PerfectClosure.nat_cast is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (n : Nat) (x : Nat), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (HasLiftT.mk.{1, succ u1} Nat (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CoeTCₓ.coe.{1, succ u1} Nat (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Nat.castCoe.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (AddMonoidWithOne.toNatCast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (AddGroupWithOne.toAddMonoidWithOne.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toAddGroupWithOne.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))))))) x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K n ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat K (HasLiftT.mk.{1, succ u1} Nat K (CoeTCₓ.coe.{1, succ u1} Nat K (Nat.castCoe.{u1} K (AddMonoidWithOne.toNatCast.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))))))) x)))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (n : Nat) (x : Nat), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Nat.cast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNatCast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K n (Nat.cast.{u1} K (NonAssocRing.toNatCast.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) x)))
Case conversion may be inaccurate. Consider using '#align perfect_closure.nat_cast PerfectClosure.nat_castₓ'. -/
theorem nat_cast (n x : ℕ) : (x : PerfectClosure K p) = mk K p (n, x) :=
  by
  induction' n with n ih
  · induction' x with x ih
    · simp
    rw [Nat.cast_succ, Nat.cast_succ, ih]
    rfl
  rw [ih]; apply Quot.sound
  conv =>
    congr
    skip
    skip
    rw [← frobenius_nat_cast K p x]
  apply r.intro
#align perfect_closure.nat_cast PerfectClosure.nat_cast

/- warning: perfect_closure.int_cast -> PerfectClosure.int_cast is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : Int), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (HasLiftT.mk.{1, succ u1} Int (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CoeTCₓ.coe.{1, succ u1} Int (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Int.castCoe.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (AddGroupWithOne.toHasIntCast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toAddGroupWithOne.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))))))) x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int K (HasLiftT.mk.{1, succ u1} Int K (CoeTCₓ.coe.{1, succ u1} Int K (Int.castCoe.{u1} K (AddGroupWithOne.toHasIntCast.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))))))) x)))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : Int), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Int.cast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toIntCast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))) x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (Int.cast.{u1} K (Ring.toIntCast.{u1} K (CommRing.toRing.{u1} K _inst_1)) x)))
Case conversion may be inaccurate. Consider using '#align perfect_closure.int_cast PerfectClosure.int_castₓ'. -/
theorem int_cast (x : ℤ) : (x : PerfectClosure K p) = mk K p (0, x) := by
  induction x <;> simp only [Int.cast_ofNat, Int.cast_negSucc, nat_cast K p 0] <;> rfl
#align perfect_closure.int_cast PerfectClosure.int_cast

/- warning: perfect_closure.nat_cast_eq_iff -> PerfectClosure.nat_cast_eq_iff is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : Nat) (y : Nat), Iff (Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (HasLiftT.mk.{1, succ u1} Nat (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CoeTCₓ.coe.{1, succ u1} Nat (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Nat.castCoe.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (AddMonoidWithOne.toNatCast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (AddGroupWithOne.toAddMonoidWithOne.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toAddGroupWithOne.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))))))) x) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (HasLiftT.mk.{1, succ u1} Nat (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CoeTCₓ.coe.{1, succ u1} Nat (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Nat.castCoe.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (AddMonoidWithOne.toNatCast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (AddGroupWithOne.toAddMonoidWithOne.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toAddGroupWithOne.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))))))) y)) (Eq.{succ u1} K ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat K (HasLiftT.mk.{1, succ u1} Nat K (CoeTCₓ.coe.{1, succ u1} Nat K (Nat.castCoe.{u1} K (AddMonoidWithOne.toNatCast.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))))))) x) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat K (HasLiftT.mk.{1, succ u1} Nat K (CoeTCₓ.coe.{1, succ u1} Nat K (Nat.castCoe.{u1} K (AddMonoidWithOne.toNatCast.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))))))) y))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : Nat) (y : Nat), Iff (Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Nat.cast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNatCast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) x) (Nat.cast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNatCast.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) y)) (Eq.{succ u1} K (Nat.cast.{u1} K (NonAssocRing.toNatCast.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) x) (Nat.cast.{u1} K (NonAssocRing.toNatCast.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) y))
Case conversion may be inaccurate. Consider using '#align perfect_closure.nat_cast_eq_iff PerfectClosure.nat_cast_eq_iffₓ'. -/
theorem nat_cast_eq_iff (x y : ℕ) : (x : PerfectClosure K p) = y ↔ (x : K) = y :=
  by
  constructor <;> intro H
  · rw [nat_cast K p 0, nat_cast K p 0, eq_iff'] at H
    cases' H with z H
    simpa only [zero_add, iterate_fixed (frobenius_nat_cast K p _)] using H
  rw [nat_cast K p 0, nat_cast K p 0, H]
#align perfect_closure.nat_cast_eq_iff PerfectClosure.nat_cast_eq_iff

instance : CharP (PerfectClosure K p) p := by
  constructor; intro x; rw [← CharP.cast_eq_zero_iff K]
  rw [← Nat.cast_zero, nat_cast_eq_iff, Nat.cast_zero]

/- warning: perfect_closure.frobenius_mk -> PerfectClosure.frobenius_mk is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : Prod.{0, u1} Nat K), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (fun (_x : RingHom.{u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) => (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) -> (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3)) (RingHom.hasCoeToFun.{u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (frobenius.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)) p _inst_2 (PerfectClosure.charP.{u1} K _inst_1 p _inst_2 _inst_3)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (Prod.fst.{0, u1} Nat K x) (HPow.hPow.{u1, 0, u1} K Nat K (instHPow.{u1, 0} K Nat (Monoid.Pow.{u1} K (Ring.toMonoid.{u1} K (CommRing.toRing.{u1} K _inst_1)))) (Prod.snd.{0, u1} Nat K x) p)))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : Prod.{0, u1} Nat K), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) => PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (fun (_x : PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) => PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (RingHom.instRingHomClassRingHom.{u1, u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))))))) (frobenius.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toCommSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)) p _inst_2 (PerfectClosure.instCharPPerfectClosureToAddMonoidWithOneToAddGroupWithOneToRingCommRing.{u1} K _inst_1 p _inst_2 _inst_3)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 x)) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (Prod.fst.{0, u1} Nat K x) (HPow.hPow.{u1, 0, u1} K Nat K (instHPow.{u1, 0} K Nat (Monoid.Pow.{u1} K (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1)))))) (Prod.snd.{0, u1} Nat K x) p)))
Case conversion may be inaccurate. Consider using '#align perfect_closure.frobenius_mk PerfectClosure.frobenius_mkₓ'. -/
theorem frobenius_mk (x : ℕ × K) :
    (frobenius (PerfectClosure K p) p : PerfectClosure K p → PerfectClosure K p) (mk K p x) =
      mk _ _ (x.1, x.2 ^ p) :=
  by
  simp only [frobenius_def]
  cases' x with n x
  dsimp only
  suffices ∀ p' : ℕ, mk K p (n, x) ^ p' = mk K p (n, x ^ p') by apply this
  intro p
  induction' p with p ih
  case zero => apply r.sound; rw [(frobenius _ _).iterate_map_one, pow_zero]
  case succ =>
    rw [pow_succ, ih]
    symm
    apply r.sound
    simp only [pow_succ, (frobenius _ _).iterate_map_mul]
#align perfect_closure.frobenius_mk PerfectClosure.frobenius_mk

/- warning: perfect_closure.of -> PerfectClosure.of is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p], RingHom.{u1, u1} K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p], RingHom.{u1, u1} K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))
Case conversion may be inaccurate. Consider using '#align perfect_closure.of PerfectClosure.ofₓ'. -/
/-- Embedding of `K` into `perfect_closure K p` -/
def of : K →+* PerfectClosure K p where
  toFun x := mk _ _ (0, x)
  map_one' := rfl
  map_mul' x y := rfl
  map_zero' := rfl
  map_add' x y := rfl
#align perfect_closure.of PerfectClosure.of

/- warning: perfect_closure.of_apply -> PerfectClosure.of_apply is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : K), Eq.{succ u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (fun (_x : RingHom.{u1, u1} K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) => K -> (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3)) (RingHom.hasCoeToFun.{u1, u1} K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (PerfectClosure.of.{u1} K _inst_1 p _inst_2 _inst_3) x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) x))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : K), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) x) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3))))) K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (RingHom.instRingHomClassRingHom.{u1, u1} K (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K _inst_1 p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K _inst_1 p _inst_2 _inst_3)))))))) (PerfectClosure.of.{u1} K _inst_1 p _inst_2 _inst_3) x) (PerfectClosure.mk.{u1} K _inst_1 p _inst_2 _inst_3 (Prod.mk.{0, u1} Nat K (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) x))
Case conversion may be inaccurate. Consider using '#align perfect_closure.of_apply PerfectClosure.of_applyₓ'. -/
theorem of_apply (x : K) : of K p x = mk _ _ (0, x) :=
  rfl
#align perfect_closure.of_apply PerfectClosure.of_apply

end Ring

/- warning: perfect_closure.eq_iff -> PerfectClosure.eq_iff is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] [_inst_2 : IsDomain.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))] (p : Nat) [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K _inst_1)))) p] (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), Iff (Eq.{succ u1} (Quot.{succ u1} (Prod.{0, u1} Nat K) (PerfectClosure.R.{u1} K _inst_1 p _inst_3 _inst_4)) (Quot.mk.{succ u1} (Prod.{0, u1} Nat K) (PerfectClosure.R.{u1} K _inst_1 p _inst_3 _inst_4) x) (Quot.mk.{succ u1} (Prod.{0, u1} Nat K) (PerfectClosure.R.{u1} K _inst_1 p _inst_3 _inst_4) y)) (Eq.{succ u1} K (Nat.iterate.{succ u1} K (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (fun (_x : RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) => K -> K) (RingHom.hasCoeToFun.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_3 _inst_4)) (Prod.fst.{0, u1} Nat K y) (Prod.snd.{0, u1} Nat K x)) (Nat.iterate.{succ u1} K (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (fun (_x : RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) => K -> K) (RingHom.hasCoeToFun.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_3 _inst_4)) (Prod.fst.{0, u1} Nat K x) (Prod.snd.{0, u1} Nat K y)))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : CommRing.{u1} K] [_inst_2 : IsDomain.{u1} K (Ring.toSemiring.{u1} K (CommRing.toRing.{u1} K _inst_1))] (p : Nat) [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (CommRing.toRing.{u1} K _inst_1))) p] (x : Prod.{0, u1} Nat K) (y : Prod.{0, u1} Nat K), Iff (Eq.{succ u1} (Quot.{succ u1} (Prod.{0, u1} Nat K) (PerfectClosure.R.{u1} K _inst_1 p _inst_3 _inst_4)) (Quot.mk.{succ u1} (Prod.{0, u1} Nat K) (PerfectClosure.R.{u1} K _inst_1 p _inst_3 _inst_4) x) (Quot.mk.{succ u1} (Prod.{0, u1} Nat K) (PerfectClosure.R.{u1} K _inst_1 p _inst_3 _inst_4) y)) (Eq.{succ u1} K (Nat.iterate.{succ u1} K (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => K) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_3 _inst_4)) (Prod.fst.{0, u1} Nat K y) (Prod.snd.{0, u1} Nat K x)) (Nat.iterate.{succ u1} K (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => K) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1)))) K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} K K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1))))))) (frobenius.{u1} K (CommRing.toCommSemiring.{u1} K _inst_1) p _inst_3 _inst_4)) (Prod.fst.{0, u1} Nat K x) (Prod.snd.{0, u1} Nat K y)))
Case conversion may be inaccurate. Consider using '#align perfect_closure.eq_iff PerfectClosure.eq_iffₓ'. -/
theorem eq_iff [CommRing K] [IsDomain K] (p : ℕ) [Fact p.Prime] [CharP K p] (x y : ℕ × K) :
    Quot.mk (R K p) x = Quot.mk (R K p) y ↔ (frobenius K p^[y.1]) x.2 = (frobenius K p^[x.1]) y.2 :=
  (eq_iff' K p x y).trans
    ⟨fun ⟨z, H⟩ => (frobenius_inj K p).iterate z <| by simpa only [add_comm, iterate_add] using H,
      fun H => ⟨0, H⟩⟩
#align perfect_closure.eq_iff PerfectClosure.eq_iff

section Field

variable [Field K] (p : ℕ) [Fact p.Prime] [CharP K p]

instance : Inv (PerfectClosure K p) :=
  ⟨Quot.lift (fun x : ℕ × K => Quot.mk (R K p) (x.1, x.2⁻¹)) fun x y (H : R K p x y) =>
      match x, y, H with
      | _, _, r.intro n x =>
        Quot.sound <| by
          simp only [frobenius_def]
          rw [← inv_pow]
          apply r.intro⟩

instance : Field (PerfectClosure K p) :=
  { (inferInstance : Inv (PerfectClosure K p)),
    (inferInstance :
      CommRing
        (PerfectClosure K
          p)) with
    exists_pair_ne := ⟨0, 1, fun H => zero_ne_one ((eq_iff _ _ _ _).1 H)⟩
    mul_inv_cancel := fun e =>
      induction_on e fun ⟨m, x⟩ H =>
        have := mt (eq_iff _ _ _ _).2 H
        (eq_iff _ _ _ _).2
          (by
            simp only [(frobenius _ _).iterate_map_one, (frobenius K p).iterate_map_zero,
                iterate_zero_apply, ← (frobenius _ p).iterate_map_mul] at this⊢ <;>
              rw [mul_inv_cancel this, (frobenius _ _).iterate_map_one])
    inv_zero := congr_arg (Quot.mk (R K p)) (by rw [inv_zero]) }

instance : PerfectRing (PerfectClosure K p) p
    where
  pthRoot' e :=
    liftOn e (fun x => mk K p (x.1 + 1, x.2)) fun x y H =>
      match x, y, H with
      | _, _, r.intro n x => Quot.sound (R.intro _ _)
  frobenius_pthRoot' e :=
    induction_on e fun ⟨n, x⟩ => by
      simp only [lift_on_mk, frobenius_mk]
      exact (Quot.sound <| r.intro _ _).symm
  pth_root_frobenius' e :=
    induction_on e fun ⟨n, x⟩ => by
      simp only [lift_on_mk, frobenius_mk]
      exact (Quot.sound <| r.intro _ _).symm

/- warning: perfect_closure.eq_pth_root -> PerfectClosure.eq_pthRoot is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : Field.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) p] (x : Prod.{0, u1} Nat K), Eq.{succ u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3 x) (Nat.iterate.{succ u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.field.{u1} K _inst_1 p _inst_2 _inst_3))))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.field.{u1} K _inst_1 p _inst_2 _inst_3)))))) (fun (_x : RingHom.{u1, u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.field.{u1} K _inst_1 p _inst_2 _inst_3))))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.field.{u1} K _inst_1 p _inst_2 _inst_3)))))) => (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) -> (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3)) (RingHom.hasCoeToFun.{u1, u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.field.{u1} K _inst_1 p _inst_2 _inst_3))))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.field.{u1} K _inst_1 p _inst_2 _inst_3)))))) (pthRoot.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.field.{u1} K _inst_1 p _inst_2 _inst_3))) p _inst_2 (PerfectClosure.charP.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.perfectRing.{u1} K _inst_1 p _inst_2 _inst_3))) (Prod.fst.{0, u1} Nat K x) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3))))) (fun (_x : RingHom.{u1, u1} K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3))))) => K -> (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3)) (RingHom.hasCoeToFun.{u1, u1} K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3))))) (PerfectClosure.of.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Prod.snd.{0, u1} Nat K x)))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : Field.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) p] (x : Prod.{0, u1} Nat K), Eq.{succ u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.mk.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3 x) (Nat.iterate.{succ u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3)))))) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (fun (_x : PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) => PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3)))))) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))))))) (NonUnitalNonAssocSemiring.toMul.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3)))))) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3)))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3)))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3)))))) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (RingHom.instRingHomClassRingHom.{u1, u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))))) (Semiring.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommSemiring.toSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))))))))) (pthRoot.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Semifield.toCommSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toSemifield.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instFieldPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3))) p _inst_2 (PerfectClosure.instCharPPerfectClosureToAddMonoidWithOneToAddGroupWithOneToRingCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instPerfectRingPerfectClosureToCommRingToCommSemiringToSemifieldInstFieldPerfectClosureToCommRingInstCharPPerfectClosureToAddMonoidWithOneToAddGroupWithOneToRingCommRing.{u1} K _inst_1 p _inst_2 _inst_3))) (Prod.fst.{0, u1} Nat K x) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3))))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3))))) K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (NonUnitalNonAssocSemiring.toMul.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3)))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3))))) K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3))))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3))))) K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3)))) (RingHom.instRingHomClassRingHom.{u1, u1} K (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (CommRing.toRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))) (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (CommRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.PerfectClosure.commRing.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3)))))))) (PerfectClosure.of.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Prod.snd.{0, u1} Nat K x)))
Case conversion may be inaccurate. Consider using '#align perfect_closure.eq_pth_root PerfectClosure.eq_pthRootₓ'. -/
theorem eq_pthRoot (x : ℕ × K) : mk K p x = (pthRoot (PerfectClosure K p) p^[x.1]) (of K p x.2) :=
  by
  rcases x with ⟨m, x⟩
  induction' m with m ih; · rfl
  rw [iterate_succ_apply', ← ih] <;> rfl
#align perfect_closure.eq_pth_root PerfectClosure.eq_pthRoot

/- warning: perfect_closure.lift -> PerfectClosure.lift is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) [_inst_1 : Field.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) p] (L : Type.{u2}) [_inst_4 : CommSemiring.{u2} L] [_inst_5 : CharP.{u2} L (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} L (NonAssocSemiring.toAddCommMonoidWithOne.{u2} L (Semiring.toNonAssocSemiring.{u2} L (CommSemiring.toSemiring.{u2} L _inst_4)))) p] [_inst_6 : PerfectRing.{u2} L _inst_4 p _inst_2 _inst_5], Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (CommSemiring.toSemiring.{u2} L _inst_4))) (RingHom.{u1, u2} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) L (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (DivisionRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Field.toDivisionRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.field.{u1} K _inst_1 p _inst_2 _inst_3))))) (Semiring.toNonAssocSemiring.{u2} L (CommSemiring.toSemiring.{u2} L _inst_4)))
but is expected to have type
  forall (K : Type.{u1}) [_inst_1 : Field.{u1} K] (p : Nat) [_inst_2 : Fact (Nat.Prime p)] [_inst_3 : CharP.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) p] (L : Type.{u2}) [_inst_4 : CommSemiring.{u2} L] [_inst_5 : CharP.{u2} L (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} L (NonAssocSemiring.toAddCommMonoidWithOne.{u2} L (Semiring.toNonAssocSemiring.{u2} L (CommSemiring.toSemiring.{u2} L _inst_4)))) p] [_inst_6 : PerfectRing.{u2} L _inst_4 p _inst_2 _inst_5], Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u1, u2} K L (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Semiring.toNonAssocSemiring.{u2} L (CommSemiring.toSemiring.{u2} L _inst_4))) (RingHom.{u1, u2} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) L (NonAssocRing.toNonAssocSemiring.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (Ring.toNonAssocRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (DivisionRing.toRing.{u1} (PerfectClosure.{u1} K (Field.toCommRing.{u1} K _inst_1) p _inst_2 _inst_3) (PerfectClosure.instDivisionRingPerfectClosureToCommRing.{u1} K _inst_1 p _inst_2 _inst_3)))) (Semiring.toNonAssocSemiring.{u2} L (CommSemiring.toSemiring.{u2} L _inst_4)))
Case conversion may be inaccurate. Consider using '#align perfect_closure.lift PerfectClosure.liftₓ'. -/
/-- Given a field `K` of characteristic `p` and a perfect ring `L` of the same characteristic,
any homomorphism `K →+* L` can be lifted to `perfect_closure K p`. -/
def lift (L : Type v) [CommSemiring L] [CharP L p] [PerfectRing L p] :
    (K →+* L) ≃ (PerfectClosure K p →+* L) :=
  by
  have := left_inverse_pth_root_frobenius.iterate
  refine_struct { .. }
  field to_fun =>
    intro f
    refine_struct { .. }
    field to_fun =>
      refine' fun e => lift_on e (fun x => (pthRoot L p^[x.1]) (f x.2)) _
      rintro a b ⟨n⟩
      simp only [f.map_frobenius, iterate_succ_apply, pthRoot_frobenius]
    field map_one' => exact f.map_one
    field map_zero' => exact f.map_zero
    field map_mul' =>
      rintro ⟨x⟩ ⟨y⟩
      simp only [quot_mk_eq_mk, lift_on_mk, mk_mul_mk, RingHom.map_iterate_frobenius,
        RingHom.iterate_map_mul, RingHom.map_mul]
      rw [iterate_add_apply, this _ _, add_comm, iterate_add_apply, this _ _]
    field map_add' =>
      rintro ⟨x⟩ ⟨y⟩
      simp only [quot_mk_eq_mk, lift_on_mk, mk_add_mk, RingHom.map_iterate_frobenius,
        RingHom.iterate_map_add, RingHom.map_add]
      rw [iterate_add_apply, this _ _, add_comm x.1, iterate_add_apply, this _ _]
  field inv_fun => exact fun f => f.comp (of K p)
  field left_inv => intro f; ext x; rfl
  field right_inv =>
    intro f; ext ⟨x⟩
    simp only [RingHom.coe_mk, quot_mk_eq_mk, RingHom.comp_apply, lift_on_mk]
    rw [eq_pth_root, RingHom.map_iterate_pthRoot]
#align perfect_closure.lift PerfectClosure.lift

end Field

end PerfectClosure

/- warning: perfect_ring.of_surjective -> PerfectRing.ofSurjective is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : CommRing.{u1} k] [_inst_2 : IsReduced.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))))) (Monoid.Pow.{u1} k (Ring.toMonoid.{u1} k (CommRing.toRing.{u1} k _inst_1)))] (p : Nat) [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))) p], (Function.Surjective.{succ u1, succ u1} k k (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} k k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1)))) (fun (_x : RingHom.{u1, u1} k k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1)))) => k -> k) (RingHom.hasCoeToFun.{u1, u1} k k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1)))) (frobenius.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1) p _inst_3 _inst_4))) -> (PerfectRing.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1) p _inst_3 _inst_4)
but is expected to have type
  forall (k : Type.{u1}) [_inst_1 : CommRing.{u1} k] [_inst_2 : IsReduced.{u1} k (CommMonoidWithZero.toZero.{u1} k (CommSemiring.toCommMonoidWithZero.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (Monoid.Pow.{u1} k (MonoidWithZero.toMonoid.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)))))] (p : Nat) [_inst_3 : Fact (Nat.Prime p)] [_inst_4 : CharP.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (Ring.toAddGroupWithOne.{u1} k (CommRing.toRing.{u1} k _inst_1))) p], (Function.Surjective.{succ u1, succ u1} k k (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} k k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1)))) k (fun (_x : k) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : k) => k) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} k k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1)))) k k (NonUnitalNonAssocSemiring.toMul.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} k k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1)))) k k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} k k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1)))) k k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u1} k k (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (Semiring.toNonAssocSemiring.{u1} k (CommSemiring.toSemiring.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))))))) (frobenius.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1) p _inst_3 _inst_4))) -> (PerfectRing.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1) p _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align perfect_ring.of_surjective PerfectRing.ofSurjectiveₓ'. -/
/-- A reduced ring with prime characteristic and surjective frobenius map is perfect. -/
noncomputable def PerfectRing.ofSurjective (k : Type _) [CommRing k] [IsReduced k] (p : ℕ)
    [Fact p.Prime] [CharP k p] (h : Function.Surjective <| frobenius k p) : PerfectRing k p
    where
  pthRoot' := Function.surjInv h
  frobenius_pthRoot' := Function.surjInv_eq h
  pth_root_frobenius' x := frobenius_inj _ _ <| Function.surjInv_eq h _
#align perfect_ring.of_surjective PerfectRing.ofSurjective

