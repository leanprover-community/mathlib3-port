/-
Copyright (c) 2019 Sébastien Gouëzel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sébastien Gouëzel

! This file was ported from Lean 3 source module topology.fiber_bundle.trivialization
! leanprover-community/mathlib commit 69c6a5a12d8a2b159f20933e60115a4f2de62b58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Bundle
import Mathbin.Topology.Algebra.Order.Field
import Mathbin.Topology.LocalHomeomorph

/-!
# Trivializations

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main definitions

### Basic definitions

* `trivialization F p` : structure extending local homeomorphisms, defining a local
                  trivialization of a topological space `Z` with projection `p` and fiber `F`.

* `pretrivialization F proj` : trivialization as a local equivalence, mainly used when the
                                      topology on the total space has not yet been defined.

### Operations on bundles

We provide the following operations on `trivialization`s.

* `trivialization.comp_homeomorph`: given a local trivialization `e` of a fiber bundle
  `p : Z → B` and a homeomorphism `h : Z' ≃ₜ Z`, returns a local trivialization of the fiber bundle
  `p ∘ h`.

## Implementation notes

Previously, in mathlib, there was a structure `topological_vector_bundle.trivialization` which
extended another structure `topological_fiber_bundle.trivialization` by a linearity hypothesis. As
of PR #17359, we have changed this to a single structure `trivialization` (no namespace), together
with a mixin class `trivialization.is_linear`.

This permits all the *data* of a vector bundle to be held at the level of fiber bundles, so that the
same trivializations can underlie an object's structure as (say) a vector bundle over `ℂ` and as a
vector bundle over `ℝ`, as well as its structure simply as a fiber bundle.

This might be a little surprising, given the general trend of the library to ever-increased
bundling.  But in this case the typical motivation for more bundling does not apply: there is no
algebraic or order structure on the whole type of linear (say) trivializations of a bundle.
Indeed, since trivializations only have meaning on their base sets (taking junk values outside), the
type of linear trivializations is not even particularly well-behaved.

-/


open TopologicalSpace Filter Set Bundle

open Topology Classical Bundle

variable {ι : Type _} {B : Type _} {F : Type _} {E : B → Type _}

variable (F) {Z : Type _} [TopologicalSpace B] [TopologicalSpace F] {proj : Z → B}

#print Pretrivialization /-
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- This structure contains the information left for a local trivialization (which is implemented
below as `trivialization F proj`) if the total space has not been given a topology, but we
have a topology on both the fiber and the base space. Through the construction
`topological_fiber_prebundle F proj` it will be possible to promote a
`pretrivialization F proj` to a `trivialization F proj`. -/
@[ext, nolint has_nonempty_instance]
structure Pretrivialization (proj : Z → B) extends LocalEquiv Z (B × F) where
  open_target : IsOpen target
  baseSet : Set B
  open_baseSet : IsOpen base_set
  source_eq : source = proj ⁻¹' base_set
  target_eq : target = base_set ×ˢ univ
  proj_toFun : ∀ p ∈ source, (to_fun p).1 = proj p
#align pretrivialization Pretrivialization
-/

namespace Pretrivialization

instance : CoeFun (Pretrivialization F proj) fun _ => Z → B × F :=
  ⟨fun e => e.toFun⟩

variable {F} (e : Pretrivialization F proj) {x : Z}

/- warning: pretrivialization.coe_coe -> Pretrivialization.coe_coe is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj), Eq.{max (succ u3) (succ (max u1 u2))} (Z -> (Prod.{u1, u2} B F)) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (LocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F)) (fun (_x : LocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F)) => Z -> (Prod.{u1, u2} B F)) (LocalEquiv.hasCoeToFun.{u3, max u1 u2} Z (Prod.{u1, u2} B F)) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (Z -> (Prod.{u3, u2} B F)) (LocalEquiv.toFun.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) (Pretrivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)
Case conversion may be inaccurate. Consider using '#align pretrivialization.coe_coe Pretrivialization.coe_coeₓ'. -/
@[simp, mfld_simps]
theorem coe_coe : ⇑e.toLocalEquiv = e :=
  rfl
#align pretrivialization.coe_coe Pretrivialization.coe_coe

/- warning: pretrivialization.coe_fst -> Pretrivialization.coe_fst is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{succ u1} B (Prod.fst.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e x)) (proj x))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} (e : Pretrivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (Pretrivialization.toLocalEquiv.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{succ u2} B (Prod.fst.{u2, u1} B F (Pretrivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e x)) (proj x))
Case conversion may be inaccurate. Consider using '#align pretrivialization.coe_fst Pretrivialization.coe_fstₓ'. -/
@[simp, mfld_simps]
theorem coe_fst (ex : x ∈ e.source) : (e x).1 = proj x :=
  e.proj_toFun x ex
#align pretrivialization.coe_fst Pretrivialization.coe_fst

/- warning: pretrivialization.mem_source -> Pretrivialization.mem_source is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, Iff (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj x) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} (e : Pretrivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, Iff (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (Pretrivialization.toLocalEquiv.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e))) (Membership.mem.{u2, u2} B (Set.{u2} B) (Set.instMembershipSet.{u2} B) (proj x) (Pretrivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e))
Case conversion may be inaccurate. Consider using '#align pretrivialization.mem_source Pretrivialization.mem_sourceₓ'. -/
theorem mem_source : x ∈ e.source ↔ proj x ∈ e.baseSet := by rw [e.source_eq, mem_preimage]
#align pretrivialization.mem_source Pretrivialization.mem_source

/- warning: pretrivialization.coe_fst' -> Pretrivialization.coe_fst' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj x) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) -> (Eq.{succ u1} B (Prod.fst.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e x)) (proj x))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (proj x) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) -> (Eq.{succ u3} B (Prod.fst.{u3, u2} B F (Pretrivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e x)) (proj x))
Case conversion may be inaccurate. Consider using '#align pretrivialization.coe_fst' Pretrivialization.coe_fst'ₓ'. -/
theorem coe_fst' (ex : proj x ∈ e.baseSet) : (e x).1 = proj x :=
  e.coe_fst (e.mem_source.2 ex)
#align pretrivialization.coe_fst' Pretrivialization.coe_fst'

/- warning: pretrivialization.eq_on -> Pretrivialization.eqOn is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj), Set.EqOn.{u3, u1} Z B (Function.comp.{succ u3, max (succ u1) (succ u2), succ u1} Z (Prod.{u1, u2} B F) B (Prod.fst.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e)) proj (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} (e : Pretrivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 proj), Set.EqOn.{u3, u2} Z B (Function.comp.{succ u3, max (succ u1) (succ u2), succ u2} Z (Prod.{u2, u1} B F) B (Prod.fst.{u2, u1} B F) (Pretrivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e)) proj (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (Pretrivialization.toLocalEquiv.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e))
Case conversion may be inaccurate. Consider using '#align pretrivialization.eq_on Pretrivialization.eqOnₓ'. -/
protected theorem eqOn : EqOn (Prod.fst ∘ e) proj e.source := fun x hx => e.coe_fst hx
#align pretrivialization.eq_on Pretrivialization.eqOn

/- warning: pretrivialization.mk_proj_snd -> Pretrivialization.mk_proj_snd is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (Prod.mk.{u1, u2} B F (proj x) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e x))) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e x))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} (e : Pretrivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (Pretrivialization.toLocalEquiv.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{max (succ u2) (succ u1)} (Prod.{u2, u1} B F) (Prod.mk.{u2, u1} B F (proj x) (Prod.snd.{u2, u1} B F (Pretrivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e x))) (Pretrivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e x))
Case conversion may be inaccurate. Consider using '#align pretrivialization.mk_proj_snd Pretrivialization.mk_proj_sndₓ'. -/
theorem mk_proj_snd (ex : x ∈ e.source) : (proj x, (e x).2) = e x :=
  Prod.ext (e.coe_fst ex).symm rfl
#align pretrivialization.mk_proj_snd Pretrivialization.mk_proj_snd

/- warning: pretrivialization.mk_proj_snd' -> Pretrivialization.mk_proj_snd' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj x) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) -> (Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (Prod.mk.{u1, u2} B F (proj x) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e x))) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e x))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (proj x) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) -> (Eq.{max (succ u3) (succ u2)} (Prod.{u3, u2} B F) (Prod.mk.{u3, u2} B F (proj x) (Prod.snd.{u3, u2} B F (Pretrivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e x))) (Pretrivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e x))
Case conversion may be inaccurate. Consider using '#align pretrivialization.mk_proj_snd' Pretrivialization.mk_proj_snd'ₓ'. -/
theorem mk_proj_snd' (ex : proj x ∈ e.baseSet) : (proj x, (e x).2) = e x :=
  Prod.ext (e.coe_fst' ex).symm rfl
#align pretrivialization.mk_proj_snd' Pretrivialization.mk_proj_snd'

#print Pretrivialization.setSymm /-
/-- Composition of inverse and coercion from the subtype of the target. -/
def setSymm : e.target → Z :=
  e.target.restrict e.toLocalEquiv.symm
#align pretrivialization.set_symm Pretrivialization.setSymm
-/

/- warning: pretrivialization.mem_target -> Pretrivialization.mem_target is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {x : Prod.{u1, u2} B F}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasMem.{max u1 u2} (Prod.{u1, u2} B F)) x (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (Prod.fst.{u1, u2} B F x) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) {x : Prod.{u3, u2} B F}, Iff (Membership.mem.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.instMembershipSet.{max u3 u2} (Prod.{u3, u2} B F)) x (LocalEquiv.target.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))) (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (Prod.fst.{u3, u2} B F x) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))
Case conversion may be inaccurate. Consider using '#align pretrivialization.mem_target Pretrivialization.mem_targetₓ'. -/
theorem mem_target {x : B × F} : x ∈ e.target ↔ x.1 ∈ e.baseSet := by
  rw [e.target_eq, prod_univ, mem_preimage]
#align pretrivialization.mem_target Pretrivialization.mem_target

/- warning: pretrivialization.proj_symm_apply -> Pretrivialization.proj_symm_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {x : Prod.{u1, u2} B F}, (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasMem.{max u1 u2} (Prod.{u1, u2} B F)) x (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{succ u1} B (proj (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (fun (_x : LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) => (Prod.{u1, u2} B F) -> Z) (LocalEquiv.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) x)) (Prod.fst.{u1, u2} B F x))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) {x : Prod.{u3, u2} B F}, (Membership.mem.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.instMembershipSet.{max u3 u2} (Prod.{u3, u2} B F)) x (LocalEquiv.target.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{succ u3} B (proj (LocalEquiv.toFun.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) x)) (Prod.fst.{u3, u2} B F x))
Case conversion may be inaccurate. Consider using '#align pretrivialization.proj_symm_apply Pretrivialization.proj_symm_applyₓ'. -/
theorem proj_symm_apply {x : B × F} (hx : x ∈ e.target) : proj (e.toLocalEquiv.symm x) = x.1 :=
  by
  have := (e.coe_fst (e.to_local_equiv.map_target hx)).symm
  rwa [← e.coe_coe, e.to_local_equiv.right_inv hx] at this
#align pretrivialization.proj_symm_apply Pretrivialization.proj_symm_apply

/- warning: pretrivialization.proj_symm_apply' -> Pretrivialization.proj_symm_apply' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {b : B} {x : F}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) -> (Eq.{succ u1} B (proj (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (fun (_x : LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) => (Prod.{u1, u2} B F) -> Z) (LocalEquiv.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) (Prod.mk.{u1, u2} B F b x))) b)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) {b : B} {x : F}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) -> (Eq.{succ u3} B (proj (LocalEquiv.toFun.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) (Prod.mk.{u3, u2} B F b x))) b)
Case conversion may be inaccurate. Consider using '#align pretrivialization.proj_symm_apply' Pretrivialization.proj_symm_apply'ₓ'. -/
theorem proj_symm_apply' {b : B} {x : F} (hx : b ∈ e.baseSet) :
    proj (e.toLocalEquiv.symm (b, x)) = b :=
  e.proj_symm_apply (e.mem_target.2 hx)
#align pretrivialization.proj_symm_apply' Pretrivialization.proj_symm_apply'

/- warning: pretrivialization.proj_surj_on_base_set -> Pretrivialization.proj_surjOn_baseSet is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) [_inst_3 : Nonempty.{succ u2} F], Set.SurjOn.{u3, u1} Z B proj (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)
but is expected to have type
  forall {B : Type.{u1}} {F : Type.{u3}} {Z : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u3} F] {proj : Z -> B} (e : Pretrivialization.{u1, u3, u2} B F Z _inst_1 _inst_2 proj) [_inst_3 : Nonempty.{succ u3} F], Set.SurjOn.{u2, u1} Z B proj (LocalEquiv.source.{u2, max u1 u3} Z (Prod.{u1, u3} B F) (Pretrivialization.toLocalEquiv.{u1, u3, u2} B F Z _inst_1 _inst_2 proj e)) (Pretrivialization.baseSet.{u1, u3, u2} B F Z _inst_1 _inst_2 proj e)
Case conversion may be inaccurate. Consider using '#align pretrivialization.proj_surj_on_base_set Pretrivialization.proj_surjOn_baseSetₓ'. -/
theorem proj_surjOn_baseSet [Nonempty F] : Set.SurjOn proj e.source e.baseSet := fun b hb =>
  let ⟨y⟩ := ‹Nonempty F›
  ⟨e.toLocalEquiv.symm (b, y), e.toLocalEquiv.map_target <| e.mem_target.2 hb,
    e.proj_symm_apply' hb⟩
#align pretrivialization.proj_surj_on_base_set Pretrivialization.proj_surjOn_baseSet

/- warning: pretrivialization.apply_symm_apply -> Pretrivialization.apply_symm_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {x : Prod.{u1, u2} B F}, (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasMem.{max u1 u2} (Prod.{u1, u2} B F)) x (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (fun (_x : LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) => (Prod.{u1, u2} B F) -> Z) (LocalEquiv.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) x)) x)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) {x : Prod.{u3, u2} B F}, (Membership.mem.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.instMembershipSet.{max u3 u2} (Prod.{u3, u2} B F)) x (LocalEquiv.target.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{max (succ u3) (succ u2)} (Prod.{u3, u2} B F) (Pretrivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e (LocalEquiv.toFun.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) x)) x)
Case conversion may be inaccurate. Consider using '#align pretrivialization.apply_symm_apply Pretrivialization.apply_symm_applyₓ'. -/
theorem apply_symm_apply {x : B × F} (hx : x ∈ e.target) : e (e.toLocalEquiv.symm x) = x :=
  e.toLocalEquiv.right_inv hx
#align pretrivialization.apply_symm_apply Pretrivialization.apply_symm_apply

/- warning: pretrivialization.apply_symm_apply' -> Pretrivialization.apply_symm_apply' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {b : B} {x : F}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) -> (Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (fun (_x : LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) => (Prod.{u1, u2} B F) -> Z) (LocalEquiv.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) (Prod.mk.{u1, u2} B F b x))) (Prod.mk.{u1, u2} B F b x))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) {b : B} {x : F}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) -> (Eq.{max (succ u3) (succ u2)} (Prod.{u3, u2} B F) (Pretrivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e (LocalEquiv.toFun.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) (Prod.mk.{u3, u2} B F b x))) (Prod.mk.{u3, u2} B F b x))
Case conversion may be inaccurate. Consider using '#align pretrivialization.apply_symm_apply' Pretrivialization.apply_symm_apply'ₓ'. -/
theorem apply_symm_apply' {b : B} {x : F} (hx : b ∈ e.baseSet) :
    e (e.toLocalEquiv.symm (b, x)) = (b, x) :=
  e.apply_symm_apply (e.mem_target.2 hx)
#align pretrivialization.apply_symm_apply' Pretrivialization.apply_symm_apply'

/- warning: pretrivialization.symm_apply_apply -> Pretrivialization.symm_apply_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{succ u3} Z (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (fun (_x : LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) => (Prod.{u1, u2} B F) -> Z) (LocalEquiv.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e x)) x)
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} (e : Pretrivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (Pretrivialization.toLocalEquiv.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{succ u3} Z (LocalEquiv.toFun.{max u2 u1, u3} (Prod.{u2, u1} B F) Z (LocalEquiv.symm.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (Pretrivialization.toLocalEquiv.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e)) (Pretrivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e x)) x)
Case conversion may be inaccurate. Consider using '#align pretrivialization.symm_apply_apply Pretrivialization.symm_apply_applyₓ'. -/
theorem symm_apply_apply {x : Z} (hx : x ∈ e.source) : e.toLocalEquiv.symm (e x) = x :=
  e.toLocalEquiv.left_inv hx
#align pretrivialization.symm_apply_apply Pretrivialization.symm_apply_apply

/- warning: pretrivialization.symm_apply_mk_proj -> Pretrivialization.symm_apply_mk_proj is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{succ u3} Z (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (fun (_x : LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) => (Prod.{u1, u2} B F) -> Z) (LocalEquiv.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) (Prod.mk.{u1, u2} B F (proj x) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (_x : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) => Z -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) e x)))) x)
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} (e : Pretrivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 proj) {x : Z}, (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (Pretrivialization.toLocalEquiv.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e))) -> (Eq.{succ u3} Z (LocalEquiv.toFun.{max u2 u1, u3} (Prod.{u2, u1} B F) Z (LocalEquiv.symm.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (Pretrivialization.toLocalEquiv.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e)) (Prod.mk.{u2, u1} B F (proj x) (Prod.snd.{u2, u1} B F (Pretrivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj e x)))) x)
Case conversion may be inaccurate. Consider using '#align pretrivialization.symm_apply_mk_proj Pretrivialization.symm_apply_mk_projₓ'. -/
@[simp, mfld_simps]
theorem symm_apply_mk_proj {x : Z} (ex : x ∈ e.source) :
    e.toLocalEquiv.symm (proj x, (e x).2) = x := by
  rw [← e.coe_fst ex, Prod.mk.eta, ← e.coe_coe, e.to_local_equiv.left_inv ex]
#align pretrivialization.symm_apply_mk_proj Pretrivialization.symm_apply_mk_proj

/- warning: pretrivialization.preimage_symm_proj_base_set -> Pretrivialization.preimage_symm_proj_baseSet is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Inter.inter.{max u1 u2} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasInter.{max u1 u2} (Prod.{u1, u2} B F)) (Set.preimage.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (fun (_x : LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) => (Prod.{u1, u2} B F) -> Z) (LocalEquiv.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) (Set.preimage.{u3, u1} Z B proj (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Inter.inter.{max u3 u2} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.instInterSet.{max u3 u2} (Prod.{u3, u2} B F)) (Set.preimage.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.toFun.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))) (Set.preimage.{u1, u3} Z B proj (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))) (LocalEquiv.target.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))) (LocalEquiv.target.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))
Case conversion may be inaccurate. Consider using '#align pretrivialization.preimage_symm_proj_base_set Pretrivialization.preimage_symm_proj_baseSetₓ'. -/
@[simp, mfld_simps]
theorem preimage_symm_proj_baseSet :
    e.toLocalEquiv.symm ⁻¹' (proj ⁻¹' e.baseSet) ∩ e.target = e.target :=
  by
  refine' inter_eq_right_iff_subset.mpr fun x hx => _
  simp only [mem_preimage, LocalEquiv.invFun_as_coe, e.proj_symm_apply hx]
  exact e.mem_target.mp hx
#align pretrivialization.preimage_symm_proj_base_set Pretrivialization.preimage_symm_proj_baseSet

/- warning: pretrivialization.preimage_symm_proj_inter -> Pretrivialization.preimage_symm_proj_inter is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (s : Set.{u1} B), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Inter.inter.{max u1 u2} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasInter.{max u1 u2} (Prod.{u1, u2} B F)) (Set.preimage.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (fun (_x : LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) => (Prod.{u1, u2} B F) -> Z) (LocalEquiv.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) (Set.preimage.{u3, u1} Z B proj s)) (Set.prod.{u1, u2} B F (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e) (Set.univ.{u2} F))) (Set.prod.{u1, u2} B F (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) s (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) (Set.univ.{u2} F))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) (s : Set.{u3} B), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Inter.inter.{max u3 u2} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.instInterSet.{max u3 u2} (Prod.{u3, u2} B F)) (Set.preimage.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.toFun.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))) (Set.preimage.{u1, u3} Z B proj s)) (Set.prod.{u3, u2} B F (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e) (Set.univ.{u2} F))) (Set.prod.{u3, u2} B F (Inter.inter.{u3} (Set.{u3} B) (Set.instInterSet.{u3} B) s (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) (Set.univ.{u2} F))
Case conversion may be inaccurate. Consider using '#align pretrivialization.preimage_symm_proj_inter Pretrivialization.preimage_symm_proj_interₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp, mfld_simps]
theorem preimage_symm_proj_inter (s : Set B) :
    e.toLocalEquiv.symm ⁻¹' (proj ⁻¹' s) ∩ e.baseSet ×ˢ univ = (s ∩ e.baseSet) ×ˢ univ :=
  by
  ext ⟨x, y⟩
  suffices x ∈ e.base_set → (proj (e.to_local_equiv.symm (x, y)) ∈ s ↔ x ∈ s) by
    simpa only [prod_mk_mem_set_prod_eq, mem_inter_iff, and_true_iff, mem_univ, and_congr_left_iff]
  intro h
  rw [e.proj_symm_apply' h]
#align pretrivialization.preimage_symm_proj_inter Pretrivialization.preimage_symm_proj_inter

/- warning: pretrivialization.target_inter_preimage_symm_source_eq -> Pretrivialization.target_inter_preimage_symm_source_eq is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (f : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Inter.inter.{max u1 u2} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasInter.{max u1 u2} (Prod.{u1, u2} B F)) (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj f)) (Set.preimage.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (fun (_x : LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) => (Prod.{u1, u2} B F) -> Z) (LocalEquiv.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj f))) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)))) (Set.prod.{u1, u2} B F (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj f)) (Set.univ.{u2} F))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) (f : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Inter.inter.{max u3 u2} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.instInterSet.{max u3 u2} (Prod.{u3, u2} B F)) (LocalEquiv.target.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj f)) (Set.preimage.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.toFun.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj f))) (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)))) (Set.prod.{u3, u2} B F (Inter.inter.{u3} (Set.{u3} B) (Set.instInterSet.{u3} B) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj f)) (Set.univ.{u2} F))
Case conversion may be inaccurate. Consider using '#align pretrivialization.target_inter_preimage_symm_source_eq Pretrivialization.target_inter_preimage_symm_source_eqₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem target_inter_preimage_symm_source_eq (e f : Pretrivialization F proj) :
    f.target ∩ f.toLocalEquiv.symm ⁻¹' e.source = (e.baseSet ∩ f.baseSet) ×ˢ univ := by
  rw [inter_comm, f.target_eq, e.source_eq, f.preimage_symm_proj_inter]
#align pretrivialization.target_inter_preimage_symm_source_eq Pretrivialization.target_inter_preimage_symm_source_eq

/- warning: pretrivialization.trans_source -> Pretrivialization.trans_source is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (f : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (LocalEquiv.source.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Prod.{u1, u2} B F) (LocalEquiv.trans.{max u1 u2, u3, max u1 u2} (Prod.{u1, u2} B F) Z (Prod.{u1, u2} B F) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj f)) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))) (Set.prod.{u1, u2} B F (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj f)) (Set.univ.{u2} F))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) (f : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (LocalEquiv.source.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Prod.{u3, u2} B F) (LocalEquiv.trans.{max u3 u2, u1, max u3 u2} (Prod.{u3, u2} B F) Z (Prod.{u3, u2} B F) (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj f)) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))) (Set.prod.{u3, u2} B F (Inter.inter.{u3} (Set.{u3} B) (Set.instInterSet.{u3} B) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj f)) (Set.univ.{u2} F))
Case conversion may be inaccurate. Consider using '#align pretrivialization.trans_source Pretrivialization.trans_sourceₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem trans_source (e f : Pretrivialization F proj) :
    (f.toLocalEquiv.symm.trans e.toLocalEquiv).source = (e.baseSet ∩ f.baseSet) ×ˢ univ := by
  rw [LocalEquiv.trans_source, LocalEquiv.symm_source, e.target_inter_preimage_symm_source_eq]
#align pretrivialization.trans_source Pretrivialization.trans_source

/- warning: pretrivialization.symm_trans_symm -> Pretrivialization.symm_trans_symm is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (e' : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj), Eq.{succ (max u1 u2)} (LocalEquiv.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Prod.{u1, u2} B F)) (LocalEquiv.symm.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Prod.{u1, u2} B F) (LocalEquiv.trans.{max u1 u2, u3, max u1 u2} (Prod.{u1, u2} B F) Z (Prod.{u1, u2} B F) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e'))) (LocalEquiv.trans.{max u1 u2, u3, max u1 u2} (Prod.{u1, u2} B F) Z (Prod.{u1, u2} B F) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e')) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) (e' : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj), Eq.{max (succ u3) (succ u2)} (LocalEquiv.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Prod.{u3, u2} B F)) (LocalEquiv.symm.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Prod.{u3, u2} B F) (LocalEquiv.trans.{max u3 u2, u1, max u3 u2} (Prod.{u3, u2} B F) Z (Prod.{u3, u2} B F) (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e'))) (LocalEquiv.trans.{max u3 u2, u1, max u3 u2} (Prod.{u3, u2} B F) Z (Prod.{u3, u2} B F) (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e')) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e))
Case conversion may be inaccurate. Consider using '#align pretrivialization.symm_trans_symm Pretrivialization.symm_trans_symmₓ'. -/
theorem symm_trans_symm (e e' : Pretrivialization F proj) :
    (e.toLocalEquiv.symm.trans e'.toLocalEquiv).symm = e'.toLocalEquiv.symm.trans e.toLocalEquiv :=
  by rw [LocalEquiv.trans_symm_eq_symm_trans_symm, LocalEquiv.symm_symm]
#align pretrivialization.symm_trans_symm Pretrivialization.symm_trans_symm

/- warning: pretrivialization.symm_trans_source_eq -> Pretrivialization.symm_trans_source_eq is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (e' : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (LocalEquiv.source.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Prod.{u1, u2} B F) (LocalEquiv.trans.{max u1 u2, u3, max u1 u2} (Prod.{u1, u2} B F) Z (Prod.{u1, u2} B F) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e'))) (Set.prod.{u1, u2} B F (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e')) (Set.univ.{u2} F))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) (e' : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (LocalEquiv.source.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Prod.{u3, u2} B F) (LocalEquiv.trans.{max u3 u2, u1, max u3 u2} (Prod.{u3, u2} B F) Z (Prod.{u3, u2} B F) (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e'))) (Set.prod.{u3, u2} B F (Inter.inter.{u3} (Set.{u3} B) (Set.instInterSet.{u3} B) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e')) (Set.univ.{u2} F))
Case conversion may be inaccurate. Consider using '#align pretrivialization.symm_trans_source_eq Pretrivialization.symm_trans_source_eqₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem symm_trans_source_eq (e e' : Pretrivialization F proj) :
    (e.toLocalEquiv.symm.trans e'.toLocalEquiv).source = (e.baseSet ∩ e'.baseSet) ×ˢ univ := by
  rw [LocalEquiv.trans_source, e'.source_eq, LocalEquiv.symm_source, e.target_eq, inter_comm,
    e.preimage_symm_proj_inter, inter_comm]
#align pretrivialization.symm_trans_source_eq Pretrivialization.symm_trans_source_eq

/- warning: pretrivialization.symm_trans_target_eq -> Pretrivialization.symm_trans_target_eq is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (e' : Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (LocalEquiv.target.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Prod.{u1, u2} B F) (LocalEquiv.trans.{max u1 u2, u3, max u1 u2} (Prod.{u1, u2} B F) Z (Prod.{u1, u2} B F) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e)) (Pretrivialization.toLocalEquiv.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e'))) (Set.prod.{u1, u2} B F (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e) (Pretrivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 proj e')) (Set.univ.{u2} F))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} (e : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) (e' : Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (LocalEquiv.target.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Prod.{u3, u2} B F) (LocalEquiv.trans.{max u3 u2, u1, max u3 u2} (Prod.{u3, u2} B F) Z (Prod.{u3, u2} B F) (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e)) (Pretrivialization.toLocalEquiv.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e'))) (Set.prod.{u3, u2} B F (Inter.inter.{u3} (Set.{u3} B) (Set.instInterSet.{u3} B) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e) (Pretrivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 proj e')) (Set.univ.{u2} F))
Case conversion may be inaccurate. Consider using '#align pretrivialization.symm_trans_target_eq Pretrivialization.symm_trans_target_eqₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem symm_trans_target_eq (e e' : Pretrivialization F proj) :
    (e.toLocalEquiv.symm.trans e'.toLocalEquiv).target = (e.baseSet ∩ e'.baseSet) ×ˢ univ := by
  rw [← LocalEquiv.symm_source, symm_trans_symm, symm_trans_source_eq, inter_comm]
#align pretrivialization.symm_trans_target_eq Pretrivialization.symm_trans_target_eq

variable {B F} (e' : Pretrivialization F (π E)) {x' : TotalSpace E} {b : B} {y : E b}

/- warning: pretrivialization.coe_mem_source -> Pretrivialization.coe_mem_source is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] (e' : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B} {y : E b}, Iff (Membership.Mem.{max u1 u3, max u1 u3} (Bundle.TotalSpace.{u1, u3} B E) (Set.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)) (Set.hasMem.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)) ((fun (a : Type.{u3}) (b : Type.{max u1 u3}) [self : HasLiftT.{succ u3, succ (max u1 u3)} a b] => self.0) (E b) (Bundle.TotalSpace.{u1, u3} B E) (HasLiftT.mk.{succ u3, succ (max u1 u3)} (E b) (Bundle.TotalSpace.{u1, u3} B E) (CoeTCₓ.coe.{succ u3, succ (max u1 u3)} (E b) (Bundle.TotalSpace.{u1, u3} B E) (Bundle.TotalSpace.hasCoeT.{u1, u3} B E b))) y) (LocalEquiv.source.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e'))) (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e'))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u1}} {E : B -> Type.{u2}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u1} F] (e' : Pretrivialization.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u2} B E)) {b : B} {y : E b}, Iff (Membership.mem.{max u3 u2, max u3 u2} (Bundle.TotalSpace.{u3, u2} B E) (Set.{max u3 u2} (Bundle.TotalSpace.{u3, u2} B E)) (Set.instMembershipSet.{max u3 u2} (Bundle.TotalSpace.{u3, u2} B E)) (Bundle.totalSpaceMk.{u3, u2} B E b y) (LocalEquiv.source.{max u3 u2, max u3 u1} (Bundle.TotalSpace.{u3, u2} B E) (Prod.{u3, u1} B F) (Pretrivialization.toLocalEquiv.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u2} B E) e'))) (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Pretrivialization.baseSet.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u2} B E) e'))
Case conversion may be inaccurate. Consider using '#align pretrivialization.coe_mem_source Pretrivialization.coe_mem_sourceₓ'. -/
theorem coe_mem_source : ↑y ∈ e'.source ↔ b ∈ e'.baseSet :=
  e'.mem_source
#align pretrivialization.coe_mem_source Pretrivialization.coe_mem_source

/- warning: pretrivialization.coe_coe_fst -> Pretrivialization.coe_coe_fst is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] (e' : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B} {y : E b}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e')) -> (Eq.{succ u1} B (Prod.fst.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) (fun (_x : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) => (Bundle.TotalSpace.{u1, u3} B E) -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) e' ((fun (a : Type.{u3}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{succ u3, max (succ u1) (succ u3)} a b] => self.0) (E b) (Bundle.TotalSpace.{u1, u3} B E) (HasLiftT.mk.{succ u3, max (succ u1) (succ u3)} (E b) (Bundle.TotalSpace.{u1, u3} B E) (CoeTCₓ.coe.{succ u3, max (succ u1) (succ u3)} (E b) (Bundle.TotalSpace.{u1, u3} B E) (Bundle.TotalSpace.hasCoeT.{u1, u3} B E b))) y))) b)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] (e' : Pretrivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B} {y : E b}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Pretrivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e')) -> (Eq.{succ u3} B (Prod.fst.{u3, u2} B F (Pretrivialization.toFun'.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e' (Bundle.totalSpaceMk.{u3, u1} B E b y))) b)
Case conversion may be inaccurate. Consider using '#align pretrivialization.coe_coe_fst Pretrivialization.coe_coe_fstₓ'. -/
@[simp, mfld_simps]
theorem coe_coe_fst (hb : b ∈ e'.baseSet) : (e' y).1 = b :=
  e'.coe_fst (e'.mem_source.2 hb)
#align pretrivialization.coe_coe_fst Pretrivialization.coe_coe_fst

/- warning: pretrivialization.mk_mem_target -> Pretrivialization.mk_mem_target is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] (e' : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) {x : B} {y : F}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasMem.{max u1 u2} (Prod.{u1, u2} B F)) (Prod.mk.{u1, u2} B F x y) (LocalEquiv.target.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e'))) (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e'))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u3}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u3} F] (e' : Pretrivialization.{u2, u3, max u2 u1} B F (Bundle.TotalSpace.{u2, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u2, u1} B E)) {x : B} {y : F}, Iff (Membership.mem.{max u3 u2, max u2 u3} (Prod.{u2, u3} B F) (Set.{max u2 u3} (Prod.{u2, u3} B F)) (Set.instMembershipSet.{max u2 u3} (Prod.{u2, u3} B F)) (Prod.mk.{u2, u3} B F x y) (LocalEquiv.target.{max u2 u1, max u2 u3} (Bundle.TotalSpace.{u2, u1} B E) (Prod.{u2, u3} B F) (Pretrivialization.toLocalEquiv.{u2, u3, max u2 u1} B F (Bundle.TotalSpace.{u2, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u2, u1} B E) e'))) (Membership.mem.{u2, u2} B (Set.{u2} B) (Set.instMembershipSet.{u2} B) x (Pretrivialization.baseSet.{u2, u3, max u2 u1} B F (Bundle.TotalSpace.{u2, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u2, u1} B E) e'))
Case conversion may be inaccurate. Consider using '#align pretrivialization.mk_mem_target Pretrivialization.mk_mem_targetₓ'. -/
theorem mk_mem_target {x : B} {y : F} : (x, y) ∈ e'.target ↔ x ∈ e'.baseSet :=
  e'.mem_target
#align pretrivialization.mk_mem_target Pretrivialization.mk_mem_target

/- warning: pretrivialization.symm_coe_proj -> Pretrivialization.symm_coe_proj is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {x : B} {y : F} (e' : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)), (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e')) -> (Eq.{succ u1} B (Sigma.fst.{u1, u3} B (fun (x : B) => E x) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalEquiv.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) (fun (_x : LocalEquiv.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalEquiv.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) (LocalEquiv.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e')) (Prod.mk.{u1, u2} B F x y))) x)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {x : B} {y : F} (e' : Pretrivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E)), (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Pretrivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e')) -> (Eq.{succ u3} B (Sigma.fst.{u3, u1} B (fun (x : B) => E x) (LocalEquiv.toFun.{max u3 u2, max u3 u1} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (LocalEquiv.symm.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e')) (Prod.mk.{u3, u2} B F x y))) x)
Case conversion may be inaccurate. Consider using '#align pretrivialization.symm_coe_proj Pretrivialization.symm_coe_projₓ'. -/
theorem symm_coe_proj {x : B} {y : F} (e' : Pretrivialization F (π E)) (h : x ∈ e'.baseSet) :
    (e'.toLocalEquiv.symm (x, y)).1 = x :=
  e'.proj_symm_apply' h
#align pretrivialization.symm_coe_proj Pretrivialization.symm_coe_proj

section Zero

variable [∀ x, Zero (E x)]

#print Pretrivialization.symm /-
/-- A fiberwise inverse to `e`. This is the function `F → E b` that induces a local inverse
`B × F → total_space E` of `e` on `e.base_set`. It is defined to be `0` outside `e.base_set`. -/
protected noncomputable def symm (e : Pretrivialization F (π E)) (b : B) (y : F) : E b :=
  if hb : b ∈ e.baseSet then
    cast (congr_arg E (e.proj_symm_apply' hb)) (e.toLocalEquiv.symm (b, y)).2
  else 0
#align pretrivialization.symm Pretrivialization.symm
-/

/- warning: pretrivialization.symm_apply -> Pretrivialization.symm_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u3} (E x)] (e : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B} (hb : Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (y : F), Eq.{succ u3} (E b) (Pretrivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b y) (cast.{succ u3} (E (Sigma.fst.{u1, u3} B (fun (x : B) => E x) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalEquiv.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) (fun (_x : LocalEquiv.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalEquiv.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) (LocalEquiv.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (Prod.mk.{u1, u2} B F b y)))) (E b) (congr_arg.{succ u1, succ (succ u3)} B Type.{u3} (Sigma.fst.{u1, u3} B (fun (x : B) => E x) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalEquiv.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) (fun (_x : LocalEquiv.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalEquiv.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) (LocalEquiv.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (Prod.mk.{u1, u2} B F b y))) b E (Pretrivialization.symm_coe_proj.{u1, u2, u3} B F E _inst_1 _inst_2 b y e hb)) (Sigma.snd.{u1, u3} B (fun (x : B) => E x) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalEquiv.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) (fun (_x : LocalEquiv.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalEquiv.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) (LocalEquiv.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (Prod.mk.{u1, u2} B F b y))))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u1} (E x)] (e : Pretrivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B} (hb : Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Pretrivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (y : F), Eq.{succ u1} (E b) (Pretrivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b y) (cast.{succ u1} (E (Sigma.fst.{u3, u1} B (fun (x : B) => E x) (LocalEquiv.toFun.{max u3 u2, max u3 u1} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (LocalEquiv.symm.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (Prod.mk.{u3, u2} B F b y)))) (E b) (congr_arg.{succ u3, succ (succ u1)} B Type.{u1} (Sigma.fst.{u3, u1} B (fun (x : B) => E x) (LocalEquiv.toFun.{max u3 u2, max u3 u1} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (LocalEquiv.symm.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (Prod.mk.{u3, u2} B F b y))) b E (Pretrivialization.symm_coe_proj.{u1, u2, u3} B F E _inst_1 _inst_2 b y e hb)) (Sigma.snd.{u3, u1} B (fun (x : B) => E x) (LocalEquiv.toFun.{max u3 u2, max u3 u1} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (LocalEquiv.symm.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (Prod.mk.{u3, u2} B F b y))))
Case conversion may be inaccurate. Consider using '#align pretrivialization.symm_apply Pretrivialization.symm_applyₓ'. -/
theorem symm_apply (e : Pretrivialization F (π E)) {b : B} (hb : b ∈ e.baseSet) (y : F) :
    e.symm b y = cast (congr_arg E (e.symm_coe_proj hb)) (e.toLocalEquiv.symm (b, y)).2 :=
  dif_pos hb
#align pretrivialization.symm_apply Pretrivialization.symm_apply

/- warning: pretrivialization.symm_apply_of_not_mem -> Pretrivialization.symm_apply_of_not_mem is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u3} (E x)] (e : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B}, (Not (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e))) -> (forall (y : F), Eq.{succ u3} (E b) (Pretrivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b y) (OfNat.ofNat.{u3} (E b) 0 (OfNat.mk.{u3} (E b) 0 (Zero.zero.{u3} (E b) (_inst_3 b)))))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u1} (E x)] (e : Pretrivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B}, (Not (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Pretrivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e))) -> (forall (y : F), Eq.{succ u1} (E b) (Pretrivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b y) (OfNat.ofNat.{u1} (E b) 0 (Zero.toOfNat0.{u1} (E b) (_inst_3 b))))
Case conversion may be inaccurate. Consider using '#align pretrivialization.symm_apply_of_not_mem Pretrivialization.symm_apply_of_not_memₓ'. -/
theorem symm_apply_of_not_mem (e : Pretrivialization F (π E)) {b : B} (hb : b ∉ e.baseSet) (y : F) :
    e.symm b y = 0 :=
  dif_neg hb
#align pretrivialization.symm_apply_of_not_mem Pretrivialization.symm_apply_of_not_mem

/- warning: pretrivialization.coe_symm_of_not_mem -> Pretrivialization.coe_symm_of_not_mem is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u3} (E x)] (e : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B}, (Not (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e))) -> (Eq.{max (succ u2) (succ u3)} (F -> (E b)) (Pretrivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b) (OfNat.ofNat.{max u2 u3} (F -> (E b)) 0 (OfNat.mk.{max u2 u3} (F -> (E b)) 0 (Zero.zero.{max u2 u3} (F -> (E b)) (Pi.instZero.{u2, u3} F (fun (y : F) => E b) (fun (i : F) => _inst_3 b))))))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u1} (E x)] (e : Pretrivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B}, (Not (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Pretrivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e))) -> (Eq.{max (succ u2) (succ u1)} (F -> (E b)) (Pretrivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b) (OfNat.ofNat.{max u2 u1} (F -> (E b)) 0 (Zero.toOfNat0.{max u2 u1} (F -> (E b)) (Pi.instZero.{u2, u1} F (fun (y : F) => E b) (fun (i : F) => _inst_3 b)))))
Case conversion may be inaccurate. Consider using '#align pretrivialization.coe_symm_of_not_mem Pretrivialization.coe_symm_of_not_memₓ'. -/
theorem coe_symm_of_not_mem (e : Pretrivialization F (π E)) {b : B} (hb : b ∉ e.baseSet) :
    (e.symm b : F → E b) = 0 :=
  funext fun y => dif_neg hb
#align pretrivialization.coe_symm_of_not_mem Pretrivialization.coe_symm_of_not_mem

/- warning: pretrivialization.mk_symm -> Pretrivialization.mk_symm is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u3} (E x)] (e : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) -> (forall (y : F), Eq.{max (succ u1) (succ u3)} (Bundle.TotalSpace.{u1, u3} B E) (Bundle.totalSpaceMk.{u1, u3} B E b (Pretrivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b y)) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalEquiv.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) (fun (_x : LocalEquiv.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalEquiv.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E)) (LocalEquiv.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (Pretrivialization.toLocalEquiv.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (Prod.mk.{u1, u2} B F b y)))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u1} (E x)] (e : Pretrivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Pretrivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) -> (forall (y : F), Eq.{max (succ u3) (succ u1)} (Bundle.TotalSpace.{u3, u1} B E) (Bundle.totalSpaceMk.{u3, u1} B E b (Pretrivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b y)) (LocalEquiv.toFun.{max u3 u2, max u3 u1} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (LocalEquiv.symm.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) (Pretrivialization.toLocalEquiv.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (Prod.mk.{u3, u2} B F b y)))
Case conversion may be inaccurate. Consider using '#align pretrivialization.mk_symm Pretrivialization.mk_symmₓ'. -/
theorem mk_symm (e : Pretrivialization F (π E)) {b : B} (hb : b ∈ e.baseSet) (y : F) :
    totalSpaceMk b (e.symm b y) = e.toLocalEquiv.symm (b, y) := by
  rw [e.symm_apply hb, total_space.mk_cast, total_space.eta]
#align pretrivialization.mk_symm Pretrivialization.mk_symm

/- warning: pretrivialization.symm_proj_apply -> Pretrivialization.symm_proj_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u3} (E x)] (e : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) (z : Bundle.TotalSpace.{u1, u3} B E), (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (Bundle.TotalSpace.proj.{u1, u3} B E z) (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) -> (Eq.{succ u3} (E (Bundle.TotalSpace.proj.{u1, u3} B E z)) (Pretrivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e (Bundle.TotalSpace.proj.{u1, u3} B E z) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) (fun (_x : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) => (Bundle.TotalSpace.{u1, u3} B E) -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) e z))) (Sigma.snd.{u1, u3} B (fun (x : B) => E x) z))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u1} (E x)] (e : Pretrivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E)) (z : Bundle.TotalSpace.{u3, u1} B E), (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (Bundle.TotalSpace.proj.{u3, u1} B E z) (Pretrivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) -> (Eq.{succ u1} (E (Bundle.TotalSpace.proj.{u3, u1} B E z)) (Pretrivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e (Bundle.TotalSpace.proj.{u3, u1} B E z) (Prod.snd.{u3, u2} B F (Pretrivialization.toFun'.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e z))) (Sigma.snd.{u3, u1} B (fun (x : B) => E x) z))
Case conversion may be inaccurate. Consider using '#align pretrivialization.symm_proj_apply Pretrivialization.symm_proj_applyₓ'. -/
theorem symm_proj_apply (e : Pretrivialization F (π E)) (z : TotalSpace E)
    (hz : z.proj ∈ e.baseSet) : e.symm z.proj (e z).2 = z.2 := by
  rw [e.symm_apply hz, cast_eq_iff_heq, e.mk_proj_snd' hz, e.symm_apply_apply (e.mem_source.mpr hz)]
#align pretrivialization.symm_proj_apply Pretrivialization.symm_proj_apply

/- warning: pretrivialization.symm_apply_apply_mk -> Pretrivialization.symm_apply_apply_mk is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u3} (E x)] (e : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) -> (forall (y : E b), Eq.{succ u3} (E b) (Pretrivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) (fun (_x : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) => (Bundle.TotalSpace.{u1, u3} B E) -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) e (Bundle.totalSpaceMk.{u1, u3} B E b y)))) y)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u1} (E x)] (e : Pretrivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Pretrivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) -> (forall (y : E b), Eq.{succ u1} (E b) (Pretrivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b (Prod.snd.{u3, u2} B F (Pretrivialization.toFun'.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e (Bundle.totalSpaceMk.{u3, u1} B E b y)))) y)
Case conversion may be inaccurate. Consider using '#align pretrivialization.symm_apply_apply_mk Pretrivialization.symm_apply_apply_mkₓ'. -/
theorem symm_apply_apply_mk (e : Pretrivialization F (π E)) {b : B} (hb : b ∈ e.baseSet) (y : E b) :
    e.symm b (e (totalSpaceMk b y)).2 = y :=
  e.symm_proj_apply (totalSpaceMk b y) hb
#align pretrivialization.symm_apply_apply_mk Pretrivialization.symm_apply_apply_mk

/- warning: pretrivialization.apply_mk_symm -> Pretrivialization.apply_mk_symm is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u3} (E x)] (e : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Pretrivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) -> (forall (y : F), Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u1) (succ u2)} (Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) (fun (_x : Pretrivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) => (Bundle.TotalSpace.{u1, u3} B E) -> (Prod.{u1, u2} B F)) (Pretrivialization.hasCoeToFun.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E)) e (Bundle.totalSpaceMk.{u1, u3} B E b (Pretrivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b y))) (Prod.mk.{u1, u2} B F b y))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_3 : forall (x : B), Zero.{u1} (E x)] (e : Pretrivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Pretrivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) -> (forall (y : F), Eq.{max (succ u3) (succ u2)} (Prod.{u3, u2} B F) (Pretrivialization.toFun'.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) e (Bundle.totalSpaceMk.{u3, u1} B E b (Pretrivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 (fun (x : B) => _inst_3 x) e b y))) (Prod.mk.{u3, u2} B F b y))
Case conversion may be inaccurate. Consider using '#align pretrivialization.apply_mk_symm Pretrivialization.apply_mk_symmₓ'. -/
theorem apply_mk_symm (e : Pretrivialization F (π E)) {b : B} (hb : b ∈ e.baseSet) (y : F) :
    e (totalSpaceMk b (e.symm b y)) = (b, y) := by
  rw [e.mk_symm hb, e.apply_symm_apply (e.mk_mem_target.mpr hb)]
#align pretrivialization.apply_mk_symm Pretrivialization.apply_mk_symm

end Zero

end Pretrivialization

variable [TopologicalSpace Z] [TopologicalSpace (TotalSpace E)]

#print Trivialization /-
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- A structure extending local homeomorphisms, defining a local trivialization of a projection
`proj : Z → B` with fiber `F`, as a local homeomorphism between `Z` and `B × F` defined between two
sets of the form `proj ⁻¹' base_set` and `base_set × F`, acting trivially on the first coordinate.
-/
@[ext, nolint has_nonempty_instance]
structure Trivialization (proj : Z → B) extends LocalHomeomorph Z (B × F) where
  baseSet : Set B
  open_baseSet : IsOpen base_set
  source_eq : source = proj ⁻¹' base_set
  target_eq : target = base_set ×ˢ univ
  proj_toFun : ∀ p ∈ source, (to_local_homeomorph p).1 = proj p
#align trivialization Trivialization
-/

namespace Trivialization

variable {F} (e : Trivialization F proj) {x : Z}

#print Trivialization.toPretrivialization /-
/-- Natural identification as a `pretrivialization`. -/
def toPretrivialization : Pretrivialization F proj :=
  { e with }
#align trivialization.to_pretrivialization Trivialization.toPretrivialization
-/

instance : CoeFun (Trivialization F proj) fun _ => Z → B × F :=
  ⟨fun e => e.toFun⟩

instance : Coe (Trivialization F proj) (Pretrivialization F proj) :=
  ⟨toPretrivialization⟩

/- warning: trivialization.to_pretrivialization_injective -> Trivialization.toPretrivialization_injective is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z], Function.Injective.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u2) (succ u3)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (Pretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj) (fun (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Trivialization.toPretrivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z], Function.Injective.{max (max (succ u3) (succ u2)) (succ u1), max (max (succ u3) (succ u2)) (succ u1)} (Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (Pretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj) (fun (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) => Trivialization.toPretrivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e)
Case conversion may be inaccurate. Consider using '#align trivialization.to_pretrivialization_injective Trivialization.toPretrivialization_injectiveₓ'. -/
theorem toPretrivialization_injective :
    Function.Injective fun e : Trivialization F proj => e.toPretrivialization :=
  by
  intro e e'
  rw [Pretrivialization.ext_iff, Trivialization.ext_iff, ←
    local_homeomorph.to_local_equiv_injective.eq_iff]
  exact id
#align trivialization.to_pretrivialization_injective Trivialization.toPretrivialization_injective

/- warning: trivialization.coe_coe -> Trivialization.coe_coe is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj), Eq.{max (succ u3) (succ (max u1 u2))} (Z -> (Prod.{u1, u2} B F)) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (LocalHomeomorph.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2)) (fun (_x : LocalHomeomorph.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2)) => Z -> (Prod.{u1, u2} B F)) (LocalHomeomorph.hasCoeToFun.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2)) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (Z -> (Prod.{u3, u2} B F)) (LocalHomeomorph.toFun'.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e)
Case conversion may be inaccurate. Consider using '#align trivialization.coe_coe Trivialization.coe_coeₓ'. -/
@[simp, mfld_simps]
theorem coe_coe : ⇑e.toLocalHomeomorph = e :=
  rfl
#align trivialization.coe_coe Trivialization.coe_coe

/- warning: trivialization.coe_fst -> Trivialization.coe_fst is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{succ u1} B (Prod.fst.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e x)) (proj x))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{succ u2} B (Prod.fst.{u2, u1} B F (Trivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj _inst_3 e x)) (proj x))
Case conversion may be inaccurate. Consider using '#align trivialization.coe_fst Trivialization.coe_fstₓ'. -/
@[simp, mfld_simps]
theorem coe_fst (ex : x ∈ e.source) : (e x).1 = proj x :=
  e.proj_toFun x ex
#align trivialization.coe_fst Trivialization.coe_fst

/- warning: trivialization.eq_on -> Trivialization.eqOn is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj), Set.EqOn.{u3, u1} Z B (Function.comp.{succ u3, max (succ u1) (succ u2), succ u1} Z (Prod.{u1, u2} B F) B (Prod.fst.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e)) proj (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj), Set.EqOn.{u3, u2} Z B (Function.comp.{succ u3, max (succ u1) (succ u2), succ u2} Z (Prod.{u2, u1} B F) B (Prod.fst.{u2, u1} B F) (Trivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj _inst_3 e)) proj (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))
Case conversion may be inaccurate. Consider using '#align trivialization.eq_on Trivialization.eqOnₓ'. -/
protected theorem eqOn : EqOn (Prod.fst ∘ e) proj e.source := fun x hx => e.coe_fst hx
#align trivialization.eq_on Trivialization.eqOn

/- warning: trivialization.mem_source -> Trivialization.mem_source is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, Iff (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj x) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, Iff (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Membership.mem.{u2, u2} B (Set.{u2} B) (Set.instMembershipSet.{u2} B) (proj x) (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))
Case conversion may be inaccurate. Consider using '#align trivialization.mem_source Trivialization.mem_sourceₓ'. -/
theorem mem_source : x ∈ e.source ↔ proj x ∈ e.baseSet := by rw [e.source_eq, mem_preimage]
#align trivialization.mem_source Trivialization.mem_source

/- warning: trivialization.coe_fst' -> Trivialization.coe_fst' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj x) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{succ u1} B (Prod.fst.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e x)) (proj x))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (proj x) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{succ u3} B (Prod.fst.{u3, u2} B F (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e x)) (proj x))
Case conversion may be inaccurate. Consider using '#align trivialization.coe_fst' Trivialization.coe_fst'ₓ'. -/
theorem coe_fst' (ex : proj x ∈ e.baseSet) : (e x).1 = proj x :=
  e.coe_fst (e.mem_source.2 ex)
#align trivialization.coe_fst' Trivialization.coe_fst'

/- warning: trivialization.mk_proj_snd -> Trivialization.mk_proj_snd is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (Prod.mk.{u1, u2} B F (proj x) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e x))) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e x))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{max (succ u2) (succ u1)} (Prod.{u2, u1} B F) (Prod.mk.{u2, u1} B F (proj x) (Prod.snd.{u2, u1} B F (Trivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj _inst_3 e x))) (Trivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj _inst_3 e x))
Case conversion may be inaccurate. Consider using '#align trivialization.mk_proj_snd Trivialization.mk_proj_sndₓ'. -/
theorem mk_proj_snd (ex : x ∈ e.source) : (proj x, (e x).2) = e x :=
  Prod.ext (e.coe_fst ex).symm rfl
#align trivialization.mk_proj_snd Trivialization.mk_proj_snd

/- warning: trivialization.mk_proj_snd' -> Trivialization.mk_proj_snd' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj x) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (Prod.mk.{u1, u2} B F (proj x) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e x))) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e x))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (proj x) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{max (succ u3) (succ u2)} (Prod.{u3, u2} B F) (Prod.mk.{u3, u2} B F (proj x) (Prod.snd.{u3, u2} B F (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e x))) (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e x))
Case conversion may be inaccurate. Consider using '#align trivialization.mk_proj_snd' Trivialization.mk_proj_snd'ₓ'. -/
theorem mk_proj_snd' (ex : proj x ∈ e.baseSet) : (proj x, (e x).2) = e x :=
  Prod.ext (e.coe_fst' ex).symm rfl
#align trivialization.mk_proj_snd' Trivialization.mk_proj_snd'

/- warning: trivialization.source_inter_preimage_target_inter -> Trivialization.source_inter_preimage_target_inter is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (s : Set.{max u1 u2} (Prod.{u1, u2} B F)), Eq.{succ u3} (Set.{u3} Z) (Inter.inter.{u3} (Set.{u3} Z) (Set.hasInter.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))) (Set.preimage.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e) (Inter.inter.{max u1 u2} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasInter.{max u1 u2} (Prod.{u1, u2} B F)) (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))) s))) (Inter.inter.{u3} (Set.{u3} Z) (Set.hasInter.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))) (Set.preimage.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e) s))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u3}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u3} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u2, u3, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (s : Set.{max u3 u2} (Prod.{u2, u3} B F)), Eq.{succ u1} (Set.{u1} Z) (Inter.inter.{u1} (Set.{u1} Z) (Set.instInterSet.{u1} Z) (LocalEquiv.source.{u1, max u2 u3} Z (Prod.{u2, u3} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u2 u3} Z (Prod.{u2, u3} B F) _inst_3 (instTopologicalSpaceProd.{u2, u3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u3, u1} B F Z _inst_1 _inst_2 _inst_3 proj e))) (Set.preimage.{u1, max u2 u3} Z (Prod.{u2, u3} B F) (Trivialization.toFun'.{u2, u3, u1} B F Z _inst_1 _inst_2 proj _inst_3 e) (Inter.inter.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} B F)) (Set.instInterSet.{max u2 u3} (Prod.{u2, u3} B F)) (LocalEquiv.target.{u1, max u2 u3} Z (Prod.{u2, u3} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u2 u3} Z (Prod.{u2, u3} B F) _inst_3 (instTopologicalSpaceProd.{u2, u3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u3, u1} B F Z _inst_1 _inst_2 _inst_3 proj e))) s))) (Inter.inter.{u1} (Set.{u1} Z) (Set.instInterSet.{u1} Z) (LocalEquiv.source.{u1, max u2 u3} Z (Prod.{u2, u3} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u2 u3} Z (Prod.{u2, u3} B F) _inst_3 (instTopologicalSpaceProd.{u2, u3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u3, u1} B F Z _inst_1 _inst_2 _inst_3 proj e))) (Set.preimage.{u1, max u2 u3} Z (Prod.{u2, u3} B F) (Trivialization.toFun'.{u2, u3, u1} B F Z _inst_1 _inst_2 proj _inst_3 e) s))
Case conversion may be inaccurate. Consider using '#align trivialization.source_inter_preimage_target_inter Trivialization.source_inter_preimage_target_interₓ'. -/
theorem source_inter_preimage_target_inter (s : Set (B × F)) :
    e.source ∩ e ⁻¹' (e.target ∩ s) = e.source ∩ e ⁻¹' s :=
  e.toLocalHomeomorph.source_inter_preimage_target_inter s
#align trivialization.source_inter_preimage_target_inter Trivialization.source_inter_preimage_target_inter

/- warning: trivialization.coe_mk -> Trivialization.coe_mk is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : LocalHomeomorph.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2)) (i : Set.{u1} B) (j : IsOpen.{u1} B _inst_1 i) (k : Eq.{succ u3} ((fun {α : Type.{u3}} {β : Type.{max u1 u2}} (self : LocalEquiv.{u3, max u1 u2} α β) => Set.{u3} α) Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) e)) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) e)) (Set.preimage.{u3, u1} Z B proj i)) (l : Eq.{succ (max u1 u2)} ((fun {α : Type.{u3}} {β : Type.{max u1 u2}} (self : LocalEquiv.{u3, max u1 u2} α β) => Set.{max u1 u2} β) Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) e)) (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) e)) (Set.prod.{u1, u2} B F i (Set.univ.{u2} F))) (m : forall (p : Z), (Membership.Mem.{u3, u3} Z ((fun {α : Type.{u3}} {β : Type.{max u1 u2}} (self : LocalEquiv.{u3, max u1 u2} α β) => Set.{u3} α) Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) e)) (Set.hasMem.{u3} Z) p (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) e))) -> (Eq.{succ u1} B (Prod.fst.{u1, u2} B F (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (LocalHomeomorph.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2)) (fun (_x : LocalHomeomorph.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2)) => Z -> (Prod.{u1, u2} B F)) (LocalHomeomorph.hasCoeToFun.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2)) e p)) (proj p))) (x : Z), Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) (Trivialization.mk.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e i j k l m) x) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (LocalHomeomorph.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2)) (fun (_x : LocalHomeomorph.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2)) => Z -> (Prod.{u1, u2} B F)) (LocalHomeomorph.hasCoeToFun.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2)) e x)
but is expected to have type
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : LocalHomeomorph.{u3, max u2 u1} Z (Prod.{u1, u2} B F) _inst_3 (instTopologicalSpaceProd.{u1, u2} B F _inst_1 _inst_2)) (i : Set.{u1} B) (j : IsOpen.{u1} B _inst_1 i) (k : Eq.{succ u3} (Set.{u3} Z) (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u1, u2} B F) _inst_3 (instTopologicalSpaceProd.{u1, u2} B F _inst_1 _inst_2) e)) (Set.preimage.{u3, u1} Z B proj i)) (l : Eq.{max (succ u1) (succ u2)} (Set.{max u2 u1} (Prod.{u1, u2} B F)) (LocalEquiv.target.{u3, max u2 u1} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u1, u2} B F) _inst_3 (instTopologicalSpaceProd.{u1, u2} B F _inst_1 _inst_2) e)) (Set.prod.{u1, u2} B F i (Set.univ.{u2} F))) (m : forall (p : Z), (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) p (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u1, u2} B F) _inst_3 (instTopologicalSpaceProd.{u1, u2} B F _inst_1 _inst_2) e))) -> (Eq.{succ u1} B (Prod.fst.{u1, u2} B F (LocalHomeomorph.toFun'.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (instTopologicalSpaceProd.{u1, u2} B F _inst_1 _inst_2) e p)) (proj p))) (x : Z), Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (Trivialization.toFun'.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 (Trivialization.mk.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e i j k l m) x) (LocalHomeomorph.toFun'.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (instTopologicalSpaceProd.{u1, u2} B F _inst_1 _inst_2) e x)
Case conversion may be inaccurate. Consider using '#align trivialization.coe_mk Trivialization.coe_mkₓ'. -/
@[simp, mfld_simps]
theorem coe_mk (e : LocalHomeomorph Z (B × F)) (i j k l m) (x : Z) :
    (Trivialization.mk e i j k l m : Trivialization F proj) x = e x :=
  rfl
#align trivialization.coe_mk Trivialization.coe_mk

/- warning: trivialization.mem_target -> Trivialization.mem_target is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Prod.{u1, u2} B F}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasMem.{max u1 u2} (Prod.{u1, u2} B F)) x (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (Prod.fst.{u1, u2} B F x) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Prod.{u3, u2} B F}, Iff (Membership.mem.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.instMembershipSet.{max u3 u2} (Prod.{u3, u2} B F)) x (LocalEquiv.target.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (Prod.fst.{u3, u2} B F x) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e))
Case conversion may be inaccurate. Consider using '#align trivialization.mem_target Trivialization.mem_targetₓ'. -/
theorem mem_target {x : B × F} : x ∈ e.target ↔ x.1 ∈ e.baseSet :=
  e.toPretrivialization.mem_target
#align trivialization.mem_target Trivialization.mem_target

/- warning: trivialization.map_target -> Trivialization.map_target is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Prod.{u1, u2} B F}, (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasMem.{max u1 u2} (Prod.{u1, u2} B F)) x (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) x) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Prod.{u3, u2} B F}, (Membership.mem.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.instMembershipSet.{max u3 u2} (Prod.{u3, u2} B F)) x (LocalEquiv.target.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) (LocalHomeomorph.toFun'.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) x) (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e))))
Case conversion may be inaccurate. Consider using '#align trivialization.map_target Trivialization.map_targetₓ'. -/
theorem map_target {x : B × F} (hx : x ∈ e.target) : e.toLocalHomeomorph.symm x ∈ e.source :=
  e.toLocalHomeomorph.map_target hx
#align trivialization.map_target Trivialization.map_target

/- warning: trivialization.proj_symm_apply -> Trivialization.proj_symm_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Prod.{u1, u2} B F}, (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasMem.{max u1 u2} (Prod.{u1, u2} B F)) x (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{succ u1} B (proj (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) x)) (Prod.fst.{u1, u2} B F x))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Prod.{u3, u2} B F}, (Membership.mem.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.instMembershipSet.{max u3 u2} (Prod.{u3, u2} B F)) x (LocalEquiv.target.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{succ u3} B (proj (LocalHomeomorph.toFun'.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) x)) (Prod.fst.{u3, u2} B F x))
Case conversion may be inaccurate. Consider using '#align trivialization.proj_symm_apply Trivialization.proj_symm_applyₓ'. -/
theorem proj_symm_apply {x : B × F} (hx : x ∈ e.target) : proj (e.toLocalHomeomorph.symm x) = x.1 :=
  e.toPretrivialization.proj_symm_apply hx
#align trivialization.proj_symm_apply Trivialization.proj_symm_apply

/- warning: trivialization.proj_symm_apply' -> Trivialization.proj_symm_apply' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B} {x : F}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{succ u1} B (proj (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u1, u2} B F b x))) b)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B} {x : F}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{succ u3} B (proj (LocalHomeomorph.toFun'.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u3, u2} B F b x))) b)
Case conversion may be inaccurate. Consider using '#align trivialization.proj_symm_apply' Trivialization.proj_symm_apply'ₓ'. -/
theorem proj_symm_apply' {b : B} {x : F} (hx : b ∈ e.baseSet) :
    proj (e.toLocalHomeomorph.symm (b, x)) = b :=
  e.toPretrivialization.proj_symm_apply' hx
#align trivialization.proj_symm_apply' Trivialization.proj_symm_apply'

/- warning: trivialization.proj_surj_on_base_set -> Trivialization.proj_surjOn_baseSet is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) [_inst_5 : Nonempty.{succ u2} F], Set.SurjOn.{u3, u1} Z B proj (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)
but is expected to have type
  forall {B : Type.{u1}} {F : Type.{u3}} {Z : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u3} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u2} Z] (e : Trivialization.{u1, u3, u2} B F Z _inst_1 _inst_2 _inst_3 proj) [_inst_5 : Nonempty.{succ u3} F], Set.SurjOn.{u2, u1} Z B proj (LocalEquiv.source.{u2, max u1 u3} Z (Prod.{u1, u3} B F) (LocalHomeomorph.toLocalEquiv.{u2, max u1 u3} Z (Prod.{u1, u3} B F) _inst_3 (instTopologicalSpaceProd.{u1, u3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u3, u2} B F Z _inst_1 _inst_2 _inst_3 proj e))) (Trivialization.baseSet.{u1, u3, u2} B F Z _inst_1 _inst_2 _inst_3 proj e)
Case conversion may be inaccurate. Consider using '#align trivialization.proj_surj_on_base_set Trivialization.proj_surjOn_baseSetₓ'. -/
theorem proj_surjOn_baseSet [Nonempty F] : Set.SurjOn proj e.source e.baseSet :=
  e.toPretrivialization.proj_surjOn_baseSet
#align trivialization.proj_surj_on_base_set Trivialization.proj_surjOn_baseSet

/- warning: trivialization.apply_symm_apply -> Trivialization.apply_symm_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Prod.{u1, u2} B F}, (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasMem.{max u1 u2} (Prod.{u1, u2} B F)) x (LocalEquiv.target.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) x)) x)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Prod.{u3, u2} B F}, (Membership.mem.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.instMembershipSet.{max u3 u2} (Prod.{u3, u2} B F)) x (LocalEquiv.target.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{max (succ u3) (succ u2)} (Prod.{u3, u2} B F) (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e (LocalHomeomorph.toFun'.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) x)) x)
Case conversion may be inaccurate. Consider using '#align trivialization.apply_symm_apply Trivialization.apply_symm_applyₓ'. -/
theorem apply_symm_apply {x : B × F} (hx : x ∈ e.target) : e (e.toLocalHomeomorph.symm x) = x :=
  e.toLocalHomeomorph.right_inv hx
#align trivialization.apply_symm_apply Trivialization.apply_symm_apply

/- warning: trivialization.apply_symm_apply' -> Trivialization.apply_symm_apply' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B} {x : F}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u1, u2} B F b x))) (Prod.mk.{u1, u2} B F b x))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B} {x : F}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{max (succ u3) (succ u2)} (Prod.{u3, u2} B F) (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e (LocalHomeomorph.toFun'.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u3, u2} B F b x))) (Prod.mk.{u3, u2} B F b x))
Case conversion may be inaccurate. Consider using '#align trivialization.apply_symm_apply' Trivialization.apply_symm_apply'ₓ'. -/
theorem apply_symm_apply' {b : B} {x : F} (hx : b ∈ e.baseSet) :
    e (e.toLocalHomeomorph.symm (b, x)) = (b, x) :=
  e.toPretrivialization.apply_symm_apply' hx
#align trivialization.apply_symm_apply' Trivialization.apply_symm_apply'

/- warning: trivialization.symm_apply_mk_proj -> Trivialization.symm_apply_mk_proj is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{succ u3} Z (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u1, u2} B F (proj x) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e x)))) x)
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{succ u3} Z (LocalHomeomorph.toFun'.{max u2 u1, u3} (Prod.{u2, u1} B F) Z (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u2, u1} B F (proj x) (Prod.snd.{u2, u1} B F (Trivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj _inst_3 e x)))) x)
Case conversion may be inaccurate. Consider using '#align trivialization.symm_apply_mk_proj Trivialization.symm_apply_mk_projₓ'. -/
@[simp, mfld_simps]
theorem symm_apply_mk_proj (ex : x ∈ e.source) : e.toLocalHomeomorph.symm (proj x, (e x).2) = x :=
  e.toPretrivialization.symm_apply_mk_proj ex
#align trivialization.symm_apply_mk_proj Trivialization.symm_apply_mk_proj

/- warning: trivialization.symm_trans_source_eq -> Trivialization.symm_trans_source_eq is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e' : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (LocalEquiv.source.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Prod.{u1, u2} B F) (LocalEquiv.trans.{max u1 u2, u3, max u1 u2} (Prod.{u1, u2} B F) Z (Prod.{u1, u2} B F) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e')))) (Set.prod.{u1, u2} B F (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e')) (Set.univ.{u2} F))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (e' : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (LocalEquiv.source.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Prod.{u3, u2} B F) (LocalEquiv.trans.{max u3 u2, u1, max u3 u2} (Prod.{u3, u2} B F) Z (Prod.{u3, u2} B F) (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e))) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e')))) (Set.prod.{u3, u2} B F (Inter.inter.{u3} (Set.{u3} B) (Set.instInterSet.{u3} B) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e')) (Set.univ.{u2} F))
Case conversion may be inaccurate. Consider using '#align trivialization.symm_trans_source_eq Trivialization.symm_trans_source_eqₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem symm_trans_source_eq (e e' : Trivialization F proj) :
    (e.toLocalEquiv.symm.trans e'.toLocalEquiv).source = (e.baseSet ∩ e'.baseSet) ×ˢ univ :=
  Pretrivialization.symm_trans_source_eq e.toPretrivialization e'
#align trivialization.symm_trans_source_eq Trivialization.symm_trans_source_eq

/- warning: trivialization.symm_trans_target_eq -> Trivialization.symm_trans_target_eq is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e' : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj), Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (LocalEquiv.target.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Prod.{u1, u2} B F) (LocalEquiv.trans.{max u1 u2, u3, max u1 u2} (Prod.{u1, u2} B F) Z (Prod.{u1, u2} B F) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e')))) (Set.prod.{u1, u2} B F (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e')) (Set.univ.{u2} F))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (e' : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (LocalEquiv.target.{max u3 u2, max u3 u2} (Prod.{u3, u2} B F) (Prod.{u3, u2} B F) (LocalEquiv.trans.{max u3 u2, u1, max u3 u2} (Prod.{u3, u2} B F) Z (Prod.{u3, u2} B F) (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e))) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e')))) (Set.prod.{u3, u2} B F (Inter.inter.{u3} (Set.{u3} B) (Set.instInterSet.{u3} B) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e')) (Set.univ.{u2} F))
Case conversion may be inaccurate. Consider using '#align trivialization.symm_trans_target_eq Trivialization.symm_trans_target_eqₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem symm_trans_target_eq (e e' : Trivialization F proj) :
    (e.toLocalEquiv.symm.trans e'.toLocalEquiv).target = (e.baseSet ∩ e'.baseSet) ×ˢ univ :=
  Pretrivialization.symm_trans_target_eq e.toPretrivialization e'
#align trivialization.symm_trans_target_eq Trivialization.symm_trans_target_eq

/- warning: trivialization.coe_fst_eventually_eq_proj -> Trivialization.coe_fst_eventuallyEq_proj is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Filter.EventuallyEq.{u3, u1} Z B (nhds.{u3} Z _inst_3 x) (Function.comp.{succ u3, max (succ u1) (succ u2), succ u1} Z (Prod.{u1, u2} B F) B (Prod.fst.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e)) proj)
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Filter.EventuallyEq.{u3, u2} Z B (nhds.{u3} Z _inst_3 x) (Function.comp.{succ u3, max (succ u1) (succ u2), succ u2} Z (Prod.{u2, u1} B F) B (Prod.fst.{u2, u1} B F) (Trivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj _inst_3 e)) proj)
Case conversion may be inaccurate. Consider using '#align trivialization.coe_fst_eventually_eq_proj Trivialization.coe_fst_eventuallyEq_projₓ'. -/
theorem coe_fst_eventuallyEq_proj (ex : x ∈ e.source) : Prod.fst ∘ e =ᶠ[𝓝 x] proj :=
  mem_nhds_iff.2 ⟨e.source, fun y hy => e.coe_fst hy, e.open_source, ex⟩
#align trivialization.coe_fst_eventually_eq_proj Trivialization.coe_fst_eventuallyEq_proj

/- warning: trivialization.coe_fst_eventually_eq_proj' -> Trivialization.coe_fst_eventuallyEq_proj' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj x) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Filter.EventuallyEq.{u3, u1} Z B (nhds.{u3} Z _inst_3 x) (Function.comp.{succ u3, max (succ u1) (succ u2), succ u1} Z (Prod.{u1, u2} B F) B (Prod.fst.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e)) proj)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (proj x) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Filter.EventuallyEq.{u1, u3} Z B (nhds.{u1} Z _inst_3 x) (Function.comp.{succ u1, max (succ u2) (succ u3), succ u3} Z (Prod.{u3, u2} B F) B (Prod.fst.{u3, u2} B F) (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e)) proj)
Case conversion may be inaccurate. Consider using '#align trivialization.coe_fst_eventually_eq_proj' Trivialization.coe_fst_eventuallyEq_proj'ₓ'. -/
theorem coe_fst_eventuallyEq_proj' (ex : proj x ∈ e.baseSet) : Prod.fst ∘ e =ᶠ[𝓝 x] proj :=
  e.coe_fst_eventuallyEq_proj (e.mem_source.2 ex)
#align trivialization.coe_fst_eventually_eq_proj' Trivialization.coe_fst_eventuallyEq_proj'

/- warning: trivialization.map_proj_nhds -> Trivialization.map_proj_nhds is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{succ u1} (Filter.{u1} B) (Filter.map.{u3, u1} Z B proj (nhds.{u3} Z _inst_3 x)) (nhds.{u1} B _inst_1 (proj x)))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Eq.{succ u2} (Filter.{u2} B) (Filter.map.{u3, u2} Z B proj (nhds.{u3} Z _inst_3 x)) (nhds.{u2} B _inst_1 (proj x)))
Case conversion may be inaccurate. Consider using '#align trivialization.map_proj_nhds Trivialization.map_proj_nhdsₓ'. -/
theorem map_proj_nhds (ex : x ∈ e.source) : map proj (𝓝 x) = 𝓝 (proj x) := by
  rw [← e.coe_fst ex, ← map_congr (e.coe_fst_eventually_eq_proj ex), ← map_map, ← e.coe_coe,
    e.to_local_homeomorph.map_nhds_eq ex, map_fst_nhds]
#align trivialization.map_proj_nhds Trivialization.map_proj_nhds

/- warning: trivialization.preimage_subset_source -> Trivialization.preimage_subset_source is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {s : Set.{u1} B}, (HasSubset.Subset.{u1} (Set.{u1} B) (Set.hasSubset.{u1} B) s (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (HasSubset.Subset.{u3} (Set.{u3} Z) (Set.hasSubset.{u3} Z) (Set.preimage.{u3, u1} Z B proj s) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {s : Set.{u3} B}, (HasSubset.Subset.{u3} (Set.{u3} B) (Set.instHasSubsetSet.{u3} B) s (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (HasSubset.Subset.{u1} (Set.{u1} Z) (Set.instHasSubsetSet.{u1} Z) (Set.preimage.{u1, u3} Z B proj s) (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e))))
Case conversion may be inaccurate. Consider using '#align trivialization.preimage_subset_source Trivialization.preimage_subset_sourceₓ'. -/
theorem preimage_subset_source {s : Set B} (hb : s ⊆ e.baseSet) : proj ⁻¹' s ⊆ e.source :=
  fun p hp => e.mem_source.mpr (hb hp)
#align trivialization.preimage_subset_source Trivialization.preimage_subset_source

/- warning: trivialization.image_preimage_eq_prod_univ -> Trivialization.image_preimage_eq_prod_univ is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {s : Set.{u1} B}, (HasSubset.Subset.{u1} (Set.{u1} B) (Set.hasSubset.{u1} B) s (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{succ (max u1 u2)} (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.image.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e) (Set.preimage.{u3, u1} Z B proj s)) (Set.prod.{u1, u2} B F s (Set.univ.{u2} F)))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {s : Set.{u3} B}, (HasSubset.Subset.{u3} (Set.{u3} B) (Set.instHasSubsetSet.{u3} B) s (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} B F)) (Set.image.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e) (Set.preimage.{u1, u3} Z B proj s)) (Set.prod.{u3, u2} B F s (Set.univ.{u2} F)))
Case conversion may be inaccurate. Consider using '#align trivialization.image_preimage_eq_prod_univ Trivialization.image_preimage_eq_prod_univₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem image_preimage_eq_prod_univ {s : Set B} (hb : s ⊆ e.baseSet) :
    e '' (proj ⁻¹' s) = s ×ˢ univ :=
  Subset.antisymm
    (image_subset_iff.mpr fun p hp =>
      ⟨(e.proj_toFun p (e.preimage_subset_source hb hp)).symm ▸ hp, trivial⟩)
    fun p hp =>
    let hp' : p ∈ e.target := e.mem_target.mpr (hb hp.1)
    ⟨e.invFun p, mem_preimage.mpr ((e.proj_symm_apply hp').symm ▸ hp.1), e.apply_symm_apply hp'⟩
#align trivialization.image_preimage_eq_prod_univ Trivialization.image_preimage_eq_prod_univ

/- warning: trivialization.preimage_homeomorph -> Trivialization.preimageHomeomorph is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {s : Set.{u1} B}, (HasSubset.Subset.{u1} (Set.{u1} B) (Set.hasSubset.{u1} B) s (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Homeomorph.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2))
but is expected to have type
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {s : Set.{u1} B}, (HasSubset.Subset.{u1} (Set.{u1} B) (Set.instHasSubsetSet.{u1} B) s (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Homeomorph.{u3, max u2 u1} (Set.Elem.{u3} Z (Set.preimage.{u3, u1} Z B proj s)) (Prod.{u1, u2} (Set.Elem.{u1} B s) F) (instTopologicalSpaceSubtype.{u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3) (instTopologicalSpaceProd.{u1, u2} (Set.Elem.{u1} B s) F (instTopologicalSpaceSubtype.{u1} B (fun (x : B) => Membership.mem.{u1, u1} B (Set.{u1} B) (Set.instMembershipSet.{u1} B) x s) _inst_1) _inst_2))
Case conversion may be inaccurate. Consider using '#align trivialization.preimage_homeomorph Trivialization.preimageHomeomorphₓ'. -/
/-- The preimage of a subset of the base set is homeomorphic to the product with the fiber. -/
def preimageHomeomorph {s : Set B} (hb : s ⊆ e.baseSet) : proj ⁻¹' s ≃ₜ s × F :=
  (e.toLocalHomeomorph.homeomorphOfImageSubsetSource (e.preimage_subset_source hb)
        (e.image_preimage_eq_prod_univ hb)).trans
    ((Homeomorph.Set.prod s univ).trans ((Homeomorph.refl s).prodCongr (Homeomorph.Set.univ F)))
#align trivialization.preimage_homeomorph Trivialization.preimageHomeomorph

/- warning: trivialization.preimage_homeomorph_apply -> Trivialization.preimageHomeomorph_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {s : Set.{u1} B} (hb : HasSubset.Subset.{u1} (Set.{u1} B) (Set.hasSubset.{u1} B) s (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (p : coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)), Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (Homeomorph.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2)) (fun (_x : Homeomorph.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2)) => (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) -> (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F)) (Homeomorph.hasCoeToFun.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2)) (Trivialization.preimageHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e s hb) p) (Prod.mk.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.mk.{succ u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) (proj ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) Z (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) Z (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) Z (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) Z (coeSubtype.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)))))) p)) (Subtype.property.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) p)) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) Z (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) Z (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) Z (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) Z (coeSubtype.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)))))) p))))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {s : Set.{u3} B} (hb : HasSubset.Subset.{u3} (Set.{u3} B) (Set.instHasSubsetSet.{u3} B) s (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) (p : Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) => Prod.{u3, u2} (Set.Elem.{u3} B s) F) p) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u1, max (succ u3) (succ u2)} (Homeomorph.{u1, max u2 u3} (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2)) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (fun (_x : Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) => Prod.{u3, u2} (Set.Elem.{u3} B s) F) _x) (EmbeddingLike.toFunLike.{max (max (succ u3) (succ u2)) (succ u1), succ u1, max (succ u3) (succ u2)} (Homeomorph.{u1, max u2 u3} (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2)) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (EquivLike.toEmbeddingLike.{max (max (succ u3) (succ u2)) (succ u1), succ u1, max (succ u3) (succ u2)} (Homeomorph.{u1, max u2 u3} (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2)) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Homeomorph.instEquivLikeHomeomorph.{u1, max u3 u2} (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2)))) (Trivialization.preimageHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e s hb) p) (Prod.mk.{u3, u2} (Set.Elem.{u3} B s) F (Subtype.mk.{succ u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) (proj (Subtype.val.{succ u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) p)) (Subtype.property.{succ u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) p)) (Prod.snd.{u3, u2} B F (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e (Subtype.val.{succ u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) p))))
Case conversion may be inaccurate. Consider using '#align trivialization.preimage_homeomorph_apply Trivialization.preimageHomeomorph_applyₓ'. -/
@[simp]
theorem preimageHomeomorph_apply {s : Set B} (hb : s ⊆ e.baseSet) (p : proj ⁻¹' s) :
    e.preimageHomeomorph hb p = (⟨proj p, p.2⟩, (e p).2) :=
  Prod.ext (Subtype.ext (e.proj_toFun p (e.mem_source.mpr (hb p.2)))) rfl
#align trivialization.preimage_homeomorph_apply Trivialization.preimageHomeomorph_apply

/- warning: trivialization.preimage_homeomorph_symm_apply -> Trivialization.preimageHomeomorph_symm_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {s : Set.{u1} B} (hb : HasSubset.Subset.{u1} (Set.{u1} B) (Set.hasSubset.{u1} B) s (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (p : Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F), Eq.{succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Homeomorph.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3)) (fun (_x : Homeomorph.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3)) => (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) -> (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s))) (Homeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3)) (Homeomorph.symm.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2) (Trivialization.preimageHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e s hb)) p) (Subtype.mk.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u1, u2} B F ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) B (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) B (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) B (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) B (coeSubtype.{succ u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s))))) (Prod.fst.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F p)) (Prod.snd.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F p))) (Subtype.property.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Homeomorph.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3)) (fun (_x : Homeomorph.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3)) => (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) -> (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s))) (Homeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3)) (Homeomorph.symm.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (Set.preimage.{u3, u1} Z B proj s)) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (Set.preimage.{u3, u1} Z B proj s)) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) s) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x s) _inst_1) _inst_2) (Trivialization.preimageHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e s hb)) p)))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {s : Set.{u3} B} (hb : HasSubset.Subset.{u3} (Set.{u3} B) (Set.instHasSubsetSet.{u3} B) s (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) (p : Prod.{u3, u2} (Set.Elem.{u3} B s) F), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u3, u2} (Set.Elem.{u3} B s) F) => Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) p) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (fun (_x : Prod.{u3, u2} (Set.Elem.{u3} B s) F) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u3, u2} (Set.Elem.{u3} B s) F) => Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) _x) (EmbeddingLike.toFunLike.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (EquivLike.toEmbeddingLike.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (Homeomorph.instEquivLikeHomeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3)))) (Homeomorph.symm.{u1, max u3 u2} (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2) (Trivialization.preimageHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e s hb)) p) (Subtype.mk.{succ u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) (LocalHomeomorph.toFun'.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u3, u2} B F (Subtype.val.{succ u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) (Prod.fst.{u3, u2} (Set.Elem.{u3} B s) F p)) (Prod.snd.{u3, u2} (Set.Elem.{u3} B s) F p))) (Subtype.property.{succ u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (fun (_x : Prod.{u3, u2} (Set.Elem.{u3} B s) F) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u3, u2} (Set.Elem.{u3} B s) F) => Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) _x) (EmbeddingLike.toFunLike.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (EquivLike.toEmbeddingLike.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (Homeomorph.instEquivLikeHomeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3)))) (Homeomorph.symm.{u1, max u3 u2} (Set.Elem.{u1} Z (Set.preimage.{u1, u3} Z B proj s)) (Prod.{u3, u2} (Set.Elem.{u3} B s) F) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (Set.preimage.{u1, u3} Z B proj s)) _inst_3) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B s) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x s) _inst_1) _inst_2) (Trivialization.preimageHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e s hb)) p)))
Case conversion may be inaccurate. Consider using '#align trivialization.preimage_homeomorph_symm_apply Trivialization.preimageHomeomorph_symm_applyₓ'. -/
@[simp]
theorem preimageHomeomorph_symm_apply {s : Set B} (hb : s ⊆ e.baseSet) (p : s × F) :
    (e.preimageHomeomorph hb).symm p = ⟨e.symm (p.1, p.2), ((e.preimageHomeomorph hb).symm p).2⟩ :=
  rfl
#align trivialization.preimage_homeomorph_symm_apply Trivialization.preimageHomeomorph_symm_apply

/- warning: trivialization.source_homeomorph_base_set_prod -> Trivialization.sourceHomeomorphBaseSetProd is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj), Homeomorph.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2)
but is expected to have type
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj), Homeomorph.{u3, max u2 u1} (Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (instTopologicalSpaceProd.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u1, u2} (Set.Elem.{u1} B (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (instTopologicalSpaceSubtype.{u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (instTopologicalSpaceProd.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (instTopologicalSpaceProd.{u1, u2} (Set.Elem.{u1} B (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u1} B (fun (x : B) => Membership.mem.{u1, u1} B (Set.{u1} B) (Set.instMembershipSet.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2)
Case conversion may be inaccurate. Consider using '#align trivialization.source_homeomorph_base_set_prod Trivialization.sourceHomeomorphBaseSetProdₓ'. -/
/-- The source is homeomorphic to the product of the base set with the fiber. -/
def sourceHomeomorphBaseSetProd : e.source ≃ₜ e.baseSet × F :=
  (Homeomorph.setCongr e.source_eq).trans (e.preimageHomeomorph subset_rfl)
#align trivialization.source_homeomorph_base_set_prod Trivialization.sourceHomeomorphBaseSetProd

/- warning: trivialization.source_homeomorph_base_set_prod_apply -> Trivialization.sourceHomeomorphBaseSetProd_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (p : coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))), Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (Homeomorph.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2)) (fun (_x : Homeomorph.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2)) => (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F)) (Homeomorph.hasCoeToFun.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2)) (Trivialization.sourceHomeomorphBaseSetProd.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e) p) (Prod.mk.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.mk.{succ u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (proj ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (coeSubtype.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))))))) p)) (Iff.mp (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (coeSubtype.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))))))) p) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (coeSubtype.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))))))) p)) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Trivialization.mem_source.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (coeSubtype.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))))))) p)) (Subtype.property.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) p))) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) Z (coeSubtype.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))))))) p))))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (p : Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) => Prod.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) p) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), succ u3, max (succ u2) (succ u1)} (Homeomorph.{u3, max u1 u2} (Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (instTopologicalSpaceSubtype.{u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (instTopologicalSpaceProd.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u2} B (fun (x : B) => Membership.mem.{u2, u2} B (Set.{u2} B) (Set.instMembershipSet.{u2} B) x (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2)) (Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (fun (_x : Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) => Prod.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) _x) (EmbeddingLike.toFunLike.{max (max (succ u2) (succ u1)) (succ u3), succ u3, max (succ u2) (succ u1)} (Homeomorph.{u3, max u1 u2} (Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (instTopologicalSpaceSubtype.{u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (instTopologicalSpaceProd.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u2} B (fun (x : B) => Membership.mem.{u2, u2} B (Set.{u2} B) (Set.instMembershipSet.{u2} B) x (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2)) (Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (EquivLike.toEmbeddingLike.{max (max (succ u2) (succ u1)) (succ u3), succ u3, max (succ u2) (succ u1)} (Homeomorph.{u3, max u1 u2} (Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (instTopologicalSpaceSubtype.{u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (instTopologicalSpaceProd.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u2} B (fun (x : B) => Membership.mem.{u2, u2} B (Set.{u2} B) (Set.instMembershipSet.{u2} B) x (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2)) (Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Homeomorph.instEquivLikeHomeomorph.{u3, max u2 u1} (Set.Elem.{u3} Z (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (instTopologicalSpaceSubtype.{u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (instTopologicalSpaceProd.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u2} B (fun (x : B) => Membership.mem.{u2, u2} B (Set.{u2} B) (Set.instMembershipSet.{u2} B) x (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2)))) (Trivialization.sourceHomeomorphBaseSetProd.{u2, u1, u3} B F Z _inst_1 _inst_2 proj _inst_3 e) p) (Prod.mk.{u2, u1} (Set.Elem.{u2} B (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.mk.{succ u2} B (fun (x : B) => Membership.mem.{u2, u2} B (Set.{u2} B) (Set.instMembershipSet.{u2} B) x (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (proj (Subtype.val.{succ u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) p)) (Iff.mp (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) (Subtype.val.{succ u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) p) (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Membership.mem.{u2, u2} B (Set.{u2} B) (Set.instMembershipSet.{u2} B) (proj (Subtype.val.{succ u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) p)) (Trivialization.baseSet.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Trivialization.mem_source.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e (Subtype.val.{succ u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) p)) (Subtype.property.{succ u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) p))) (Prod.snd.{u2, u1} B F (Trivialization.toFun'.{u2, u1, u3} B F Z _inst_1 _inst_2 proj _inst_3 e (Subtype.val.{succ u3} Z (fun (x : Z) => Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) p))))
Case conversion may be inaccurate. Consider using '#align trivialization.source_homeomorph_base_set_prod_apply Trivialization.sourceHomeomorphBaseSetProd_applyₓ'. -/
@[simp]
theorem sourceHomeomorphBaseSetProd_apply (p : e.source) :
    e.sourceHomeomorphBaseSetProd p = (⟨proj p, e.mem_source.mp p.2⟩, (e p).2) :=
  e.preimageHomeomorph_apply subset_rfl ⟨p, e.mem_source.mp p.2⟩
#align trivialization.source_homeomorph_base_set_prod_apply Trivialization.sourceHomeomorphBaseSetProd_apply

/- warning: trivialization.source_homeomorph_base_set_prod_symm_apply -> Trivialization.sourceHomeomorphBaseSetProd_symm_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (p : Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F), Eq.{succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Homeomorph.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) (fun (_x : Homeomorph.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) => (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) -> (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))))) (Homeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) (Homeomorph.symm.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (Trivialization.sourceHomeomorphBaseSetProd.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e)) p) (Subtype.mk.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u1, u2} B F ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) B (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) B (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) B (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) B (coeSubtype.{succ u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))))) (Prod.fst.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F p)) (Prod.snd.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F p))) (Subtype.property.{succ u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (Homeomorph.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) (fun (_x : Homeomorph.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) => (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) -> (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))))) (Homeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) (Homeomorph.symm.{u3, max u1 u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} Z) Type.{u3} (Set.hasCoeToSort.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Subtype.topologicalSpace.{u3} Z (fun (x : Z) => Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (Prod.topologicalSpace.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} B) Type.{u1} (Set.hasCoeToSort.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (Subtype.topologicalSpace.{u1} B (fun (x : B) => Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (Trivialization.sourceHomeomorphBaseSetProd.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e)) p)))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (p : Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) => Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) p) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (fun (_x : Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) => Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _x) (EmbeddingLike.toFunLike.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (EquivLike.toEmbeddingLike.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Homeomorph.instEquivLikeHomeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)))) (Homeomorph.symm.{u1, max u3 u2} (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (Trivialization.sourceHomeomorphBaseSetProd.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e)) p) (Subtype.mk.{succ u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (LocalHomeomorph.toFun'.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u3, u2} B F (Subtype.val.{succ u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.fst.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F p)) (Prod.snd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F p))) (Subtype.property.{succ u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (fun (_x : Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) => Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _x) (EmbeddingLike.toFunLike.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (EquivLike.toEmbeddingLike.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (Homeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)) (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Homeomorph.instEquivLikeHomeomorph.{max u3 u2, u1} (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3)))) (Homeomorph.symm.{u1, max u3 u2} (Set.Elem.{u1} Z (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) (Prod.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F) (instTopologicalSpaceSubtype.{u1} Z (fun (x : Z) => Membership.mem.{u1, u1} Z (Set.{u1} Z) (Set.instMembershipSet.{u1} Z) x (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)))) _inst_3) (instTopologicalSpaceProd.{u3, u2} (Set.Elem.{u3} B (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) F (instTopologicalSpaceSubtype.{u3} B (fun (x : B) => Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) _inst_1) _inst_2) (Trivialization.sourceHomeomorphBaseSetProd.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e)) p)))
Case conversion may be inaccurate. Consider using '#align trivialization.source_homeomorph_base_set_prod_symm_apply Trivialization.sourceHomeomorphBaseSetProd_symm_applyₓ'. -/
@[simp]
theorem sourceHomeomorphBaseSetProd_symm_apply (p : e.baseSet × F) :
    e.sourceHomeomorphBaseSetProd.symm p =
      ⟨e.symm (p.1, p.2), (e.sourceHomeomorphBaseSetProd.symm p).2⟩ :=
  rfl
#align trivialization.source_homeomorph_base_set_prod_symm_apply Trivialization.sourceHomeomorphBaseSetProd_symm_apply

/- warning: trivialization.preimage_singleton_homeomorph -> Trivialization.preimageSingletonHomeomorph is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u_2}} {F : Type.{u_3}} {Z : Type.{u_5}} [_inst_1 : TopologicalSpace.{u_2} B] [_inst_2 : TopologicalSpace.{u_3} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u_5} Z] (e : Trivialization.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Trivialization.baseSet.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Homeomorph.{u_5, u_3} (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) F (Subtype.topologicalSpace.{u_5} Z (fun (x : Z) => Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) x (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_3) _inst_2)
but is expected to have type
  forall {B : Type.{u_1}} {F : Type.{u_2}} {Z : Type.{u_3}} [_inst_1 : TopologicalSpace.{u_1} B] [_inst_2 : TopologicalSpace.{u_2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u_3} Z] (e : Trivialization.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Trivialization.baseSet.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Homeomorph.{u_3, u_2} (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) F (instTopologicalSpaceSubtype.{u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_3) _inst_2)
Case conversion may be inaccurate. Consider using '#align trivialization.preimage_singleton_homeomorph Trivialization.preimageSingletonHomeomorphₓ'. -/
/-- Each fiber of a trivialization is homeomorphic to the specified fiber. -/
def preimageSingletonHomeomorph {b : B} (hb : b ∈ e.baseSet) : proj ⁻¹' {b} ≃ₜ F :=
  (e.preimageHomeomorph (Set.singleton_subset_iff.mpr hb)).trans
    (((Homeomorph.homeomorphOfUnique ({b} : Set B) PUnit).prodCongr (Homeomorph.refl F)).trans
      (Homeomorph.punitProd F))
#align trivialization.preimage_singleton_homeomorph Trivialization.preimageSingletonHomeomorph

/- warning: trivialization.preimage_singleton_homeomorph_apply -> Trivialization.preimageSingletonHomeomorph_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u_2}} {F : Type.{u_3}} {Z : Type.{u_5}} [_inst_1 : TopologicalSpace.{u_2} B] [_inst_2 : TopologicalSpace.{u_3} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u_5} Z] (e : Trivialization.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B} (hb : Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Trivialization.baseSet.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (p : coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))), Eq.{succ u_3} F (coeFn.{max (succ u_5) (succ u_3), max (succ u_5) (succ u_3)} (Homeomorph.{u_5, u_3} (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) F (Subtype.topologicalSpace.{u_5} Z (fun (x : Z) => Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) x (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_3) _inst_2) (fun (_x : Homeomorph.{u_5, u_3} (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) F (Subtype.topologicalSpace.{u_5} Z (fun (x : Z) => Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) x (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_3) _inst_2) => (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) -> F) (Homeomorph.hasCoeToFun.{u_5, u_3} (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) F (Subtype.topologicalSpace.{u_5} Z (fun (x : Z) => Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) x (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_3) _inst_2) (Trivialization.preimageSingletonHomeomorph.{u_2, u_3, u_5, u_1} B F Z _inst_1 _inst_2 proj _inst_3 e b hb) p) (Prod.snd.{u_2, u_3} B F (coeFn.{max (succ u_2) (succ u_3) (succ u_5), max (succ u_5) (succ u_2) (succ u_3)} (Trivialization.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u_2, u_3} B F)) (Trivialization.hasCoeToFun.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 proj _inst_3) e ((fun (a : Type.{u_5}) (b : Type.{u_5}) [self : HasLiftT.{succ u_5, succ u_5} a b] => self.0) (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) Z (HasLiftT.mk.{succ u_5, succ u_5} (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) Z (CoeTCₓ.coe.{succ u_5, succ u_5} (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) Z (coeBase.{succ u_5, succ u_5} (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) Z (coeSubtype.{succ u_5} Z (fun (x : Z) => Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) x (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))))))) p)))
but is expected to have type
  forall {B : Type.{u_1}} {F : Type.{u_2}} {Z : Type.{u_3}} [_inst_1 : TopologicalSpace.{u_1} B] [_inst_2 : TopologicalSpace.{u_2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u_3} Z] (e : Trivialization.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B} (hb : Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Trivialization.baseSet.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (p : Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))), Eq.{succ u_2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) => F) p) (FunLike.coe.{max (succ u_2) (succ u_3), succ u_3, succ u_2} (Homeomorph.{u_3, u_2} (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) F (instTopologicalSpaceSubtype.{u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_3) _inst_2) (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (fun (_x : Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) => F) _x) (EmbeddingLike.toFunLike.{max (succ u_2) (succ u_3), succ u_3, succ u_2} (Homeomorph.{u_3, u_2} (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) F (instTopologicalSpaceSubtype.{u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_3) _inst_2) (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) F (EquivLike.toEmbeddingLike.{max (succ u_2) (succ u_3), succ u_3, succ u_2} (Homeomorph.{u_3, u_2} (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) F (instTopologicalSpaceSubtype.{u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_3) _inst_2) (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) F (Homeomorph.instEquivLikeHomeomorph.{u_3, u_2} (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) F (instTopologicalSpaceSubtype.{u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_3) _inst_2))) (Trivialization.preimageSingletonHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 proj _inst_3 e b hb) p) (Prod.snd.{u_1, u_2} B F (Trivialization.toFun'.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 proj _inst_3 e (Subtype.val.{succ u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) p)))
Case conversion may be inaccurate. Consider using '#align trivialization.preimage_singleton_homeomorph_apply Trivialization.preimageSingletonHomeomorph_applyₓ'. -/
@[simp]
theorem preimageSingletonHomeomorph_apply {b : B} (hb : b ∈ e.baseSet) (p : proj ⁻¹' {b}) :
    e.preimageSingletonHomeomorph hb p = (e p).2 :=
  rfl
#align trivialization.preimage_singleton_homeomorph_apply Trivialization.preimageSingletonHomeomorph_apply

/- warning: trivialization.preimage_singleton_homeomorph_symm_apply -> Trivialization.preimageSingletonHomeomorph_symm_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u_2}} {F : Type.{u_3}} {Z : Type.{u_5}} [_inst_1 : TopologicalSpace.{u_2} B] [_inst_2 : TopologicalSpace.{u_3} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u_5} Z] (e : Trivialization.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B} (hb : Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Trivialization.baseSet.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (p : F), Eq.{succ u_5} (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) (coeFn.{max (succ u_3) (succ u_5), max (succ u_3) (succ u_5)} (Homeomorph.{u_3, u_5} F (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_2 (Subtype.topologicalSpace.{u_5} Z (fun (x : Z) => Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) x (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_3)) (fun (_x : Homeomorph.{u_3, u_5} F (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_2 (Subtype.topologicalSpace.{u_5} Z (fun (x : Z) => Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) x (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_3)) => F -> (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)))) (Homeomorph.hasCoeToFun.{u_3, u_5} F (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_2 (Subtype.topologicalSpace.{u_5} Z (fun (x : Z) => Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) x (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_3)) (Homeomorph.symm.{u_5, u_3} (coeSort.{max (succ u_5) 1, succ (succ u_5)} (Set.{u_5} Z) Type.{u_5} (Set.hasCoeToSort.{u_5} Z) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) F (Subtype.topologicalSpace.{u_5} Z (fun (x : Z) => Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) x (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _inst_3) _inst_2 (Trivialization.preimageSingletonHomeomorph.{u_2, u_3, u_5, u_1} B F Z _inst_1 _inst_2 proj _inst_3 e b hb)) p) (Subtype.mk.{succ u_5} Z (fun (x : Z) => Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) x (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p)) (Eq.mpr.{0} (Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p)) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) (proj (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p))) (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p)) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) (proj (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p))) (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) (Eq.ndrec.{0, 1} Prop (Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p)) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) (fun (_a : Prop) => Eq.{1} Prop (Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p)) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) _a) (rfl.{1} Prop (Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p)) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)))) (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) (proj (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p))) (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (propext (Membership.Mem.{u_5, u_5} Z (Set.{u_5} Z) (Set.hasMem.{u_5} Z) (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p)) (Set.preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) (proj (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p))) (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (Set.mem_preimage.{u_5, u_2} Z B proj (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b) (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p)))))) (Eq.mpr.{0} (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) (proj (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p))) (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) (proj (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p))) (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) (Eq.ndrec.{0, succ u_2} B (proj (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p))) (fun (_a : B) => Eq.{1} Prop (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) (proj (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p))) (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) _a (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) (rfl.{1} Prop (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) (proj (coeFn.{max (succ (max u_2 u_3)) (succ u_5), max (succ (max u_2 u_3)) (succ u_5)} (LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) => (Prod.{u_2, u_3} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u_2 u_3, u_5} (Prod.{u_2, u_3} B F) Z (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u_5, max u_2 u_3} Z (Prod.{u_2, u_3} B F) _inst_3 (Prod.topologicalSpace.{u_2, u_3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_2, u_3} B F b p))) (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) b (Trivialization.proj_symm_apply'.{u_2, u_3, u_5} B F Z _inst_1 _inst_2 proj _inst_3 e b p hb))) (Eq.mpr.{0} (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (Eq.{succ u_2} B b b) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (Eq.{succ u_2} B b b)) (Eq.ndrec.{0, 1} Prop (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (fun (_a : Prop) => Eq.{1} Prop (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) _a) (rfl.{1} Prop (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b))) (Eq.{succ u_2} B b b) (propext (Membership.Mem.{u_2, u_2} B (Set.{u_2} B) (Set.hasMem.{u_2} B) b (Singleton.singleton.{u_2, u_2} B (Set.{u_2} B) (Set.hasSingleton.{u_2} B) b)) (Eq.{succ u_2} B b b) (Set.mem_singleton_iff.{u_2} B b b)))) (rfl.{succ u_2} B b)))))
but is expected to have type
  forall {B : Type.{u_1}} {F : Type.{u_2}} {Z : Type.{u_3}} [_inst_1 : TopologicalSpace.{u_1} B] [_inst_2 : TopologicalSpace.{u_2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u_3} Z] (e : Trivialization.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B} (hb : Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Trivialization.baseSet.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (p : F), Eq.{succ u_3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : F) => Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) p) (FunLike.coe.{max (succ u_2) (succ u_3), succ u_2, succ u_3} (Homeomorph.{u_2, u_3} F (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_2 (instTopologicalSpaceSubtype.{u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_3)) F (fun (_x : F) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : F) => Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _x) (EmbeddingLike.toFunLike.{max (succ u_2) (succ u_3), succ u_2, succ u_3} (Homeomorph.{u_2, u_3} F (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_2 (instTopologicalSpaceSubtype.{u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_3)) F (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (EquivLike.toEmbeddingLike.{max (succ u_2) (succ u_3), succ u_2, succ u_3} (Homeomorph.{u_2, u_3} F (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_2 (instTopologicalSpaceSubtype.{u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_3)) F (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (Homeomorph.instEquivLikeHomeomorph.{u_2, u_3} F (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_2 (instTopologicalSpaceSubtype.{u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_3)))) (Homeomorph.symm.{u_3, u_2} (Set.Elem.{u_3} Z (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) F (instTopologicalSpaceSubtype.{u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _inst_3) _inst_2 (Trivialization.preimageSingletonHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 proj _inst_3 e b hb)) p) (Subtype.mk.{succ u_3} Z (fun (x : Z) => Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) x (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p)) (Eq.mpr.{0} (Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p)) (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) (proj (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p))) (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (id.{0} (Eq.{1} Prop (Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p)) (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) (proj (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p))) (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (Eq.ndrec.{0, 1} Prop (Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p)) (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (fun (_a : Prop) => Eq.{1} Prop (Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p)) (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) _a) (Eq.refl.{1} Prop (Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p)) (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)))) (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) (proj (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p))) (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (propext (Membership.mem.{u_3, u_3} Z (Set.{u_3} Z) (Set.instMembershipSet.{u_3} Z) (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p)) (Set.preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) (proj (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p))) (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (Set.mem_preimage.{u_3, u_1} Z B proj (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b) (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p)))))) (Eq.mpr.{0} (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) (proj (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p))) (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (id.{0} (Eq.{1} Prop (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) (proj (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p))) (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (Eq.ndrec.{0, succ u_1} B (proj (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p))) (fun (_a : B) => Eq.{1} Prop (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) (proj (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p))) (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) _a (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (Eq.refl.{1} Prop (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) (proj (LocalHomeomorph.toFun'.{max u_1 u_2, u_3} (Prod.{u_1, u_2} B F) Z (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u_3, max u_1 u_2} Z (Prod.{u_1, u_2} B F) _inst_3 (instTopologicalSpaceProd.{u_1, u_2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u_1, u_2, u_3} B F Z _inst_1 _inst_2 _inst_3 proj e)) (Prod.mk.{u_1, u_2} B F b p))) (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) b (Trivialization.proj_symm_apply'.{u_3, u_2, u_1} B F Z _inst_1 _inst_2 proj _inst_3 e b p hb))) (Eq.mpr.{0} (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (Eq.{succ u_1} B b b) (id.{0} (Eq.{1} Prop (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (Eq.{succ u_1} B b b)) (Eq.ndrec.{0, 1} Prop (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (fun (_a : Prop) => Eq.{1} Prop (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) _a) (Eq.refl.{1} Prop (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b))) (Eq.{succ u_1} B b b) (propext (Membership.mem.{u_1, u_1} B (Set.{u_1} B) (Set.instMembershipSet.{u_1} B) b (Singleton.singleton.{u_1, u_1} B (Set.{u_1} B) (Set.instSingletonSet.{u_1} B) b)) (Eq.{succ u_1} B b b) (Set.mem_singleton_iff.{u_1} B b b)))) (Eq.refl.{succ u_1} B b)))))
Case conversion may be inaccurate. Consider using '#align trivialization.preimage_singleton_homeomorph_symm_apply Trivialization.preimageSingletonHomeomorph_symm_applyₓ'. -/
@[simp]
theorem preimageSingletonHomeomorph_symm_apply {b : B} (hb : b ∈ e.baseSet) (p : F) :
    (e.preimageSingletonHomeomorph hb).symm p =
      ⟨e.symm (b, p), by rw [mem_preimage, e.proj_symm_apply' hb, mem_singleton_iff]⟩ :=
  rfl
#align trivialization.preimage_singleton_homeomorph_symm_apply Trivialization.preimageSingletonHomeomorph_symm_apply

/- warning: trivialization.continuous_at_proj -> Trivialization.continuousAt_proj is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.Mem.{u3, u3} Z (Set.{u3} Z) (Set.hasMem.{u3} Z) x (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (ContinuousAt.{u3, u1} Z B _inst_3 _inst_1 proj x)
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u1}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u1} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {x : Z}, (Membership.mem.{u3, u3} Z (Set.{u3} Z) (Set.instMembershipSet.{u3} Z) x (LocalEquiv.source.{u3, max u2 u1} Z (Prod.{u2, u1} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u2 u1} Z (Prod.{u2, u1} B F) _inst_3 (instTopologicalSpaceProd.{u2, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u1, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)))) -> (ContinuousAt.{u3, u2} Z B _inst_3 _inst_1 proj x)
Case conversion may be inaccurate. Consider using '#align trivialization.continuous_at_proj Trivialization.continuousAt_projₓ'. -/
/-- In the domain of a bundle trivialization, the projection is continuous-/
theorem continuousAt_proj (ex : x ∈ e.source) : ContinuousAt proj x :=
  (e.map_proj_nhds ex).le
#align trivialization.continuous_at_proj Trivialization.continuousAt_proj

/- warning: trivialization.comp_homeomorph -> Trivialization.compHomeomorph is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z], (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) -> (forall {Z' : Type.{u4}} [_inst_5 : TopologicalSpace.{u4} Z'] (h : Homeomorph.{u4, u3} Z' Z _inst_5 _inst_3), Trivialization.{u1, u2, u4} B F Z' _inst_1 _inst_2 _inst_5 (Function.comp.{succ u4, succ u3, succ u1} Z' Z B proj (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (Homeomorph.{u4, u3} Z' Z _inst_5 _inst_3) (fun (_x : Homeomorph.{u4, u3} Z' Z _inst_5 _inst_3) => Z' -> Z) (Homeomorph.hasCoeToFun.{u4, u3} Z' Z _inst_5 _inst_3) h)))
but is expected to have type
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z], (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) -> (forall {Z' : Type.{u4}} [_inst_5 : TopologicalSpace.{u4} Z'] (h : Homeomorph.{u4, u3} Z' Z _inst_5 _inst_3), Trivialization.{u1, u2, u4} B F Z' _inst_1 _inst_2 _inst_5 (Function.comp.{succ u4, succ u3, succ u1} Z' Z B proj (FunLike.coe.{max (succ u3) (succ u4), succ u4, succ u3} (Homeomorph.{u4, u3} Z' Z _inst_5 _inst_3) Z' (fun (_x : Z') => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Z') => Z) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u4), succ u4, succ u3} (Homeomorph.{u4, u3} Z' Z _inst_5 _inst_3) Z' Z (EquivLike.toEmbeddingLike.{max (succ u3) (succ u4), succ u4, succ u3} (Homeomorph.{u4, u3} Z' Z _inst_5 _inst_3) Z' Z (Homeomorph.instEquivLikeHomeomorph.{u4, u3} Z' Z _inst_5 _inst_3))) h)))
Case conversion may be inaccurate. Consider using '#align trivialization.comp_homeomorph Trivialization.compHomeomorphₓ'. -/
/-- Composition of a `trivialization` and a `homeomorph`. -/
protected def compHomeomorph {Z' : Type _} [TopologicalSpace Z'] (h : Z' ≃ₜ Z) :
    Trivialization F (proj ∘ h)
    where
  toLocalHomeomorph := h.toLocalHomeomorph.trans e.toLocalHomeomorph
  baseSet := e.baseSet
  open_baseSet := e.open_baseSet
  source_eq := by simp [e.source_eq, preimage_preimage]
  target_eq := by simp [e.target_eq]
  proj_toFun p hp := by
    have hp : h p ∈ e.source := by simpa using hp
    simp [hp]
#align trivialization.comp_homeomorph Trivialization.compHomeomorph

/- warning: trivialization.continuous_at_of_comp_right -> Trivialization.continuousAt_of_comp_right is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] {X : Type.{u4}} [_inst_5 : TopologicalSpace.{u4} X] {f : Z -> X} {z : Z} (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj), (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj z) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (ContinuousAt.{max u1 u2, u4} (Prod.{u1, u2} B F) X (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_5 (Function.comp.{succ (max u1 u2), succ u3, succ u4} (Prod.{u1, u2} B F) Z X f (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (fun (_x : LocalEquiv.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) => (Prod.{u1, u2} B F) -> Z) (LocalEquiv.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z) (LocalEquiv.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))))) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e z)) -> (ContinuousAt.{u3, u4} Z X _inst_3 _inst_5 f z)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] {X : Type.{u4}} [_inst_5 : TopologicalSpace.{u4} X] {f : Z -> X} {z : Z} (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj), (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (proj z) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (ContinuousAt.{max u3 u2, u4} (Prod.{u3, u2} B F) X (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_5 (Function.comp.{succ (max u3 u2), succ u1, succ u4} (Prod.{u3, u2} B F) Z X f (LocalEquiv.toFun.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (LocalEquiv.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e))))) (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e z)) -> (ContinuousAt.{u1, u4} Z X _inst_3 _inst_5 f z)
Case conversion may be inaccurate. Consider using '#align trivialization.continuous_at_of_comp_right Trivialization.continuousAt_of_comp_rightₓ'. -/
/-- Read off the continuity of a function `f : Z → X` at `z : Z` by transferring via a
trivialization of `Z` containing `z`. -/
theorem continuousAt_of_comp_right {X : Type _} [TopologicalSpace X] {f : Z → X} {z : Z}
    (e : Trivialization F proj) (he : proj z ∈ e.baseSet)
    (hf : ContinuousAt (f ∘ e.toLocalEquiv.symm) (e z)) : ContinuousAt f z :=
  by
  have hez : z ∈ e.to_local_equiv.symm.target :=
    by
    rw [LocalEquiv.symm_target, e.mem_source]
    exact he
  rwa [e.to_local_homeomorph.symm.continuous_at_iff_continuous_at_comp_right hez,
    LocalHomeomorph.symm_symm]
#align trivialization.continuous_at_of_comp_right Trivialization.continuousAt_of_comp_right

/- warning: trivialization.continuous_at_of_comp_left -> Trivialization.continuousAt_of_comp_left is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] {X : Type.{u4}} [_inst_5 : TopologicalSpace.{u4} X] {f : X -> Z} {x : X} (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj), (ContinuousAt.{u4, u1} X B _inst_5 _inst_1 (Function.comp.{succ u4, succ u3, succ u1} X Z B proj f) x) -> (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj (f x)) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (ContinuousAt.{u4, max u1 u2} X (Prod.{u1, u2} B F) _inst_5 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Function.comp.{succ u4, succ u3, succ (max u1 u2)} X Z (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e) f) x) -> (ContinuousAt.{u4, u3} X Z _inst_5 _inst_3 f x)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] {X : Type.{u4}} [_inst_5 : TopologicalSpace.{u4} X] {f : X -> Z} {x : X} (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj), (ContinuousAt.{u4, u3} X B _inst_5 _inst_1 (Function.comp.{succ u4, succ u1, succ u3} X Z B proj f) x) -> (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (proj (f x)) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (ContinuousAt.{u4, max u3 u2} X (Prod.{u3, u2} B F) _inst_5 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Function.comp.{succ u4, succ u1, succ (max u3 u2)} X Z (Prod.{u3, u2} B F) (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e) f) x) -> (ContinuousAt.{u4, u1} X Z _inst_5 _inst_3 f x)
Case conversion may be inaccurate. Consider using '#align trivialization.continuous_at_of_comp_left Trivialization.continuousAt_of_comp_leftₓ'. -/
/-- Read off the continuity of a function `f : X → Z` at `x : X` by transferring via a
trivialization of `Z` containing `f x`. -/
theorem continuousAt_of_comp_left {X : Type _} [TopologicalSpace X] {f : X → Z} {x : X}
    (e : Trivialization F proj) (hf_proj : ContinuousAt (proj ∘ f) x) (he : proj (f x) ∈ e.baseSet)
    (hf : ContinuousAt (e ∘ f) x) : ContinuousAt f x :=
  by
  rw [e.to_local_homeomorph.continuous_at_iff_continuous_at_comp_left]
  · exact hf
  rw [e.source_eq, ← preimage_comp]
  exact hf_proj.preimage_mem_nhds (e.open_base_set.mem_nhds he)
#align trivialization.continuous_at_of_comp_left Trivialization.continuousAt_of_comp_left

variable {E} (e' : Trivialization F (π E)) {x' : TotalSpace E} {b : B} {y : E b}

/- warning: trivialization.continuous_on -> Trivialization.continuousOn is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] (e' : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)), ContinuousOn.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (coeFn.{max (succ u1) (succ u2) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u1) (succ u2)} (Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) (fun (_x : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) => (Bundle.TotalSpace.{u1, u3} B E) -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) _inst_4) e') (LocalEquiv.source.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e')))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u1}} {E : B -> Type.{u2}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u1} F] [_inst_4 : TopologicalSpace.{max u2 u3} (Bundle.TotalSpace.{u3, u2} B E)] (e' : Trivialization.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u2} B E)), ContinuousOn.{max u3 u2, max u3 u1} (Bundle.TotalSpace.{u3, u2} B E) (Prod.{u3, u1} B F) _inst_4 (instTopologicalSpaceProd.{u3, u1} B F _inst_1 _inst_2) (Trivialization.toFun'.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u2} B E) _inst_4 e') (LocalEquiv.source.{max u3 u2, max u3 u1} (Bundle.TotalSpace.{u3, u2} B E) (Prod.{u3, u1} B F) (LocalHomeomorph.toLocalEquiv.{max u3 u2, max u3 u1} (Bundle.TotalSpace.{u3, u2} B E) (Prod.{u3, u1} B F) _inst_4 (instTopologicalSpaceProd.{u3, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u2} B E) e')))
Case conversion may be inaccurate. Consider using '#align trivialization.continuous_on Trivialization.continuousOnₓ'. -/
protected theorem continuousOn : ContinuousOn e' e'.source :=
  e'.continuous_toFun
#align trivialization.continuous_on Trivialization.continuousOn

/- warning: trivialization.coe_mem_source -> Trivialization.coe_mem_source is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] (e' : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B} {y : E b}, Iff (Membership.Mem.{max u1 u3, max u1 u3} (Bundle.TotalSpace.{u1, u3} B E) (Set.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)) (Set.hasMem.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)) ((fun (a : Type.{u3}) (b : Type.{max u1 u3}) [self : HasLiftT.{succ u3, succ (max u1 u3)} a b] => self.0) (E b) (Bundle.TotalSpace.{u1, u3} B E) (HasLiftT.mk.{succ u3, succ (max u1 u3)} (E b) (Bundle.TotalSpace.{u1, u3} B E) (CoeTCₓ.coe.{succ u3, succ (max u1 u3)} (E b) (Bundle.TotalSpace.{u1, u3} B E) (Bundle.TotalSpace.hasCoeT.{u1, u3} B E b))) y) (LocalEquiv.source.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e')))) (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e'))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u1}} {E : B -> Type.{u2}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u1} F] [_inst_4 : TopologicalSpace.{max u2 u3} (Bundle.TotalSpace.{u3, u2} B E)] (e' : Trivialization.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u2} B E)) {b : B} {y : E b}, Iff (Membership.mem.{max u3 u2, max u3 u2} (Bundle.TotalSpace.{u3, u2} B E) (Set.{max u3 u2} (Bundle.TotalSpace.{u3, u2} B E)) (Set.instMembershipSet.{max u3 u2} (Bundle.TotalSpace.{u3, u2} B E)) (Bundle.totalSpaceMk.{u3, u2} B E b y) (LocalEquiv.source.{max u3 u2, max u3 u1} (Bundle.TotalSpace.{u3, u2} B E) (Prod.{u3, u1} B F) (LocalHomeomorph.toLocalEquiv.{max u3 u2, max u3 u1} (Bundle.TotalSpace.{u3, u2} B E) (Prod.{u3, u1} B F) _inst_4 (instTopologicalSpaceProd.{u3, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u2} B E) e')))) (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u2} B E) e'))
Case conversion may be inaccurate. Consider using '#align trivialization.coe_mem_source Trivialization.coe_mem_sourceₓ'. -/
theorem coe_mem_source : ↑y ∈ e'.source ↔ b ∈ e'.baseSet :=
  e'.mem_source
#align trivialization.coe_mem_source Trivialization.coe_mem_source

/- warning: trivialization.open_target -> Trivialization.open_target' is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] (e' : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)), IsOpen.{max u1 u2} (Prod.{u1, u2} B F) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (LocalEquiv.target.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e')))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u3, u1} B E)] (e' : Trivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E)), IsOpen.{max u3 u2} (Prod.{u3, u2} B F) (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (LocalEquiv.target.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) _inst_4 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e')))
Case conversion may be inaccurate. Consider using '#align trivialization.open_target Trivialization.open_target'ₓ'. -/
theorem open_target' : IsOpen e'.target :=
  by
  rw [e'.target_eq]
  exact e'.open_base_set.prod isOpen_univ
#align trivialization.open_target Trivialization.open_target'

/- warning: trivialization.coe_coe_fst -> Trivialization.coe_coe_fst is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] (e' : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B} {y : E b}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e')) -> (Eq.{succ u1} B (Prod.fst.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u1) (succ u2)} (Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) (fun (_x : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) => (Bundle.TotalSpace.{u1, u3} B E) -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) _inst_4) e' ((fun (a : Type.{u3}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{succ u3, max (succ u1) (succ u3)} a b] => self.0) (E b) (Bundle.TotalSpace.{u1, u3} B E) (HasLiftT.mk.{succ u3, max (succ u1) (succ u3)} (E b) (Bundle.TotalSpace.{u1, u3} B E) (CoeTCₓ.coe.{succ u3, max (succ u1) (succ u3)} (E b) (Bundle.TotalSpace.{u1, u3} B E) (Bundle.TotalSpace.hasCoeT.{u1, u3} B E b))) y))) b)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u3, u1} B E)] (e' : Trivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B} {y : E b}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e')) -> (Eq.{succ u3} B (Prod.fst.{u3, u2} B F (Trivialization.toFun'.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) _inst_4 e' (Bundle.totalSpaceMk.{u3, u1} B E b y))) b)
Case conversion may be inaccurate. Consider using '#align trivialization.coe_coe_fst Trivialization.coe_coe_fstₓ'. -/
@[simp, mfld_simps]
theorem coe_coe_fst (hb : b ∈ e'.baseSet) : (e' y).1 = b :=
  e'.coe_fst (e'.mem_source.2 hb)
#align trivialization.coe_coe_fst Trivialization.coe_coe_fst

/- warning: trivialization.mk_mem_target -> Trivialization.mk_mem_target is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] (e' : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B} {y : F}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} B F) (Set.{max u1 u2} (Prod.{u1, u2} B F)) (Set.hasMem.{max u1 u2} (Prod.{u1, u2} B F)) (Prod.mk.{u1, u2} B F b y) (LocalEquiv.target.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e')))) (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e'))
but is expected to have type
  forall {B : Type.{u2}} {F : Type.{u3}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u2} B] [_inst_2 : TopologicalSpace.{u3} F] [_inst_4 : TopologicalSpace.{max u1 u2} (Bundle.TotalSpace.{u2, u1} B E)] (e' : Trivialization.{u2, u3, max u2 u1} B F (Bundle.TotalSpace.{u2, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u2, u1} B E)) {b : B} {y : F}, Iff (Membership.mem.{max u3 u2, max u2 u3} (Prod.{u2, u3} B F) (Set.{max u2 u3} (Prod.{u2, u3} B F)) (Set.instMembershipSet.{max u2 u3} (Prod.{u2, u3} B F)) (Prod.mk.{u2, u3} B F b y) (LocalEquiv.target.{max u2 u1, max u2 u3} (Bundle.TotalSpace.{u2, u1} B E) (Prod.{u2, u3} B F) (LocalHomeomorph.toLocalEquiv.{max u2 u1, max u2 u3} (Bundle.TotalSpace.{u2, u1} B E) (Prod.{u2, u3} B F) _inst_4 (instTopologicalSpaceProd.{u2, u3} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u2, u3, max u2 u1} B F (Bundle.TotalSpace.{u2, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u2, u1} B E) e')))) (Membership.mem.{u2, u2} B (Set.{u2} B) (Set.instMembershipSet.{u2} B) b (Trivialization.baseSet.{u2, u3, max u2 u1} B F (Bundle.TotalSpace.{u2, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u2, u1} B E) e'))
Case conversion may be inaccurate. Consider using '#align trivialization.mk_mem_target Trivialization.mk_mem_targetₓ'. -/
theorem mk_mem_target {y : F} : (b, y) ∈ e'.target ↔ b ∈ e'.baseSet :=
  e'.toPretrivialization.mem_target
#align trivialization.mk_mem_target Trivialization.mk_mem_target

/- warning: trivialization.symm_apply_apply -> Trivialization.symm_apply_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] (e' : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) {x : Bundle.TotalSpace.{u1, u3} B E}, (Membership.Mem.{max u1 u3, max u1 u3} (Bundle.TotalSpace.{u1, u3} B E) (Set.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)) (Set.hasMem.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)) x (LocalEquiv.source.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e')))) -> (Eq.{max (succ u1) (succ u3)} (Bundle.TotalSpace.{u1, u3} B E) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (fun (_x : LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalHomeomorph.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (LocalHomeomorph.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e')) (coeFn.{max (succ u1) (succ u2) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u1) (succ u2)} (Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) (fun (_x : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) => (Bundle.TotalSpace.{u1, u3} B E) -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) _inst_4) e' x)) x)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u1}} {E : B -> Type.{u2}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u1} F] [_inst_4 : TopologicalSpace.{max u2 u3} (Bundle.TotalSpace.{u3, u2} B E)] (e' : Trivialization.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u2} B E)) {x : Bundle.TotalSpace.{u3, u2} B E}, (Membership.mem.{max u3 u2, max u3 u2} (Bundle.TotalSpace.{u3, u2} B E) (Set.{max u3 u2} (Bundle.TotalSpace.{u3, u2} B E)) (Set.instMembershipSet.{max u3 u2} (Bundle.TotalSpace.{u3, u2} B E)) x (LocalEquiv.source.{max u3 u2, max u3 u1} (Bundle.TotalSpace.{u3, u2} B E) (Prod.{u3, u1} B F) (LocalHomeomorph.toLocalEquiv.{max u3 u2, max u3 u1} (Bundle.TotalSpace.{u3, u2} B E) (Prod.{u3, u1} B F) _inst_4 (instTopologicalSpaceProd.{u3, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u2} B E) e')))) -> (Eq.{max (succ u3) (succ u2)} (Bundle.TotalSpace.{u3, u2} B E) (LocalHomeomorph.toFun'.{max u3 u1, max u3 u2} (Prod.{u3, u1} B F) (Bundle.TotalSpace.{u3, u2} B E) (instTopologicalSpaceProd.{u3, u1} B F _inst_1 _inst_2) _inst_4 (LocalHomeomorph.symm.{max u3 u2, max u3 u1} (Bundle.TotalSpace.{u3, u2} B E) (Prod.{u3, u1} B F) _inst_4 (instTopologicalSpaceProd.{u3, u1} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u2} B E) e')) (Trivialization.toFun'.{u3, u1, max u3 u2} B F (Bundle.TotalSpace.{u3, u2} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u2} B E) _inst_4 e' x)) x)
Case conversion may be inaccurate. Consider using '#align trivialization.symm_apply_apply Trivialization.symm_apply_applyₓ'. -/
theorem symm_apply_apply {x : TotalSpace E} (hx : x ∈ e'.source) :
    e'.toLocalHomeomorph.symm (e' x) = x :=
  e'.toLocalEquiv.left_inv hx
#align trivialization.symm_apply_apply Trivialization.symm_apply_apply

/- warning: trivialization.symm_coe_proj -> Trivialization.symm_coe_proj is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] {x : B} {y : F} (e : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)), (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) x (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) -> (Eq.{succ u1} B (Sigma.fst.{u1, u3} B (fun (x : B) => E x) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (fun (_x : LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalHomeomorph.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (LocalHomeomorph.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (Prod.mk.{u1, u2} B F x y))) x)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u3, u1} B E)] {x : B} {y : F} (e : Trivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E)), (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) x (Trivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) -> (Eq.{succ u3} B (Sigma.fst.{u3, u1} B (fun (x : B) => E x) (LocalHomeomorph.toFun'.{max u3 u2, max u3 u1} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_4 (LocalHomeomorph.symm.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) _inst_4 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (Prod.mk.{u3, u2} B F x y))) x)
Case conversion may be inaccurate. Consider using '#align trivialization.symm_coe_proj Trivialization.symm_coe_projₓ'. -/
@[simp, mfld_simps]
theorem symm_coe_proj {x : B} {y : F} (e : Trivialization F (π E)) (h : x ∈ e.baseSet) :
    (e.toLocalHomeomorph.symm (x, y)).1 = x :=
  e.proj_symm_apply' h
#align trivialization.symm_coe_proj Trivialization.symm_coe_proj

section Zero

variable [∀ x, Zero (E x)]

#print Trivialization.symm /-
/-- A fiberwise inverse to `e'`. The function `F → E x` that induces a local inverse
`B × F → total_space E` of `e'` on `e'.base_set`. It is defined to be `0` outside `e'.base_set`. -/
protected noncomputable def symm (e : Trivialization F (π E)) (b : B) (y : F) : E b :=
  e.toPretrivialization.symm b y
#align trivialization.symm Trivialization.symm
-/

/- warning: trivialization.symm_apply -> Trivialization.symm_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] [_inst_5 : forall (x : B), Zero.{u3} (E x)] (e : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B} (hb : Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (y : F), Eq.{succ u3} (E b) (Trivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e b y) (cast.{succ u3} (E (Sigma.fst.{u1, u3} B (fun (x : B) => E x) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (fun (_x : LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalHomeomorph.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (LocalHomeomorph.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (Prod.mk.{u1, u2} B F b y)))) (E b) (congr_arg.{succ u1, succ (succ u3)} B Type.{u3} (Sigma.fst.{u1, u3} B (fun (x : B) => E x) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (fun (_x : LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalHomeomorph.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (LocalHomeomorph.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (Prod.mk.{u1, u2} B F b y))) b E (Trivialization.symm_coe_proj.{u1, u2, u3} B F E _inst_1 _inst_2 _inst_4 b y e hb)) (Sigma.snd.{u1, u3} B (fun (x : B) => E x) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (fun (_x : LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalHomeomorph.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (LocalHomeomorph.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (Prod.mk.{u1, u2} B F b y))))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u3, u1} B E)] [_inst_5 : forall (x : B), Zero.{u1} (E x)] (e : Trivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B} (hb : Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (y : F), Eq.{succ u1} (E b) (Trivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e b y) (cast.{succ u1} (E (Sigma.fst.{u3, u1} B (fun (x : B) => E x) (LocalHomeomorph.toFun'.{max u3 u2, max u3 u1} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_4 (LocalHomeomorph.symm.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) _inst_4 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (Prod.mk.{u3, u2} B F b y)))) (E b) (congr_arg.{succ u3, succ (succ u1)} B Type.{u1} (Sigma.fst.{u3, u1} B (fun (x : B) => E x) (LocalHomeomorph.toFun'.{max u3 u2, max u3 u1} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_4 (LocalHomeomorph.symm.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) _inst_4 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (Prod.mk.{u3, u2} B F b y))) b E (Trivialization.symm_coe_proj.{u1, u2, u3} B F E _inst_1 _inst_2 _inst_4 b y e hb)) (Sigma.snd.{u3, u1} B (fun (x : B) => E x) (LocalHomeomorph.toFun'.{max u3 u2, max u3 u1} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_4 (LocalHomeomorph.symm.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) _inst_4 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (Prod.mk.{u3, u2} B F b y))))
Case conversion may be inaccurate. Consider using '#align trivialization.symm_apply Trivialization.symm_applyₓ'. -/
theorem symm_apply (e : Trivialization F (π E)) {b : B} (hb : b ∈ e.baseSet) (y : F) :
    e.symm b y = cast (congr_arg E (e.symm_coe_proj hb)) (e.toLocalHomeomorph.symm (b, y)).2 :=
  dif_pos hb
#align trivialization.symm_apply Trivialization.symm_apply

/- warning: trivialization.symm_apply_of_not_mem -> Trivialization.symm_apply_of_not_mem is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] [_inst_5 : forall (x : B), Zero.{u3} (E x)] (e : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B}, (Not (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e))) -> (forall (y : F), Eq.{succ u3} (E b) (Trivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e b y) (OfNat.ofNat.{u3} (E b) 0 (OfNat.mk.{u3} (E b) 0 (Zero.zero.{u3} (E b) (_inst_5 b)))))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u3, u1} B E)] [_inst_5 : forall (x : B), Zero.{u1} (E x)] (e : Trivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B}, (Not (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e))) -> (forall (y : F), Eq.{succ u1} (E b) (Trivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e b y) (OfNat.ofNat.{u1} (E b) 0 (Zero.toOfNat0.{u1} (E b) (_inst_5 b))))
Case conversion may be inaccurate. Consider using '#align trivialization.symm_apply_of_not_mem Trivialization.symm_apply_of_not_memₓ'. -/
theorem symm_apply_of_not_mem (e : Trivialization F (π E)) {b : B} (hb : b ∉ e.baseSet) (y : F) :
    e.symm b y = 0 :=
  dif_neg hb
#align trivialization.symm_apply_of_not_mem Trivialization.symm_apply_of_not_mem

/- warning: trivialization.mk_symm -> Trivialization.mk_symm is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] [_inst_5 : forall (x : B), Zero.{u3} (E x)] (e : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) -> (forall (y : F), Eq.{max (succ u1) (succ u3)} (Bundle.TotalSpace.{u1, u3} B E) (Bundle.totalSpaceMk.{u1, u3} B E b (Trivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e b y)) (coeFn.{max (succ (max u1 u2)) (succ (max u1 u3)), max (succ (max u1 u2)) (succ (max u1 u3))} (LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (fun (_x : LocalHomeomorph.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) => (Prod.{u1, u2} B F) -> (Bundle.TotalSpace.{u1, u3} B E)) (LocalHomeomorph.hasCoeToFun.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4) (LocalHomeomorph.symm.{max u1 u3, max u1 u2} (Bundle.TotalSpace.{u1, u3} B E) (Prod.{u1, u2} B F) _inst_4 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) (Prod.mk.{u1, u2} B F b y)))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u3, u1} B E)] [_inst_5 : forall (x : B), Zero.{u1} (E x)] (e : Trivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) -> (forall (y : F), Eq.{max (succ u3) (succ u1)} (Bundle.TotalSpace.{u3, u1} B E) (Bundle.totalSpaceMk.{u3, u1} B E b (Trivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e b y)) (LocalHomeomorph.toFun'.{max u3 u2, max u3 u1} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_4 (LocalHomeomorph.symm.{max u3 u1, max u3 u2} (Bundle.TotalSpace.{u3, u1} B E) (Prod.{u3, u2} B F) _inst_4 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) (Prod.mk.{u3, u2} B F b y)))
Case conversion may be inaccurate. Consider using '#align trivialization.mk_symm Trivialization.mk_symmₓ'. -/
theorem mk_symm (e : Trivialization F (π E)) {b : B} (hb : b ∈ e.baseSet) (y : F) :
    totalSpaceMk b (e.symm b y) = e.toLocalHomeomorph.symm (b, y) :=
  e.toPretrivialization.mk_symm hb y
#align trivialization.mk_symm Trivialization.mk_symm

/- warning: trivialization.symm_proj_apply -> Trivialization.symm_proj_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] [_inst_5 : forall (x : B), Zero.{u3} (E x)] (e : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) (z : Bundle.TotalSpace.{u1, u3} B E), (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (Bundle.TotalSpace.proj.{u1, u3} B E z) (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) -> (Eq.{succ u3} (E (Bundle.TotalSpace.proj.{u1, u3} B E z)) (Trivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e (Bundle.TotalSpace.proj.{u1, u3} B E z) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u1) (succ u2)} (Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) (fun (_x : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) => (Bundle.TotalSpace.{u1, u3} B E) -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) _inst_4) e z))) (Sigma.snd.{u1, u3} B (fun (x : B) => E x) z))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u3, u1} B E)] [_inst_5 : forall (x : B), Zero.{u1} (E x)] (e : Trivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E)) (z : Bundle.TotalSpace.{u3, u1} B E), (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (Bundle.TotalSpace.proj.{u3, u1} B E z) (Trivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) -> (Eq.{succ u1} (E (Bundle.TotalSpace.proj.{u3, u1} B E z)) (Trivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e (Bundle.TotalSpace.proj.{u3, u1} B E z) (Prod.snd.{u3, u2} B F (Trivialization.toFun'.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) _inst_4 e z))) (Sigma.snd.{u3, u1} B (fun (x : B) => E x) z))
Case conversion may be inaccurate. Consider using '#align trivialization.symm_proj_apply Trivialization.symm_proj_applyₓ'. -/
theorem symm_proj_apply (e : Trivialization F (π E)) (z : TotalSpace E) (hz : z.proj ∈ e.baseSet) :
    e.symm z.proj (e z).2 = z.2 :=
  e.toPretrivialization.symm_proj_apply z hz
#align trivialization.symm_proj_apply Trivialization.symm_proj_apply

/- warning: trivialization.symm_apply_apply_mk -> Trivialization.symm_apply_apply_mk is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] [_inst_5 : forall (x : B), Zero.{u3} (E x)] (e : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) -> (forall (y : E b), Eq.{succ u3} (E b) (Trivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e b (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u1) (succ u2)} (Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) (fun (_x : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) => (Bundle.TotalSpace.{u1, u3} B E) -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) _inst_4) e (Bundle.totalSpaceMk.{u1, u3} B E b y)))) y)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u3, u1} B E)] [_inst_5 : forall (x : B), Zero.{u1} (E x)] (e : Trivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) -> (forall (y : E b), Eq.{succ u1} (E b) (Trivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e b (Prod.snd.{u3, u2} B F (Trivialization.toFun'.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) _inst_4 e (Bundle.totalSpaceMk.{u3, u1} B E b y)))) y)
Case conversion may be inaccurate. Consider using '#align trivialization.symm_apply_apply_mk Trivialization.symm_apply_apply_mkₓ'. -/
theorem symm_apply_apply_mk (e : Trivialization F (π E)) {b : B} (hb : b ∈ e.baseSet) (y : E b) :
    e.symm b (e (totalSpaceMk b y)).2 = y :=
  e.symm_proj_apply (totalSpaceMk b y) hb
#align trivialization.symm_apply_apply_mk Trivialization.symm_apply_apply_mk

/- warning: trivialization.apply_mk_symm -> Trivialization.apply_mk_symm is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] [_inst_5 : forall (x : B), Zero.{u3} (E x)] (e : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e)) -> (forall (y : F), Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ (max u1 u3)), max (succ (max u1 u3)) (succ u1) (succ u2)} (Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) (fun (_x : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)) => (Bundle.TotalSpace.{u1, u3} B E) -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u1, u3} B E) _inst_4) e (Bundle.totalSpaceMk.{u1, u3} B E b (Trivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e b y))) (Prod.mk.{u1, u2} B F b y))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u3, u1} B E)] [_inst_5 : forall (x : B), Zero.{u1} (E x)] (e : Trivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E)) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e)) -> (forall (y : F), Eq.{max (succ u3) (succ u2)} (Prod.{u3, u2} B F) (Trivialization.toFun'.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 (Bundle.TotalSpace.proj.{u3, u1} B E) _inst_4 e (Bundle.totalSpaceMk.{u3, u1} B E b (Trivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e b y))) (Prod.mk.{u3, u2} B F b y))
Case conversion may be inaccurate. Consider using '#align trivialization.apply_mk_symm Trivialization.apply_mk_symmₓ'. -/
theorem apply_mk_symm (e : Trivialization F (π E)) {b : B} (hb : b ∈ e.baseSet) (y : F) :
    e (totalSpaceMk b (e.symm b y)) = (b, y) :=
  e.toPretrivialization.apply_mk_symm hb y
#align trivialization.apply_mk_symm Trivialization.apply_mk_symm

/- warning: trivialization.continuous_on_symm -> Trivialization.continuousOn_symm is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {E : B -> Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u1, u3} B E)] [_inst_5 : forall (x : B), Zero.{u3} (E x)] (e : Trivialization.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E)), ContinuousOn.{max u1 u2, max u1 u3} (Prod.{u1, u2} B F) (Bundle.TotalSpace.{u1, u3} B E) (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_4 (fun (z : Prod.{u1, u2} B F) => Bundle.totalSpaceMk.{u1, u3} B E (Prod.fst.{u1, u2} B F z) (Trivialization.symm.{u1, u2, u3} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e (Prod.fst.{u1, u2} B F z) (Prod.snd.{u1, u2} B F z))) (Set.prod.{u1, u2} B F (Trivialization.baseSet.{u1, u2, max u1 u3} B F (Bundle.TotalSpace.{u1, u3} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u1, u3} B E) e) (Set.univ.{u2} F))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {E : B -> Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] [_inst_4 : TopologicalSpace.{max u1 u3} (Bundle.TotalSpace.{u3, u1} B E)] [_inst_5 : forall (x : B), Zero.{u1} (E x)] (e : Trivialization.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E)), ContinuousOn.{max u3 u2, max u1 u3} (Prod.{u3, u2} B F) (Bundle.TotalSpace.{u3, u1} B E) (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_4 (fun (z : Prod.{u3, u2} B F) => Bundle.totalSpaceMk.{u3, u1} B E (Prod.fst.{u3, u2} B F z) (Trivialization.symm.{u3, u2, u1} B F E _inst_1 _inst_2 _inst_4 (fun (x : B) => _inst_5 x) e (Prod.fst.{u3, u2} B F z) (Prod.snd.{u3, u2} B F z))) (Set.prod.{u3, u2} B F (Trivialization.baseSet.{u3, u2, max u3 u1} B F (Bundle.TotalSpace.{u3, u1} B E) _inst_1 _inst_2 _inst_4 (Bundle.TotalSpace.proj.{u3, u1} B E) e) (Set.univ.{u2} F))
Case conversion may be inaccurate. Consider using '#align trivialization.continuous_on_symm Trivialization.continuousOn_symmₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem continuousOn_symm (e : Trivialization F (π E)) :
    ContinuousOn (fun z : B × F => totalSpaceMk z.1 (e.symm z.1 z.2)) (e.baseSet ×ˢ univ) :=
  by
  have :
    ∀ (z : B × F) (hz : z ∈ e.base_set ×ˢ (univ : Set F)),
      total_space_mk z.1 (e.symm z.1 z.2) = e.to_local_homeomorph.symm z :=
    by
    rintro x ⟨hx : x.1 ∈ e.base_set, _⟩
    simp_rw [e.mk_symm hx, Prod.mk.eta]
  refine' ContinuousOn.congr _ this
  rw [← e.target_eq]
  exact e.to_local_homeomorph.continuous_on_symm
#align trivialization.continuous_on_symm Trivialization.continuousOn_symm

end Zero

#print Trivialization.transFiberHomeomorph /-
/-- If `e` is a `trivialization` of `proj : Z → B` with fiber `F` and `h` is a homeomorphism
`F ≃ₜ F'`, then `e.trans_fiber_homeomorph h` is the trivialization of `proj` with the fiber `F'`
that sends `p : Z` to `((e p).1, h (e p).2)`. -/
def transFiberHomeomorph {F' : Type _} [TopologicalSpace F'] (e : Trivialization F proj)
    (h : F ≃ₜ F') : Trivialization F' proj
    where
  toLocalHomeomorph := e.toLocalHomeomorph.transHomeomorph <| (Homeomorph.refl _).prodCongr h
  baseSet := e.baseSet
  open_baseSet := e.open_baseSet
  source_eq := e.source_eq
  target_eq := by simp [e.target_eq, prod_univ, preimage_preimage]
  proj_toFun := e.proj_toFun
#align trivialization.trans_fiber_homeomorph Trivialization.transFiberHomeomorph
-/

/- warning: trivialization.trans_fiber_homeomorph_apply -> Trivialization.transFiberHomeomorph_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] {F' : Type.{u4}} [_inst_5 : TopologicalSpace.{u4} F'] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (h : Homeomorph.{u2, u4} F F' _inst_2 _inst_5) (x : Z), Eq.{max (succ u1) (succ u4)} (Prod.{u1, u4} B F') (coeFn.{max (succ u1) (succ u4) (succ u3), max (succ u3) (succ u1) (succ u4)} (Trivialization.{u1, u4, u3} B F' Z _inst_1 _inst_5 _inst_3 proj) (fun (_x : Trivialization.{u1, u4, u3} B F' Z _inst_1 _inst_5 _inst_3 proj) => Z -> (Prod.{u1, u4} B F')) (Trivialization.hasCoeToFun.{u1, u4, u3} B F' Z _inst_1 _inst_5 proj _inst_3) (Trivialization.transFiberHomeomorph.{u1, u2, u3, u4} B F Z _inst_1 _inst_2 proj _inst_3 F' _inst_5 e h) x) (Prod.mk.{u1, u4} B F' (Prod.fst.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e x)) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (Homeomorph.{u2, u4} F F' _inst_2 _inst_5) (fun (_x : Homeomorph.{u2, u4} F F' _inst_2 _inst_5) => F -> F') (Homeomorph.hasCoeToFun.{u2, u4} F F' _inst_2 _inst_5) h (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e x))))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] {F' : Type.{u4}} [_inst_5 : TopologicalSpace.{u4} F'] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (h : Homeomorph.{u2, u4} F F' _inst_2 _inst_5) (x : Z), Eq.{max (succ u3) (succ u4)} (Prod.{u3, u4} B F') (Trivialization.toFun'.{u3, u4, u1} B F' Z _inst_1 _inst_5 proj _inst_3 (Trivialization.transFiberHomeomorph.{u3, u2, u1, u4} B F Z _inst_1 _inst_2 proj _inst_3 F' _inst_5 e h) x) (Prod.mk.{u3, u4} B ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : F) => F') (Prod.snd.{u3, u2} B F (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e x))) (Prod.fst.{u3, u2} B F (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e x)) (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (Homeomorph.{u2, u4} F F' _inst_2 _inst_5) F (fun (_x : F) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : F) => F') _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u4), succ u2, succ u4} (Homeomorph.{u2, u4} F F' _inst_2 _inst_5) F F' (EquivLike.toEmbeddingLike.{max (succ u2) (succ u4), succ u2, succ u4} (Homeomorph.{u2, u4} F F' _inst_2 _inst_5) F F' (Homeomorph.instEquivLikeHomeomorph.{u2, u4} F F' _inst_2 _inst_5))) h (Prod.snd.{u3, u2} B F (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e x))))
Case conversion may be inaccurate. Consider using '#align trivialization.trans_fiber_homeomorph_apply Trivialization.transFiberHomeomorph_applyₓ'. -/
@[simp]
theorem transFiberHomeomorph_apply {F' : Type _} [TopologicalSpace F'] (e : Trivialization F proj)
    (h : F ≃ₜ F') (x : Z) : e.transFiberHomeomorph h x = ((e x).1, h (e x).2) :=
  rfl
#align trivialization.trans_fiber_homeomorph_apply Trivialization.transFiberHomeomorph_apply

#print Trivialization.coordChange /-
/-- Coordinate transformation in the fiber induced by a pair of bundle trivializations. See also
`trivialization.coord_change_homeomorph` for a version bundled as `F ≃ₜ F`. -/
def coordChange (e₁ e₂ : Trivialization F proj) (b : B) (x : F) : F :=
  (e₂ <| e₁.toLocalHomeomorph.symm (b, x)).2
#align trivialization.coord_change Trivialization.coordChange
-/

/- warning: trivialization.mk_coord_change -> Trivialization.mk_coordChange is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e₁ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e₂ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) -> (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e₂)) -> (forall (x : F), Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (Prod.mk.{u1, u2} B F b (Trivialization.coordChange.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ b x)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e₂ (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (fun (_x : LocalHomeomorph.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} B F) -> Z) (LocalHomeomorph.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} B F) Z (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) _inst_3) (LocalHomeomorph.symm.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) (Prod.mk.{u1, u2} B F b x))))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e₁ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (e₂ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) -> (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e₂)) -> (forall (x : F), Eq.{max (succ u3) (succ u2)} (Prod.{u3, u2} B F) (Prod.mk.{u3, u2} B F b (Trivialization.coordChange.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ b x)) (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₂ (LocalHomeomorph.toFun'.{max u3 u2, u1} (Prod.{u3, u2} B F) Z (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) _inst_3 (LocalHomeomorph.symm.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) (Prod.mk.{u3, u2} B F b x))))
Case conversion may be inaccurate. Consider using '#align trivialization.mk_coord_change Trivialization.mk_coordChangeₓ'. -/
theorem mk_coordChange (e₁ e₂ : Trivialization F proj) {b : B} (h₁ : b ∈ e₁.baseSet)
    (h₂ : b ∈ e₂.baseSet) (x : F) :
    (b, e₁.coordChange e₂ b x) = e₂ (e₁.toLocalHomeomorph.symm (b, x)) :=
  by
  refine' Prod.ext _ rfl
  rw [e₂.coe_fst', ← e₁.coe_fst', e₁.apply_symm_apply' h₁]
  · rwa [e₁.proj_symm_apply' h₁]
  · rwa [e₁.proj_symm_apply' h₁]
#align trivialization.mk_coord_change Trivialization.mk_coordChange

/- warning: trivialization.coord_change_apply_snd -> Trivialization.coordChange_apply_snd is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e₁ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e₂ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {p : Z}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) (proj p) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) -> (Eq.{succ u2} F (Trivialization.coordChange.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ (proj p) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e₁ p))) (Prod.snd.{u1, u2} B F (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e₂ p)))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e₁ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (e₂ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {p : Z}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) (proj p) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) -> (Eq.{succ u2} F (Trivialization.coordChange.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ (proj p) (Prod.snd.{u3, u2} B F (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₁ p))) (Prod.snd.{u3, u2} B F (Trivialization.toFun'.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₂ p)))
Case conversion may be inaccurate. Consider using '#align trivialization.coord_change_apply_snd Trivialization.coordChange_apply_sndₓ'. -/
theorem coordChange_apply_snd (e₁ e₂ : Trivialization F proj) {p : Z} (h : proj p ∈ e₁.baseSet) :
    e₁.coordChange e₂ (proj p) (e₁ p).snd = (e₂ p).snd := by
  rw [coord_change, e₁.symm_apply_mk_proj (e₁.mem_source.2 h)]
#align trivialization.coord_change_apply_snd Trivialization.coordChange_apply_snd

/- warning: trivialization.coord_change_same_apply -> Trivialization.coordChange_same_apply is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (forall (x : F), Eq.{succ u2} F (Trivialization.coordChange.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e e b x) x)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (forall (x : F), Eq.{succ u2} F (Trivialization.coordChange.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e e b x) x)
Case conversion may be inaccurate. Consider using '#align trivialization.coord_change_same_apply Trivialization.coordChange_same_applyₓ'. -/
theorem coordChange_same_apply (e : Trivialization F proj) {b : B} (h : b ∈ e.baseSet) (x : F) :
    e.coordChange e b x = x := by rw [coord_change, e.apply_symm_apply' h]
#align trivialization.coord_change_same_apply Trivialization.coordChange_same_apply

/- warning: trivialization.coord_change_same -> Trivialization.coordChange_same is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{succ u2} (F -> F) (Trivialization.coordChange.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e e b) (id.{succ u2} F))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Eq.{succ u2} (F -> F) (Trivialization.coordChange.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e e b) (id.{succ u2} F))
Case conversion may be inaccurate. Consider using '#align trivialization.coord_change_same Trivialization.coordChange_sameₓ'. -/
theorem coordChange_same (e : Trivialization F proj) {b : B} (h : b ∈ e.baseSet) :
    e.coordChange e b = id :=
  funext <| e.coordChange_same_apply h
#align trivialization.coord_change_same Trivialization.coordChange_same

/- warning: trivialization.coord_change_coord_change -> Trivialization.coordChange_coordChange is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e₁ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e₂ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e₃ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) -> (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e₂)) -> (forall (x : F), Eq.{succ u2} F (Trivialization.coordChange.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e₂ e₃ b (Trivialization.coordChange.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ b x)) (Trivialization.coordChange.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₃ b x))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e₁ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (e₂ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (e₃ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) -> (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e₂)) -> (forall (x : F), Eq.{succ u2} F (Trivialization.coordChange.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₂ e₃ b (Trivialization.coordChange.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ b x)) (Trivialization.coordChange.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₃ b x))
Case conversion may be inaccurate. Consider using '#align trivialization.coord_change_coord_change Trivialization.coordChange_coordChangeₓ'. -/
theorem coordChange_coordChange (e₁ e₂ e₃ : Trivialization F proj) {b : B} (h₁ : b ∈ e₁.baseSet)
    (h₂ : b ∈ e₂.baseSet) (x : F) :
    e₂.coordChange e₃ b (e₁.coordChange e₂ b x) = e₁.coordChange e₃ b x :=
  by
  rw [coord_change, e₁.mk_coord_change _ h₁ h₂, ← e₂.coe_coe, e₂.to_local_homeomorph.left_inv,
    coord_change]
  rwa [e₂.mem_source, e₁.proj_symm_apply' h₁]
#align trivialization.coord_change_coord_change Trivialization.coordChange_coordChange

/- warning: trivialization.continuous_coord_change -> Trivialization.continuous_coordChange is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e₁ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e₂ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) -> (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e₂)) -> (Continuous.{u2, u2} F F _inst_2 _inst_2 (Trivialization.coordChange.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ b))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e₁ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (e₂ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B}, (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) -> (Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e₂)) -> (Continuous.{u2, u2} F F _inst_2 _inst_2 (Trivialization.coordChange.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ b))
Case conversion may be inaccurate. Consider using '#align trivialization.continuous_coord_change Trivialization.continuous_coordChangeₓ'. -/
theorem continuous_coordChange (e₁ e₂ : Trivialization F proj) {b : B} (h₁ : b ∈ e₁.baseSet)
    (h₂ : b ∈ e₂.baseSet) : Continuous (e₁.coordChange e₂ b) :=
  by
  refine'
    continuous_snd.comp
      (e₂.to_local_homeomorph.continuous_on.comp_continuous
        (e₁.to_local_homeomorph.continuous_on_symm.comp_continuous _ _) _)
  · exact continuous_const.prod_mk continuous_id
  · exact fun x => e₁.mem_target.2 h₁
  · intro x
    rwa [e₂.mem_source, e₁.proj_symm_apply' h₁]
#align trivialization.continuous_coord_change Trivialization.continuous_coordChange

#print Trivialization.coordChangeHomeomorph /-
/-- Coordinate transformation in the fiber induced by a pair of bundle trivializations,
as a homeomorphism. -/
protected def coordChangeHomeomorph (e₁ e₂ : Trivialization F proj) {b : B} (h₁ : b ∈ e₁.baseSet)
    (h₂ : b ∈ e₂.baseSet) : F ≃ₜ F
    where
  toFun := e₁.coordChange e₂ b
  invFun := e₂.coordChange e₁ b
  left_inv x := by simp only [*, coord_change_coord_change, coord_change_same_apply]
  right_inv x := by simp only [*, coord_change_coord_change, coord_change_same_apply]
  continuous_toFun := e₁.continuous_coordChange e₂ h₁ h₂
  continuous_invFun := e₂.continuous_coordChange e₁ h₂ h₁
#align trivialization.coord_change_homeomorph Trivialization.coordChangeHomeomorph
-/

/- warning: trivialization.coord_change_homeomorph_coe -> Trivialization.coordChangeHomeomorph_coe is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e₁ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e₂ : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B} (h₁ : Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) (h₂ : Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) b (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e₂)), Eq.{succ u2} (F -> F) (coeFn.{succ u2, succ u2} (Homeomorph.{u2, u2} F F _inst_2 _inst_2) (fun (_x : Homeomorph.{u2, u2} F F _inst_2 _inst_2) => F -> F) (Homeomorph.hasCoeToFun.{u2, u2} F F _inst_2 _inst_2) (Trivialization.coordChangeHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ b h₁ h₂)) (Trivialization.coordChange.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ b)
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e₁ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (e₂ : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) {b : B} (h₁ : Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e₁)) (h₂ : Membership.mem.{u3, u3} B (Set.{u3} B) (Set.instMembershipSet.{u3} B) b (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e₂)), Eq.{succ u2} (forall (ᾰ : F), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : F) => F) ᾰ) (FunLike.coe.{succ u2, succ u2, succ u2} (Homeomorph.{u2, u2} F F _inst_2 _inst_2) F (fun (_x : F) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : F) => F) _x) (EmbeddingLike.toFunLike.{succ u2, succ u2, succ u2} (Homeomorph.{u2, u2} F F _inst_2 _inst_2) F F (EquivLike.toEmbeddingLike.{succ u2, succ u2, succ u2} (Homeomorph.{u2, u2} F F _inst_2 _inst_2) F F (Homeomorph.instEquivLikeHomeomorph.{u2, u2} F F _inst_2 _inst_2))) (Trivialization.coordChangeHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ b h₁ h₂)) (Trivialization.coordChange.{u3, u2, u1} B F Z _inst_1 _inst_2 proj _inst_3 e₁ e₂ b)
Case conversion may be inaccurate. Consider using '#align trivialization.coord_change_homeomorph_coe Trivialization.coordChangeHomeomorph_coeₓ'. -/
@[simp]
theorem coordChangeHomeomorph_coe (e₁ e₂ : Trivialization F proj) {b : B} (h₁ : b ∈ e₁.baseSet)
    (h₂ : b ∈ e₂.baseSet) : ⇑(e₁.coordChangeHomeomorph e₂ h₁ h₂) = e₁.coordChange e₂ b :=
  rfl
#align trivialization.coord_change_homeomorph_coe Trivialization.coordChangeHomeomorph_coe

variable {F} {B' : Type _} [TopologicalSpace B']

/- warning: trivialization.is_image_preimage_prod -> Trivialization.isImage_preimage_prod is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (s : Set.{u1} B), LocalHomeomorph.IsImage.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e) (Set.preimage.{u3, u1} Z B proj s) (Set.prod.{u1, u2} B F s (Set.univ.{u2} F))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (s : Set.{u3} B), LocalHomeomorph.IsImage.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e) (Set.preimage.{u1, u3} Z B proj s) (Set.prod.{u3, u2} B F s (Set.univ.{u2} F))
Case conversion may be inaccurate. Consider using '#align trivialization.is_image_preimage_prod Trivialization.isImage_preimage_prodₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem isImage_preimage_prod (e : Trivialization F proj) (s : Set B) :
    e.toLocalHomeomorph.IsImage (proj ⁻¹' s) (s ×ˢ univ) := fun x hx => by simp [e.coe_fst', hx]
#align trivialization.is_image_preimage_prod Trivialization.isImage_preimage_prod

#print Trivialization.restrOpen /-
/-- Restrict a `trivialization` to an open set in the base. `-/
protected def restrOpen (e : Trivialization F proj) (s : Set B) (hs : IsOpen s) :
    Trivialization F proj
    where
  toLocalHomeomorph :=
    ((e.isImage_preimage_prod s).symm.restr (IsOpen.inter e.open_target (hs.Prod isOpen_univ))).symm
  baseSet := e.baseSet ∩ s
  open_baseSet := IsOpen.inter e.open_baseSet hs
  source_eq := by simp [e.source_eq]
  target_eq := by simp [e.target_eq, prod_univ]
  proj_toFun p hp := e.proj_toFun p hp.1
#align trivialization.restr_open Trivialization.restrOpen
-/

section Piecewise

/- warning: trivialization.frontier_preimage -> Trivialization.frontier_preimage is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (s : Set.{u1} B), Eq.{succ u3} (Set.{u3} Z) (Inter.inter.{u3} (Set.{u3} Z) (Set.hasInter.{u3} Z) (LocalEquiv.source.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (LocalHomeomorph.toLocalEquiv.{u3, max u1 u2} Z (Prod.{u1, u2} B F) _inst_3 (Prod.topologicalSpace.{u1, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e))) (frontier.{u3} Z _inst_3 (Set.preimage.{u3, u1} Z B proj s))) (Set.preimage.{u3, u1} Z B proj (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e) (frontier.{u1} B _inst_1 s)))
but is expected to have type
  forall {B : Type.{u3}} {F : Type.{u2}} {Z : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u1} Z] (e : Trivialization.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj) (s : Set.{u3} B), Eq.{succ u1} (Set.{u1} Z) (Inter.inter.{u1} (Set.{u1} Z) (Set.instInterSet.{u1} Z) (LocalEquiv.source.{u1, max u3 u2} Z (Prod.{u3, u2} B F) (LocalHomeomorph.toLocalEquiv.{u1, max u3 u2} Z (Prod.{u3, u2} B F) _inst_3 (instTopologicalSpaceProd.{u3, u2} B F _inst_1 _inst_2) (Trivialization.toLocalHomeomorph.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e))) (frontier.{u1} Z _inst_3 (Set.preimage.{u1, u3} Z B proj s))) (Set.preimage.{u1, u3} Z B proj (Inter.inter.{u3} (Set.{u3} B) (Set.instInterSet.{u3} B) (Trivialization.baseSet.{u3, u2, u1} B F Z _inst_1 _inst_2 _inst_3 proj e) (frontier.{u3} B _inst_1 s)))
Case conversion may be inaccurate. Consider using '#align trivialization.frontier_preimage Trivialization.frontier_preimageₓ'. -/
theorem frontier_preimage (e : Trivialization F proj) (s : Set B) :
    e.source ∩ frontier (proj ⁻¹' s) = proj ⁻¹' (e.baseSet ∩ frontier s) := by
  rw [← (e.is_image_preimage_prod s).frontier.preimage_eq, frontier_prod_univ_eq,
    (e.is_image_preimage_prod _).preimage_eq, e.source_eq, preimage_inter]
#align trivialization.frontier_preimage Trivialization.frontier_preimage

/- warning: trivialization.piecewise -> Trivialization.piecewise is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e' : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (s : Set.{u1} B), (Eq.{succ u1} (Set.{u1} B) (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e) (frontier.{u1} B _inst_1 s)) (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e') (frontier.{u1} B _inst_1 s))) -> (Set.EqOn.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e') (Set.preimage.{u3, u1} Z B proj (Inter.inter.{u1} (Set.{u1} B) (Set.hasInter.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e) (frontier.{u1} B _inst_1 s)))) -> (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj)
but is expected to have type
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e' : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (s : Set.{u1} B), (Eq.{succ u1} (Set.{u1} B) (Inter.inter.{u1} (Set.{u1} B) (Set.instInterSet.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e) (frontier.{u1} B _inst_1 s)) (Inter.inter.{u1} (Set.{u1} B) (Set.instInterSet.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e') (frontier.{u1} B _inst_1 s))) -> (Set.EqOn.{u3, max u1 u2} Z (Prod.{u1, u2} B F) (Trivialization.toFun'.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e) (Trivialization.toFun'.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e') (Set.preimage.{u3, u1} Z B proj (Inter.inter.{u1} (Set.{u1} B) (Set.instInterSet.{u1} B) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e) (frontier.{u1} B _inst_1 s)))) -> (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj)
Case conversion may be inaccurate. Consider using '#align trivialization.piecewise Trivialization.piecewiseₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Given two bundle trivializations `e`, `e'` of `proj : Z → B` and a set `s : set B` such that
the base sets of `e` and `e'` intersect `frontier s` on the same set and `e p = e' p` whenever
`proj p ∈ e.base_set ∩ frontier s`, `e.piecewise e' s Hs Heq` is the bundle trivialization over
`set.ite s e.base_set e'.base_set` that is equal to `e` on `proj ⁻¹ s` and is equal to `e'`
otherwise. -/
noncomputable def piecewise (e e' : Trivialization F proj) (s : Set B)
    (Hs : e.baseSet ∩ frontier s = e'.baseSet ∩ frontier s)
    (Heq : EqOn e e' <| proj ⁻¹' (e.baseSet ∩ frontier s)) : Trivialization F proj
    where
  toLocalHomeomorph :=
    e.toLocalHomeomorph.piecewise e'.toLocalHomeomorph (proj ⁻¹' s) (s ×ˢ univ)
      (e.isImage_preimage_prod s) (e'.isImage_preimage_prod s)
      (by rw [e.frontier_preimage, e'.frontier_preimage, Hs]) (by rwa [e.frontier_preimage])
  baseSet := s.ite e.baseSet e'.baseSet
  open_baseSet := e.open_baseSet.ite e'.open_baseSet Hs
  source_eq := by simp [e.source_eq, e'.source_eq]
  target_eq := by simp [e.target_eq, e'.target_eq, prod_univ]
  proj_toFun := by rintro p (⟨he, hs⟩ | ⟨he, hs⟩) <;> simp [*]
#align trivialization.piecewise Trivialization.piecewise

/- warning: trivialization.piecewise_le_of_eq -> Trivialization.piecewiseLeOfEq is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] [_inst_6 : LinearOrder.{u1} B] [_inst_7 : OrderTopology.{u1} B _inst_1 (PartialOrder.toPreorder.{u1} B (SemilatticeInf.toPartialOrder.{u1} B (Lattice.toSemilatticeInf.{u1} B (LinearOrder.toLattice.{u1} B _inst_6))))] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e' : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (a : B), (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) a (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Membership.Mem.{u1, u1} B (Set.{u1} B) (Set.hasMem.{u1} B) a (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e')) -> (forall (p : Z), (Eq.{succ u1} B (proj p) a) -> (Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e p) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u3) (succ u1) (succ u2)} (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (fun (_x : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) => Z -> (Prod.{u1, u2} B F)) (Trivialization.hasCoeToFun.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3) e' p))) -> (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj)
but is expected to have type
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] [_inst_6 : LinearOrder.{u1} B] [_inst_7 : OrderTopology.{u1} B _inst_1 (PartialOrder.toPreorder.{u1} B (SemilatticeInf.toPartialOrder.{u1} B (Lattice.toSemilatticeInf.{u1} B (DistribLattice.toLattice.{u1} B (instDistribLattice.{u1} B _inst_6)))))] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e' : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (a : B), (Membership.mem.{u1, u1} B (Set.{u1} B) (Set.instMembershipSet.{u1} B) a (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e)) -> (Membership.mem.{u1, u1} B (Set.{u1} B) (Set.instMembershipSet.{u1} B) a (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e')) -> (forall (p : Z), (Eq.{succ u1} B (proj p) a) -> (Eq.{max (succ u1) (succ u2)} (Prod.{u1, u2} B F) (Trivialization.toFun'.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e p) (Trivialization.toFun'.{u1, u2, u3} B F Z _inst_1 _inst_2 proj _inst_3 e' p))) -> (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj)
Case conversion may be inaccurate. Consider using '#align trivialization.piecewise_le_of_eq Trivialization.piecewiseLeOfEqₓ'. -/
/-- Given two bundle trivializations `e`, `e'` of a topological fiber bundle `proj : Z → B`
over a linearly ordered base `B` and a point `a ∈ e.base_set ∩ e'.base_set` such that
`e` equals `e'` on `proj ⁻¹' {a}`, `e.piecewise_le_of_eq e' a He He' Heq` is the bundle
trivialization over `set.ite (Iic a) e.base_set e'.base_set` that is equal to `e` on points `p`
such that `proj p ≤ a` and is equal to `e'` otherwise. -/
noncomputable def piecewiseLeOfEq [LinearOrder B] [OrderTopology B] (e e' : Trivialization F proj)
    (a : B) (He : a ∈ e.baseSet) (He' : a ∈ e'.baseSet) (Heq : ∀ p, proj p = a → e p = e' p) :
    Trivialization F proj :=
  e.piecewise e' (Iic a)
    (Set.ext fun x =>
      and_congr_left_iff.2 fun hx => by
        simp [He, He', mem_singleton_iff.1 (frontier_Iic_subset _ hx)])
    fun p hp => Heq p <| frontier_Iic_subset _ hp.2
#align trivialization.piecewise_le_of_eq Trivialization.piecewiseLeOfEq

#print Trivialization.piecewiseLe /-
/-- Given two bundle trivializations `e`, `e'` of a topological fiber bundle `proj : Z → B` over a
linearly ordered base `B` and a point `a ∈ e.base_set ∩ e'.base_set`, `e.piecewise_le e' a He He'`
is the bundle trivialization over `set.ite (Iic a) e.base_set e'.base_set` that is equal to `e` on
points `p` such that `proj p ≤ a` and is equal to `((e' p).1, h (e' p).2)` otherwise, where
`h = `e'.coord_change_homeomorph e _ _` is the homeomorphism of the fiber such that
`h (e' p).2 = (e p).2` whenever `e p = a`. -/
noncomputable def piecewiseLe [LinearOrder B] [OrderTopology B] (e e' : Trivialization F proj)
    (a : B) (He : a ∈ e.baseSet) (He' : a ∈ e'.baseSet) : Trivialization F proj :=
  e.piecewiseLeOfEq (e'.transFiberHomeomorph (e'.coordChangeHomeomorph e He' He)) a He He' <|
    by
    rintro p rfl
    ext1
    · simp [e.coe_fst', e'.coe_fst', *]
    · simp [e'.coord_change_apply_snd, *]
#align trivialization.piecewise_le Trivialization.piecewiseLe
-/

/- warning: trivialization.disjoint_union -> Trivialization.disjointUnion is a dubious translation:
lean 3 declaration is
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e' : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj), (Disjoint.{u1} (Set.{u1} B) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} B) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} B) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} B) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} B) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} B) (Set.completeBooleanAlgebra.{u1} B)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} B) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} B) (Set.booleanAlgebra.{u1} B))) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e')) -> (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj)
but is expected to have type
  forall {B : Type.{u1}} {F : Type.{u2}} {Z : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} B] [_inst_2 : TopologicalSpace.{u2} F] {proj : Z -> B} [_inst_3 : TopologicalSpace.{u3} Z] (e : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj) (e' : Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj), (Disjoint.{u1} (Set.{u1} B) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} B) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} B) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} B) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} B) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} B) (Set.instCompleteBooleanAlgebraSet.{u1} B)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} B) (Preorder.toLE.{u1} (Set.{u1} B) (PartialOrder.toPreorder.{u1} (Set.{u1} B) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} B) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} B) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} B) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} B) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} B) (Set.instCompleteBooleanAlgebraSet.{u1} B)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} B) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} B) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} B) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} B) (Set.instCompleteBooleanAlgebraSet.{u1} B)))))) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e) (Trivialization.baseSet.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj e')) -> (Trivialization.{u1, u2, u3} B F Z _inst_1 _inst_2 _inst_3 proj)
Case conversion may be inaccurate. Consider using '#align trivialization.disjoint_union Trivialization.disjointUnionₓ'. -/
/-- Given two bundle trivializations `e`, `e'` over disjoint sets, `e.disjoint_union e' H` is the
bundle trivialization over the union of the base sets that agrees with `e` and `e'` over their
base sets. -/
noncomputable def disjointUnion (e e' : Trivialization F proj) (H : Disjoint e.baseSet e'.baseSet) :
    Trivialization F proj
    where
  toLocalHomeomorph :=
    e.toLocalHomeomorph.disjointUnion e'.toLocalHomeomorph
      (by
        rw [e.source_eq, e'.source_eq]
        exact H.preimage _)
      (by
        rw [e.target_eq, e'.target_eq, disjoint_iff_inf_le]
        intro x hx
        exact H.le_bot ⟨hx.1.1, hx.2.1⟩)
  baseSet := e.baseSet ∪ e'.baseSet
  open_baseSet := IsOpen.union e.open_baseSet e'.open_baseSet
  source_eq := congr_arg₂ (· ∪ ·) e.source_eq e'.source_eq
  target_eq := (congr_arg₂ (· ∪ ·) e.target_eq e'.target_eq).trans union_prod.symm
  proj_toFun := by
    rintro p (hp | hp')
    · show (e.source.piecewise e e' p).1 = proj p
      rw [piecewise_eq_of_mem, e.coe_fst] <;> exact hp
    · show (e.source.piecewise e e' p).1 = proj p
      rw [piecewise_eq_of_not_mem, e'.coe_fst hp']
      simp only [e.source_eq, e'.source_eq] at hp'⊢
      exact fun h => H.le_bot ⟨h, hp'⟩
#align trivialization.disjoint_union Trivialization.disjointUnion

end Piecewise

end Trivialization

