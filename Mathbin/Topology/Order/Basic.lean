/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Yury Kudryashov

! This file was ported from Lean 3 source module topology.order.basic
! leanprover-community/mathlib commit c985ae9840e06836a71db38de372f20acb49b790
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Set.Intervals.Pi
import Mathbin.Data.Set.Pointwise.Interval
import Mathbin.Order.Filter.Interval
import Mathbin.Topology.Support
import Mathbin.Topology.Algebra.Order.LeftRight

/-!
# Theory of topology on ordered spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-‚àû, a)` and `(b, +‚àû)`). We define it as `preorder.topology Œ±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `preorder.topology Œ±`). Instead,
we introduce a class `order_topology Œ±` (which is a `Prop`, also known as a mixin) saying that on
the type `Œ±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We also introduce another (mixin) class `order_closed_topology Œ±` saying that the set of points
`(x, y)` with `x ‚â§ y` is closed in the product space. This is automatically satisfied on a linear
order with the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`order_closed_topology` vs `order_topology`, `preorder` vs `partial_order` vs `linear_order` etc)
see their statements.

### Open / closed sets

* `is_open_lt` : if `f` and `g` are continuous functions, then `{x | f x < g x}` is open;
* `is_open_Iio`, `is_open_Ioi`, `is_open_Ioo` : open intervals are open;
* `is_closed_le` : if `f` and `g` are continuous functions, then `{x | f x ‚â§ g x}` is closed;
* `is_closed_Iic`, `is_closed_Ici`, `is_closed_Icc` : closed intervals are closed;
* `frontier_le_subset_eq`, `frontier_lt_subset_eq` : frontiers of both `{x | f x ‚â§ g x}`
  and `{x | f x < g x}` are included by `{x | f x = g x}`;
* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z ‚àà (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z ‚àà [x, y)`.

### Convergence and inequalities

* `le_of_tendsto_of_tendsto` : if `f` converges to `a`, `g` converges to `b`, and eventually
  `f x ‚â§ g x`, then `a ‚â§ b`
* `le_of_tendsto`, `ge_of_tendsto` : if `f` converges to `a` and eventually `f x ‚â§ b`
  (resp., `b ‚â§ f x`), then `a ‚â§ b` (resp., `b ‚â§ a); we also provide primed versions
  that assume the inequalities to hold for all `x`.

### Min, max, `Sup` and `Inf`

* `continuous.min`, `continuous.max`: pointwise `min`/`max` of two continuous functions is
  continuous.
* `tendsto.min`, `tendsto.max` : if `f` tends to `a` and `g` tends to `b`, then their pointwise
  `min`/`max` tend to `min a b` and `max a b`, respectively.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x ‚â§ f x ‚â§ h x`, then `f` converges to `a`.

## Implementation notes

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `‚Ñï` or `‚Ñ§`, or `‚Ñù` that could inherit a topology as the completion of `‚Ñö`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `preorder.topology Œ±` though, that can be registered as an instance when necessary, or
for specific types.
-/


open Set Filter TopologicalSpace

open Function

open OrderDual (toDual ofDual)

open Topology Classical Filter

universe u v w

variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}

#print OrderClosedTopology /-
/-- A topology on a set which is both a topological space and a preorder is _order-closed_ if the
set of points `(x, y)` with `x ‚â§ y` is closed in the product space. We introduce this as a mixin.
This property is satisfied for the order topology on a linear order, but it can be satisfied more
generally, and suffices to derive many interesting properties relating order and topology. -/
class OrderClosedTopology (Œ± : Type _) [TopologicalSpace Œ±] [Preorder Œ±] : Prop where
  isClosed_le' : IsClosed { p : Œ± √ó Œ± | p.1 ‚â§ p.2 }
#align order_closed_topology OrderClosedTopology
-/

instance [TopologicalSpace Œ±] [h : FirstCountableTopology Œ±] : FirstCountableTopology Œ±·µí·µà :=
  h

instance [TopologicalSpace Œ±] [h : SecondCountableTopology Œ±] : SecondCountableTopology Œ±·µí·µà :=
  h

#print Dense.orderDual /-
theorem Dense.orderDual [TopologicalSpace Œ±] {s : Set Œ±} (hs : Dense s) :
    Dense (OrderDual.ofDual ‚Åª¬π' s) :=
  hs
#align dense.order_dual Dense.orderDual
-/

section OrderClosedTopology

section Preorder

variable [TopologicalSpace Œ±] [Preorder Œ±] [t : OrderClosedTopology Œ±]

include t

namespace Subtype

instance {p : Œ± ‚Üí Prop} : OrderClosedTopology (Subtype p) :=
  have this : Continuous fun p : Subtype p √ó Subtype p => ((p.fst : Œ±), (p.snd : Œ±)) :=
    (continuous_subtype_val.comp continuous_fst).prod_mk
      (continuous_subtype_val.comp continuous_snd)
  OrderClosedTopology.mk (t.isClosed_le'.Preimage this)

end Subtype

/- warning: is_closed_le_prod -> isClosed_le_prod is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [t : OrderClosedTopology.{u1} Œ± _inst_1 _inst_2], IsClosed.{u1} (Prod.{u1, u1} Œ± Œ±) (Prod.topologicalSpace.{u1, u1} Œ± Œ± _inst_1 _inst_1) (setOf.{u1} (Prod.{u1, u1} Œ± Œ±) (fun (p : Prod.{u1, u1} Œ± Œ±) => LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [t : OrderClosedTopology.{u1} Œ± _inst_1 _inst_2], IsClosed.{u1} (Prod.{u1, u1} Œ± Œ±) (instTopologicalSpaceProd.{u1, u1} Œ± Œ± _inst_1 _inst_1) (setOf.{u1} (Prod.{u1, u1} Œ± Œ±) (fun (p : Prod.{u1, u1} Œ± Œ±) => LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p)))
Case conversion may be inaccurate. Consider using '#align is_closed_le_prod isClosed_le_prod‚Çì'. -/
theorem isClosed_le_prod : IsClosed { p : Œ± √ó Œ± | p.1 ‚â§ p.2 } :=
  t.isClosed_le'
#align is_closed_le_prod isClosed_le_prod

#print isClosed_le /-
theorem isClosed_le [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) :
    IsClosed { b | f b ‚â§ g b } :=
  continuous_iff_isClosed.mp (hf.prod_mk hg) _ isClosed_le_prod
#align is_closed_le isClosed_le
-/

#print isClosed_le' /-
theorem isClosed_le' (a : Œ±) : IsClosed { b | b ‚â§ a } :=
  isClosed_le continuous_id continuous_const
#align is_closed_le' isClosed_le'
-/

#print isClosed_Iic /-
theorem isClosed_Iic {a : Œ±} : IsClosed (Iic a) :=
  isClosed_le' a
#align is_closed_Iic isClosed_Iic
-/

#print isClosed_ge' /-
theorem isClosed_ge' (a : Œ±) : IsClosed { b | a ‚â§ b } :=
  isClosed_le continuous_const continuous_id
#align is_closed_ge' isClosed_ge'
-/

#print isClosed_Ici /-
theorem isClosed_Ici {a : Œ±} : IsClosed (Ici a) :=
  isClosed_ge' a
#align is_closed_Ici isClosed_Ici
-/

instance : OrderClosedTopology Œ±·µí·µà :=
  ‚ü®(@OrderClosedTopology.isClosed_le' Œ± _ _ _).Preimage continuous_swap‚ü©

#print isClosed_Icc /-
theorem isClosed_Icc {a b : Œ±} : IsClosed (Icc a b) :=
  IsClosed.inter isClosed_Ici isClosed_Iic
#align is_closed_Icc isClosed_Icc
-/

#print closure_Icc /-
@[simp]
theorem closure_Icc (a b : Œ±) : closure (Icc a b) = Icc a b :=
  isClosed_Icc.closure_eq
#align closure_Icc closure_Icc
-/

#print closure_Iic /-
@[simp]
theorem closure_Iic (a : Œ±) : closure (Iic a) = Iic a :=
  isClosed_Iic.closure_eq
#align closure_Iic closure_Iic
-/

#print closure_Ici /-
@[simp]
theorem closure_Ici (a : Œ±) : closure (Ici a) = Ici a :=
  isClosed_Ici.closure_eq
#align closure_Ici closure_Ici
-/

#print le_of_tendsto_of_tendsto /-
theorem le_of_tendsto_of_tendsto {f g : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [NeBot b]
    (hf : Tendsto f b (ùìù a‚ÇÅ)) (hg : Tendsto g b (ùìù a‚ÇÇ)) (h : f ‚â§·∂†[b] g) : a‚ÇÅ ‚â§ a‚ÇÇ :=
  have : Tendsto (fun b => (f b, g b)) b (ùìù (a‚ÇÅ, a‚ÇÇ)) := by
    rw [nhds_prod_eq] <;> exact hf.prod_mk hg
  show (a‚ÇÅ, a‚ÇÇ) ‚àà { p : Œ± √ó Œ± | p.1 ‚â§ p.2 } from t.isClosed_le'.mem_of_tendsto this h
#align le_of_tendsto_of_tendsto le_of_tendsto_of_tendsto
-/

alias le_of_tendsto_of_tendsto ‚Üê tendsto_le_of_eventuallyLE
#align tendsto_le_of_eventually_le tendsto_le_of_eventuallyLE

#print le_of_tendsto_of_tendsto' /-
theorem le_of_tendsto_of_tendsto' {f g : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [NeBot b]
    (hf : Tendsto f b (ùìù a‚ÇÅ)) (hg : Tendsto g b (ùìù a‚ÇÇ)) (h : ‚àÄ x, f x ‚â§ g x) : a‚ÇÅ ‚â§ a‚ÇÇ :=
  le_of_tendsto_of_tendsto hf hg (eventually_of_forall h)
#align le_of_tendsto_of_tendsto' le_of_tendsto_of_tendsto'
-/

#print le_of_tendsto /-
theorem le_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : Filter Œ≤} [NeBot x] (lim : Tendsto f x (ùìù a))
    (h : ‚àÄ·∂† c in x, f c ‚â§ b) : a ‚â§ b :=
  le_of_tendsto_of_tendsto limUnder tendsto_const_nhds h
#align le_of_tendsto le_of_tendsto
-/

#print le_of_tendsto' /-
theorem le_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : Filter Œ≤} [NeBot x] (lim : Tendsto f x (ùìù a))
    (h : ‚àÄ c, f c ‚â§ b) : a ‚â§ b :=
  le_of_tendsto limUnder (eventually_of_forall h)
#align le_of_tendsto' le_of_tendsto'
-/

#print ge_of_tendsto /-
theorem ge_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : Filter Œ≤} [NeBot x] (lim : Tendsto f x (ùìù a))
    (h : ‚àÄ·∂† c in x, b ‚â§ f c) : b ‚â§ a :=
  le_of_tendsto_of_tendsto tendsto_const_nhds limUnder h
#align ge_of_tendsto ge_of_tendsto
-/

#print ge_of_tendsto' /-
theorem ge_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : Filter Œ≤} [NeBot x] (lim : Tendsto f x (ùìù a))
    (h : ‚àÄ c, b ‚â§ f c) : b ‚â§ a :=
  ge_of_tendsto limUnder (eventually_of_forall h)
#align ge_of_tendsto' ge_of_tendsto'
-/

#print closure_le_eq /-
@[simp]
theorem closure_le_eq [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) :
    closure { b | f b ‚â§ g b } = { b | f b ‚â§ g b } :=
  (isClosed_le hf hg).closure_eq
#align closure_le_eq closure_le_eq
-/

#print closure_lt_subset_le /-
theorem closure_lt_subset_le [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : Continuous f)
    (hg : Continuous g) : closure { b | f b < g b } ‚äÜ { b | f b ‚â§ g b } :=
  (closure_minimal fun x => le_of_lt) <| isClosed_le hf hg
#align closure_lt_subset_le closure_lt_subset_le
-/

#print ContinuousWithinAt.closure_le /-
theorem ContinuousWithinAt.closure_le [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : Set Œ≤} {x : Œ≤}
    (hx : x ‚àà closure s) (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x)
    (h : ‚àÄ y ‚àà s, f y ‚â§ g y) : f x ‚â§ g x :=
  show (f x, g x) ‚àà { p : Œ± √ó Œ± | p.1 ‚â§ p.2 } from
    OrderClosedTopology.isClosed_le'.closure_subset ((hf.Prod hg).mem_closure hx h)
#align continuous_within_at.closure_le ContinuousWithinAt.closure_le
-/

#print IsClosed.isClosed_le /-
/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,
then the set `{x ‚àà s | f x ‚â§ g x}` is a closed set. -/
theorem IsClosed.isClosed_le [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : Set Œ≤} (hs : IsClosed s)
    (hf : ContinuousOn f s) (hg : ContinuousOn g s) : IsClosed ({ x ‚àà s | f x ‚â§ g x }) :=
  (hf.Prod hg).preimage_closed_of_closed hs OrderClosedTopology.isClosed_le'
#align is_closed.is_closed_le IsClosed.isClosed_le
-/

#print le_on_closure /-
theorem le_on_closure [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : Set Œ≤} (h : ‚àÄ x ‚àà s, f x ‚â§ g x)
    (hf : ContinuousOn f (closure s)) (hg : ContinuousOn g (closure s)) ‚¶Éx‚¶Ñ (hx : x ‚àà closure s) :
    f x ‚â§ g x :=
  have : s ‚äÜ { y ‚àà closure s | f y ‚â§ g y } := fun y hy => ‚ü®subset_closure hy, h y hy‚ü©
  (closure_minimal this (isClosed_closure.isClosed_le hf hg) hx).2
#align le_on_closure le_on_closure
-/

/- warning: is_closed.epigraph -> IsClosed.epigraph is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [t : OrderClosedTopology.{u1} Œ± _inst_1 _inst_2] [_inst_3 : TopologicalSpace.{u2} Œ≤] {f : Œ≤ -> Œ±} {s : Set.{u2} Œ≤}, (IsClosed.{u2} Œ≤ _inst_3 s) -> (ContinuousOn.{u2, u1} Œ≤ Œ± _inst_3 _inst_1 f s) -> (IsClosed.{max u2 u1} (Prod.{u2, u1} Œ≤ Œ±) (Prod.topologicalSpace.{u2, u1} Œ≤ Œ± _inst_3 _inst_1) (setOf.{max u2 u1} (Prod.{u2, u1} Œ≤ Œ±) (fun (p : Prod.{u2, u1} Œ≤ Œ±) => And (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) (Prod.fst.{u2, u1} Œ≤ Œ± p) s) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) (f (Prod.fst.{u2, u1} Œ≤ Œ± p)) (Prod.snd.{u2, u1} Œ≤ Œ± p)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [t : OrderClosedTopology.{u1} Œ± _inst_1 _inst_2] [_inst_3 : TopologicalSpace.{u2} Œ≤] {f : Œ≤ -> Œ±} {s : Set.{u2} Œ≤}, (IsClosed.{u2} Œ≤ _inst_3 s) -> (ContinuousOn.{u2, u1} Œ≤ Œ± _inst_3 _inst_1 f s) -> (IsClosed.{max u1 u2} (Prod.{u2, u1} Œ≤ Œ±) (instTopologicalSpaceProd.{u2, u1} Œ≤ Œ± _inst_3 _inst_1) (setOf.{max u1 u2} (Prod.{u2, u1} Œ≤ Œ±) (fun (p : Prod.{u2, u1} Œ≤ Œ±) => And (Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) (Prod.fst.{u2, u1} Œ≤ Œ± p) s) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) (f (Prod.fst.{u2, u1} Œ≤ Œ± p)) (Prod.snd.{u2, u1} Œ≤ Œ± p)))))
Case conversion may be inaccurate. Consider using '#align is_closed.epigraph IsClosed.epigraph‚Çì'. -/
theorem IsClosed.epigraph [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ≤} (hs : IsClosed s)
    (hf : ContinuousOn f s) : IsClosed { p : Œ≤ √ó Œ± | p.1 ‚àà s ‚àß f p.1 ‚â§ p.2 } :=
  (hs.Preimage continuous_fst).isClosed_le (hf.comp continuousOn_fst Subset.rfl) continuousOn_snd
#align is_closed.epigraph IsClosed.epigraph

/- warning: is_closed.hypograph -> IsClosed.hypograph is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [t : OrderClosedTopology.{u1} Œ± _inst_1 _inst_2] [_inst_3 : TopologicalSpace.{u2} Œ≤] {f : Œ≤ -> Œ±} {s : Set.{u2} Œ≤}, (IsClosed.{u2} Œ≤ _inst_3 s) -> (ContinuousOn.{u2, u1} Œ≤ Œ± _inst_3 _inst_1 f s) -> (IsClosed.{max u2 u1} (Prod.{u2, u1} Œ≤ Œ±) (Prod.topologicalSpace.{u2, u1} Œ≤ Œ± _inst_3 _inst_1) (setOf.{max u2 u1} (Prod.{u2, u1} Œ≤ Œ±) (fun (p : Prod.{u2, u1} Œ≤ Œ±) => And (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) (Prod.fst.{u2, u1} Œ≤ Œ± p) s) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) (Prod.snd.{u2, u1} Œ≤ Œ± p) (f (Prod.fst.{u2, u1} Œ≤ Œ± p))))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [t : OrderClosedTopology.{u1} Œ± _inst_1 _inst_2] [_inst_3 : TopologicalSpace.{u2} Œ≤] {f : Œ≤ -> Œ±} {s : Set.{u2} Œ≤}, (IsClosed.{u2} Œ≤ _inst_3 s) -> (ContinuousOn.{u2, u1} Œ≤ Œ± _inst_3 _inst_1 f s) -> (IsClosed.{max u1 u2} (Prod.{u2, u1} Œ≤ Œ±) (instTopologicalSpaceProd.{u2, u1} Œ≤ Œ± _inst_3 _inst_1) (setOf.{max u1 u2} (Prod.{u2, u1} Œ≤ Œ±) (fun (p : Prod.{u2, u1} Œ≤ Œ±) => And (Membership.mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.instMembershipSet.{u2} Œ≤) (Prod.fst.{u2, u1} Œ≤ Œ± p) s) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) (Prod.snd.{u2, u1} Œ≤ Œ± p) (f (Prod.fst.{u2, u1} Œ≤ Œ± p))))))
Case conversion may be inaccurate. Consider using '#align is_closed.hypograph IsClosed.hypograph‚Çì'. -/
theorem IsClosed.hypograph [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ≤} (hs : IsClosed s)
    (hf : ContinuousOn f s) : IsClosed { p : Œ≤ √ó Œ± | p.1 ‚àà s ‚àß p.2 ‚â§ f p.1 } :=
  (hs.Preimage continuous_fst).isClosed_le continuousOn_snd (hf.comp continuousOn_fst Subset.rfl)
#align is_closed.hypograph IsClosed.hypograph

omit t

#print nhdsWithin_Ici_neBot /-
theorem nhdsWithin_Ici_neBot {a b : Œ±} (H‚ÇÇ : a ‚â§ b) : NeBot (ùìù[Ici a] b) :=
  nhdsWithin_neBot_of_mem H‚ÇÇ
#align nhds_within_Ici_ne_bot nhdsWithin_Ici_neBot
-/

#print nhdsWithin_Ici_self_neBot /-
@[instance]
theorem nhdsWithin_Ici_self_neBot (a : Œ±) : NeBot (ùìù[‚â•] a) :=
  nhdsWithin_Ici_neBot (le_refl a)
#align nhds_within_Ici_self_ne_bot nhdsWithin_Ici_self_neBot
-/

#print nhdsWithin_Iic_neBot /-
theorem nhdsWithin_Iic_neBot {a b : Œ±} (H : a ‚â§ b) : NeBot (ùìù[Iic b] a) :=
  nhdsWithin_neBot_of_mem H
#align nhds_within_Iic_ne_bot nhdsWithin_Iic_neBot
-/

#print nhdsWithin_Iic_self_neBot /-
@[instance]
theorem nhdsWithin_Iic_self_neBot (a : Œ±) : NeBot (ùìù[‚â§] a) :=
  nhdsWithin_Iic_neBot (le_refl a)
#align nhds_within_Iic_self_ne_bot nhdsWithin_Iic_self_neBot
-/

end Preorder

section PartialOrder

variable [TopologicalSpace Œ±] [PartialOrder Œ±] [t : OrderClosedTopology Œ±]

include t

#print OrderClosedTopology.to_t2Space /-
-- see Note [lower instance priority]
instance (priority := 90) OrderClosedTopology.to_t2Space : T2Space Œ± :=
  t2_iff_isClosed_diagonal.2 <| by
    simpa only [diagonal, le_antisymm_iff] using
      t.is_closed_le'.inter (isClosed_le continuous_snd continuous_fst)
#align order_closed_topology.to_t2_space OrderClosedTopology.to_t2Space
-/

end PartialOrder

section LinearOrder

variable [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderClosedTopology Œ±]

/- warning: is_open_lt_prod -> isOpen_lt_prod is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))], IsOpen.{u1} (Prod.{u1, u1} Œ± Œ±) (Prod.topologicalSpace.{u1, u1} Œ± Œ± _inst_1 _inst_1) (setOf.{u1} (Prod.{u1, u1} Œ± Œ±) (fun (p : Prod.{u1, u1} Œ± Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))], IsOpen.{u1} (Prod.{u1, u1} Œ± Œ±) (instTopologicalSpaceProd.{u1, u1} Œ± Œ± _inst_1 _inst_1) (setOf.{u1} (Prod.{u1, u1} Œ± Œ±) (fun (p : Prod.{u1, u1} Œ± Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p)))
Case conversion may be inaccurate. Consider using '#align is_open_lt_prod isOpen_lt_prod‚Çì'. -/
theorem isOpen_lt_prod : IsOpen { p : Œ± √ó Œ± | p.1 < p.2 } :=
  by
  simp_rw [‚Üê isClosed_compl_iff, compl_set_of, not_lt]
  exact isClosed_le continuous_snd continuous_fst
#align is_open_lt_prod isOpen_lt_prod

#print isOpen_lt /-
theorem isOpen_lt [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) :
    IsOpen { b | f b < g b } := by
  simp [lt_iff_not_ge, -not_le] <;> exact (isClosed_le hg hf).isOpen_compl
#align is_open_lt isOpen_lt
-/

variable {a b : Œ±}

#print isOpen_Iio /-
theorem isOpen_Iio : IsOpen (Iio a) :=
  isOpen_lt continuous_id continuous_const
#align is_open_Iio isOpen_Iio
-/

#print isOpen_Ioi /-
theorem isOpen_Ioi : IsOpen (Ioi a) :=
  isOpen_lt continuous_const continuous_id
#align is_open_Ioi isOpen_Ioi
-/

#print isOpen_Ioo /-
theorem isOpen_Ioo : IsOpen (Ioo a b) :=
  IsOpen.inter isOpen_Ioi isOpen_Iio
#align is_open_Ioo isOpen_Ioo
-/

#print interior_Ioi /-
@[simp]
theorem interior_Ioi : interior (Ioi a) = Ioi a :=
  isOpen_Ioi.interior_eq
#align interior_Ioi interior_Ioi
-/

#print interior_Iio /-
@[simp]
theorem interior_Iio : interior (Iio a) = Iio a :=
  isOpen_Iio.interior_eq
#align interior_Iio interior_Iio
-/

#print interior_Ioo /-
@[simp]
theorem interior_Ioo : interior (Ioo a b) = Ioo a b :=
  isOpen_Ioo.interior_eq
#align interior_Ioo interior_Ioo
-/

#print Ioo_subset_closure_interior /-
theorem Ioo_subset_closure_interior : Ioo a b ‚äÜ closure (interior (Ioo a b)) := by
  simp only [interior_Ioo, subset_closure]
#align Ioo_subset_closure_interior Ioo_subset_closure_interior
-/

#print Iio_mem_nhds /-
theorem Iio_mem_nhds {a b : Œ±} (h : a < b) : Iio b ‚àà ùìù a :=
  IsOpen.mem_nhds isOpen_Iio h
#align Iio_mem_nhds Iio_mem_nhds
-/

#print Ioi_mem_nhds /-
theorem Ioi_mem_nhds {a b : Œ±} (h : a < b) : Ioi a ‚àà ùìù b :=
  IsOpen.mem_nhds isOpen_Ioi h
#align Ioi_mem_nhds Ioi_mem_nhds
-/

#print Iic_mem_nhds /-
theorem Iic_mem_nhds {a b : Œ±} (h : a < b) : Iic b ‚àà ùìù a :=
  mem_of_superset (Iio_mem_nhds h) Iio_subset_Iic_self
#align Iic_mem_nhds Iic_mem_nhds
-/

#print Ici_mem_nhds /-
theorem Ici_mem_nhds {a b : Œ±} (h : a < b) : Ici a ‚àà ùìù b :=
  mem_of_superset (Ioi_mem_nhds h) Ioi_subset_Ici_self
#align Ici_mem_nhds Ici_mem_nhds
-/

#print Ioo_mem_nhds /-
theorem Ioo_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ioo a b ‚àà ùìù x :=
  IsOpen.mem_nhds isOpen_Ioo ‚ü®ha, hb‚ü©
#align Ioo_mem_nhds Ioo_mem_nhds
-/

#print Ioc_mem_nhds /-
theorem Ioc_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ioc a b ‚àà ùìù x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ioc_self
#align Ioc_mem_nhds Ioc_mem_nhds
-/

#print Ico_mem_nhds /-
theorem Ico_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ico a b ‚àà ùìù x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ico_self
#align Ico_mem_nhds Ico_mem_nhds
-/

#print Icc_mem_nhds /-
theorem Icc_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Icc a b ‚àà ùìù x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Icc_self
#align Icc_mem_nhds Icc_mem_nhds
-/

#print eventually_lt_of_tendsto_lt /-
theorem eventually_lt_of_tendsto_lt {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} {u v : Œ±} (hv : v < u)
    (h : Filter.Tendsto f l (ùìù v)) : ‚àÄ·∂† a in l, f a < u :=
  tendsto_nhds.1 h (¬∑ < u) isOpen_Iio hv
#align eventually_lt_of_tendsto_lt eventually_lt_of_tendsto_lt
-/

#print eventually_gt_of_tendsto_gt /-
theorem eventually_gt_of_tendsto_gt {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} {u v : Œ±} (hv : u < v)
    (h : Filter.Tendsto f l (ùìù v)) : ‚àÄ·∂† a in l, u < f a :=
  tendsto_nhds.1 h (¬∑ > u) isOpen_Ioi hv
#align eventually_gt_of_tendsto_gt eventually_gt_of_tendsto_gt
-/

#print eventually_le_of_tendsto_lt /-
theorem eventually_le_of_tendsto_lt {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} {u v : Œ±} (hv : v < u)
    (h : Tendsto f l (ùìù v)) : ‚àÄ·∂† a in l, f a ‚â§ u :=
  (eventually_lt_of_tendsto_lt hv h).mono fun v => le_of_lt
#align eventually_le_of_tendsto_lt eventually_le_of_tendsto_lt
-/

#print eventually_ge_of_tendsto_gt /-
theorem eventually_ge_of_tendsto_gt {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} {u v : Œ±} (hv : u < v)
    (h : Tendsto f l (ùìù v)) : ‚àÄ·∂† a in l, u ‚â§ f a :=
  (eventually_gt_of_tendsto_gt hv h).mono fun v => le_of_lt
#align eventually_ge_of_tendsto_gt eventually_ge_of_tendsto_gt
-/

variable [TopologicalSpace Œ≥]

/-!
### Neighborhoods to the left and to the right on an `order_closed_topology`

Limits to the left and to the right of real functions are defined in terms of neighborhoods to
the left and to the right, either open or closed, i.e., members of `ùìù[>] a` and
`ùìù[‚â•] a` on the right, and similarly on the left. Here we simply prove that all
right-neighborhoods of a point are equal, and we'll prove later other useful characterizations which
require the stronger hypothesis `order_topology Œ±` -/


/-!
#### Right neighborhoods, point excluded
-/


#print Ioo_mem_nhdsWithin_Ioi /-
theorem Ioo_mem_nhdsWithin_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) : Ioo a c ‚àà ùìù[>] b :=
  mem_nhdsWithin.2
    ‚ü®Iio c, isOpen_Iio, H.2, by rw [inter_comm, Ioi_inter_Iio] <;> exact Ioo_subset_Ioo_left H.1‚ü©
#align Ioo_mem_nhds_within_Ioi Ioo_mem_nhdsWithin_Ioi
-/

#print Ioc_mem_nhdsWithin_Ioi /-
theorem Ioc_mem_nhdsWithin_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) : Ioc a c ‚àà ùìù[>] b :=
  mem_of_superset (Ioo_mem_nhdsWithin_Ioi H) Ioo_subset_Ioc_self
#align Ioc_mem_nhds_within_Ioi Ioc_mem_nhdsWithin_Ioi
-/

#print Ico_mem_nhdsWithin_Ioi /-
theorem Ico_mem_nhdsWithin_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) : Ico a c ‚àà ùìù[>] b :=
  mem_of_superset (Ioo_mem_nhdsWithin_Ioi H) Ioo_subset_Ico_self
#align Ico_mem_nhds_within_Ioi Ico_mem_nhdsWithin_Ioi
-/

#print Icc_mem_nhdsWithin_Ioi /-
theorem Icc_mem_nhdsWithin_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) : Icc a c ‚àà ùìù[>] b :=
  mem_of_superset (Ioo_mem_nhdsWithin_Ioi H) Ioo_subset_Icc_self
#align Icc_mem_nhds_within_Ioi Icc_mem_nhdsWithin_Ioi
-/

#print nhdsWithin_Ioc_eq_nhdsWithin_Ioi /-
@[simp]
theorem nhdsWithin_Ioc_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioc a b] a = ùìù[>] a :=
  le_antisymm (nhdsWithin_mono _ Ioc_subset_Ioi_self) <|
    nhdsWithin_le_of_mem <| Ioc_mem_nhdsWithin_Ioi <| left_mem_Ico.2 h
#align nhds_within_Ioc_eq_nhds_within_Ioi nhdsWithin_Ioc_eq_nhdsWithin_Ioi
-/

#print nhdsWithin_Ioo_eq_nhdsWithin_Ioi /-
@[simp]
theorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=
  le_antisymm (nhdsWithin_mono _ Ioo_subset_Ioi_self) <|
    nhdsWithin_le_of_mem <| Ioo_mem_nhdsWithin_Ioi <| left_mem_Ico.2 h
#align nhds_within_Ioo_eq_nhds_within_Ioi nhdsWithin_Ioo_eq_nhdsWithin_Ioi
-/

#print continuousWithinAt_Ioc_iff_Ioi /-
@[simp]
theorem continuousWithinAt_Ioc_iff_Ioi [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
    ContinuousWithinAt f (Ioc a b) a ‚Üî ContinuousWithinAt f (Ioi a) a := by
  simp only [ContinuousWithinAt, nhdsWithin_Ioc_eq_nhdsWithin_Ioi h]
#align continuous_within_at_Ioc_iff_Ioi continuousWithinAt_Ioc_iff_Ioi
-/

#print continuousWithinAt_Ioo_iff_Ioi /-
@[simp]
theorem continuousWithinAt_Ioo_iff_Ioi [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
    ContinuousWithinAt f (Ioo a b) a ‚Üî ContinuousWithinAt f (Ioi a) a := by
  simp only [ContinuousWithinAt, nhdsWithin_Ioo_eq_nhdsWithin_Ioi h]
#align continuous_within_at_Ioo_iff_Ioi continuousWithinAt_Ioo_iff_Ioi
-/

/-!
#### Left neighborhoods, point excluded
-/


#print Ioo_mem_nhdsWithin_Iio /-
theorem Ioo_mem_nhdsWithin_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) : Ioo a c ‚àà ùìù[<] b := by
  simpa only [dual_Ioo] using
    Ioo_mem_nhdsWithin_Ioi (show to_dual b ‚àà Ico (to_dual c) (to_dual a) from H.symm)
#align Ioo_mem_nhds_within_Iio Ioo_mem_nhdsWithin_Iio
-/

#print Ico_mem_nhdsWithin_Iio /-
theorem Ico_mem_nhdsWithin_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) : Ico a c ‚àà ùìù[<] b :=
  mem_of_superset (Ioo_mem_nhdsWithin_Iio H) Ioo_subset_Ico_self
#align Ico_mem_nhds_within_Iio Ico_mem_nhdsWithin_Iio
-/

#print Ioc_mem_nhdsWithin_Iio /-
theorem Ioc_mem_nhdsWithin_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) : Ioc a c ‚àà ùìù[<] b :=
  mem_of_superset (Ioo_mem_nhdsWithin_Iio H) Ioo_subset_Ioc_self
#align Ioc_mem_nhds_within_Iio Ioc_mem_nhdsWithin_Iio
-/

#print Icc_mem_nhdsWithin_Iio /-
theorem Icc_mem_nhdsWithin_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) : Icc a c ‚àà ùìù[<] b :=
  mem_of_superset (Ioo_mem_nhdsWithin_Iio H) Ioo_subset_Icc_self
#align Icc_mem_nhds_within_Iio Icc_mem_nhdsWithin_Iio
-/

#print nhdsWithin_Ico_eq_nhdsWithin_Iio /-
@[simp]
theorem nhdsWithin_Ico_eq_nhdsWithin_Iio {a b : Œ±} (h : a < b) : ùìù[Ico a b] b = ùìù[<] b := by
  simpa only [dual_Ioc] using nhdsWithin_Ioc_eq_nhdsWithin_Ioi h.dual
#align nhds_within_Ico_eq_nhds_within_Iio nhdsWithin_Ico_eq_nhdsWithin_Iio
-/

#print nhdsWithin_Ioo_eq_nhdsWithin_Iio /-
@[simp]
theorem nhdsWithin_Ioo_eq_nhdsWithin_Iio {a b : Œ±} (h : a < b) : ùìù[Ioo a b] b = ùìù[<] b := by
  simpa only [dual_Ioo] using nhdsWithin_Ioo_eq_nhdsWithin_Ioi h.dual
#align nhds_within_Ioo_eq_nhds_within_Iio nhdsWithin_Ioo_eq_nhdsWithin_Iio
-/

#print continuousWithinAt_Ico_iff_Iio /-
@[simp]
theorem continuousWithinAt_Ico_iff_Iio {a b : Œ±} {f : Œ± ‚Üí Œ≥} (h : a < b) :
    ContinuousWithinAt f (Ico a b) b ‚Üî ContinuousWithinAt f (Iio b) b := by
  simp only [ContinuousWithinAt, nhdsWithin_Ico_eq_nhdsWithin_Iio h]
#align continuous_within_at_Ico_iff_Iio continuousWithinAt_Ico_iff_Iio
-/

#print continuousWithinAt_Ioo_iff_Iio /-
@[simp]
theorem continuousWithinAt_Ioo_iff_Iio {a b : Œ±} {f : Œ± ‚Üí Œ≥} (h : a < b) :
    ContinuousWithinAt f (Ioo a b) b ‚Üî ContinuousWithinAt f (Iio b) b := by
  simp only [ContinuousWithinAt, nhdsWithin_Ioo_eq_nhdsWithin_Iio h]
#align continuous_within_at_Ioo_iff_Iio continuousWithinAt_Ioo_iff_Iio
-/

/-!
#### Right neighborhoods, point included
-/


#print Ioo_mem_nhdsWithin_Ici /-
theorem Ioo_mem_nhdsWithin_Ici {a b c : Œ±} (H : b ‚àà Ioo a c) : Ioo a c ‚àà ùìù[‚â•] b :=
  mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds isOpen_Ioo H
#align Ioo_mem_nhds_within_Ici Ioo_mem_nhdsWithin_Ici
-/

#print Ioc_mem_nhdsWithin_Ici /-
theorem Ioc_mem_nhdsWithin_Ici {a b c : Œ±} (H : b ‚àà Ioo a c) : Ioc a c ‚àà ùìù[‚â•] b :=
  mem_of_superset (Ioo_mem_nhdsWithin_Ici H) Ioo_subset_Ioc_self
#align Ioc_mem_nhds_within_Ici Ioc_mem_nhdsWithin_Ici
-/

#print Ico_mem_nhdsWithin_Ici /-
theorem Ico_mem_nhdsWithin_Ici {a b c : Œ±} (H : b ‚àà Ico a c) : Ico a c ‚àà ùìù[‚â•] b :=
  mem_nhdsWithin.2
    ‚ü®Iio c, isOpen_Iio, H.2, by simp only [inter_comm, Ici_inter_Iio, Ico_subset_Ico_left H.1]‚ü©
#align Ico_mem_nhds_within_Ici Ico_mem_nhdsWithin_Ici
-/

#print Icc_mem_nhdsWithin_Ici /-
theorem Icc_mem_nhdsWithin_Ici {a b c : Œ±} (H : b ‚àà Ico a c) : Icc a c ‚àà ùìù[‚â•] b :=
  mem_of_superset (Ico_mem_nhdsWithin_Ici H) Ico_subset_Icc_self
#align Icc_mem_nhds_within_Ici Icc_mem_nhdsWithin_Ici
-/

#print nhdsWithin_Icc_eq_nhdsWithin_Ici /-
@[simp]
theorem nhdsWithin_Icc_eq_nhdsWithin_Ici {a b : Œ±} (h : a < b) : ùìù[Icc a b] a = ùìù[‚â•] a :=
  le_antisymm (nhdsWithin_mono _ Icc_subset_Ici_self) <|
    nhdsWithin_le_of_mem <| Icc_mem_nhdsWithin_Ici <| left_mem_Ico.2 h
#align nhds_within_Icc_eq_nhds_within_Ici nhdsWithin_Icc_eq_nhdsWithin_Ici
-/

#print nhdsWithin_Ico_eq_nhdsWithin_Ici /-
@[simp]
theorem nhdsWithin_Ico_eq_nhdsWithin_Ici {a b : Œ±} (h : a < b) : ùìù[Ico a b] a = ùìù[‚â•] a :=
  le_antisymm (nhdsWithin_mono _ fun x => And.left) <|
    nhdsWithin_le_of_mem <| Ico_mem_nhdsWithin_Ici <| left_mem_Ico.2 h
#align nhds_within_Ico_eq_nhds_within_Ici nhdsWithin_Ico_eq_nhdsWithin_Ici
-/

#print continuousWithinAt_Icc_iff_Ici /-
@[simp]
theorem continuousWithinAt_Icc_iff_Ici [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
    ContinuousWithinAt f (Icc a b) a ‚Üî ContinuousWithinAt f (Ici a) a := by
  simp only [ContinuousWithinAt, nhdsWithin_Icc_eq_nhdsWithin_Ici h]
#align continuous_within_at_Icc_iff_Ici continuousWithinAt_Icc_iff_Ici
-/

#print continuousWithinAt_Ico_iff_Ici /-
@[simp]
theorem continuousWithinAt_Ico_iff_Ici [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
    ContinuousWithinAt f (Ico a b) a ‚Üî ContinuousWithinAt f (Ici a) a := by
  simp only [ContinuousWithinAt, nhdsWithin_Ico_eq_nhdsWithin_Ici h]
#align continuous_within_at_Ico_iff_Ici continuousWithinAt_Ico_iff_Ici
-/

/-!
#### Left neighborhoods, point included
-/


#print Ioo_mem_nhdsWithin_Iic /-
theorem Ioo_mem_nhdsWithin_Iic {a b c : Œ±} (H : b ‚àà Ioo a c) : Ioo a c ‚àà ùìù[‚â§] b :=
  mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds isOpen_Ioo H
#align Ioo_mem_nhds_within_Iic Ioo_mem_nhdsWithin_Iic
-/

#print Ico_mem_nhdsWithin_Iic /-
theorem Ico_mem_nhdsWithin_Iic {a b c : Œ±} (H : b ‚àà Ioo a c) : Ico a c ‚àà ùìù[‚â§] b :=
  mem_of_superset (Ioo_mem_nhdsWithin_Iic H) Ioo_subset_Ico_self
#align Ico_mem_nhds_within_Iic Ico_mem_nhdsWithin_Iic
-/

#print Ioc_mem_nhdsWithin_Iic /-
theorem Ioc_mem_nhdsWithin_Iic {a b c : Œ±} (H : b ‚àà Ioc a c) : Ioc a c ‚àà ùìù[‚â§] b := by
  simpa only [dual_Ico] using
    Ico_mem_nhdsWithin_Ici (show to_dual b ‚àà Ico (to_dual c) (to_dual a) from H.symm)
#align Ioc_mem_nhds_within_Iic Ioc_mem_nhdsWithin_Iic
-/

#print Icc_mem_nhdsWithin_Iic /-
theorem Icc_mem_nhdsWithin_Iic {a b c : Œ±} (H : b ‚àà Ioc a c) : Icc a c ‚àà ùìù[‚â§] b :=
  mem_of_superset (Ioc_mem_nhdsWithin_Iic H) Ioc_subset_Icc_self
#align Icc_mem_nhds_within_Iic Icc_mem_nhdsWithin_Iic
-/

#print nhdsWithin_Icc_eq_nhdsWithin_Iic /-
@[simp]
theorem nhdsWithin_Icc_eq_nhdsWithin_Iic {a b : Œ±} (h : a < b) : ùìù[Icc a b] b = ùìù[‚â§] b := by
  simpa only [dual_Icc] using nhdsWithin_Icc_eq_nhdsWithin_Ici h.dual
#align nhds_within_Icc_eq_nhds_within_Iic nhdsWithin_Icc_eq_nhdsWithin_Iic
-/

#print nhdsWithin_Ioc_eq_nhdsWithin_Iic /-
@[simp]
theorem nhdsWithin_Ioc_eq_nhdsWithin_Iic {a b : Œ±} (h : a < b) : ùìù[Ioc a b] b = ùìù[‚â§] b := by
  simpa only [dual_Ico] using nhdsWithin_Ico_eq_nhdsWithin_Ici h.dual
#align nhds_within_Ioc_eq_nhds_within_Iic nhdsWithin_Ioc_eq_nhdsWithin_Iic
-/

#print continuousWithinAt_Icc_iff_Iic /-
@[simp]
theorem continuousWithinAt_Icc_iff_Iic [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
    ContinuousWithinAt f (Icc a b) b ‚Üî ContinuousWithinAt f (Iic b) b := by
  simp only [ContinuousWithinAt, nhdsWithin_Icc_eq_nhdsWithin_Iic h]
#align continuous_within_at_Icc_iff_Iic continuousWithinAt_Icc_iff_Iic
-/

#print continuousWithinAt_Ioc_iff_Iic /-
@[simp]
theorem continuousWithinAt_Ioc_iff_Iic [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
    ContinuousWithinAt f (Ioc a b) b ‚Üî ContinuousWithinAt f (Iic b) b := by
  simp only [ContinuousWithinAt, nhdsWithin_Ioc_eq_nhdsWithin_Iic h]
#align continuous_within_at_Ioc_iff_Iic continuousWithinAt_Ioc_iff_Iic
-/

end LinearOrder

section LinearOrder

variable [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderClosedTopology Œ±] {f g : Œ≤ ‚Üí Œ±}

section

variable [TopologicalSpace Œ≤]

#print lt_subset_interior_le /-
theorem lt_subset_interior_le (hf : Continuous f) (hg : Continuous g) :
    { b | f b < g b } ‚äÜ interior { b | f b ‚â§ g b } :=
  (interior_maximal fun p => le_of_lt) <| isOpen_lt hf hg
#align lt_subset_interior_le lt_subset_interior_le
-/

#print frontier_le_subset_eq /-
theorem frontier_le_subset_eq (hf : Continuous f) (hg : Continuous g) :
    frontier { b | f b ‚â§ g b } ‚äÜ { b | f b = g b } :=
  by
  rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg]
  rintro b ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©
  refine' le_antisymm hb‚ÇÅ (closure_lt_subset_le hg hf _)
  convert hb‚ÇÇ using 2; simp only [not_le.symm]; rfl
#align frontier_le_subset_eq frontier_le_subset_eq
-/

#print frontier_Iic_subset /-
theorem frontier_Iic_subset (a : Œ±) : frontier (Iic a) ‚äÜ {a} :=
  frontier_le_subset_eq (@continuous_id Œ± _) continuous_const
#align frontier_Iic_subset frontier_Iic_subset
-/

#print frontier_Ici_subset /-
theorem frontier_Ici_subset (a : Œ±) : frontier (Ici a) ‚äÜ {a} :=
  @frontier_Iic_subset Œ±·µí·µà _ _ _ _
#align frontier_Ici_subset frontier_Ici_subset
-/

#print frontier_lt_subset_eq /-
theorem frontier_lt_subset_eq (hf : Continuous f) (hg : Continuous g) :
    frontier { b | f b < g b } ‚äÜ { b | f b = g b } := by
  rw [‚Üê frontier_compl] <;> convert frontier_le_subset_eq hg hf <;> simp [ext_iff, eq_comm]
#align frontier_lt_subset_eq frontier_lt_subset_eq
-/

#print continuous_if_le /-
theorem continuous_if_le [TopologicalSpace Œ≥] [‚àÄ x, Decidable (f x ‚â§ g x)] {f' g' : Œ≤ ‚Üí Œ≥}
    (hf : Continuous f) (hg : Continuous g) (hf' : ContinuousOn f' { x | f x ‚â§ g x })
    (hg' : ContinuousOn g' { x | g x ‚â§ f x }) (hfg : ‚àÄ x, f x = g x ‚Üí f' x = g' x) :
    Continuous fun x => if f x ‚â§ g x then f' x else g' x :=
  by
  refine' continuous_if (fun a ha => hfg _ (frontier_le_subset_eq hf hg ha)) _ (hg'.mono _)
  ¬∑ rwa [(isClosed_le hf hg).closure_eq]
  ¬∑ simp only [not_le]
    exact closure_lt_subset_le hg hf
#align continuous_if_le continuous_if_le
-/

#print Continuous.if_le /-
theorem Continuous.if_le [TopologicalSpace Œ≥] [‚àÄ x, Decidable (f x ‚â§ g x)] {f' g' : Œ≤ ‚Üí Œ≥}
    (hf' : Continuous f') (hg' : Continuous g') (hf : Continuous f) (hg : Continuous g)
    (hfg : ‚àÄ x, f x = g x ‚Üí f' x = g' x) : Continuous fun x => if f x ‚â§ g x then f' x else g' x :=
  continuous_if_le hf hg hf'.ContinuousOn hg'.ContinuousOn hfg
#align continuous.if_le Continuous.if_le
-/

#print Filter.Tendsto.eventually_lt /-
theorem Filter.Tendsto.eventually_lt {l : Filter Œ≥} {f g : Œ≥ ‚Üí Œ±} {y z : Œ±} (hf : Tendsto f l (ùìù y))
    (hg : Tendsto g l (ùìù z)) (hyz : y < z) : ‚àÄ·∂† x in l, f x < g x :=
  by
  by_cases h : y ‚ãñ z
  ¬∑ filter_upwards [hf (Iio_mem_nhds hyz), hg (Ioi_mem_nhds hyz)]
    rw [h.Iio_eq]
    exact fun x hfx hgx => lt_of_le_of_lt hfx hgx
  ¬∑ obtain ‚ü®w, hyw, hwz‚ü© := (not_covby_iff hyz).mp h
    filter_upwards [hf (Iio_mem_nhds hyw), hg (Ioi_mem_nhds hwz)]
    exact fun x => lt_trans
#align tendsto.eventually_lt Filter.Tendsto.eventually_lt
-/

#print ContinuousAt.eventually_lt /-
theorem ContinuousAt.eventually_lt {x‚ÇÄ : Œ≤} (hf : ContinuousAt f x‚ÇÄ) (hg : ContinuousAt g x‚ÇÄ)
    (hfg : f x‚ÇÄ < g x‚ÇÄ) : ‚àÄ·∂† x in ùìù x‚ÇÄ, f x < g x :=
  Filter.Tendsto.eventually_lt hf hg hfg
#align continuous_at.eventually_lt ContinuousAt.eventually_lt
-/

/- warning: continuous.min -> Continuous.min is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} [_inst_4 : TopologicalSpace.{u2} Œ≤], (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 f) -> (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 g) -> (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 (fun (b : Œ≤) => LinearOrder.min.{u1} Œ± _inst_2 (f b) (g b)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} [_inst_4 : TopologicalSpace.{u2} Œ≤], (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 f) -> (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 g) -> (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 (fun (b : Œ≤) => Min.min.{u1} Œ± (LinearOrder.toMin.{u1} Œ± _inst_2) (f b) (g b)))
Case conversion may be inaccurate. Consider using '#align continuous.min Continuous.min‚Çì'. -/
@[continuity]
theorem Continuous.min (hf : Continuous f) (hg : Continuous g) :
    Continuous fun b => min (f b) (g b) :=
  by
  simp only [min_def]
  exact hf.if_le hg hf hg fun x => id
#align continuous.min Continuous.min

/- warning: continuous.max -> Continuous.max is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} [_inst_4 : TopologicalSpace.{u2} Œ≤], (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 f) -> (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 g) -> (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 (fun (b : Œ≤) => LinearOrder.max.{u1} Œ± _inst_2 (f b) (g b)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} [_inst_4 : TopologicalSpace.{u2} Œ≤], (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 f) -> (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 g) -> (Continuous.{u2, u1} Œ≤ Œ± _inst_4 _inst_1 (fun (b : Œ≤) => Max.max.{u1} Œ± (LinearOrder.toMax.{u1} Œ± _inst_2) (f b) (g b)))
Case conversion may be inaccurate. Consider using '#align continuous.max Continuous.max‚Çì'. -/
@[continuity]
theorem Continuous.max (hf : Continuous f) (hg : Continuous g) :
    Continuous fun b => max (f b) (g b) :=
  @Continuous.min Œ±·µí·µà _ _ _ _ _ _ _ hf hg
#align continuous.max Continuous.max

end

/- warning: continuous_min -> continuous_min is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))], Continuous.{u1, u1} (Prod.{u1, u1} Œ± Œ±) Œ± (Prod.topologicalSpace.{u1, u1} Œ± Œ± _inst_1 _inst_1) _inst_1 (fun (p : Prod.{u1, u1} Œ± Œ±) => LinearOrder.min.{u1} Œ± _inst_2 (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))], Continuous.{u1, u1} (Prod.{u1, u1} Œ± Œ±) Œ± (instTopologicalSpaceProd.{u1, u1} Œ± Œ± _inst_1 _inst_1) _inst_1 (fun (p : Prod.{u1, u1} Œ± Œ±) => Min.min.{u1} Œ± (LinearOrder.toMin.{u1} Œ± _inst_2) (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p))
Case conversion may be inaccurate. Consider using '#align continuous_min continuous_min‚Çì'. -/
theorem continuous_min : Continuous fun p : Œ± √ó Œ± => min p.1 p.2 :=
  continuous_fst.min continuous_snd
#align continuous_min continuous_min

/- warning: continuous_max -> continuous_max is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))], Continuous.{u1, u1} (Prod.{u1, u1} Œ± Œ±) Œ± (Prod.topologicalSpace.{u1, u1} Œ± Œ± _inst_1 _inst_1) _inst_1 (fun (p : Prod.{u1, u1} Œ± Œ±) => LinearOrder.max.{u1} Œ± _inst_2 (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))], Continuous.{u1, u1} (Prod.{u1, u1} Œ± Œ±) Œ± (instTopologicalSpaceProd.{u1, u1} Œ± Œ± _inst_1 _inst_1) _inst_1 (fun (p : Prod.{u1, u1} Œ± Œ±) => Max.max.{u1} Œ± (LinearOrder.toMax.{u1} Œ± _inst_2) (Prod.fst.{u1, u1} Œ± Œ± p) (Prod.snd.{u1, u1} Œ± Œ± p))
Case conversion may be inaccurate. Consider using '#align continuous_max continuous_max‚Çì'. -/
theorem continuous_max : Continuous fun p : Œ± √ó Œ± => max p.1 p.2 :=
  continuous_fst.max continuous_snd
#align continuous_max continuous_max

/- warning: filter.tendsto.max -> Filter.Tendsto.max is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {b : Filter.{u2} Œ≤} {a‚ÇÅ : Œ±} {a‚ÇÇ : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f b (nhds.{u1} Œ± _inst_1 a‚ÇÅ)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g b (nhds.{u1} Œ± _inst_1 a‚ÇÇ)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (b : Œ≤) => LinearOrder.max.{u1} Œ± _inst_2 (f b) (g b)) b (nhds.{u1} Œ± _inst_1 (LinearOrder.max.{u1} Œ± _inst_2 a‚ÇÅ a‚ÇÇ)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {b : Filter.{u2} Œ≤} {a‚ÇÅ : Œ±} {a‚ÇÇ : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f b (nhds.{u1} Œ± _inst_1 a‚ÇÅ)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g b (nhds.{u1} Œ± _inst_1 a‚ÇÇ)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (b : Œ≤) => Max.max.{u1} Œ± (LinearOrder.toMax.{u1} Œ± _inst_2) (f b) (g b)) b (nhds.{u1} Œ± _inst_1 (Max.max.{u1} Œ± (LinearOrder.toMax.{u1} Œ± _inst_2) a‚ÇÅ a‚ÇÇ)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.max Filter.Tendsto.max‚Çì'. -/
theorem Filter.Tendsto.max {b : Filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : Tendsto f b (ùìù a‚ÇÅ))
    (hg : Tendsto g b (ùìù a‚ÇÇ)) : Tendsto (fun b => max (f b) (g b)) b (ùìù (max a‚ÇÅ a‚ÇÇ)) :=
  (continuous_max.Tendsto (a‚ÇÅ, a‚ÇÇ)).comp (hf.prod_mk_nhds hg)
#align filter.tendsto.max Filter.Tendsto.max

/- warning: filter.tendsto.min -> Filter.Tendsto.min is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {b : Filter.{u2} Œ≤} {a‚ÇÅ : Œ±} {a‚ÇÇ : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f b (nhds.{u1} Œ± _inst_1 a‚ÇÅ)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g b (nhds.{u1} Œ± _inst_1 a‚ÇÇ)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (b : Œ≤) => LinearOrder.min.{u1} Œ± _inst_2 (f b) (g b)) b (nhds.{u1} Œ± _inst_1 (LinearOrder.min.{u1} Œ± _inst_2 a‚ÇÅ a‚ÇÇ)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {b : Filter.{u2} Œ≤} {a‚ÇÅ : Œ±} {a‚ÇÇ : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f b (nhds.{u1} Œ± _inst_1 a‚ÇÅ)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g b (nhds.{u1} Œ± _inst_1 a‚ÇÇ)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (b : Œ≤) => Min.min.{u1} Œ± (LinearOrder.toMin.{u1} Œ± _inst_2) (f b) (g b)) b (nhds.{u1} Œ± _inst_1 (Min.min.{u1} Œ± (LinearOrder.toMin.{u1} Œ± _inst_2) a‚ÇÅ a‚ÇÇ)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.min Filter.Tendsto.min‚Çì'. -/
theorem Filter.Tendsto.min {b : Filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : Tendsto f b (ùìù a‚ÇÅ))
    (hg : Tendsto g b (ùìù a‚ÇÇ)) : Tendsto (fun b => min (f b) (g b)) b (ùìù (min a‚ÇÅ a‚ÇÇ)) :=
  (continuous_min.Tendsto (a‚ÇÅ, a‚ÇÇ)).comp (hf.prod_mk_nhds hg)
#align filter.tendsto.min Filter.Tendsto.min

/- warning: filter.tendsto.max_right -> Filter.Tendsto.max_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 a)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => LinearOrder.max.{u1} Œ± _inst_2 a (f i)) l (nhds.{u1} Œ± _inst_1 a))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 a)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => Max.max.{u1} Œ± (LinearOrder.toMax.{u1} Œ± _inst_2) a (f i)) l (nhds.{u1} Œ± _inst_1 a))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.max_right Filter.Tendsto.max_right‚Çì'. -/
theorem Filter.Tendsto.max_right {l : Filter Œ≤} {a : Œ±} (h : Tendsto f l (ùìù a)) :
    Tendsto (fun i => max a (f i)) l (ùìù a) :=
  by
  convert((continuous_max.comp (@Continuous.Prod.mk Œ± Œ± _ _ a)).Tendsto a).comp h
  simp
#align filter.tendsto.max_right Filter.Tendsto.max_right

/- warning: filter.tendsto.max_left -> Filter.Tendsto.max_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 a)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => LinearOrder.max.{u1} Œ± _inst_2 (f i) a) l (nhds.{u1} Œ± _inst_1 a))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 a)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => Max.max.{u1} Œ± (LinearOrder.toMax.{u1} Œ± _inst_2) (f i) a) l (nhds.{u1} Œ± _inst_1 a))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.max_left Filter.Tendsto.max_left‚Çì'. -/
theorem Filter.Tendsto.max_left {l : Filter Œ≤} {a : Œ±} (h : Tendsto f l (ùìù a)) :
    Tendsto (fun i => max (f i) a) l (ùìù a) :=
  by
  simp_rw [max_comm _ a]
  exact h.max_right
#align filter.tendsto.max_left Filter.Tendsto.max_left

/- warning: filter.tendsto_nhds_max_right -> Filter.tendsto_nhds_max_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => LinearOrder.max.{u1} Œ± _inst_2 a (f i)) l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => Max.max.{u1} Œ± (LinearOrder.toMax.{u1} Œ± _inst_2) a (f i)) l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_nhds_max_right Filter.tendsto_nhds_max_right‚Çì'. -/
theorem Filter.tendsto_nhds_max_right {l : Filter Œ≤} {a : Œ±} (h : Tendsto f l (ùìù[>] a)) :
    Tendsto (fun i => max a (f i)) l (ùìù[>] a) :=
  by
  obtain ‚ü®h‚ÇÅ : tendsto f l (ùìù a), h‚ÇÇ : ‚àÄ·∂† i in l, f i ‚àà Ioi a‚ü© := tendsto_nhds_within_iff.mp h
  exact tendsto_nhds_within_iff.mpr ‚ü®h‚ÇÅ.max_right, h‚ÇÇ.mono fun i hi => lt_max_of_lt_right hi‚ü©
#align filter.tendsto_nhds_max_right Filter.tendsto_nhds_max_right

/- warning: filter.tendsto_nhds_max_left -> Filter.tendsto_nhds_max_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => LinearOrder.max.{u1} Œ± _inst_2 (f i) a) l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => Max.max.{u1} Œ± (LinearOrder.toMax.{u1} Œ± _inst_2) (f i) a) l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_nhds_max_left Filter.tendsto_nhds_max_left‚Çì'. -/
theorem Filter.tendsto_nhds_max_left {l : Filter Œ≤} {a : Œ±} (h : Tendsto f l (ùìù[>] a)) :
    Tendsto (fun i => max (f i) a) l (ùìù[>] a) :=
  by
  simp_rw [max_comm _ a]
  exact Filter.tendsto_nhds_max_right h
#align filter.tendsto_nhds_max_left Filter.tendsto_nhds_max_left

/- warning: filter.tendsto.min_right -> Filter.Tendsto.min_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 a)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => LinearOrder.min.{u1} Œ± _inst_2 a (f i)) l (nhds.{u1} Œ± _inst_1 a))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 a)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => Min.min.{u1} Œ± (LinearOrder.toMin.{u1} Œ± _inst_2) a (f i)) l (nhds.{u1} Œ± _inst_1 a))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.min_right Filter.Tendsto.min_right‚Çì'. -/
theorem Filter.Tendsto.min_right {l : Filter Œ≤} {a : Œ±} (h : Tendsto f l (ùìù a)) :
    Tendsto (fun i => min a (f i)) l (ùìù a) :=
  @Filter.Tendsto.max_right Œ±·µí·µà Œ≤ _ _ _ f l a h
#align filter.tendsto.min_right Filter.Tendsto.min_right

/- warning: filter.tendsto.min_left -> Filter.Tendsto.min_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 a)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => LinearOrder.min.{u1} Œ± _inst_2 (f i) a) l (nhds.{u1} Œ± _inst_1 a))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 a)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => Min.min.{u1} Œ± (LinearOrder.toMin.{u1} Œ± _inst_2) (f i) a) l (nhds.{u1} Œ± _inst_1 a))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.min_left Filter.Tendsto.min_left‚Çì'. -/
theorem Filter.Tendsto.min_left {l : Filter Œ≤} {a : Œ±} (h : Tendsto f l (ùìù a)) :
    Tendsto (fun i => min (f i) a) l (ùìù a) :=
  @Filter.Tendsto.max_left Œ±·µí·µà Œ≤ _ _ _ f l a h
#align filter.tendsto.min_left Filter.Tendsto.min_left

/- warning: filter.tendsto_nhds_min_right -> Filter.tendsto_nhds_min_right is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => LinearOrder.min.{u1} Œ± _inst_2 a (f i)) l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => Min.min.{u1} Œ± (LinearOrder.toMin.{u1} Œ± _inst_2) a (f i)) l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_nhds_min_right Filter.tendsto_nhds_min_right‚Çì'. -/
theorem Filter.tendsto_nhds_min_right {l : Filter Œ≤} {a : Œ±} (h : Tendsto f l (ùìù[<] a)) :
    Tendsto (fun i => min a (f i)) l (ùìù[<] a) :=
  @Filter.tendsto_nhds_max_right Œ±·µí·µà Œ≤ _ _ _ f l a h
#align filter.tendsto_nhds_min_right Filter.tendsto_nhds_min_right

/- warning: filter.tendsto_nhds_min_left -> Filter.tendsto_nhds_min_left is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => LinearOrder.min.{u1} Œ± _inst_2 (f i) a) l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {f : Œ≤ -> Œ±} {l : Filter.{u2} Œ≤} {a : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (i : Œ≤) => Min.min.{u1} Œ± (LinearOrder.toMin.{u1} Œ± _inst_2) (f i) a) l (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)))
Case conversion may be inaccurate. Consider using '#align filter.tendsto_nhds_min_left Filter.tendsto_nhds_min_left‚Çì'. -/
theorem Filter.tendsto_nhds_min_left {l : Filter Œ≤} {a : Œ±} (h : Tendsto f l (ùìù[<] a)) :
    Tendsto (fun i => min (f i) a) l (ùìù[<] a) :=
  @Filter.tendsto_nhds_max_left Œ±·µí·µà Œ≤ _ _ _ f l a h
#align filter.tendsto_nhds_min_left Filter.tendsto_nhds_min_left

/- warning: dense.exists_lt -> Dense.exists_lt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) y x)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) y s) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) y x)))
Case conversion may be inaccurate. Consider using '#align dense.exists_lt Dense.exists_lt‚Çì'. -/
theorem Dense.exists_lt [NoMinOrder Œ±] {s : Set Œ±} (hs : Dense s) (x : Œ±) : ‚àÉ y ‚àà s, y < x :=
  hs.exists_mem_open isOpen_Iio (exists_lt x)
#align dense.exists_lt Dense.exists_lt

/- warning: dense.exists_gt -> Dense.exists_gt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) x y)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) y s) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) x y)))
Case conversion may be inaccurate. Consider using '#align dense.exists_gt Dense.exists_gt‚Çì'. -/
theorem Dense.exists_gt [NoMaxOrder Œ±] {s : Set Œ±} (hs : Dense s) (x : Œ±) : ‚àÉ y ‚àà s, x < y :=
  hs.OrderDual.exists_lt x
#align dense.exists_gt Dense.exists_gt

/- warning: dense.exists_le -> Dense.exists_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) => LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) y x)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) y s) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) y x)))
Case conversion may be inaccurate. Consider using '#align dense.exists_le Dense.exists_le‚Çì'. -/
theorem Dense.exists_le [NoMinOrder Œ±] {s : Set Œ±} (hs : Dense s) (x : Œ±) : ‚àÉ y ‚àà s, y ‚â§ x :=
  (hs.exists_lt x).imp fun y hy => ‚ü®hy.fst, hy.snd.le‚ü©
#align dense.exists_le Dense.exists_le

/- warning: dense.exists_ge -> Dense.exists_ge is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) => LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) x y)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) y s) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) x y)))
Case conversion may be inaccurate. Consider using '#align dense.exists_ge Dense.exists_ge‚Çì'. -/
theorem Dense.exists_ge [NoMaxOrder Œ±] {s : Set Œ±} (hs : Dense s) (x : Œ±) : ‚àÉ y ‚àà s, x ‚â§ y :=
  hs.OrderDual.exists_le x
#align dense.exists_ge Dense.exists_ge

/- warning: dense.exists_le' -> Dense.exists_le' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), (IsBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) x) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) => LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) y x)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), (IsBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) x) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) y s) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) y x)))
Case conversion may be inaccurate. Consider using '#align dense.exists_le' Dense.exists_le'‚Çì'. -/
theorem Dense.exists_le' {s : Set Œ±} (hs : Dense s) (hbot : ‚àÄ x, IsBot x ‚Üí x ‚àà s) (x : Œ±) :
    ‚àÉ y ‚àà s, y ‚â§ x := by
  by_cases hx : IsBot x
  ¬∑ exact ‚ü®x, hbot x hx, le_rfl‚ü©
  ¬∑ simp only [IsBot, not_forall, not_le] at hx
    rcases hs.exists_mem_open isOpen_Iio hx with ‚ü®y, hys, hy : y < x‚ü©
    exact ‚ü®y, hys, hy.le‚ü©
#align dense.exists_le' Dense.exists_le'

/- warning: dense.exists_ge' -> Dense.exists_ge' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), (IsTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) x) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) y s) => LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) x y)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall (x : Œ±), (IsTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) x) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) -> (forall (x : Œ±), Exists.{succ u1} Œ± (fun (y : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) y s) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) x y)))
Case conversion may be inaccurate. Consider using '#align dense.exists_ge' Dense.exists_ge'‚Çì'. -/
theorem Dense.exists_ge' {s : Set Œ±} (hs : Dense s) (htop : ‚àÄ x, IsTop x ‚Üí x ‚àà s) (x : Œ±) :
    ‚àÉ y ‚àà s, x ‚â§ y :=
  hs.OrderDual.exists_le' htop x
#align dense.exists_ge' Dense.exists_ge'

/- warning: dense.exists_between -> Dense.exists_between is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) x y) -> (Exists.{succ u1} Œ± (fun (z : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) z s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) z s) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) z (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) x y)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderClosedTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {s : Set.{u1} Œ±}, (Dense.{u1} Œ± _inst_1 s) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) x y) -> (Exists.{succ u1} Œ± (fun (z : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) z s) (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) z (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) x y)))))
Case conversion may be inaccurate. Consider using '#align dense.exists_between Dense.exists_between‚Çì'. -/
theorem Dense.exists_between [DenselyOrdered Œ±] {s : Set Œ±} (hs : Dense s) {x y : Œ±} (h : x < y) :
    ‚àÉ z ‚àà s, z ‚àà Ioo x y :=
  hs.exists_mem_open isOpen_Ioo (nonempty_Ioo.2 h)
#align dense.exists_between Dense.exists_between

variable [Nonempty Œ±] [TopologicalSpace Œ≤]

#print IsCompact.bddBelow /-
/-- A compact set is bounded below -/
theorem IsCompact.bddBelow {s : Set Œ±} (hs : IsCompact s) : BddBelow s :=
  by
  by_contra H
  rcases hs.elim_finite_subcover_image (fun x (_ : x ‚àà s) => @isOpen_Ioi _ _ _ _ x) _ with
    ‚ü®t, st, ft, ht‚ü©
  ¬∑ refine' H (ft.bdd_below.imp fun C hC y hy => _)
    rcases mem_Union‚ÇÇ.1 (ht hy) with ‚ü®x, hx, xy‚ü©
    exact le_trans (hC hx) (le_of_lt xy)
  ¬∑ refine' fun x hx => mem_Union‚ÇÇ.2 (not_imp_comm.1 _ H)
    exact fun h => ‚ü®x, fun y hy => le_of_not_lt (h.imp fun ys => ‚ü®_, hy, ys‚ü©)‚ü©
#align is_compact.bdd_below IsCompact.bddBelow
-/

#print IsCompact.bddAbove /-
/-- A compact set is bounded above -/
theorem IsCompact.bddAbove {s : Set Œ±} (hs : IsCompact s) : BddAbove s :=
  @IsCompact.bddBelow Œ±·µí·µà _ _ _ _ _ hs
#align is_compact.bdd_above IsCompact.bddAbove
-/

#print IsCompact.bddBelow_image /-
/-- A continuous function is bounded below on a compact set. -/
theorem IsCompact.bddBelow_image {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤} (hK : IsCompact K)
    (hf : ContinuousOn f K) : BddBelow (f '' K) :=
  (hK.image_of_continuousOn hf).BddBelow
#align is_compact.bdd_below_image IsCompact.bddBelow_image
-/

#print IsCompact.bddAbove_image /-
/-- A continuous function is bounded above on a compact set. -/
theorem IsCompact.bddAbove_image {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤} (hK : IsCompact K)
    (hf : ContinuousOn f K) : BddAbove (f '' K) :=
  @IsCompact.bddBelow_image Œ±·µí·µà _ _ _ _ _ _ _ _ hK hf
#align is_compact.bdd_above_image IsCompact.bddAbove_image
-/

#print Continuous.bddBelow_range_of_hasCompactMulSupport /-
/-- A continuous function with compact support is bounded below. -/
@[to_additive " A continuous function with compact support is bounded below. "]
theorem Continuous.bddBelow_range_of_hasCompactMulSupport [One Œ±] {f : Œ≤ ‚Üí Œ±} (hf : Continuous f)
    (h : HasCompactMulSupport f) : BddBelow (range f) :=
  (h.isCompact_range hf).BddBelow
#align continuous.bdd_below_range_of_has_compact_mul_support Continuous.bddBelow_range_of_hasCompactMulSupport
#align continuous.bdd_below_range_of_has_compact_support Continuous.bddBelow_range_of_hasCompactSupport
-/

#print Continuous.bddAbove_range_of_hasCompactMulSupport /-
/-- A continuous function with compact support is bounded above. -/
@[to_additive " A continuous function with compact support is bounded above. "]
theorem Continuous.bddAbove_range_of_hasCompactMulSupport [One Œ±] {f : Œ≤ ‚Üí Œ±} (hf : Continuous f)
    (h : HasCompactMulSupport f) : BddAbove (range f) :=
  @Continuous.bddBelow_range_of_hasCompactMulSupport Œ±·µí·µà _ _ _ _ _ _ _ _ hf h
#align continuous.bdd_above_range_of_has_compact_mul_support Continuous.bddAbove_range_of_hasCompactMulSupport
#align continuous.bdd_above_range_of_has_compact_support Continuous.bddAbove_range_of_hasCompactSupport
-/

end LinearOrder

end OrderClosedTopology

instance [Preorder Œ±] [TopologicalSpace Œ±] [OrderClosedTopology Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤]
    [OrderClosedTopology Œ≤] : OrderClosedTopology (Œ± √ó Œ≤) :=
  ‚ü®(isClosed_le (continuous_fst.comp continuous_fst) (continuous_fst.comp continuous_snd)).inter
      (isClosed_le (continuous_snd.comp continuous_fst) (continuous_snd.comp continuous_snd))‚ü©

instance {Œπ : Type _} {Œ± : Œπ ‚Üí Type _} [‚àÄ i, Preorder (Œ± i)] [‚àÄ i, TopologicalSpace (Œ± i)]
    [‚àÄ i, OrderClosedTopology (Œ± i)] : OrderClosedTopology (‚àÄ i, Œ± i) :=
  by
  constructor
  simp only [Pi.le_def, set_of_forall]
  exact
    isClosed_iInter fun i =>
      isClosed_le ((continuous_apply i).comp continuous_fst)
        ((continuous_apply i).comp continuous_snd)

#print Pi.orderClosedTopology' /-
instance Pi.orderClosedTopology' [Preorder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] :
    OrderClosedTopology (Œ± ‚Üí Œ≤) :=
  Pi.orderClosedTopology
#align pi.order_closed_topology' Pi.orderClosedTopology'
-/

#print OrderTopology /-
/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`preorder.topology`. -/
class OrderTopology (Œ± : Type _) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where
  topology_eq_generate_intervals : t = generateFrom { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a }
#align order_topology OrderTopology
-/

#print Preorder.topology /-
/-- (Order) topology on a partial order `Œ±` generated by the subbase of open intervals
`(a, ‚àû) = { x ‚à£ a < x }, (-‚àû , b) = {x ‚à£ x < b}` for all `a, b` in `Œ±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def Preorder.topology (Œ± : Type _) [Preorder Œ±] : TopologicalSpace Œ± :=
  generateFrom { s : Set Œ± | ‚àÉ a : Œ±, s = { b : Œ± | a < b } ‚à® s = { b : Œ± | b < a } }
#align preorder.topology Preorder.topology
-/

section OrderTopology

section Preorder

variable [TopologicalSpace Œ±] [Preorder Œ±] [t : OrderTopology Œ±]

include t

instance : OrderTopology Œ±·µí·µà :=
  ‚ü®by
    convert@OrderTopology.topology_eq_generate_intervals Œ± _ _ _ <;>
        conv in _ ‚à® _ => rw [or_comm] <;>
      rfl‚ü©

#print isOpen_iff_generate_intervals /-
theorem isOpen_iff_generate_intervals {s : Set Œ±} :
    IsOpen s ‚Üî GenerateOpen { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a } s := by
  rw [t.topology_eq_generate_intervals] <;> rfl
#align is_open_iff_generate_intervals isOpen_iff_generate_intervals
-/

#print isOpen_lt' /-
theorem isOpen_lt' (a : Œ±) : IsOpen { b : Œ± | a < b } := by
  rw [@isOpen_iff_generate_intervals Œ± _ _ t] <;> exact generate_open.basic _ ‚ü®a, Or.inl rfl‚ü©
#align is_open_lt' isOpen_lt'
-/

#print isOpen_gt' /-
theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } := by
  rw [@isOpen_iff_generate_intervals Œ± _ _ t] <;> exact generate_open.basic _ ‚ü®a, Or.inr rfl‚ü©
#align is_open_gt' isOpen_gt'
-/

#print lt_mem_nhds /-
theorem lt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a < x :=
  IsOpen.mem_nhds (isOpen_lt' _) h
#align lt_mem_nhds lt_mem_nhds
-/

#print le_mem_nhds /-
theorem le_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a ‚â§ x :=
  (ùìù b).sets_of_superset (lt_mem_nhds h) fun b hb => le_of_lt hb
#align le_mem_nhds le_mem_nhds
-/

#print gt_mem_nhds /-
theorem gt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=
  IsOpen.mem_nhds (isOpen_gt' _) h
#align gt_mem_nhds gt_mem_nhds
-/

#print ge_mem_nhds /-
theorem ge_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=
  (ùìù a).sets_of_superset (gt_mem_nhds h) fun b hb => le_of_lt hb
#align ge_mem_nhds ge_mem_nhds
-/

/- warning: nhds_eq_order -> nhds_eq_order is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [t : OrderTopology.{u1} Œ± _inst_1 _inst_2] (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 a) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (b : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) b (Set.Iio.{u1} Œ± _inst_2 a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) b (Set.Iio.{u1} Œ± _inst_2 a)) => Filter.principal.{u1} Œ± (Set.Ioi.{u1} Œ± _inst_2 b)))) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (b : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) b (Set.Ioi.{u1} Œ± _inst_2 a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) b (Set.Ioi.{u1} Œ± _inst_2 a)) => Filter.principal.{u1} Œ± (Set.Iio.{u1} Œ± _inst_2 b)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [t : OrderTopology.{u1} Œ± _inst_1 _inst_2] (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 a) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (b : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) b (Set.Iio.{u1} Œ± _inst_2 a)) (fun (H : Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) b (Set.Iio.{u1} Œ± _inst_2 a)) => Filter.principal.{u1} Œ± (Set.Ioi.{u1} Œ± _inst_2 b)))) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (b : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) b (Set.Ioi.{u1} Œ± _inst_2 a)) (fun (H : Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) b (Set.Ioi.{u1} Œ± _inst_2 a)) => Filter.principal.{u1} Œ± (Set.Iio.{u1} Œ± _inst_2 b)))))
Case conversion may be inaccurate. Consider using '#align nhds_eq_order nhds_eq_order‚Çì'. -/
theorem nhds_eq_order (a : Œ±) : ùìù a = (‚®Ö b ‚àà Iio a, ùìü (Ioi b)) ‚äì ‚®Ö b ‚àà Ioi a, ùìü (Iio b) := by
  rw [t.topology_eq_generate_intervals, nhds_generate_from] <;>
    exact
      le_antisymm
        (le_inf
          (le_iInf‚ÇÇ fun b hb => iInf_le_of_le { c : Œ± | b < c } <| iInf_le _ ‚ü®hb, b, Or.inl rfl‚ü©)
          (le_iInf‚ÇÇ fun b hb => iInf_le_of_le { c : Œ± | c < b } <| iInf_le _ ‚ü®hb, b, Or.inr rfl‚ü©))
        (le_iInf fun s =>
          le_iInf fun ‚ü®ha, b, hs‚ü© =>
            match s, ha, hs with
            | _, h, Or.inl rfl => inf_le_of_left_le <| iInf_le_of_le b <| iInf_le _ h
            | _, h, Or.inr rfl => inf_le_of_right_le <| iInf_le_of_le b <| iInf_le _ h)
#align nhds_eq_order nhds_eq_order

#print tendsto_order /-
theorem tendsto_order {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤} :
    Tendsto f x (ùìù a) ‚Üî (‚àÄ a' < a, ‚àÄ·∂† b in x, a' < f b) ‚àß ‚àÄ a' > a, ‚àÄ·∂† b in x, f b < a' := by
  simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]
#align tendsto_order tendsto_order
-/

#print tendstoIccClassNhds /-
instance tendstoIccClassNhds (a : Œ±) : TendstoIxxClass Icc (ùìù a) (ùìù a) :=
  by
  simp only [nhds_eq_order, iInf_subtype']
  refine'
    ((has_basis_infi_principal_finite _).inf (has_basis_infi_principal_finite _)).TendstoIxxClass
      fun s hs => _
  refine' ((ord_connected_bInter _).inter (ord_connected_bInter _)).out <;> intro _ _
  exacts[ord_connected_Ioi, ord_connected_Iio]
#align tendsto_Icc_class_nhds tendstoIccClassNhds
-/

#print tendstoIcoClassNhds /-
instance tendstoIcoClassNhds (a : Œ±) : TendstoIxxClass Ico (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self
#align tendsto_Ico_class_nhds tendstoIcoClassNhds
-/

#print tendstoIocClassNhds /-
instance tendstoIocClassNhds (a : Œ±) : TendstoIxxClass Ioc (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self
#align tendsto_Ioc_class_nhds tendstoIocClassNhds
-/

#print tendstoIooClassNhds /-
instance tendstoIooClassNhds (a : Œ±) : TendstoIxxClass Ioo (ùìù a) (ùìù a) :=
  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Icc_self
#align tendsto_Ioo_class_nhds tendstoIooClassNhds
-/

#print tendsto_of_tendsto_of_tendsto_of_le_of_le' /-
/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold eventually for the filter. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a : Œ±}
    (hg : Tendsto g b (ùìù a)) (hh : Tendsto h b (ùìù a)) (hgf : ‚àÄ·∂† b in b, g b ‚â§ f b)
    (hfh : ‚àÄ·∂† b in b, f b ‚â§ h b) : Tendsto f b (ùìù a) :=
  (hg.Icc hh).of_smallSets <| hgf.And hfh
#align tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_of_tendsto_of_tendsto_of_le_of_le'
-/

#print tendsto_of_tendsto_of_tendsto_of_le_of_le /-
/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold everywhere. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a : Œ±}
    (hg : Tendsto g b (ùìù a)) (hh : Tendsto h b (ùìù a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) :
    Tendsto f b (ùìù a) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (eventually_of_forall hgf)
    (eventually_of_forall hfh)
#align tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_of_tendsto_of_tendsto_of_le_of_le
-/

/- warning: nhds_order_unbounded -> nhds_order_unbounded is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [t : OrderTopology.{u1} Œ± _inst_1 _inst_2] {a : Œ±}, (Exists.{succ u1} Œ± (fun (u : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u)) -> (Exists.{succ u1} Œ± (fun (l : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a)) -> (Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 a) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (l : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) (fun (h‚ÇÇ : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) => iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (u : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) (fun (h‚ÇÇ : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) => Filter.principal.{u1} Œ± (Set.Ioo.{u1} Œ± _inst_2 l u)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [t : OrderTopology.{u1} Œ± _inst_1 _inst_2] {a : Œ±}, (Exists.{succ u1} Œ± (fun (u : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u)) -> (Exists.{succ u1} Œ± (fun (l : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a)) -> (Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 a) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (l : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) (fun (h‚ÇÇ : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) => iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (u : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) (fun (h‚ÇÇ : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) => Filter.principal.{u1} Œ± (Set.Ioo.{u1} Œ± _inst_2 l u)))))))
Case conversion may be inaccurate. Consider using '#align nhds_order_unbounded nhds_order_unbounded‚Çì'. -/
theorem nhds_order_unbounded {a : Œ±} (hu : ‚àÉ u, a < u) (hl : ‚àÉ l, l < a) :
    ùìù a = ‚®Ö (l) (h‚ÇÇ : l < a) (u) (h‚ÇÇ : a < u), ùìü (Ioo l u) :=
  by
  have : ‚àÉ u, u ‚àà Ioi a := hu
  have : ‚àÉ l, l ‚àà Iio a := hl
  simp only [nhds_eq_order, inf_biInf, biInf_inf, *, inf_principal, Ioi_inter_Iio]
  rfl
#align nhds_order_unbounded nhds_order_unbounded

#print tendsto_order_unbounded /-
theorem tendsto_order_unbounded {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤} (hu : ‚àÉ u, a < u)
    (hl : ‚àÉ l, l < a) (h : ‚àÄ l u, l < a ‚Üí a < u ‚Üí ‚àÄ·∂† b in x, l < f b ‚àß f b < u) :
    Tendsto f x (ùìù a) := by
  rw [nhds_order_unbounded hu hl] <;>
    exact
      tendsto_infi.2 fun l =>
        tendsto_infi.2 fun hl =>
          tendsto_infi.2 fun u => tendsto_infi.2 fun hu => tendsto_principal.2 <| h l u hl hu
#align tendsto_order_unbounded tendsto_order_unbounded
-/

end Preorder

#print tendstoIxxNhdsWithin /-
instance tendstoIxxNhdsWithin {Œ± : Type _} [Preorder Œ±] [TopologicalSpace Œ±] (a : Œ±) {s t : Set Œ±}
    {Ixx} [TendstoIxxClass Ixx (ùìù a) (ùìù a)] [TendstoIxxClass Ixx (ùìü s) (ùìü t)] :
    TendstoIxxClass Ixx (ùìù[s] a) (ùìù[t] a) :=
  Filter.tendstoIxxClass_inf
#align tendsto_Ixx_nhds_within tendstoIxxNhdsWithin
-/

#print tendstoIccClassNhdsPi /-
instance tendstoIccClassNhdsPi {Œπ : Type _} {Œ± : Œπ ‚Üí Type _} [‚àÄ i, Preorder (Œ± i)]
    [‚àÄ i, TopologicalSpace (Œ± i)] [‚àÄ i, OrderTopology (Œ± i)] (f : ‚àÄ i, Œ± i) :
    TendstoIxxClass Icc (ùìù f) (ùìù f) := by
  constructor
  conv in (ùìù f).smallSets => rw [nhds_pi, Filter.pi]
  simp only [small_sets_infi, small_sets_comap, tendsto_infi, tendsto_lift', (¬∑ ‚àò ¬∑),
    mem_powerset_iff]
  intro i s hs
  have : tendsto (fun g : ‚àÄ i, Œ± i => g i) (ùìù f) (ùìù (f i)) := (continuous_apply i).Tendsto f
  refine' (tendsto_lift'.1 ((this.comp tendsto_fst).Icc (this.comp tendsto_snd)) s hs).mono _
  exact fun p hp g hg => hp ‚ü®hg.1 _, hg.2 _‚ü©
#align tendsto_Icc_class_nhds_pi tendstoIccClassNhdsPi
-/

/- warning: induced_order_topology' -> induced_orderTopology' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : Preorder.{u1} Œ±] [ta : TopologicalSpace.{u2} Œ≤] [_inst_2 : Preorder.{u2} Œ≤] [_inst_3 : OrderTopology.{u2} Œ≤ ta _inst_2] (f : Œ± -> Œ≤), (forall {x : Œ±} {y : Œ±}, Iff (LT.lt.{u2} Œ≤ (Preorder.toLT.{u2} Œ≤ _inst_2) (f x) (f y)) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_1) x y)) -> (forall {a : Œ±} {x : Œ≤}, (LT.lt.{u2} Œ≤ (Preorder.toLT.{u2} Œ≤ _inst_2) x (f a)) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_1) b a) (fun (H : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_1) b a) => LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) x (f b))))) -> (forall {a : Œ±} {x : Œ≤}, (LT.lt.{u2} Œ≤ (Preorder.toLT.{u2} Œ≤ _inst_2) (f a) x) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => Exists.{0} (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_1) b a) (fun (H : GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_1) b a) => LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) (f b) x)))) -> (OrderTopology.{u1} Œ± (TopologicalSpace.induced.{u1, u2} Œ± Œ≤ f ta) _inst_1)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : Preorder.{u1} Œ±] [ta : TopologicalSpace.{u2} Œ≤] [_inst_2 : Preorder.{u2} Œ≤] [_inst_3 : OrderTopology.{u2} Œ≤ ta _inst_2] (f : Œ± -> Œ≤), (forall {x : Œ±} {y : Œ±}, Iff (LT.lt.{u2} Œ≤ (Preorder.toLT.{u2} Œ≤ _inst_2) (f x) (f y)) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_1) x y)) -> (forall {a : Œ±} {x : Œ≤}, (LT.lt.{u2} Œ≤ (Preorder.toLT.{u2} Œ≤ _inst_2) x (f a)) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_1) b a) (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) x (f b))))) -> (forall {a : Œ±} {x : Œ≤}, (LT.lt.{u2} Œ≤ (Preorder.toLT.{u2} Œ≤ _inst_2) (f a) x) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => And (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_1) b a) (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) (f b) x)))) -> (OrderTopology.{u1} Œ± (TopologicalSpace.induced.{u1, u2} Œ± Œ≤ f ta) _inst_1)
Case conversion may be inaccurate. Consider using '#align induced_order_topology' induced_orderTopology'‚Çì'. -/
theorem induced_orderTopology' {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [ta : TopologicalSpace Œ≤]
    [Preorder Œ≤] [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H‚ÇÅ : ‚àÄ {a x}, x < f a ‚Üí ‚àÉ b < a, x ‚â§ f b) (H‚ÇÇ : ‚àÄ {a x}, f a < x ‚Üí ‚àÉ b > a, f b ‚â§ x) :
    @OrderTopology _ (induced f ta) _ :=
  by
  letI := induced f ta
  refine' ‚ü®eq_of_nhds_eq_nhds fun a => _‚ü©
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (f a)]
  apply le_antisymm
  ¬∑ refine' le_iInf fun s => le_iInf fun hs => le_principal_iff.2 _
    rcases hs with ‚ü®ab, b, rfl | rfl‚ü©
    ¬∑
      exact
        mem_comap.2
          ‚ü®{ x | f b < x },
            mem_inf_of_left <|
              mem_infi_of_mem _ <| mem_infi_of_mem (hf.2 ab) <| mem_principal_self _,
            fun x => hf.1‚ü©
    ¬∑
      exact
        mem_comap.2
          ‚ü®{ x | x < f b },
            mem_inf_of_right <|
              mem_infi_of_mem _ <| mem_infi_of_mem (hf.2 ab) <| mem_principal_self _,
            fun x => hf.1‚ü©
  ¬∑ rw [‚Üê map_le_iff_le_comap]
    refine' le_inf _ _ <;> refine' le_iInf fun x => le_iInf fun h => le_principal_iff.2 _ <;> simp
    ¬∑ rcases H‚ÇÅ h with ‚ü®b, ab, xb‚ü©
      refine' mem_infi_of_mem _ (mem_infi_of_mem ‚ü®ab, b, Or.inl rfl‚ü© (mem_principal.2 _))
      exact fun c hc => lt_of_le_of_lt xb (hf.2 hc)
    ¬∑ rcases H‚ÇÇ h with ‚ü®b, ab, xb‚ü©
      refine' mem_infi_of_mem _ (mem_infi_of_mem ‚ü®ab, b, Or.inr rfl‚ü© (mem_principal.2 _))
      exact fun c hc => lt_of_lt_of_le (hf.2 hc) xb
#align induced_order_topology' induced_orderTopology'

#print induced_orderTopology /-
theorem induced_orderTopology {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [ta : TopologicalSpace Œ≤]
    [Preorder Œ≤] [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
    (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) : @OrderTopology _ (induced f ta) _ :=
  induced_orderTopology' f (@hf)
    (fun a x xa =>
      let ‚ü®b, xb, ba‚ü© := H xa
      ‚ü®b, hf.1 ba, le_of_lt xb‚ü©)
    fun a x ax =>
    let ‚ü®b, ab, bx‚ü© := H ax
    ‚ü®b, hf.1 ab, le_of_lt bx‚ü©
#align induced_order_topology induced_orderTopology
-/

#print orderTopology_of_ordConnected /-
/-- On an `ord_connected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance orderTopology_of_ordConnected {Œ± : Type u} [ta : TopologicalSpace Œ±] [LinearOrder Œ±]
    [OrderTopology Œ±] {t : Set Œ±} [ht : OrdConnected t] : OrderTopology t :=
  by
  letI := induced (coe : t ‚Üí Œ±) ta
  refine' ‚ü®eq_of_nhds_eq_nhds fun a => _‚ü©
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (a : Œ±)]
  apply le_antisymm
  ¬∑ refine' le_iInf fun s => le_iInf fun hs => le_principal_iff.2 _
    rcases hs with ‚ü®ab, b, rfl | rfl‚ü©
    ¬∑ refine' ‚ü®Ioi b, _, fun _ => id‚ü©
      refine' mem_inf_of_left (mem_infi_of_mem b _)
      exact mem_infi_of_mem ab (mem_principal_self (Ioi ‚Üëb))
    ¬∑ refine' ‚ü®Iio b, _, fun _ => id‚ü©
      refine' mem_inf_of_right (mem_infi_of_mem b _)
      exact mem_infi_of_mem ab (mem_principal_self (Iio b))
  ¬∑ rw [‚Üê map_le_iff_le_comap]
    refine' le_inf _ _
    ¬∑ refine' le_iInf fun x => le_iInf fun h => le_principal_iff.2 _
      by_cases hx : x ‚àà t
      ¬∑ refine' mem_infi_of_mem (Ioi ‚ü®x, hx‚ü©) (mem_infi_of_mem ‚ü®h, ‚ü®‚ü®x, hx‚ü©, Or.inl rfl‚ü©‚ü© _)
        exact fun _ => id
      simp only [SetCoe.exists, mem_set_of_eq, mem_map']
      convert univ_sets _
      suffices hx' : ‚àÄ y : t, ‚Üëy ‚àà Ioi x
      ¬∑ simp [hx']
      intro y
      revert hx
      contrapose!
      -- here we use the `ord_connected` hypothesis
      exact fun hx => ht.out y.2 a.2 ‚ü®le_of_not_gt hx, le_of_lt h‚ü©
    ¬∑ refine' le_iInf fun x => le_iInf fun h => le_principal_iff.2 _
      by_cases hx : x ‚àà t
      ¬∑ refine' mem_infi_of_mem (Iio ‚ü®x, hx‚ü©) (mem_infi_of_mem ‚ü®h, ‚ü®‚ü®x, hx‚ü©, Or.inr rfl‚ü©‚ü© _)
        exact fun _ => id
      simp only [SetCoe.exists, mem_set_of_eq, mem_map']
      convert univ_sets _
      suffices hx' : ‚àÄ y : t, ‚Üëy ‚àà Iio x
      ¬∑ simp [hx']
      intro y
      revert hx
      contrapose!
      -- here we use the `ord_connected` hypothesis
      exact fun hx => ht.out a.2 y.2 ‚ü®le_of_lt h, le_of_not_gt hx‚ü©
#align order_topology_of_ord_connected orderTopology_of_ordConnected
-/

/- warning: nhds_within_Ici_eq'' -> nhdsWithin_Ici_eq'' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 _inst_2] (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± _inst_2 a)) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (u : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) (fun (hu : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) => Filter.principal.{u1} Œ± (Set.Iio.{u1} Œ± _inst_2 u)))) (Filter.principal.{u1} Œ± (Set.Ici.{u1} Œ± _inst_2 a)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 _inst_2] (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± _inst_2 a)) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (u : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) (fun (hu : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) => Filter.principal.{u1} Œ± (Set.Iio.{u1} Œ± _inst_2 u)))) (Filter.principal.{u1} Œ± (Set.Ici.{u1} Œ± _inst_2 a)))
Case conversion may be inaccurate. Consider using '#align nhds_within_Ici_eq'' nhdsWithin_Ici_eq''‚Çì'. -/
theorem nhdsWithin_Ici_eq'' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] (a : Œ±) :
    ùìù[‚â•] a = (‚®Ö (u) (hu : a < u), ùìü (Iio u)) ‚äì ùìü (Ici a) :=
  by
  rw [nhdsWithin, nhds_eq_order]
  refine' le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf _ inf_le_left) inf_le_right)
  exact inf_le_right.trans (le_iInf‚ÇÇ fun l hl => principal_mono.2 <| Ici_subset_Ioi.2 hl)
#align nhds_within_Ici_eq'' nhdsWithin_Ici_eq''

/- warning: nhds_within_Iic_eq'' -> nhdsWithin_Iic_eq'' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 _inst_2] (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± _inst_2 a)) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (l : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) (fun (H : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) => Filter.principal.{u1} Œ± (Set.Ioi.{u1} Œ± _inst_2 l)))) (Filter.principal.{u1} Œ± (Set.Iic.{u1} Œ± _inst_2 a)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 _inst_2] (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± _inst_2 a)) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (l : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) (fun (H : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) => Filter.principal.{u1} Œ± (Set.Ioi.{u1} Œ± _inst_2 l)))) (Filter.principal.{u1} Œ± (Set.Iic.{u1} Œ± _inst_2 a)))
Case conversion may be inaccurate. Consider using '#align nhds_within_Iic_eq'' nhdsWithin_Iic_eq''‚Çì'. -/
theorem nhdsWithin_Iic_eq'' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] (a : Œ±) :
    ùìù[‚â§] a = (‚®Ö l < a, ùìü (Ioi l)) ‚äì ùìü (Iic a) :=
  nhdsWithin_Ici_eq'' (toDual a)
#align nhds_within_Iic_eq'' nhdsWithin_Iic_eq''

/- warning: nhds_within_Ici_eq' -> nhdsWithin_Ici_eq' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 _inst_2] {a : Œ±}, (Exists.{succ u1} Œ± (fun (u : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u)) -> (Eq.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± _inst_2 a)) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (u : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) (fun (hu : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) => Filter.principal.{u1} Œ± (Set.Ico.{u1} Œ± _inst_2 a u)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 _inst_2] {a : Œ±}, (Exists.{succ u1} Œ± (fun (u : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u)) -> (Eq.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± _inst_2 a)) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (u : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) (fun (hu : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) a u) => Filter.principal.{u1} Œ± (Set.Ico.{u1} Œ± _inst_2 a u)))))
Case conversion may be inaccurate. Consider using '#align nhds_within_Ici_eq' nhdsWithin_Ici_eq'‚Çì'. -/
theorem nhdsWithin_Ici_eq' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ u, a < u) : ùìù[‚â•] a = ‚®Ö (u) (hu : a < u), ùìü (Ico a u) := by
  simp only [nhdsWithin_Ici_eq'', biInf_inf ha, inf_principal, Iio_inter_Ici]
#align nhds_within_Ici_eq' nhdsWithin_Ici_eq'

/- warning: nhds_within_Iic_eq' -> nhdsWithin_Iic_eq' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 _inst_2] {a : Œ±}, (Exists.{succ u1} Œ± (fun (l : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a)) -> (Eq.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± _inst_2 a)) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (l : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) (fun (H : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) => Filter.principal.{u1} Œ± (Set.Ioc.{u1} Œ± _inst_2 l a)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 _inst_2] {a : Œ±}, (Exists.{succ u1} Œ± (fun (l : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a)) -> (Eq.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± _inst_2 a)) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (l : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) (fun (H : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l a) => Filter.principal.{u1} Œ± (Set.Ioc.{u1} Œ± _inst_2 l a)))))
Case conversion may be inaccurate. Consider using '#align nhds_within_Iic_eq' nhdsWithin_Iic_eq'‚Çì'. -/
theorem nhdsWithin_Iic_eq' [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ l, l < a) : ùìù[‚â§] a = ‚®Ö l < a, ùìü (Ioc l a) := by
  simp only [nhdsWithin_Iic_eq'', biInf_inf ha, inf_principal, Ioi_inter_Iic]
#align nhds_within_Iic_eq' nhdsWithin_Iic_eq'

#print nhdsWithin_Ici_basis' /-
theorem nhdsWithin_Ici_basis' [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ u, a < u) : (ùìù[‚â•] a).HasBasis (fun u => a < u) fun u => Ico a u :=
  (nhdsWithin_Ici_eq' ha).symm ‚ñ∏
    hasBasis_biInf_principal
      (fun b hb c hc =>
        ‚ü®min b c, lt_min hb hc, Ico_subset_Ico_right (min_le_left _ _),
          Ico_subset_Ico_right (min_le_right _ _)‚ü©)
      ha
#align nhds_within_Ici_basis' nhdsWithin_Ici_basis'
-/

#print nhdsWithin_Iic_basis' /-
theorem nhdsWithin_Iic_basis' [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±}
    (ha : ‚àÉ l, l < a) : (ùìù[‚â§] a).HasBasis (fun l => l < a) fun l => Ioc l a :=
  by
  convert@nhdsWithin_Ici_basis' Œ±·µí·µà _ _ _ (to_dual a) ha
  exact funext fun x => (@dual_Ico _ _ _ _).symm
#align nhds_within_Iic_basis' nhdsWithin_Iic_basis'
-/

#print nhdsWithin_Ici_basis /-
theorem nhdsWithin_Ici_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [NoMaxOrder Œ±]
    (a : Œ±) : (ùìù[‚â•] a).HasBasis (fun u => a < u) fun u => Ico a u :=
  nhdsWithin_Ici_basis' (exists_gt a)
#align nhds_within_Ici_basis nhdsWithin_Ici_basis
-/

#print nhdsWithin_Iic_basis /-
theorem nhdsWithin_Iic_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [NoMinOrder Œ±]
    (a : Œ±) : (ùìù[‚â§] a).HasBasis (fun l => l < a) fun l => Ioc l a :=
  nhdsWithin_Iic_basis' (exists_lt a)
#align nhds_within_Iic_basis nhdsWithin_Iic_basis
-/

/- warning: nhds_top_order -> nhds_top_order is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderTop.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2)] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 _inst_2], Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 (Top.top.{u1} Œ± (OrderTop.toHasTop.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3))) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (l : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l (Top.top.{u1} Œ± (OrderTop.toHasTop.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3))) (fun (h‚ÇÇ : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l (Top.top.{u1} Œ± (OrderTop.toHasTop.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3))) => Filter.principal.{u1} Œ± (Set.Ioi.{u1} Œ± _inst_2 l))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderTop.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2)] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 _inst_2], Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 (Top.top.{u1} Œ± (OrderTop.toTop.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3))) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (l : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l (Top.top.{u1} Œ± (OrderTop.toTop.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3))) (fun (h‚ÇÇ : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) l (Top.top.{u1} Œ± (OrderTop.toTop.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3))) => Filter.principal.{u1} Œ± (Set.Ioi.{u1} Œ± _inst_2 l))))
Case conversion may be inaccurate. Consider using '#align nhds_top_order nhds_top_order‚Çì'. -/
theorem nhds_top_order [TopologicalSpace Œ±] [Preorder Œ±] [OrderTop Œ±] [OrderTopology Œ±] :
    ùìù (‚ä§ : Œ±) = ‚®Ö (l) (h‚ÇÇ : l < ‚ä§), ùìü (Ioi l) := by simp [nhds_eq_order (‚ä§ : Œ±)]
#align nhds_top_order nhds_top_order

/- warning: nhds_bot_order -> nhds_bot_order is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderBot.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2)] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 _inst_2], Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 (Bot.bot.{u1} Œ± (OrderBot.toHasBot.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3))) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (l : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) (Bot.bot.{u1} Œ± (OrderBot.toHasBot.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3)) l) (fun (h‚ÇÇ : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) (Bot.bot.{u1} Œ± (OrderBot.toHasBot.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3)) l) => Filter.principal.{u1} Œ± (Set.Iio.{u1} Œ± _inst_2 l))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : Preorder.{u1} Œ±] [_inst_3 : OrderBot.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2)] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 _inst_2], Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 (Bot.bot.{u1} Œ± (OrderBot.toBot.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3))) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (l : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) (Bot.bot.{u1} Œ± (OrderBot.toBot.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3)) l) (fun (h‚ÇÇ : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± _inst_2) (Bot.bot.{u1} Œ± (OrderBot.toBot.{u1} Œ± (Preorder.toLE.{u1} Œ± _inst_2) _inst_3)) l) => Filter.principal.{u1} Œ± (Set.Iio.{u1} Œ± _inst_2 l))))
Case conversion may be inaccurate. Consider using '#align nhds_bot_order nhds_bot_order‚Çì'. -/
theorem nhds_bot_order [TopologicalSpace Œ±] [Preorder Œ±] [OrderBot Œ±] [OrderTopology Œ±] :
    ùìù (‚ä• : Œ±) = ‚®Ö (l) (h‚ÇÇ : ‚ä• < l), ùìü (Iio l) := by simp [nhds_eq_order (‚ä• : Œ±)]
#align nhds_bot_order nhds_bot_order

/- warning: nhds_top_basis -> nhds_top_basis is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_5 : Nontrivial.{u1} Œ±], Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 (Top.top.{u1} Œ± (OrderTop.toHasTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) _inst_3))) (fun (a : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a (Top.top.{u1} Œ± (OrderTop.toHasTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) _inst_3))) (fun (a : Œ±) => Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_5 : Nontrivial.{u1} Œ±], Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 (Top.top.{u1} Œ± (OrderTop.toTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) _inst_3))) (fun (a : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a (Top.top.{u1} Œ± (OrderTop.toTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) _inst_3))) (fun (a : Œ±) => Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)
Case conversion may be inaccurate. Consider using '#align nhds_top_basis nhds_top_basis‚Çì'. -/
theorem nhds_top_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTop Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] : (ùìù ‚ä§).HasBasis (fun a : Œ± => a < ‚ä§) fun a : Œ± => Ioi a :=
  by
  have : ‚àÉ x : Œ±, x < ‚ä§ := (exists_ne ‚ä§).imp fun x hx => hx.lt_top
  simpa only [Iic_top, nhdsWithin_univ, Ioc_top] using nhdsWithin_Iic_basis' this
#align nhds_top_basis nhds_top_basis

/- warning: nhds_bot_basis -> nhds_bot_basis is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_5 : Nontrivial.{u1} Œ±], Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 (Bot.bot.{u1} Œ± (OrderBot.toHasBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) _inst_3))) (fun (a : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (Bot.bot.{u1} Œ± (OrderBot.toHasBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) _inst_3)) a) (fun (a : Œ±) => Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_5 : Nontrivial.{u1} Œ±], Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 (Bot.bot.{u1} Œ± (OrderBot.toBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) _inst_3))) (fun (a : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) (Bot.bot.{u1} Œ± (OrderBot.toBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) _inst_3)) a) (fun (a : Œ±) => Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)
Case conversion may be inaccurate. Consider using '#align nhds_bot_basis nhds_bot_basis‚Çì'. -/
theorem nhds_bot_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderBot Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] : (ùìù ‚ä•).HasBasis (fun a : Œ± => ‚ä• < a) fun a : Œ± => Iio a :=
  @nhds_top_basis Œ±·µí·µà _ _ _ _ _
#align nhds_bot_basis nhds_bot_basis

/- warning: nhds_top_basis_Ici -> nhds_top_basis_Ici is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_5 : Nontrivial.{u1} Œ±] [_inst_6 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))], Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 (Top.top.{u1} Œ± (OrderTop.toHasTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) _inst_3))) (fun (a : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a (Top.top.{u1} Œ± (OrderTop.toHasTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) _inst_3))) (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_5 : Nontrivial.{u1} Œ±] [_inst_6 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))], Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 (Top.top.{u1} Œ± (OrderTop.toTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) _inst_3))) (fun (a : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a (Top.top.{u1} Œ± (OrderTop.toTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) _inst_3))) (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))
Case conversion may be inaccurate. Consider using '#align nhds_top_basis_Ici nhds_top_basis_Ici‚Çì'. -/
theorem nhds_top_basis_Ici [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTop Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] [DenselyOrdered Œ±] : (ùìù ‚ä§).HasBasis (fun a : Œ± => a < ‚ä§) Ici :=
  nhds_top_basis.to_hasBasis
    (fun a ha =>
      let ‚ü®b, hab, hb‚ü© := exists_between ha
      ‚ü®b, hb, Ici_subset_Ioi.mpr hab‚ü©)
    fun a ha => ‚ü®a, ha, Ioi_subset_Ici_self‚ü©
#align nhds_top_basis_Ici nhds_top_basis_Ici

/- warning: nhds_bot_basis_Iic -> nhds_bot_basis_Iic is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_5 : Nontrivial.{u1} Œ±] [_inst_6 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))], Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 (Bot.bot.{u1} Œ± (OrderBot.toHasBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) _inst_3))) (fun (a : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (Bot.bot.{u1} Œ± (OrderBot.toHasBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) _inst_3)) a) (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] [_inst_4 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_5 : Nontrivial.{u1} Œ±] [_inst_6 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))], Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 (Bot.bot.{u1} Œ± (OrderBot.toBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) _inst_3))) (fun (a : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) (Bot.bot.{u1} Œ± (OrderBot.toBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) _inst_3)) a) (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))
Case conversion may be inaccurate. Consider using '#align nhds_bot_basis_Iic nhds_bot_basis_Iic‚Çì'. -/
theorem nhds_bot_basis_Iic [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderBot Œ±] [OrderTopology Œ±]
    [Nontrivial Œ±] [DenselyOrdered Œ±] : (ùìù ‚ä•).HasBasis (fun a : Œ± => ‚ä• < a) Iic :=
  @nhds_top_basis_Ici Œ±·µí·µà _ _ _ _ _ _
#align nhds_bot_basis_Iic nhds_bot_basis_Iic

/- warning: tendsto_nhds_top_mono -> tendsto_nhds_top_mono is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ≤] [_inst_2 : Preorder.{u2} Œ≤] [_inst_3 : OrderTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2)] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_1 _inst_2] {l : Filter.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.Tendsto.{u1, u2} Œ± Œ≤ f l (nhds.{u2} Œ≤ _inst_1 (Top.top.{u2} Œ≤ (OrderTop.toHasTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3)))) -> (Filter.EventuallyLE.{u1, u2} Œ± Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) l f g) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ g l (nhds.{u2} Œ≤ _inst_1 (Top.top.{u2} Œ≤ (OrderTop.toHasTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ≤] [_inst_2 : Preorder.{u2} Œ≤] [_inst_3 : OrderTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2)] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_1 _inst_2] {l : Filter.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.Tendsto.{u1, u2} Œ± Œ≤ f l (nhds.{u2} Œ≤ _inst_1 (Top.top.{u2} Œ≤ (OrderTop.toTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3)))) -> (Filter.EventuallyLE.{u1, u2} Œ± Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) l f g) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ g l (nhds.{u2} Œ≤ _inst_1 (Top.top.{u2} Œ≤ (OrderTop.toTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align tendsto_nhds_top_mono tendsto_nhds_top_mono‚Çì'. -/
theorem tendsto_nhds_top_mono [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä§)) (hg : f ‚â§·∂†[l] g) : Tendsto g l (ùìù ‚ä§) :=
  by
  simp only [nhds_top_order, tendsto_infi, tendsto_principal] at hf‚ä¢
  intro x hx
  filter_upwards [hf x hx, hg]with _ using lt_of_lt_of_le
#align tendsto_nhds_top_mono tendsto_nhds_top_mono

/- warning: tendsto_nhds_bot_mono -> tendsto_nhds_bot_mono is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ≤] [_inst_2 : Preorder.{u2} Œ≤] [_inst_3 : OrderBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2)] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_1 _inst_2] {l : Filter.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.Tendsto.{u1, u2} Œ± Œ≤ f l (nhds.{u2} Œ≤ _inst_1 (Bot.bot.{u2} Œ≤ (OrderBot.toHasBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3)))) -> (Filter.EventuallyLE.{u1, u2} Œ± Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) l g f) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ g l (nhds.{u2} Œ≤ _inst_1 (Bot.bot.{u2} Œ≤ (OrderBot.toHasBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ≤] [_inst_2 : Preorder.{u2} Œ≤] [_inst_3 : OrderBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2)] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_1 _inst_2] {l : Filter.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.Tendsto.{u1, u2} Œ± Œ≤ f l (nhds.{u2} Œ≤ _inst_1 (Bot.bot.{u2} Œ≤ (OrderBot.toBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3)))) -> (Filter.EventuallyLE.{u1, u2} Œ± Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) l g f) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ g l (nhds.{u2} Œ≤ _inst_1 (Bot.bot.{u2} Œ≤ (OrderBot.toBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align tendsto_nhds_bot_mono tendsto_nhds_bot_mono‚Çì'. -/
theorem tendsto_nhds_bot_mono [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä•)) (hg : g ‚â§·∂†[l] f) : Tendsto g l (ùìù ‚ä•) :=
  @tendsto_nhds_top_mono Œ± Œ≤·µí·µà _ _ _ _ _ _ _ hf hg
#align tendsto_nhds_bot_mono tendsto_nhds_bot_mono

/- warning: tendsto_nhds_top_mono' -> tendsto_nhds_top_mono' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ≤] [_inst_2 : Preorder.{u2} Œ≤] [_inst_3 : OrderTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2)] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_1 _inst_2] {l : Filter.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.Tendsto.{u1, u2} Œ± Œ≤ f l (nhds.{u2} Œ≤ _inst_1 (Top.top.{u2} Œ≤ (OrderTop.toHasTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3)))) -> (LE.le.{max u1 u2} (Œ± -> Œ≤) (Pi.hasLe.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => Preorder.toLE.{u2} Œ≤ _inst_2)) f g) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ g l (nhds.{u2} Œ≤ _inst_1 (Top.top.{u2} Œ≤ (OrderTop.toHasTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ≤] [_inst_2 : Preorder.{u2} Œ≤] [_inst_3 : OrderTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2)] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_1 _inst_2] {l : Filter.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.Tendsto.{u1, u2} Œ± Œ≤ f l (nhds.{u2} Œ≤ _inst_1 (Top.top.{u2} Œ≤ (OrderTop.toTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3)))) -> (LE.le.{max u1 u2} (Œ± -> Œ≤) (Pi.hasLe.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => Preorder.toLE.{u2} Œ≤ _inst_2)) f g) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ g l (nhds.{u2} Œ≤ _inst_1 (Top.top.{u2} Œ≤ (OrderTop.toTop.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align tendsto_nhds_top_mono' tendsto_nhds_top_mono'‚Çì'. -/
theorem tendsto_nhds_top_mono' [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä§)) (hg : f ‚â§ g) : Tendsto g l (ùìù ‚ä§) :=
  tendsto_nhds_top_mono hf (eventually_of_forall hg)
#align tendsto_nhds_top_mono' tendsto_nhds_top_mono'

/- warning: tendsto_nhds_bot_mono' -> tendsto_nhds_bot_mono' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ≤] [_inst_2 : Preorder.{u2} Œ≤] [_inst_3 : OrderBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2)] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_1 _inst_2] {l : Filter.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.Tendsto.{u1, u2} Œ± Œ≤ f l (nhds.{u2} Œ≤ _inst_1 (Bot.bot.{u2} Œ≤ (OrderBot.toHasBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3)))) -> (LE.le.{max u1 u2} (Œ± -> Œ≤) (Pi.hasLe.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => Preorder.toLE.{u2} Œ≤ _inst_2)) g f) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ g l (nhds.{u2} Œ≤ _inst_1 (Bot.bot.{u2} Œ≤ (OrderBot.toHasBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ≤] [_inst_2 : Preorder.{u2} Œ≤] [_inst_3 : OrderBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2)] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_1 _inst_2] {l : Filter.{u1} Œ±} {f : Œ± -> Œ≤} {g : Œ± -> Œ≤}, (Filter.Tendsto.{u1, u2} Œ± Œ≤ f l (nhds.{u2} Œ≤ _inst_1 (Bot.bot.{u2} Œ≤ (OrderBot.toBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3)))) -> (LE.le.{max u1 u2} (Œ± -> Œ≤) (Pi.hasLe.{u1, u2} Œ± (fun (·æ∞ : Œ±) => Œ≤) (fun (i : Œ±) => Preorder.toLE.{u2} Œ≤ _inst_2)) g f) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ g l (nhds.{u2} Œ≤ _inst_1 (Bot.bot.{u2} Œ≤ (OrderBot.toBot.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align tendsto_nhds_bot_mono' tendsto_nhds_bot_mono'‚Çì'. -/
theorem tendsto_nhds_bot_mono' [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤]
    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä•)) (hg : g ‚â§ f) : Tendsto g l (ùìù ‚ä•) :=
  tendsto_nhds_bot_mono hf (eventually_of_forall hg)
#align tendsto_nhds_bot_mono' tendsto_nhds_bot_mono'

section LinearOrder

variable [TopologicalSpace Œ±] [LinearOrder Œ±]

section OrderClosedTopology

variable [OrderClosedTopology Œ±] {a b : Œ±}

#print eventually_le_nhds /-
theorem eventually_le_nhds (hab : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=
  eventually_iff.mpr (mem_nhds_iff.mpr ‚ü®Iio b, Iio_subset_Iic_self, isOpen_Iio, hab‚ü©)
#align eventually_le_nhds eventually_le_nhds
-/

#print eventually_lt_nhds /-
theorem eventually_lt_nhds (hab : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=
  eventually_iff.mpr (mem_nhds_iff.mpr ‚ü®Iio b, rfl.Subset, isOpen_Iio, hab‚ü©)
#align eventually_lt_nhds eventually_lt_nhds
-/

#print eventually_ge_nhds /-
theorem eventually_ge_nhds (hab : b < a) : ‚àÄ·∂† x in ùìù a, b ‚â§ x :=
  eventually_iff.mpr (mem_nhds_iff.mpr ‚ü®Ioi b, Ioi_subset_Ici_self, isOpen_Ioi, hab‚ü©)
#align eventually_ge_nhds eventually_ge_nhds
-/

#print eventually_gt_nhds /-
theorem eventually_gt_nhds (hab : b < a) : ‚àÄ·∂† x in ùìù a, b < x :=
  eventually_iff.mpr (mem_nhds_iff.mpr ‚ü®Ioi b, rfl.Subset, isOpen_Ioi, hab‚ü©)
#align eventually_gt_nhds eventually_gt_nhds
-/

end OrderClosedTopology

section OrderTopology

variable [OrderTopology Œ±]

#print order_separated /-
theorem order_separated {a‚ÇÅ a‚ÇÇ : Œ±} (h : a‚ÇÅ < a‚ÇÇ) :
    ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß a‚ÇÅ ‚àà u ‚àß a‚ÇÇ ‚àà v ‚àß ‚àÄ b‚ÇÅ ‚àà u, ‚àÄ b‚ÇÇ ‚àà v, b‚ÇÅ < b‚ÇÇ :=
  match dense_or_discrete a‚ÇÅ a‚ÇÇ with
  | Or.inl ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© =>
    ‚ü®{ a' | a' < a }, { a' | a < a' }, isOpen_gt' a, isOpen_lt' a, ha‚ÇÅ, ha‚ÇÇ, fun b‚ÇÅ h‚ÇÅ b‚ÇÇ h‚ÇÇ =>
      lt_trans h‚ÇÅ h‚ÇÇ‚ü©
  | Or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© =>
    ‚ü®{ a | a < a‚ÇÇ }, { a | a‚ÇÅ < a }, isOpen_gt' a‚ÇÇ, isOpen_lt' a‚ÇÅ, h, h, fun b‚ÇÅ hb‚ÇÅ b‚ÇÇ hb‚ÇÇ =>
      calc
        b‚ÇÅ ‚â§ a‚ÇÅ := h‚ÇÇ _ hb‚ÇÅ
        _ < a‚ÇÇ := h
        _ ‚â§ b‚ÇÇ := h‚ÇÅ _ hb‚ÇÇ
        ‚ü©
#align order_separated order_separated
-/

#print OrderTopology.to_orderClosedTopology /-
-- see Note [lower instance priority]
instance (priority := 100) OrderTopology.to_orderClosedTopology : OrderClosedTopology Œ±
    where isClosed_le' :=
    isOpen_compl_iff.1 <|
      isOpen_prod_iff.mpr fun a‚ÇÅ a‚ÇÇ (h : ¬¨a‚ÇÅ ‚â§ a‚ÇÇ) =>
        have h : a‚ÇÇ < a‚ÇÅ := lt_of_not_ge h
        let ‚ü®u, v, hu, hv, ha‚ÇÅ, ha‚ÇÇ, h‚ü© := order_separated h
        ‚ü®v, u, hv, hu, ha‚ÇÇ, ha‚ÇÅ, fun ‚ü®b‚ÇÅ, b‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => not_le_of_gt <| h b‚ÇÇ h‚ÇÇ b‚ÇÅ h‚ÇÅ‚ü©
#align order_topology.to_order_closed_topology OrderTopology.to_orderClosedTopology
-/

/- warning: exists_Ioc_subset_of_mem_nhds -> exists_Ioc_subset_of_mem_nhds is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhds.{u1} Œ± _inst_1 a)) -> (Exists.{succ u1} Œ± (fun (l : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) l a)) -> (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) l a) (fun (H : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) l a) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l a) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhds.{u1} Œ± _inst_1 a)) -> (Exists.{succ u1} Œ± (fun (l : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) l a)) -> (Exists.{succ u1} Œ± (fun (l : Œ±) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) l a) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l a) s)))
Case conversion may be inaccurate. Consider using '#align exists_Ioc_subset_of_mem_nhds exists_Ioc_subset_of_mem_nhds‚Çì'. -/
theorem exists_Ioc_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ l, l < a) :
    ‚àÉ l < a, Ioc l a ‚äÜ s :=
  (nhdsWithin_Iic_basis' h).mem_iff.mp (nhdsWithin_le_nhds hs)
#align exists_Ioc_subset_of_mem_nhds exists_Ioc_subset_of_mem_nhds

/- warning: exists_Ioc_subset_of_mem_nhds' -> exists_Ioc_subset_of_mem_nhds' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhds.{u1} Œ± _inst_1 a)) -> (forall {l : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) l a) -> (Exists.{succ u1} Œ± (fun (l' : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l' (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l' (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l' a) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhds.{u1} Œ± _inst_1 a)) -> (forall {l : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) l a) -> (Exists.{succ u1} Œ± (fun (l' : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l' (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l' a) s))))
Case conversion may be inaccurate. Consider using '#align exists_Ioc_subset_of_mem_nhds' exists_Ioc_subset_of_mem_nhds'‚Çì'. -/
theorem exists_Ioc_subset_of_mem_nhds' {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {l : Œ±} (hl : l < a) :
    ‚àÉ l' ‚àà Ico l a, Ioc l' a ‚äÜ s :=
  let ‚ü®l', hl'a, hl's‚ü© := exists_Ioc_subset_of_mem_nhds hs ‚ü®l, hl‚ü©
  ‚ü®max l l', ‚ü®le_max_left _ _, max_lt hl hl'a‚ü©,
    (Ioc_subset_Ioc_left <| le_max_right _ _).trans hl's‚ü©
#align exists_Ioc_subset_of_mem_nhds' exists_Ioc_subset_of_mem_nhds'

/- warning: exists_Ico_subset_of_mem_nhds' -> exists_Ico_subset_of_mem_nhds' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhds.{u1} Œ± _inst_1 a)) -> (forall {u : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a u) -> (Exists.{succ u1} Œ± (fun (u' : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u' (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u' (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u') s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhds.{u1} Œ± _inst_1 a)) -> (forall {u : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a u) -> (Exists.{succ u1} Œ± (fun (u' : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u' (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u') s))))
Case conversion may be inaccurate. Consider using '#align exists_Ico_subset_of_mem_nhds' exists_Ico_subset_of_mem_nhds'‚Çì'. -/
theorem exists_Ico_subset_of_mem_nhds' {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {u : Œ±} (hu : a < u) :
    ‚àÉ u' ‚àà Ioc a u, Ico a u' ‚äÜ s := by
  simpa only [OrderDual.exists, exists_prop, dual_Ico, dual_Ioc] using
    exists_Ioc_subset_of_mem_nhds' (show of_dual ‚Åª¬π' s ‚àà ùìù (to_dual a) from hs) hu.dual
#align exists_Ico_subset_of_mem_nhds' exists_Ico_subset_of_mem_nhds'

/- warning: exists_Ico_subset_of_mem_nhds -> exists_Ico_subset_of_mem_nhds is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhds.{u1} Œ± _inst_1 a)) -> (Exists.{succ u1} Œ± (fun (u : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a u)) -> (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a u) (fun (_x : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a u) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhds.{u1} Œ± _inst_1 a)) -> (Exists.{succ u1} Œ± (fun (u : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a u)) -> (Exists.{succ u1} Œ± (fun (u : Œ±) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a u) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s)))
Case conversion may be inaccurate. Consider using '#align exists_Ico_subset_of_mem_nhds exists_Ico_subset_of_mem_nhds‚Çì'. -/
theorem exists_Ico_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ u, a < u) :
    ‚àÉ (u : _)(_ : a < u), Ico a u ‚äÜ s :=
  let ‚ü®l', hl'‚ü© := h
  let ‚ü®l, hl‚ü© := exists_Ico_subset_of_mem_nhds' hs hl'
  ‚ü®l, hl.fst.1, hl.snd‚ü©
#align exists_Ico_subset_of_mem_nhds exists_Ico_subset_of_mem_nhds

/- warning: exists_Icc_mem_subset_of_mem_nhds_within_Ici -> exists_Icc_mem_subset_of_mem_nhdsWithin_Ici is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => Exists.{0} (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) (fun (_x : LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) => And (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => And (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a b) (And (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b) s))))
Case conversion may be inaccurate. Consider using '#align exists_Icc_mem_subset_of_mem_nhds_within_Ici exists_Icc_mem_subset_of_mem_nhdsWithin_Ici‚Çì'. -/
theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Ici {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù[‚â•] a) :
    ‚àÉ (b : _)(_ : a ‚â§ b), Icc a b ‚àà ùìù[‚â•] a ‚àß Icc a b ‚äÜ s :=
  by
  rcases(em (IsMax a)).imp_right not_is_max_iff.mp with (ha | ha)
  ¬∑ use a
    simpa [ha.Ici_eq] using hs
  ¬∑ rcases(nhdsWithin_Ici_basis' ha).mem_iff.mp hs with ‚ü®b, hab, hbs‚ü©
    rcases eq_empty_or_nonempty (Ioo a b) with (H | ‚ü®c, hac, hcb‚ü©)
    ¬∑ have : Ico a b = Icc a a := by rw [‚Üê Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty]
      exact ‚ü®a, le_rfl, this ‚ñ∏ ‚ü®Ico_mem_nhdsWithin_Ici <| left_mem_Ico.2 hab, hbs‚ü©‚ü©
    ¬∑ refine' ‚ü®c, hac.le, Icc_mem_nhdsWithin_Ici <| left_mem_Ico.mpr hac, _‚ü©
      exact (Icc_subset_Ico_right hcb).trans hbs
#align exists_Icc_mem_subset_of_mem_nhds_within_Ici exists_Icc_mem_subset_of_mem_nhdsWithin_Ici

/- warning: exists_Icc_mem_subset_of_mem_nhds_within_Iic -> exists_Icc_mem_subset_of_mem_nhdsWithin_Iic is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => Exists.{0} (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b a) (fun (H : LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b a) => And (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b a) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b a) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => And (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) b a) (And (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) b a) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) b a) s))))
Case conversion may be inaccurate. Consider using '#align exists_Icc_mem_subset_of_mem_nhds_within_Iic exists_Icc_mem_subset_of_mem_nhdsWithin_Iic‚Çì'. -/
theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Iic {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù[‚â§] a) :
    ‚àÉ b ‚â§ a, Icc b a ‚àà ùìù[‚â§] a ‚àß Icc b a ‚äÜ s := by
  simpa only [dual_Icc, to_dual.surjective.exists] using
    @exists_Icc_mem_subset_of_mem_nhdsWithin_Ici Œ±·µí·µà _ _ _ (to_dual a) _ hs
#align exists_Icc_mem_subset_of_mem_nhds_within_Iic exists_Icc_mem_subset_of_mem_nhdsWithin_Iic

#print exists_Icc_mem_subset_of_mem_nhds /-
theorem exists_Icc_mem_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) :
    ‚àÉ b c, a ‚àà Icc b c ‚àß Icc b c ‚àà ùìù a ‚àß Icc b c ‚äÜ s :=
  by
  rcases exists_Icc_mem_subset_of_mem_nhdsWithin_Iic (nhdsWithin_le_nhds hs) with
    ‚ü®b, hba, hb_nhds, hbs‚ü©
  rcases exists_Icc_mem_subset_of_mem_nhdsWithin_Ici (nhdsWithin_le_nhds hs) with
    ‚ü®c, hac, hc_nhds, hcs‚ü©
  refine' ‚ü®b, c, ‚ü®hba, hac‚ü©, _‚ü©
  rw [‚Üê Icc_union_Icc_eq_Icc hba hac, ‚Üê nhds_left_sup_nhds_right]
  exact ‚ü®union_mem_sup hb_nhds hc_nhds, union_subset hbs hcs‚ü©
#align exists_Icc_mem_subset_of_mem_nhds exists_Icc_mem_subset_of_mem_nhds
-/

#print IsOpen.exists_Ioo_subset /-
theorem IsOpen.exists_Ioo_subset [Nontrivial Œ±] {s : Set Œ±} (hs : IsOpen s) (h : s.Nonempty) :
    ‚àÉ a b, a < b ‚àß Ioo a b ‚äÜ s :=
  by
  obtain ‚ü®x, hx‚ü© : ‚àÉ x, x ‚àà s := h
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, y ‚â† x := exists_ne x
  rcases lt_trichotomy x y with (H | rfl | H)
  ¬∑ obtain ‚ü®u, xu, hu‚ü© : ‚àÉ (u : Œ±)(hu : x < u), Ico x u ‚äÜ s :=
      exists_Ico_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©
    exact ‚ü®x, u, xu, Ioo_subset_Ico_self.trans hu‚ü©
  ¬∑ exact (hy rfl).elim
  ¬∑ obtain ‚ü®l, lx, hl‚ü© : ‚àÉ (l : Œ±)(hl : l < x), Ioc l x ‚äÜ s :=
      exists_Ioc_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©
    exact ‚ü®l, x, lx, Ioo_subset_Ioc_self.trans hl‚ü©
#align is_open.exists_Ioo_subset IsOpen.exists_Ioo_subset
-/

/- warning: dense_of_exists_between -> dense_of_exists_between is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : Nontrivial.{u1} Œ±] {s : Set.{u1} Œ±}, (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) -> (Exists.{succ u1} Œ± (fun (c : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) c s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) c s) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a c) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) c b))))) -> (Dense.{u1} Œ± _inst_1 s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : Nontrivial.{u1} Œ±] {s : Set.{u1} Œ±}, (forall {{a : Œ±}} {{b : Œ±}}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a b) -> (Exists.{succ u1} Œ± (fun (c : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) c s) (And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a c) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) c b))))) -> (Dense.{u1} Œ± _inst_1 s)
Case conversion may be inaccurate. Consider using '#align dense_of_exists_between dense_of_exists_between‚Çì'. -/
theorem dense_of_exists_between [Nontrivial Œ±] {s : Set Œ±}
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b) : Dense s :=
  by
  apply dense_iff_inter_open.2 fun U U_open U_nonempty => _
  obtain ‚ü®a, b, hab, H‚ü© : ‚àÉ a b : Œ±, a < b ‚àß Ioo a b ‚äÜ U := U_open.exists_Ioo_subset U_nonempty
  obtain ‚ü®x, xs, hx‚ü© : ‚àÉ (x : Œ±)(H : x ‚àà s), a < x ‚àß x < b := h hab
  exact ‚ü®x, ‚ü®H hx, xs‚ü©‚ü©
#align dense_of_exists_between dense_of_exists_between

/- warning: dense_iff_exists_between -> dense_iff_exists_between is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] [_inst_5 : Nontrivial.{u1} Œ±] {s : Set.{u1} Œ±}, Iff (Dense.{u1} Œ± _inst_1 s) (forall (a : Œ±) (b : Œ±), (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) -> (Exists.{succ u1} Œ± (fun (c : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) c s) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) c s) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a c) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) c b)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] [_inst_5 : Nontrivial.{u1} Œ±] {s : Set.{u1} Œ±}, Iff (Dense.{u1} Œ± _inst_1 s) (forall (a : Œ±) (b : Œ±), (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a b) -> (Exists.{succ u1} Œ± (fun (c : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) c s) (And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a c) (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) c b)))))
Case conversion may be inaccurate. Consider using '#align dense_iff_exists_between dense_iff_exists_between‚Çì'. -/
/-- A set in a nontrivial densely linear ordered type is dense in the sense of topology if and only
if for any `a < b` there exists `c ‚àà s`, `a < c < b`. Each implication requires less typeclass
assumptions. -/
theorem dense_iff_exists_between [DenselyOrdered Œ±] [Nontrivial Œ±] {s : Set Œ±} :
    Dense s ‚Üî ‚àÄ a b, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b :=
  ‚ü®fun h a b hab => h.exists_between hab, dense_of_exists_between‚ü©
#align dense_iff_exists_between dense_iff_exists_between

#print mem_nhds_iff_exists_Ioo_subset' /-
/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
theorem mem_nhds_iff_exists_Ioo_subset' {a : Œ±} {s : Set Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
    s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
  by
  constructor
  ¬∑ intro h
    rcases exists_Ico_subset_of_mem_nhds h hu with ‚ü®u, au, hu‚ü©
    rcases exists_Ioc_subset_of_mem_nhds h hl with ‚ü®l, la, hl‚ü©
    exact ‚ü®l, u, ‚ü®la, au‚ü©, Ioc_union_Ico_eq_Ioo la au ‚ñ∏ union_subset hl hu‚ü©
  ¬∑ rintro ‚ü®l, u, ha, h‚ü©
    apply mem_of_superset (Ioo_mem_nhds ha.1 ha.2) h
#align mem_nhds_iff_exists_Ioo_subset' mem_nhds_iff_exists_Ioo_subset'
-/

#print mem_nhds_iff_exists_Ioo_subset /-
/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
theorem mem_nhds_iff_exists_Ioo_subset [NoMaxOrder Œ±] [NoMinOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
  mem_nhds_iff_exists_Ioo_subset' (exists_lt a) (exists_gt a)
#align mem_nhds_iff_exists_Ioo_subset mem_nhds_iff_exists_Ioo_subset
-/

#print nhds_basis_Ioo' /-
theorem nhds_basis_Ioo' {a : Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
    (ùìù a).HasBasis (fun b : Œ± √ó Œ± => b.1 < a ‚àß a < b.2) fun b => Ioo b.1 b.2 :=
  ‚ü®fun s => (mem_nhds_iff_exists_Ioo_subset' hl hu).trans <| by simp‚ü©
#align nhds_basis_Ioo' nhds_basis_Ioo'
-/

#print nhds_basis_Ioo /-
theorem nhds_basis_Ioo [NoMaxOrder Œ±] [NoMinOrder Œ±] (a : Œ±) :
    (ùìù a).HasBasis (fun b : Œ± √ó Œ± => b.1 < a ‚àß a < b.2) fun b => Ioo b.1 b.2 :=
  nhds_basis_Ioo' (exists_lt a) (exists_gt a)
#align nhds_basis_Ioo nhds_basis_Ioo
-/

#print Filter.Eventually.exists_Ioo_subset /-
theorem Filter.Eventually.exists_Ioo_subset [NoMaxOrder Œ±] [NoMinOrder Œ±] {a : Œ±} {p : Œ± ‚Üí Prop}
    (hp : ‚àÄ·∂† x in ùìù a, p x) : ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ { x | p x } :=
  mem_nhds_iff_exists_Ioo_subset.1 hp
#align filter.eventually.exists_Ioo_subset Filter.Eventually.exists_Ioo_subset
-/

#print countable_of_isolated_right' /-
/-- The set of points which are isolated on the right is countable when the space is
second-countable. -/
theorem countable_of_isolated_right' [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ } :=
  by
  nontriviality Œ±
  let s := { x : Œ± | ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ }
  have : ‚àÄ x ‚àà s, ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ := fun x => id
  choose! y hy h'y using this
  have Hy : ‚àÄ x z, x ‚àà s ‚Üí z < y x ‚Üí z ‚â§ x :=
    by
    intro x z xs hz
    have A : Ioo x (y x) = ‚àÖ := h'y _ xs
    contrapose! A
    exact nonempty.ne_empty ‚ü®z, A, hz‚ü©
  suffices H : ‚àÄ a : Set Œ±, IsOpen a ‚Üí Set.Countable { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a }
  ¬∑ have : s ‚äÜ ‚ãÉ a ‚àà countable_basis Œ±, { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a } :=
      by
      intro x hx
      rcases(is_basis_countable_basis Œ±).exists_mem_of_ne (hy x hx).Ne with ‚ü®a, ab, xa, ya‚ü©
      simp only [mem_set_of_eq, mem_Union]
      exact ‚ü®a, ab, hx, xa, ya‚ü©
    apply countable.mono this
    refine' countable.bUnion (countable_countable_basis Œ±) fun a ha => H _ _
    exact is_open_of_mem_countable_basis ha
  intro a ha
  suffices H : Set.Countable { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨IsBot x }
  ¬∑ have :
      { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a } ‚äÜ
        { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨IsBot x } ‚à™ { x | IsBot x } :=
      by
      intro x hx
      by_cases h'x : IsBot x
      ¬∑ simp only [h'x, mem_set_of_eq, mem_union, not_true, and_false_iff, false_or_iff]
      ¬∑
        simpa only [h'x, hx.2.1, hx.2.2, mem_set_of_eq, mem_union, not_false_iff, and_true_iff,
          or_false_iff] using hx.left
    exact countable.mono this (H.union (subsingleton_is_bot Œ±).Countable)
  let t := { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨IsBot x }
  have : ‚àÄ x ‚àà t, ‚àÉ z < x, Ioc z x ‚äÜ a := by
    intro x hx
    apply exists_Ioc_subset_of_mem_nhds (ha.mem_nhds hx.2.1)
    simpa only [IsBot, not_forall, not_le] using hx.right.right.right
  choose! z hz h'z using this
  have : pairwise_disjoint t fun x => Ioc (z x) x :=
    by
    intro x xt x' x't hxx'
    rcases lt_or_gt_of_ne hxx' with (h' | h')
    ¬∑ refine' disjoint_left.2 fun u ux ux' => xt.2.2.1 _
      refine' h'z x' x't ‚ü®ux'.1.trans_le (ux.2.trans (hy x xt.1).le), _‚ü©
      by_contra' H
      exact False.elim (lt_irrefl _ ((Hy _ _ xt.1 H).trans_lt h'))
    ¬∑ refine' disjoint_left.2 fun u ux ux' => x't.2.2.1 _
      refine' h'z x xt ‚ü®ux.1.trans_le (ux'.2.trans (hy x' x't.1).le), _‚ü©
      by_contra' H
      exact False.elim (lt_irrefl _ ((Hy _ _ x't.1 H).trans_lt h'))
  refine' this.countable_of_is_open (fun x hx => _) fun x hx => ‚ü®x, hz x hx, le_rfl‚ü©
  suffices H : Ioc (z x) x = Ioo (z x) (y x)
  ¬∑ rw [H]
    exact isOpen_Ioo
  exact subset.antisymm (Ioc_subset_Ioo_right (hy x hx.1)) fun u hu => ‚ü®hu.1, Hy _ _ hx.1 hu.2‚ü©
#align countable_of_isolated_right countable_of_isolated_right'
-/

#print countable_of_isolated_left' /-
/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
theorem countable_of_isolated_left' [SecondCountableTopology Œ±] :
    Set.Countable { x : Œ± | ‚àÉ y, y < x ‚àß Ioo y x = ‚àÖ } :=
  by
  convert@countable_of_isolated_right' Œ±·µí·µà _ _ _ _
  have : ‚àÄ x y : Œ±, Ioo x y = { z | z < y ‚àß x < z } :=
    by
    simp_rw [and_comm', Ioo]
    simp only [eq_self_iff_true, forall‚ÇÇ_true_iff]
  simp_rw [this]
  rfl
#align countable_of_isolated_left countable_of_isolated_left'
-/

/- warning: set.pairwise_disjoint.countable_of_Ioo -> Set.PairwiseDisjoint.countable_of_Ioo is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {y : Œ± -> Œ±} {s : Set.{u1} Œ±}, (Set.PairwiseDisjoint.{u1, u1} (Set.{u1} Œ±) Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.completeBooleanAlgebra.{u1} Œ±)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} Œ±) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} Œ±) (Set.booleanAlgebra.{u1} Œ±))) s (fun (x : Œ±) => Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) x (y x))) -> (forall (x : Œ±), (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) -> (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) x (y x))) -> (Set.Countable.{u1} Œ± s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : TopologicalSpace.SecondCountableTopology.{u1} Œ± _inst_1] {y : Œ± -> Œ±} {s : Set.{u1} Œ±}, (Set.PairwiseDisjoint.{u1, u1} (Set.{u1} Œ±) Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} Œ±) (Preorder.toLE.{u1} (Set.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Set.{u1} Œ±) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} Œ±) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} Œ±) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} Œ±) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} Œ±) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} Œ±) (Set.instCompleteBooleanAlgebraSet.{u1} Œ±)))))) s (fun (x : Œ±) => Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) x (y x))) -> (forall (x : Œ±), (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) -> (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) x (y x))) -> (Set.Countable.{u1} Œ± s)
Case conversion may be inaccurate. Consider using '#align set.pairwise_disjoint.countable_of_Ioo Set.PairwiseDisjoint.countable_of_Ioo‚Çì'. -/
/-- Consider a disjoint family of intervals `(x, y)` with `x < y` in a second-countable space.
Then the family is countable.
This is not a straightforward consequence of second-countability as some of these intervals might be
empty (but in fact this can happen only for countably many of them). -/
theorem Set.PairwiseDisjoint.countable_of_Ioo [SecondCountableTopology Œ±] {y : Œ± ‚Üí Œ±} {s : Set Œ±}
    (h : PairwiseDisjoint s fun x => Ioo x (y x)) (h' : ‚àÄ x ‚àà s, x < y x) : s.Countable :=
  by
  let t := { x | x ‚àà s ‚àß (Ioo x (y x)).Nonempty }
  have t_count : t.countable :=
    haveI : t ‚äÜ s := fun x hx => hx.1
    (h.subset this).countable_of_isOpen (fun x hx => isOpen_Ioo) fun x hx => hx.2
  have : s ‚äÜ t ‚à™ { x : Œ± | ‚àÉ x', x < x' ‚àß Ioo x x' = ‚àÖ } :=
    by
    intro x hx
    by_cases h'x : (Ioo x (y x)).Nonempty
    ¬∑ exact Or.inl ‚ü®hx, h'x‚ü©
    ¬∑ exact Or.inr ‚ü®y x, h' x hx, not_nonempty_iff_eq_empty.1 h'x‚ü©
  exact countable.mono this (t_count.union countable_of_isolated_right')
#align set.pairwise_disjoint.countable_of_Ioo Set.PairwiseDisjoint.countable_of_Ioo

section Pi

/-!
### Intervals in `Œ† i, œÄ i` belong to `ùìù x`

For each lemma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `Œπ ‚Üí ‚Ñù`.
-/


variable {Œπ : Type _} {œÄ : Œπ ‚Üí Type _} [Finite Œπ] [‚àÄ i, LinearOrder (œÄ i)]
  [‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, OrderTopology (œÄ i)] {a b x : ‚àÄ i, œÄ i} {a' b' x' : Œπ ‚Üí Œ±}

#print pi_Iic_mem_nhds /-
theorem pi_Iic_mem_nhds (ha : ‚àÄ i, x i < a i) : Iic a ‚àà ùìù x :=
  pi_univ_Iic a ‚ñ∏ set_pi_mem_nhds (Set.toFinite _) fun i _ => Iic_mem_nhds (ha _)
#align pi_Iic_mem_nhds pi_Iic_mem_nhds
-/

/- warning: pi_Iic_mem_nhds' -> pi_Iic_mem_nhds' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {Œπ : Type.{u2}} [_inst_4 : Finite.{succ u2} Œπ] {a' : Œπ -> Œ±} {x' : Œπ -> Œ±}, (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (x' i) (a' i)) -> (Membership.Mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (Filter.hasMem.{max u2 u1} (Œπ -> Œ±)) (Set.Iic.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_1 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {Œπ : Type.{u1}} [_inst_4 : Finite.{succ u1} Œπ] {a' : Œπ -> Œ±} {x' : Œπ -> Œ±}, (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (x' i) (a' i)) -> (Membership.mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (instMembershipSetFilter.{max u2 u1} (Œπ -> Œ±)) (Set.Iic.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) a') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
Case conversion may be inaccurate. Consider using '#align pi_Iic_mem_nhds' pi_Iic_mem_nhds'‚Çì'. -/
theorem pi_Iic_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iic a' ‚àà ùìù x' :=
  pi_Iic_mem_nhds ha
#align pi_Iic_mem_nhds' pi_Iic_mem_nhds'

#print pi_Ici_mem_nhds /-
theorem pi_Ici_mem_nhds (ha : ‚àÄ i, a i < x i) : Ici a ‚àà ùìù x :=
  pi_univ_Ici a ‚ñ∏ set_pi_mem_nhds (Set.toFinite _) fun i _ => Ici_mem_nhds (ha _)
#align pi_Ici_mem_nhds pi_Ici_mem_nhds
-/

/- warning: pi_Ici_mem_nhds' -> pi_Ici_mem_nhds' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {Œπ : Type.{u2}} [_inst_4 : Finite.{succ u2} Œπ] {a' : Œπ -> Œ±} {x' : Œπ -> Œ±}, (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (a' i) (x' i)) -> (Membership.Mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (Filter.hasMem.{max u2 u1} (Œπ -> Œ±)) (Set.Ici.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_1 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {Œπ : Type.{u1}} [_inst_4 : Finite.{succ u1} Œπ] {a' : Œπ -> Œ±} {x' : Œπ -> Œ±}, (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (a' i) (x' i)) -> (Membership.mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (instMembershipSetFilter.{max u2 u1} (Œπ -> Œ±)) (Set.Ici.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) a') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
Case conversion may be inaccurate. Consider using '#align pi_Ici_mem_nhds' pi_Ici_mem_nhds'‚Çì'. -/
theorem pi_Ici_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ici a' ‚àà ùìù x' :=
  pi_Ici_mem_nhds ha
#align pi_Ici_mem_nhds' pi_Ici_mem_nhds'

#print pi_Icc_mem_nhds /-
theorem pi_Icc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Icc a b ‚àà ùìù x :=
  pi_univ_Icc a b ‚ñ∏ set_pi_mem_nhds finite_univ fun i _ => Icc_mem_nhds (ha _) (hb _)
#align pi_Icc_mem_nhds pi_Icc_mem_nhds
-/

/- warning: pi_Icc_mem_nhds' -> pi_Icc_mem_nhds' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {Œπ : Type.{u2}} [_inst_4 : Finite.{succ u2} Œπ] {a' : Œπ -> Œ±} {b' : Œπ -> Œ±} {x' : Œπ -> Œ±}, (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (a' i) (x' i)) -> (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (x' i) (b' i)) -> (Membership.Mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (Filter.hasMem.{max u2 u1} (Œπ -> Œ±)) (Set.Icc.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a' b') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_1 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {Œπ : Type.{u1}} [_inst_4 : Finite.{succ u1} Œπ] {a' : Œπ -> Œ±} {b' : Œπ -> Œ±} {x' : Œπ -> Œ±}, (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (a' i) (x' i)) -> (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (x' i) (b' i)) -> (Membership.mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (instMembershipSetFilter.{max u2 u1} (Œπ -> Œ±)) (Set.Icc.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) a' b') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
Case conversion may be inaccurate. Consider using '#align pi_Icc_mem_nhds' pi_Icc_mem_nhds'‚Çì'. -/
theorem pi_Icc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Icc a' b' ‚àà ùìù x' :=
  pi_Icc_mem_nhds ha hb
#align pi_Icc_mem_nhds' pi_Icc_mem_nhds'

variable [Nonempty Œπ]

#print pi_Iio_mem_nhds /-
theorem pi_Iio_mem_nhds (ha : ‚àÄ i, x i < a i) : Iio a ‚àà ùìù x :=
  by
  refine' mem_of_superset (set_pi_mem_nhds (Set.toFinite _) fun i _ => _) (pi_univ_Iio_subset a)
  exact Iio_mem_nhds (ha i)
#align pi_Iio_mem_nhds pi_Iio_mem_nhds
-/

/- warning: pi_Iio_mem_nhds' -> pi_Iio_mem_nhds' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {Œπ : Type.{u2}} [_inst_4 : Finite.{succ u2} Œπ] {a' : Œπ -> Œ±} {x' : Œπ -> Œ±} [_inst_8 : Nonempty.{succ u2} Œπ], (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (x' i) (a' i)) -> (Membership.Mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (Filter.hasMem.{max u2 u1} (Œπ -> Œ±)) (Set.Iio.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_1 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {Œπ : Type.{u1}} [_inst_4 : Finite.{succ u1} Œπ] {a' : Œπ -> Œ±} {x' : Œπ -> Œ±} [_inst_8 : Nonempty.{succ u1} Œπ], (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (x' i) (a' i)) -> (Membership.mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (instMembershipSetFilter.{max u2 u1} (Œπ -> Œ±)) (Set.Iio.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) a') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
Case conversion may be inaccurate. Consider using '#align pi_Iio_mem_nhds' pi_Iio_mem_nhds'‚Çì'. -/
theorem pi_Iio_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iio a' ‚àà ùìù x' :=
  pi_Iio_mem_nhds ha
#align pi_Iio_mem_nhds' pi_Iio_mem_nhds'

#print pi_Ioi_mem_nhds /-
theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=
  @pi_Iio_mem_nhds Œπ (fun i => (œÄ i)·µí·µà) _ _ _ _ _ _ _ ha
#align pi_Ioi_mem_nhds pi_Ioi_mem_nhds
-/

/- warning: pi_Ioi_mem_nhds' -> pi_Ioi_mem_nhds' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {Œπ : Type.{u2}} [_inst_4 : Finite.{succ u2} Œπ] {a' : Œπ -> Œ±} {x' : Œπ -> Œ±} [_inst_8 : Nonempty.{succ u2} Œπ], (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (a' i) (x' i)) -> (Membership.Mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (Filter.hasMem.{max u2 u1} (Œπ -> Œ±)) (Set.Ioi.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_1 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {Œπ : Type.{u1}} [_inst_4 : Finite.{succ u1} Œπ] {a' : Œπ -> Œ±} {x' : Œπ -> Œ±} [_inst_8 : Nonempty.{succ u1} Œπ], (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (a' i) (x' i)) -> (Membership.mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (instMembershipSetFilter.{max u2 u1} (Œπ -> Œ±)) (Set.Ioi.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) a') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
Case conversion may be inaccurate. Consider using '#align pi_Ioi_mem_nhds' pi_Ioi_mem_nhds'‚Çì'. -/
theorem pi_Ioi_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ioi a' ‚àà ùìù x' :=
  pi_Ioi_mem_nhds ha
#align pi_Ioi_mem_nhds' pi_Ioi_mem_nhds'

#print pi_Ioc_mem_nhds /-
theorem pi_Ioc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioc a b ‚àà ùìù x :=
  by
  refine' mem_of_superset (set_pi_mem_nhds (Set.toFinite _) fun i _ => _) (pi_univ_Ioc_subset a b)
  exact Ioc_mem_nhds (ha i) (hb i)
#align pi_Ioc_mem_nhds pi_Ioc_mem_nhds
-/

/- warning: pi_Ioc_mem_nhds' -> pi_Ioc_mem_nhds' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {Œπ : Type.{u2}} [_inst_4 : Finite.{succ u2} Œπ] {a' : Œπ -> Œ±} {b' : Œπ -> Œ±} {x' : Œπ -> Œ±} [_inst_8 : Nonempty.{succ u2} Œπ], (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (a' i) (x' i)) -> (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (x' i) (b' i)) -> (Membership.Mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (Filter.hasMem.{max u2 u1} (Œπ -> Œ±)) (Set.Ioc.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a' b') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_1 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {Œπ : Type.{u1}} [_inst_4 : Finite.{succ u1} Œπ] {a' : Œπ -> Œ±} {b' : Œπ -> Œ±} {x' : Œπ -> Œ±} [_inst_8 : Nonempty.{succ u1} Œπ], (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (a' i) (x' i)) -> (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (x' i) (b' i)) -> (Membership.mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (instMembershipSetFilter.{max u2 u1} (Œπ -> Œ±)) (Set.Ioc.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) a' b') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
Case conversion may be inaccurate. Consider using '#align pi_Ioc_mem_nhds' pi_Ioc_mem_nhds'‚Çì'. -/
theorem pi_Ioc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioc a' b' ‚àà ùìù x' :=
  pi_Ioc_mem_nhds ha hb
#align pi_Ioc_mem_nhds' pi_Ioc_mem_nhds'

#print pi_Ico_mem_nhds /-
theorem pi_Ico_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ico a b ‚àà ùìù x :=
  by
  refine' mem_of_superset (set_pi_mem_nhds (Set.toFinite _) fun i _ => _) (pi_univ_Ico_subset a b)
  exact Ico_mem_nhds (ha i) (hb i)
#align pi_Ico_mem_nhds pi_Ico_mem_nhds
-/

/- warning: pi_Ico_mem_nhds' -> pi_Ico_mem_nhds' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {Œπ : Type.{u2}} [_inst_4 : Finite.{succ u2} Œπ] {a' : Œπ -> Œ±} {b' : Œπ -> Œ±} {x' : Œπ -> Œ±} [_inst_8 : Nonempty.{succ u2} Œπ], (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (a' i) (x' i)) -> (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (x' i) (b' i)) -> (Membership.Mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (Filter.hasMem.{max u2 u1} (Œπ -> Œ±)) (Set.Ico.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a' b') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_1 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {Œπ : Type.{u1}} [_inst_4 : Finite.{succ u1} Œπ] {a' : Œπ -> Œ±} {b' : Œπ -> Œ±} {x' : Œπ -> Œ±} [_inst_8 : Nonempty.{succ u1} Œπ], (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (a' i) (x' i)) -> (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (x' i) (b' i)) -> (Membership.mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (instMembershipSetFilter.{max u2 u1} (Œπ -> Œ±)) (Set.Ico.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) a' b') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
Case conversion may be inaccurate. Consider using '#align pi_Ico_mem_nhds' pi_Ico_mem_nhds'‚Çì'. -/
theorem pi_Ico_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ico a' b' ‚àà ùìù x' :=
  pi_Ico_mem_nhds ha hb
#align pi_Ico_mem_nhds' pi_Ico_mem_nhds'

#print pi_Ioo_mem_nhds /-
theorem pi_Ioo_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioo a b ‚àà ùìù x :=
  by
  refine' mem_of_superset (set_pi_mem_nhds (Set.toFinite _) fun i _ => _) (pi_univ_Ioo_subset a b)
  exact Ioo_mem_nhds (ha i) (hb i)
#align pi_Ioo_mem_nhds pi_Ioo_mem_nhds
-/

/- warning: pi_Ioo_mem_nhds' -> pi_Ioo_mem_nhds' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {Œπ : Type.{u2}} [_inst_4 : Finite.{succ u2} Œπ] {a' : Œπ -> Œ±} {b' : Œπ -> Œ±} {x' : Œπ -> Œ±} [_inst_8 : Nonempty.{succ u2} Œπ], (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (a' i) (x' i)) -> (forall (i : Œπ), LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) (x' i) (b' i)) -> (Membership.Mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (Filter.hasMem.{max u2 u1} (Œπ -> Œ±)) (Set.Ioo.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a' b') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u2, u1} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
but is expected to have type
  forall {Œ± : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : LinearOrder.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_1 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))] {Œπ : Type.{u1}} [_inst_4 : Finite.{succ u1} Œπ] {a' : Œπ -> Œ±} {b' : Œπ -> Œ±} {x' : Œπ -> Œ±} [_inst_8 : Nonempty.{succ u1} Œπ], (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (a' i) (x' i)) -> (forall (i : Œπ), LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) (x' i) (b' i)) -> (Membership.mem.{max u2 u1, max u2 u1} (Set.{max u2 u1} (Œπ -> Œ±)) (Filter.{max u2 u1} (Œπ -> Œ±)) (instMembershipSetFilter.{max u2 u1} (Œπ -> Œ±)) (Set.Ioo.{max u2 u1} (Œπ -> Œ±) (Pi.preorder.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (i : Œπ) => PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_2)))))) a' b') (nhds.{max u2 u1} (Œπ -> Œ±) (Pi.topologicalSpace.{u1, u2} Œπ (fun (·æ∞ : Œπ) => Œ±) (fun (a : Œπ) => _inst_1)) x'))
Case conversion may be inaccurate. Consider using '#align pi_Ioo_mem_nhds' pi_Ioo_mem_nhds'‚Çì'. -/
theorem pi_Ioo_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioo a' b' ‚àà ùìù x' :=
  pi_Ioo_mem_nhds ha hb
#align pi_Ioo_mem_nhds' pi_Ioo_mem_nhds'

end Pi

/- warning: disjoint_nhds_at_top -> disjoint_nhds_atTop is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] (x : Œ±), Disjoint.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (nhds.{u1} Œ± _inst_1 x) (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] (x : Œ±), Disjoint.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (nhds.{u1} Œ± _inst_1 x) (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))
Case conversion may be inaccurate. Consider using '#align disjoint_nhds_at_top disjoint_nhds_atTop‚Çì'. -/
theorem disjoint_nhds_atTop [NoMaxOrder Œ±] (x : Œ±) : Disjoint (ùìù x) atTop :=
  by
  rcases exists_gt x with ‚ü®y, hy : x < y‚ü©
  refine' disjoint_of_disjoint_of_mem _ (Iio_mem_nhds hy) (mem_at_top y)
  exact disjoint_left.mpr fun z => not_le.2
#align disjoint_nhds_at_top disjoint_nhds_atTop

/- warning: inf_nhds_at_top -> inf_nhds_atTop is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] (x : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) (nhds.{u1} Œ± _inst_1 x) (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] (x : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 x) (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align inf_nhds_at_top inf_nhds_atTop‚Çì'. -/
@[simp]
theorem inf_nhds_atTop [NoMaxOrder Œ±] (x : Œ±) : ùìù x ‚äì atTop = ‚ä• :=
  disjoint_iff.1 (disjoint_nhds_atTop x)
#align inf_nhds_at_top inf_nhds_atTop

/- warning: disjoint_nhds_at_bot -> disjoint_nhds_atBot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] (x : Œ±), Disjoint.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.partialOrder.{u1} Œ±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (nhds.{u1} Œ± _inst_1 x) (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] (x : Œ±), Disjoint.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±) (BoundedOrder.toOrderBot.{u1} (Filter.{u1} Œ±) (Preorder.toLE.{u1} (Filter.{u1} Œ±) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ±) (Filter.instPartialOrderFilter.{u1} Œ±))) (CompleteLattice.toBoundedOrder.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (nhds.{u1} Œ± _inst_1 x) (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))
Case conversion may be inaccurate. Consider using '#align disjoint_nhds_at_bot disjoint_nhds_atBot‚Çì'. -/
theorem disjoint_nhds_atBot [NoMinOrder Œ±] (x : Œ±) : Disjoint (ùìù x) atBot :=
  @disjoint_nhds_atTop Œ±·µí·µà _ _ _ _ x
#align disjoint_nhds_at_bot disjoint_nhds_atBot

/- warning: inf_nhds_at_bot -> inf_nhds_atBot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] (x : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) (nhds.{u1} Œ± _inst_1 x) (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] (x : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 x) (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toBot.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±)))
Case conversion may be inaccurate. Consider using '#align inf_nhds_at_bot inf_nhds_atBot‚Çì'. -/
@[simp]
theorem inf_nhds_atBot [NoMinOrder Œ±] (x : Œ±) : ùìù x ‚äì atBot = ‚ä• :=
  @inf_nhds_atTop Œ±·µí·µà _ _ _ _ x
#align inf_nhds_at_bot inf_nhds_atBot

#print not_tendsto_nhds_of_tendsto_atTop /-
theorem not_tendsto_nhds_of_tendsto_atTop [NoMaxOrder Œ±] {F : Filter Œ≤} [NeBot F] {f : Œ≤ ‚Üí Œ±}
    (hf : Tendsto f F atTop) (x : Œ±) : ¬¨Tendsto f F (ùìù x) :=
  hf.not_tendsto (disjoint_nhds_atTop x).symm
#align not_tendsto_nhds_of_tendsto_at_top not_tendsto_nhds_of_tendsto_atTop
-/

#print not_tendsto_atTop_of_tendsto_nhds /-
theorem not_tendsto_atTop_of_tendsto_nhds [NoMaxOrder Œ±] {F : Filter Œ≤} [NeBot F] {f : Œ≤ ‚Üí Œ±}
    {x : Œ±} (hf : Tendsto f F (ùìù x)) : ¬¨Tendsto f F atTop :=
  hf.not_tendsto (disjoint_nhds_atTop x)
#align not_tendsto_at_top_of_tendsto_nhds not_tendsto_atTop_of_tendsto_nhds
-/

#print not_tendsto_nhds_of_tendsto_atBot /-
theorem not_tendsto_nhds_of_tendsto_atBot [NoMinOrder Œ±] {F : Filter Œ≤} [NeBot F] {f : Œ≤ ‚Üí Œ±}
    (hf : Tendsto f F atBot) (x : Œ±) : ¬¨Tendsto f F (ùìù x) :=
  hf.not_tendsto (disjoint_nhds_atBot x).symm
#align not_tendsto_nhds_of_tendsto_at_bot not_tendsto_nhds_of_tendsto_atBot
-/

#print not_tendsto_atBot_of_tendsto_nhds /-
theorem not_tendsto_atBot_of_tendsto_nhds [NoMinOrder Œ±] {F : Filter Œ≤} [NeBot F] {f : Œ≤ ‚Üí Œ±}
    {x : Œ±} (hf : Tendsto f F (ùìù x)) : ¬¨Tendsto f F atBot :=
  hf.not_tendsto (disjoint_nhds_atBot x)
#align not_tendsto_at_bot_of_tendsto_nhds not_tendsto_atBot_of_tendsto_nhds
-/

/-!
### Neighborhoods to the left and to the right on an `order_topology`

We've seen some properties of left and right neighborhood of a point in an `order_closed_topology`.
In an `order_topology`, such neighborhoods can be characterized as the sets containing suitable
intervals to the right or to the left of `a`. We give now these characterizations. -/


/- warning: tfae_mem_nhds_within_Ioi -> TFAE_mem_nhdsWithin_Ioi is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) -> (forall (s : Set.{u1} Œ±), List.TFAE (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b))) (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s))) (List.nil.{0} Prop)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a b) -> (forall (s : Set.{u1} Œ±), List.TFAE (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b))) (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s))) (List.nil.{0} Prop)))))))
Case conversion may be inaccurate. Consider using '#align tfae_mem_nhds_within_Ioi TFAE_mem_nhdsWithin_Ioi‚Çì'. -/
-- NB: If you extend the list, append to the end please to avoid breaking the API
/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `(a, +‚àû)`
1. `s` is a neighborhood of `a` within `(a, b]`
2. `s` is a neighborhood of `a` within `(a, b)`
3. `s` includes `(a, u)` for some `u ‚àà (a, b]`
4. `s` includes `(a, u)` for some `u > a` -/
theorem TFAE_mem_nhdsWithin_Ioi {a b : Œ±} (hab : a < b) (s : Set Œ±) :
    TFAE
      [s ‚àà ùìù[>] a,-- 0 : `s` is a neighborhood of `a` within `(a, +‚àû)`
          s ‚àà
          ùìù[Ioc a b] a,-- 1 : `s` is a neighborhood of `a` within `(a, b]`
          s ‚àà
          ùìù[Ioo a b] a,-- 2 : `s` is a neighborhood of `a` within `(a, b)`
        ‚àÉ u ‚àà Ioc a b, Ioo a u ‚äÜ s,-- 3 : `s` includes `(a, u)` for some `u ‚àà (a, b]`
        ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s] :=
  by
  -- 4 : `s` includes `(a, u)` for some `u > a`
  tfae_have 1 ‚Üî 2;
  ¬∑ rw [nhdsWithin_Ioc_eq_nhdsWithin_Ioi hab]
  tfae_have 1 ‚Üî 3; ¬∑ rw [nhdsWithin_Ioo_eq_nhdsWithin_Ioi hab]
  tfae_have 4 ‚Üí 5; exact fun ‚ü®u, umem, hu‚ü© => ‚ü®u, umem.1, hu‚ü©
  tfae_have 5 ‚Üí 1
  ¬∑ rintro ‚ü®u, hau, hu‚ü©
    exact mem_of_superset (Ioo_mem_nhdsWithin_Ioi ‚ü®le_refl a, hau‚ü©) hu
  tfae_have 1 ‚Üí 4
  ¬∑ intro h
    rcases mem_nhdsWithin_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©
    rcases exists_Ico_subset_of_mem_nhds' va hab with ‚ü®u, au, hu‚ü©
    refine' ‚ü®u, au, fun x hx => _‚ü©
    refine' hv ‚ü®hu ‚ü®le_of_lt hx.1, hx.2‚ü©, _‚ü©
    exact hx.1
  tfae_finish
#align tfae_mem_nhds_within_Ioi TFAE_mem_nhdsWithin_Ioi

/- warning: mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset -> mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {u' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a u') -> (Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u')) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u')) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {u' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a u') -> (Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u')) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s))))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset‚Çì'. -/
theorem mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
    s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioc a u', Ioo a u ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Ioi hu' s).out 0 3
#align mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset

/- warning: mem_nhds_within_Ioi_iff_exists_Ioo_subset' -> mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {u' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a u') -> (Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {u' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a u') -> (Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s))))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Ioi_iff_exists_Ioo_subset' mem_nhdsWithin_Ioi_iff_exists_Ioo_subset'‚Çì'. -/
/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
    s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Ioi hu' s).out 0 4
#align mem_nhds_within_Ioi_iff_exists_Ioo_subset' mem_nhdsWithin_Ioi_iff_exists_Ioo_subset'

/- warning: mem_nhds_within_Ioi_iff_exists_Ioo_subset -> mem_nhdsWithin_Ioi_iff_exists_Ioo_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s)))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Ioi_iff_exists_Ioo_subset mem_nhdsWithin_Ioi_iff_exists_Ioo_subset‚Çì'. -/
/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
theorem mem_nhdsWithin_Ioi_iff_exists_Ioo_subset [NoMaxOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s :=
  let ‚ü®u', hu'‚ü© := exists_gt a
  mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' hu'
#align mem_nhds_within_Ioi_iff_exists_Ioo_subset mem_nhdsWithin_Ioi_iff_exists_Ioo_subset

/- warning: mem_nhds_within_Ioi_iff_exists_Ioc_subset -> mem_nhdsWithin_Ioi_iff_exists_Ioc_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] [_inst_5 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] [_inst_5 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s)))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Ioi_iff_exists_Ioc_subset mem_nhdsWithin_Ioi_iff_exists_Ioc_subset‚Çì'. -/
/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
theorem mem_nhdsWithin_Ioi_iff_exists_Ioc_subset [NoMaxOrder Œ±] [DenselyOrdered Œ±] {a : Œ±}
    {s : Set Œ±} : s ‚àà ùìù[>] a ‚Üî ‚àÉ u ‚àà Ioi a, Ioc a u ‚äÜ s :=
  by
  rw [mem_nhdsWithin_Ioi_iff_exists_Ioo_subset]
  constructor
  ¬∑ rintro ‚ü®u, au, as‚ü©
    rcases exists_between au with ‚ü®v, hv‚ü©
    exact ‚ü®v, hv.1, fun x hx => as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü©
  ¬∑ rintro ‚ü®u, au, as‚ü©
    exact ‚ü®u, au, subset.trans Ioo_subset_Ioc_self as‚ü©
#align mem_nhds_within_Ioi_iff_exists_Ioc_subset mem_nhdsWithin_Ioi_iff_exists_Ioc_subset

/- warning: tfae_mem_nhds_within_Iio -> TFAE_mem_nhdsWithin_Iio is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) -> (forall (s : Set.{u1} Œ±), List.TFAE (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b))) (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b))) (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l b) s))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l b) s))) (List.nil.{0} Prop)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a b) -> (forall (s : Set.{u1} Œ±), List.TFAE (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) b))) (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b))) (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l b) s))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) b)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l b) s))) (List.nil.{0} Prop)))))))
Case conversion may be inaccurate. Consider using '#align tfae_mem_nhds_within_Iio TFAE_mem_nhdsWithin_Iio‚Çì'. -/
/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b)`
1. `s` is a neighborhood of `b` within `[a, b)`
2. `s` is a neighborhood of `b` within `(a, b)`
3. `s` includes `(l, b)` for some `l ‚àà [a, b)`
4. `s` includes `(l, b)` for some `l < b` -/
theorem TFAE_mem_nhdsWithin_Iio {a b : Œ±} (h : a < b) (s : Set Œ±) :
    TFAE
      [s ‚àà ùìù[<] b,-- 0 : `s` is a neighborhood of `b` within `(-‚àû, b)`
          s ‚àà
          ùìù[Ico a b] b,-- 1 : `s` is a neighborhood of `b` within `[a, b)`
          s ‚àà
          ùìù[Ioo a b] b,-- 2 : `s` is a neighborhood of `b` within `(a, b)`
        ‚àÉ l ‚àà Ico a b, Ioo l b ‚äÜ s,-- 3 : `s` includes `(l, b)` for some `l ‚àà [a, b)`
        ‚àÉ l ‚àà Iio b, Ioo l b ‚äÜ s] :=
  by-- 4 : `s` includes `(l, b)` for some `l < b`
  simpa only [exists_prop, OrderDual.exists, dual_Ioi, dual_Ioc, dual_Ioo] using
    TFAE_mem_nhdsWithin_Ioi h.dual (of_dual ‚Åª¬π' s)
#align tfae_mem_nhds_within_Iio TFAE_mem_nhdsWithin_Iio

/- warning: mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset -> mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {l' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) l' a) -> (Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l' a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l' a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l a) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {l' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) l' a) -> (Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l' a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l a) s))))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset‚Çì'. -/
theorem mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
    s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Ico l' a, Ioo l a ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Iio hl' s).out 0 3
#align mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset

/- warning: mem_nhds_within_Iio_iff_exists_Ioo_subset' -> mem_nhdsWithin_Iio_iff_exists_Ioo_subset' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {l' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) l' a) -> (Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l a) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {l' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) l' a) -> (Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l a) s))))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Iio_iff_exists_Ioo_subset' mem_nhdsWithin_Iio_iff_exists_Ioo_subset'‚Çì'. -/
/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhdsWithin_Iio_iff_exists_Ioo_subset' {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
    s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Iio a, Ioo l a ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Iio hl' s).out 0 4
#align mem_nhds_within_Iio_iff_exists_Ioo_subset' mem_nhdsWithin_Iio_iff_exists_Ioo_subset'

/- warning: mem_nhds_within_Iio_iff_exists_Ioo_subset -> mem_nhdsWithin_Iio_iff_exists_Ioo_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l a) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l a) s)))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Iio_iff_exists_Ioo_subset mem_nhdsWithin_Iio_iff_exists_Ioo_subset‚Çì'. -/
/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
theorem mem_nhdsWithin_Iio_iff_exists_Ioo_subset [NoMinOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Iio a, Ioo l a ‚äÜ s :=
  let ‚ü®l', hl'‚ü© := exists_lt a
  mem_nhdsWithin_Iio_iff_exists_Ioo_subset' hl'
#align mem_nhds_within_Iio_iff_exists_Ioo_subset mem_nhdsWithin_Iio_iff_exists_Ioo_subset

/- warning: mem_nhds_within_Iio_iff_exists_Ico_subset -> mem_nhdsWithin_Iio_iff_exists_Ico_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] [_inst_5 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l a) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] [_inst_5 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l a) s)))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Iio_iff_exists_Ico_subset mem_nhdsWithin_Iio_iff_exists_Ico_subset‚Çì'. -/
/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
theorem mem_nhdsWithin_Iio_iff_exists_Ico_subset [NoMinOrder Œ±] [DenselyOrdered Œ±] {a : Œ±}
    {s : Set Œ±} : s ‚àà ùìù[<] a ‚Üî ‚àÉ l ‚àà Iio a, Ico l a ‚äÜ s :=
  by
  have : of_dual ‚Åª¬π' s ‚àà ùìù[>] to_dual a ‚Üî _ := mem_nhdsWithin_Ioi_iff_exists_Ioc_subset
  simpa only [OrderDual.exists, exists_prop, dual_Ioc] using this
#align mem_nhds_within_Iio_iff_exists_Ico_subset mem_nhdsWithin_Iio_iff_exists_Ico_subset

/- warning: tfae_mem_nhds_within_Ici -> TFAE_mem_nhdsWithin_Ici is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) -> (forall (s : Set.{u1} Œ±), List.TFAE (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b))) (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s))) (List.nil.{0} Prop)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a b) -> (forall (s : Set.{u1} Œ±), List.TFAE (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b))) (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s))) (List.nil.{0} Prop)))))))
Case conversion may be inaccurate. Consider using '#align tfae_mem_nhds_within_Ici TFAE_mem_nhdsWithin_Ici‚Çì'. -/
/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `[a, +‚àû)`
1. `s` is a neighborhood of `a` within `[a, b]`
2. `s` is a neighborhood of `a` within `[a, b)`
3. `s` includes `[a, u)` for some `u ‚àà (a, b]`
4. `s` includes `[a, u)` for some `u > a` -/
theorem TFAE_mem_nhdsWithin_Ici {a b : Œ±} (hab : a < b) (s : Set Œ±) :
    TFAE
      [s ‚àà ùìù[‚â•] a,-- 0 : `s` is a neighborhood of `a` within `[a, +‚àû)`
          s ‚àà
          ùìù[Icc a b] a,-- 1 : `s` is a neighborhood of `a` within `[a, b]`
          s ‚àà
          ùìù[Ico a b] a,-- 2 : `s` is a neighborhood of `a` within `[a, b)`
        ‚àÉ u ‚àà Ioc a b, Ico a u ‚äÜ s,-- 3 : `s` includes `[a, u)` for some `u ‚àà (a, b]`
        ‚àÉ u ‚àà Ioi a, Ico a u ‚äÜ s] :=
  by
  -- 4 : `s` includes `[a, u)` for some `u > a`
  tfae_have 1 ‚Üî 2;
  ¬∑ rw [nhdsWithin_Icc_eq_nhdsWithin_Ici hab]
  tfae_have 1 ‚Üî 3; ¬∑ rw [nhdsWithin_Ico_eq_nhdsWithin_Ici hab]
  tfae_have 1 ‚Üî 5; exact (nhdsWithin_Ici_basis' ‚ü®b, hab‚ü©).mem_iff
  tfae_have 4 ‚Üí 5; exact fun ‚ü®u, umem, hu‚ü© => ‚ü®u, umem.1, hu‚ü©
  tfae_have 5 ‚Üí 4
  ¬∑ rintro ‚ü®u, hua, hus‚ü©
    exact
      ‚ü®min u b, ‚ü®lt_min hua hab, min_le_right _ _‚ü©,
        (Ico_subset_Ico_right <| min_le_left _ _).trans hus‚ü©
  tfae_finish
#align tfae_mem_nhds_within_Ici TFAE_mem_nhdsWithin_Ici

/- warning: mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset -> mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {u' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a u') -> (Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u')) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u')) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {u' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a u') -> (Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u')) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s))))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset‚Çì'. -/
theorem mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
    s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u ‚àà Ioc a u', Ico a u ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Ici hu' s).out 0 3 (by norm_num) (by norm_num)
#align mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset

/- warning: mem_nhds_within_Ici_iff_exists_Ico_subset' -> mem_nhdsWithin_Ici_iff_exists_Ico_subset' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {u' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a u') -> (Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {u' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a u') -> (Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s))))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Ici_iff_exists_Ico_subset' mem_nhdsWithin_Ici_iff_exists_Ico_subset'‚Çì'. -/
/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhdsWithin_Ici_iff_exists_Ico_subset' {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
    s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u ‚àà Ioi a, Ico a u ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Ici hu' s).out 0 4 (by norm_num) (by norm_num)
#align mem_nhds_within_Ici_iff_exists_Ico_subset' mem_nhdsWithin_Ici_iff_exists_Ico_subset'

/- warning: mem_nhds_within_Ici_iff_exists_Ico_subset -> mem_nhdsWithin_Ici_iff_exists_Ico_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a u) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ici.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (u : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) u (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a u) s)))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Ici_iff_exists_Ico_subset mem_nhdsWithin_Ici_iff_exists_Ico_subset‚Çì'. -/
/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
theorem mem_nhdsWithin_Ici_iff_exists_Ico_subset [NoMaxOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u ‚àà Ioi a, Ico a u ‚äÜ s :=
  let ‚ü®u', hu'‚ü© := exists_gt a
  mem_nhdsWithin_Ici_iff_exists_Ico_subset' hu'
#align mem_nhds_within_Ici_iff_exists_Ico_subset mem_nhdsWithin_Ici_iff_exists_Ico_subset

#print nhdsWithin_Ici_basis_Ico /-
theorem nhdsWithin_Ici_basis_Ico [NoMaxOrder Œ±] (a : Œ±) :
    (ùìù[‚â•] a).HasBasis (fun u => a < u) (Ico a) :=
  ‚ü®fun s => mem_nhdsWithin_Ici_iff_exists_Ico_subset‚ü©
#align nhds_within_Ici_basis_Ico nhdsWithin_Ici_basis_Ico
-/

#print mem_nhdsWithin_Ici_iff_exists_Icc_subset /-
/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
theorem mem_nhdsWithin_Ici_iff_exists_Icc_subset [NoMaxOrder Œ±] [DenselyOrdered Œ±] {a : Œ±}
    {s : Set Œ±} : s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u, a < u ‚àß Icc a u ‚äÜ s :=
  by
  rw [mem_nhdsWithin_Ici_iff_exists_Ico_subset]
  constructor
  ¬∑ rintro ‚ü®u, au, as‚ü©
    rcases exists_between au with ‚ü®v, hv‚ü©
    exact ‚ü®v, hv.1, fun x hx => as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü©
  ¬∑ rintro ‚ü®u, au, as‚ü©
    exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü©
#align mem_nhds_within_Ici_iff_exists_Icc_subset mem_nhdsWithin_Ici_iff_exists_Icc_subset
-/

/- warning: tfae_mem_nhds_within_Iic -> TFAE_mem_nhdsWithin_Iic is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) -> (forall (s : Set.{u1} Œ±), List.TFAE (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b))) (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b))) (List.cons.{0} Prop (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l b) s))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l b) s))) (List.nil.{0} Prop)))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {b : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a b) -> (forall (s : Set.{u1} Œ±), List.TFAE (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) b))) (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Icc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b))) (List.cons.{0} Prop (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 b (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l b) s))) (List.cons.{0} Prop (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) b)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l b) s))) (List.nil.{0} Prop)))))))
Case conversion may be inaccurate. Consider using '#align tfae_mem_nhds_within_Iic TFAE_mem_nhdsWithin_Iic‚Çì'. -/
/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b]`
1. `s` is a neighborhood of `b` within `[a, b]`
2. `s` is a neighborhood of `b` within `(a, b]`
3. `s` includes `(l, b]` for some `l ‚àà [a, b)`
4. `s` includes `(l, b]` for some `l < b` -/
theorem TFAE_mem_nhdsWithin_Iic {a b : Œ±} (h : a < b) (s : Set Œ±) :
    TFAE
      [s ‚àà ùìù[‚â§] b,-- 0 : `s` is a neighborhood of `b` within `(-‚àû, b]`
          s ‚àà
          ùìù[Icc a b] b,-- 1 : `s` is a neighborhood of `b` within `[a, b]`
          s ‚àà
          ùìù[Ioc a b] b,-- 2 : `s` is a neighborhood of `b` within `(a, b]`
        ‚àÉ l ‚àà Ico a b, Ioc l b ‚äÜ s,-- 3 : `s` includes `(l, b]` for some `l ‚àà [a, b)`
        ‚àÉ l ‚àà Iio b, Ioc l b ‚äÜ s] :=
  by-- 4 : `s` includes `(l, b]` for some `l < b`
  simpa only [exists_prop, OrderDual.exists, dual_Ici, dual_Ioc, dual_Icc, dual_Ico] using
    TFAE_mem_nhdsWithin_Ici h.dual (of_dual ‚Åª¬π' s)
#align tfae_mem_nhds_within_Iic TFAE_mem_nhdsWithin_Iic

/- warning: mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset -> mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {l' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) l' a) -> (Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l' a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l' a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l a) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {l' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) l' a) -> (Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Ico.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l' a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l a) s))))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset‚Çì'. -/
theorem mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
    s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l ‚àà Ico l' a, Ioc l a ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Iic hl' s).out 0 3 (by norm_num) (by norm_num)
#align mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset

/- warning: mem_nhds_within_Iic_iff_exists_Ioc_subset' -> mem_nhdsWithin_Iic_iff_exists_Ioc_subset' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] {a : Œ±} {l' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) l' a) -> (Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l a) s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {l' : Œ±} {s : Set.{u1} Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) l' a) -> (Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l a) s))))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Iic_iff_exists_Ioc_subset' mem_nhdsWithin_Iic_iff_exists_Ioc_subset'‚Çì'. -/
/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhdsWithin_Iic_iff_exists_Ioc_subset' {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
    s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l ‚àà Iio a, Ioc l a ‚äÜ s :=
  (TFAE_mem_nhdsWithin_Iic hl' s).out 0 4 (by norm_num) (by norm_num)
#align mem_nhds_within_Iic_iff_exists_Ioc_subset' mem_nhdsWithin_Iic_iff_exists_Ioc_subset'

/- warning: mem_nhds_within_Iic_iff_exists_Ioc_subset -> mem_nhdsWithin_Iic_iff_exists_Ioc_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => Exists.{0} (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) (fun (H : Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) l a) s)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {a : Œ±} {s : Set.{u1} Œ±}, Iff (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s (nhdsWithin.{u1} Œ± _inst_1 a (Set.Iic.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Exists.{succ u1} Œ± (fun (l : Œ±) => And (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) l (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioc.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) l a) s)))
Case conversion may be inaccurate. Consider using '#align mem_nhds_within_Iic_iff_exists_Ioc_subset mem_nhdsWithin_Iic_iff_exists_Ioc_subset‚Çì'. -/
/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
theorem mem_nhdsWithin_Iic_iff_exists_Ioc_subset [NoMinOrder Œ±] {a : Œ±} {s : Set Œ±} :
    s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l ‚àà Iio a, Ioc l a ‚äÜ s :=
  let ‚ü®l', hl'‚ü© := exists_lt a
  mem_nhdsWithin_Iic_iff_exists_Ioc_subset' hl'
#align mem_nhds_within_Iic_iff_exists_Ioc_subset mem_nhdsWithin_Iic_iff_exists_Ioc_subset

#print mem_nhdsWithin_Iic_iff_exists_Icc_subset /-
/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
theorem mem_nhdsWithin_Iic_iff_exists_Icc_subset [NoMinOrder Œ±] [DenselyOrdered Œ±] {a : Œ±}
    {s : Set Œ±} : s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l, l < a ‚àß Icc l a ‚äÜ s :=
  by
  convert@mem_nhdsWithin_Ici_iff_exists_Icc_subset Œ±·µí·µà _ _ _ _ _ _ _
  simp_rw [show ‚àÄ u : Œ±·µí·µà, @Icc Œ±·µí·µà _ a u = @Icc Œ± _ u a from fun u => dual_Icc]
  rfl
#align mem_nhds_within_Iic_iff_exists_Icc_subset mem_nhdsWithin_Iic_iff_exists_Icc_subset
-/

end OrderTopology

end LinearOrder

section LinearOrderedAddCommGroup

variable [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±] [OrderTopology Œ±]

variable {l : Filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

/- warning: nhds_eq_infi_abs_sub -> nhds_eq_iInf_abs_sub is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 a) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (r : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) r (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))))))) (fun (H : GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) r (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))))))) => Filter.principal.{u1} Œ± (setOf.{u1} Œ± (fun (b : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (SubNegMonoid.toHasNeg.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) (SemilatticeSup.toHasSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_2))))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toHasSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) a b)) r)))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 a) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (r : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) r (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))))) (fun (H : GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) r (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))))) => Filter.principal.{u1} Œ± (setOf.{u1} Œ± (fun (b : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (NegZeroClass.toNeg.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))) (SemilatticeSup.toSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_2)))))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) a b)) r)))))
Case conversion may be inaccurate. Consider using '#align nhds_eq_infi_abs_sub nhds_eq_iInf_abs_sub‚Çì'. -/
theorem nhds_eq_iInf_abs_sub (a : Œ±) : ùìù a = ‚®Ö r > 0, ùìü { b | |a - b| < r } :=
  by
  simp only [le_antisymm_iff, nhds_eq_order, le_inf_iff, le_iInf_iff, le_principal_iff, mem_Ioi,
    mem_Iio, abs_sub_lt_iff, @sub_lt_iff_lt_add _ _ _ _ _ _ a, @sub_lt_comm _ _ _ _ a, set_of_and]
  refine' ‚ü®_, _, _‚ü©
  ¬∑ intro Œµ Œµ0
    exact
      inter_mem_inf
        (mem_infi_of_mem (a - Œµ) <| mem_infi_of_mem (sub_lt_self a Œµ0) (mem_principal_self _))
        (mem_infi_of_mem (Œµ + a) <| mem_infi_of_mem (by simpa) (mem_principal_self _))
  ¬∑ intro b hb
    exact mem_infi_of_mem (a - b) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Ioi]))
  ¬∑ intro b hb
    exact mem_infi_of_mem (b - a) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Iio]))
#align nhds_eq_infi_abs_sub nhds_eq_iInf_abs_sub

/- warning: order_topology_of_nhds_abs -> orderTopology_of_nhds_abs is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} Œ±] [_inst_5 : LinearOrderedAddCommGroup.{u1} Œ±], (forall (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_4 a) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) Œ± (fun (r : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toHasInf.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±))) (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5)))) r (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5))))))))))) (fun (H : GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5)))) r (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5))))))))))) => Filter.principal.{u1} Œ± (setOf.{u1} Œ± (fun (b : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (SubNegMonoid.toHasNeg.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5))))) (SemilatticeSup.toHasSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_5))))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toHasSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5)))))) a b)) r)))))) -> (OrderTopology.{u1} Œ± _inst_4 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_4 : TopologicalSpace.{u1} Œ±] [_inst_5 : LinearOrderedAddCommGroup.{u1} Œ±], (forall (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_4 a) (iInf.{u1, succ u1} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) Œ± (fun (r : Œ±) => iInf.{u1, 0} (Filter.{u1} Œ±) (ConditionallyCompleteLattice.toInfSet.{u1} (Filter.{u1} Œ±) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Filter.{u1} Œ±) (Filter.instCompleteLatticeFilter.{u1} Œ±))) (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5)))) r (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5)))))))))) (fun (H : GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5)))) r (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5)))))))))) => Filter.principal.{u1} Œ± (setOf.{u1} Œ± (fun (b : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (NegZeroClass.toNeg.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5))))))) (SemilatticeSup.toSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_5)))))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5)))))) a b)) r)))))) -> (OrderTopology.{u1} Œ± _inst_4 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_5))))
Case conversion may be inaccurate. Consider using '#align order_topology_of_nhds_abs orderTopology_of_nhds_abs‚Çì'. -/
theorem orderTopology_of_nhds_abs {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrderedAddCommGroup Œ±]
    (h_nhds : ‚àÄ a : Œ±, ùìù a = ‚®Ö r > 0, ùìü { b | |a - b| < r }) : OrderTopology Œ± :=
  by
  refine' ‚ü®eq_of_nhds_eq_nhds fun a => _‚ü©
  rw [h_nhds]
  letI := Preorder.topology Œ±; letI : OrderTopology Œ± := ‚ü®rfl‚ü©
  exact (nhds_eq_iInf_abs_sub a).symm
#align order_topology_of_nhds_abs orderTopology_of_nhds_abs

/- warning: linear_ordered_add_comm_group.tendsto_nhds -> LinearOrderedAddCommGroup.tendsto_nhds is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] {f : Œ≤ -> Œ±} {x : Filter.{u2} Œ≤} {a : Œ±}, Iff (Filter.Tendsto.{u2, u1} Œ≤ Œ± f x (nhds.{u1} Œ± _inst_1 a)) (forall (Œµ : Œ±), (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) Œµ (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))))))) -> (Filter.Eventually.{u2} Œ≤ (fun (b : Œ≤) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (SubNegMonoid.toHasNeg.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) (SemilatticeSup.toHasSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_2))))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toHasSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) (f b) a)) Œµ) x))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] {f : Œ≤ -> Œ±} {x : Filter.{u2} Œ≤} {a : Œ±}, Iff (Filter.Tendsto.{u2, u1} Œ≤ Œ± f x (nhds.{u1} Œ± _inst_1 a)) (forall (Œµ : Œ±), (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) Œµ (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))))) -> (Filter.Eventually.{u2} Œ≤ (fun (b : Œ≤) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (NegZeroClass.toNeg.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))) (SemilatticeSup.toSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_2)))))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) (f b) a)) Œµ) x))
Case conversion may be inaccurate. Consider using '#align linear_ordered_add_comm_group.tendsto_nhds LinearOrderedAddCommGroup.tendsto_nhds‚Çì'. -/
theorem LinearOrderedAddCommGroup.tendsto_nhds {x : Filter Œ≤} {a : Œ±} :
    Tendsto f x (ùìù a) ‚Üî ‚àÄ Œµ > (0 : Œ±), ‚àÄ·∂† b in x, |f b - a| < Œµ := by
  simp [nhds_eq_iInf_abs_sub, abs_sub_comm a]
#align linear_ordered_add_comm_group.tendsto_nhds LinearOrderedAddCommGroup.tendsto_nhds

/- warning: eventually_abs_sub_lt -> eventually_abs_sub_lt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] (a : Œ±) {Œµ : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))))) Œµ) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (SubNegMonoid.toHasNeg.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) (SemilatticeSup.toHasSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_2))))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toHasSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) x a)) Œµ) (nhds.{u1} Œ± _inst_1 a))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] (a : Œ±) {Œµ : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))))) Œµ) -> (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (NegZeroClass.toNeg.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))) (SemilatticeSup.toSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_2)))))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) x a)) Œµ) (nhds.{u1} Œ± _inst_1 a))
Case conversion may be inaccurate. Consider using '#align eventually_abs_sub_lt eventually_abs_sub_lt‚Çì'. -/
theorem eventually_abs_sub_lt (a : Œ±) {Œµ : Œ±} (hŒµ : 0 < Œµ) : ‚àÄ·∂† x in ùìù a, |x - a| < Œµ :=
  (nhds_eq_iInf_abs_sub a).symm ‚ñ∏
    mem_iInf_of_mem Œµ (mem_iInf_of_mem hŒµ <| by simp only [abs_sub_comm, mem_principal_self])
#align eventually_abs_sub_lt eventually_abs_sub_lt

/- warning: filter.tendsto.add_at_top -> Filter.Tendsto.add_atTop is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] {l : Filter.{u2} Œ≤} {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {C : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 C)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g l (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (x : Œ≤) => HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toHasAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) (f x) (g x)) l (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] {l : Filter.{u2} Œ≤} {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {C : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 C)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g l (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (x : Œ≤) => HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) (f x) (g x)) l (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.add_at_top Filter.Tendsto.add_atTop‚Çì'. -/
/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_top` then `f + g` tends to `at_top`. -/
theorem Filter.Tendsto.add_atTop {C : Œ±} (hf : Tendsto f l (ùìù C)) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  by
  nontriviality Œ±
  obtain ‚ü®C', hC'‚ü© : ‚àÉ C', C' < C := exists_lt C
  refine' tendsto_at_top_add_left_of_le' _ C' _ hg
  exact (hf.eventually (lt_mem_nhds hC')).mono fun x => le_of_lt
#align filter.tendsto.add_at_top Filter.Tendsto.add_atTop

/- warning: filter.tendsto.add_at_bot -> Filter.Tendsto.add_atBot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] {l : Filter.{u2} Œ≤} {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {C : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 C)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g l (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (x : Œ≤) => HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toHasAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) (f x) (g x)) l (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] {l : Filter.{u2} Œ≤} {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {C : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (nhds.{u1} Œ± _inst_1 C)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g l (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (x : Œ≤) => HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) (f x) (g x)) l (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.add_at_bot Filter.Tendsto.add_atBot‚Çì'. -/
/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_bot` then `f + g` tends to `at_bot`. -/
theorem Filter.Tendsto.add_atBot {C : Œ±} (hf : Tendsto f l (ùìù C)) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @Filter.Tendsto.add_atTop Œ±·µí·µà _ _ _ _ _ _ _ _ hf hg
#align filter.tendsto.add_at_bot Filter.Tendsto.add_atBot

/- warning: filter.tendsto.at_top_add -> Filter.Tendsto.atTop_add is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] {l : Filter.{u2} Œ≤} {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {C : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g l (nhds.{u1} Œ± _inst_1 C)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (x : Œ≤) => HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toHasAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) (f x) (g x)) l (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] {l : Filter.{u2} Œ≤} {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {C : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g l (nhds.{u1} Œ± _inst_1 C)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (x : Œ≤) => HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) (f x) (g x)) l (Filter.atTop.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_top_add Filter.Tendsto.atTop_add‚Çì'. -/
/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_top` and `g` tends to `C` then `f + g` tends to `at_top`. -/
theorem Filter.Tendsto.atTop_add {C : Œ±} (hf : Tendsto f l atTop) (hg : Tendsto g l (ùìù C)) :
    Tendsto (fun x => f x + g x) l atTop :=
  by
  conv in _ + _ => rw [add_comm]
  exact hg.add_at_top hf
#align filter.tendsto.at_top_add Filter.Tendsto.atTop_add

/- warning: filter.tendsto.at_bot_add -> Filter.Tendsto.atBot_add is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] {l : Filter.{u2} Œ≤} {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {C : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g l (nhds.{u1} Œ± _inst_1 C)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (x : Œ≤) => HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toHasAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) (f x) (g x)) l (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] {l : Filter.{u2} Œ≤} {f : Œ≤ -> Œ±} {g : Œ≤ -> Œ±} {C : Œ±}, (Filter.Tendsto.{u2, u1} Œ≤ Œ± f l (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± g l (nhds.{u1} Œ± _inst_1 C)) -> (Filter.Tendsto.{u2, u1} Œ≤ Œ± (fun (x : Œ≤) => HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) (f x) (g x)) l (Filter.atBot.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))
Case conversion may be inaccurate. Consider using '#align filter.tendsto.at_bot_add Filter.Tendsto.atBot_add‚Çì'. -/
/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_bot` and `g` tends to `C` then `f + g` tends to `at_bot`. -/
theorem Filter.Tendsto.atBot_add {C : Œ±} (hf : Tendsto f l atBot) (hg : Tendsto g l (ùìù C)) :
    Tendsto (fun x => f x + g x) l atBot :=
  by
  conv in _ + _ => rw [add_comm]
  exact hg.add_at_bot hf
#align filter.tendsto.at_bot_add Filter.Tendsto.atBot_add

/- warning: nhds_basis_Ioo_pos -> nhds_basis_Ioo_pos is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))] [_inst_5 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))] (a : Œ±), Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 a) (fun (Œµ : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))))) Œµ) (fun (Œµ : Œ±) => Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toHasSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) a Œµ) (HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toHasAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) a Œµ))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))] (_inst_5 : Œ±), Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 _inst_5) (fun (Œµ : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))))) Œµ) (fun (Œµ : Œ±) => Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) _inst_5 Œµ) (HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) _inst_5 Œµ))
Case conversion may be inaccurate. Consider using '#align nhds_basis_Ioo_pos nhds_basis_Ioo_pos‚Çì'. -/
theorem nhds_basis_Ioo_pos [NoMinOrder Œ±] [NoMaxOrder Œ±] (a : Œ±) :
    (ùìù a).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ) fun Œµ => Ioo (a - Œµ) (a + Œµ) :=
  ‚ü®by
    refine' fun t => (nhds_basis_Ioo a).mem_iff.trans ‚ü®_, _‚ü©
    ¬∑ rintro ‚ü®‚ü®l, u‚ü©, ‚ü®hl : l < a, hu : a < u‚ü©, h' : Ioo l u ‚äÜ t‚ü©
      refine' ‚ü®min (a - l) (u - a), by apply lt_min <;> rwa [sub_pos], _‚ü©
      rintro x ‚ü®hx, hx'‚ü©
      apply h'
      rw [sub_lt_comm, lt_min_iff, sub_lt_sub_iff_left] at hx
      rw [‚Üê sub_lt_iff_lt_add', lt_min_iff, sub_lt_sub_iff_right] at hx'
      exact ‚ü®hx.1, hx'.2‚ü©
    ¬∑ rintro ‚ü®Œµ, Œµ_pos, h‚ü©
      exact ‚ü®(a - Œµ, a + Œµ), by simp [Œµ_pos], h‚ü©‚ü©
#align nhds_basis_Ioo_pos nhds_basis_Ioo_pos

/- warning: nhds_basis_abs_sub_lt -> nhds_basis_abs_sub_lt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))] [_inst_5 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))] (a : Œ±), Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 a) (fun (Œµ : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))))) Œµ) (fun (Œµ : Œ±) => setOf.{u1} Œ± (fun (b : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (SubNegMonoid.toHasNeg.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) (SemilatticeSup.toHasSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_2))))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toHasSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) b a)) Œµ))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))] (_inst_5 : Œ±), Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 _inst_5) (fun (Œµ : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))))) Œµ) (fun (Œµ : Œ±) => setOf.{u1} Œ± (fun (b : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (NegZeroClass.toNeg.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))) (SemilatticeSup.toSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_2)))))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) b _inst_5)) Œµ))
Case conversion may be inaccurate. Consider using '#align nhds_basis_abs_sub_lt nhds_basis_abs_sub_lt‚Çì'. -/
theorem nhds_basis_abs_sub_lt [NoMinOrder Œ±] [NoMaxOrder Œ±] (a : Œ±) :
    (ùìù a).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ) fun Œµ => { b | |b - a| < Œµ } :=
  by
  convert nhds_basis_Ioo_pos a
  ¬∑ ext Œµ
    change |x - a| < Œµ ‚Üî a - Œµ < x ‚àß x < a + Œµ
    simp [abs_lt, sub_lt_iff_lt_add, add_comm Œµ a, add_comm x Œµ]
#align nhds_basis_abs_sub_lt nhds_basis_abs_sub_lt

variable (Œ±)

/- warning: nhds_basis_zero_abs_sub_lt -> nhds_basis_zero_abs_sub_lt is a dubious translation:
lean 3 declaration is
  forall (Œ± : Type.{u1}) [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))] [_inst_5 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))], Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))))))) (fun (Œµ : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))))) Œµ) (fun (Œµ : Œ±) => setOf.{u1} Œ± (fun (b : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (SubNegMonoid.toHasNeg.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))) (SemilatticeSup.toHasSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_2))))) b) Œµ))
but is expected to have type
  forall (Œ± : Type.{u1}) [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))], Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))))) (fun (Œµ : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))))) Œµ) (fun (Œµ : Œ±) => setOf.{u1} Œ± (fun (b : Œ±) => LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (Abs.abs.{u1} Œ± (Neg.toHasAbs.{u1} Œ± (NegZeroClass.toNeg.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))) (SemilatticeSup.toSup.{u1} Œ± (Lattice.toSemilatticeSup.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± (LinearOrderedAddCommGroup.toLinearOrder.{u1} Œ± _inst_2)))))) b) Œµ))
Case conversion may be inaccurate. Consider using '#align nhds_basis_zero_abs_sub_lt nhds_basis_zero_abs_sub_lt‚Çì'. -/
theorem nhds_basis_zero_abs_sub_lt [NoMinOrder Œ±] [NoMaxOrder Œ±] :
    (ùìù (0 : Œ±)).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ) fun Œµ => { b | |b| < Œµ } := by
  simpa using nhds_basis_abs_sub_lt (0 : Œ±)
#align nhds_basis_zero_abs_sub_lt nhds_basis_zero_abs_sub_lt

variable {Œ±}

/- warning: nhds_basis_Ioo_pos_of_pos -> nhds_basis_Ioo_pos_of_pos is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] [_inst_4 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))] [_inst_5 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))] {a : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))))) a) -> (Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 a) (fun (Œµ : Œ±) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (OfNat.mk.{u1} Œ± 0 (Zero.zero.{u1} Œ± (AddZeroClass.toHasZero.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))))) Œµ) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) Œµ a)) (fun (Œµ : Œ±) => Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toHasSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) a Œµ) (HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toHasAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) a Œµ)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrderedAddCommGroup.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))] [_inst_4 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))] {_inst_5 : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))))) _inst_5) -> (Filter.HasBasis.{u1, succ u1} Œ± Œ± (nhds.{u1} Œ± _inst_1 _inst_5) (fun (Œµ : Œ±) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) (OfNat.ofNat.{u1} Œ± 0 (Zero.toOfNat0.{u1} Œ± (NegZeroClass.toZero.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (SubtractionCommMonoid.toSubtractionMonoid.{u1} Œ± (AddCommGroup.toDivisionAddCommMonoid.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))))))))) Œµ) (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))) Œµ _inst_5)) (fun (Œµ : Œ±) => Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (OrderedAddCommGroup.toPartialOrder.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2))) (HSub.hSub.{u1, u1, u1} Œ± Œ± Œ± (instHSub.{u1} Œ± (SubNegMonoid.toSub.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))) _inst_5 Œµ) (HAdd.hAdd.{u1, u1, u1} Œ± Œ± Œ± (instHAdd.{u1} Œ± (AddZeroClass.toAdd.{u1} Œ± (AddMonoid.toAddZeroClass.{u1} Œ± (SubNegMonoid.toAddMonoid.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± (AddCommGroup.toAddGroup.{u1} Œ± (OrderedAddCommGroup.toAddCommGroup.{u1} Œ± (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} Œ± _inst_2)))))))) _inst_5 Œµ)))
Case conversion may be inaccurate. Consider using '#align nhds_basis_Ioo_pos_of_pos nhds_basis_Ioo_pos_of_pos‚Çì'. -/
/-- If `a` is positive we can form a basis from only nonnegative `Ioo` intervals -/
theorem nhds_basis_Ioo_pos_of_pos [NoMinOrder Œ±] [NoMaxOrder Œ±] {a : Œ±} (ha : 0 < a) :
    (ùìù a).HasBasis (fun Œµ : Œ± => (0 : Œ±) < Œµ ‚àß Œµ ‚â§ a) fun Œµ => Ioo (a - Œµ) (a + Œµ) :=
  ‚ü®fun t =>
    (nhds_basis_Ioo_pos a).mem_iff.trans
      ‚ü®fun h =>
        let ‚ü®i, hi, hit‚ü© := h
        ‚ü®min i a, ‚ü®lt_min hi ha, min_le_right i a‚ü©,
          trans
            (Ioo_subset_Ioo (sub_le_sub_left (min_le_left i a) a)
              (add_le_add_left (min_le_left i a) a))
            hit‚ü©,
        fun h =>
        let ‚ü®i, hi, hit‚ü© := h
        ‚ü®i, hi.1, hit‚ü©‚ü©‚ü©
#align nhds_basis_Ioo_pos_of_pos nhds_basis_Ioo_pos_of_pos

end LinearOrderedAddCommGroup

/- warning: preimage_neg -> preimage_neg is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : AddGroup.{u1} Œ±], Eq.{succ u1} ((Set.{u1} Œ±) -> (Set.{u1} Œ±)) (Set.preimage.{u1, u1} Œ± Œ± (Neg.neg.{u1} Œ± (SubNegMonoid.toHasNeg.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± _inst_1)))) (Set.image.{u1, u1} Œ± Œ± (Neg.neg.{u1} Œ± (SubNegMonoid.toHasNeg.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± _inst_1))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : AddGroup.{u1} Œ±], Eq.{succ u1} ((Set.{u1} Œ±) -> (Set.{u1} Œ±)) (Set.preimage.{u1, u1} Œ± Œ± (Neg.neg.{u1} Œ± (NegZeroClass.toNeg.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (AddGroup.toSubtractionMonoid.{u1} Œ± _inst_1)))))) (Set.image.{u1, u1} Œ± Œ± (Neg.neg.{u1} Œ± (NegZeroClass.toNeg.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (AddGroup.toSubtractionMonoid.{u1} Œ± _inst_1))))))
Case conversion may be inaccurate. Consider using '#align preimage_neg preimage_neg‚Çì'. -/
theorem preimage_neg [AddGroup Œ±] : preimage (Neg.neg : Œ± ‚Üí Œ±) = image (Neg.neg : Œ± ‚Üí Œ±) :=
  (image_eq_preimage_of_inverse neg_neg neg_neg).symm
#align preimage_neg preimage_neg

/- warning: filter.map_neg_eq_comap_neg -> Filter.map_neg_eq_comap_neg is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : AddGroup.{u1} Œ±], Eq.{succ u1} ((Filter.{u1} Œ±) -> (Filter.{u1} Œ±)) (Filter.map.{u1, u1} Œ± Œ± (Neg.neg.{u1} Œ± (SubNegMonoid.toHasNeg.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± _inst_1)))) (Filter.comap.{u1, u1} Œ± Œ± (Neg.neg.{u1} Œ± (SubNegMonoid.toHasNeg.{u1} Œ± (AddGroup.toSubNegMonoid.{u1} Œ± _inst_1))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : AddGroup.{u1} Œ±], Eq.{succ u1} ((Filter.{u1} Œ±) -> (Filter.{u1} Œ±)) (Filter.map.{u1, u1} Œ± Œ± (Neg.neg.{u1} Œ± (NegZeroClass.toNeg.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (AddGroup.toSubtractionMonoid.{u1} Œ± _inst_1)))))) (Filter.comap.{u1, u1} Œ± Œ± (Neg.neg.{u1} Œ± (NegZeroClass.toNeg.{u1} Œ± (SubNegZeroMonoid.toNegZeroClass.{u1} Œ± (SubtractionMonoid.toSubNegZeroMonoid.{u1} Œ± (AddGroup.toSubtractionMonoid.{u1} Œ± _inst_1))))))
Case conversion may be inaccurate. Consider using '#align filter.map_neg_eq_comap_neg Filter.map_neg_eq_comap_neg‚Çì'. -/
theorem Filter.map_neg_eq_comap_neg [AddGroup Œ±] :
    map (Neg.neg : Œ± ‚Üí Œ±) = comap (Neg.neg : Œ± ‚Üí Œ±) :=
  funext fun f => map_eq_comap_of_inverse (funext neg_neg) (funext neg_neg)
#align filter.map_neg_eq_comap_neg Filter.map_neg_eq_comap_neg

section OrderTopology

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [LinearOrder Œ±] [LinearOrder Œ≤] [OrderTopology Œ±]
  [OrderTopology Œ≤]

#print IsLUB.frequently_mem /-
theorem IsLUB.frequently_mem {a : Œ±} {s : Set Œ±} (ha : IsLUB s a) (hs : s.Nonempty) :
    ‚àÉ·∂† x in ùìù[‚â§] a, x ‚àà s := by
  rcases hs with ‚ü®a', ha'‚ü©
  intro h
  rcases(ha.1 ha').eq_or_lt with (rfl | ha'a)
  ¬∑ exact h.self_of_nhds_within le_rfl ha'
  ¬∑ rcases(mem_nhdsWithin_Iic_iff_exists_Ioc_subset' ha'a).1 h with ‚ü®b, hba, hb‚ü©
    rcases ha.exists_between hba with ‚ü®b', hb's, hb'‚ü©
    exact hb hb' hb's
#align is_lub.frequently_mem IsLUB.frequently_mem
-/

#print IsLUB.frequently_nhds_mem /-
theorem IsLUB.frequently_nhds_mem {a : Œ±} {s : Set Œ±} (ha : IsLUB s a) (hs : s.Nonempty) :
    ‚àÉ·∂† x in ùìù a, x ‚àà s :=
  (ha.frequently_mem hs).filter_mono inf_le_left
#align is_lub.frequently_nhds_mem IsLUB.frequently_nhds_mem
-/

#print IsGLB.frequently_mem /-
theorem IsGLB.frequently_mem {a : Œ±} {s : Set Œ±} (ha : IsGLB s a) (hs : s.Nonempty) :
    ‚àÉ·∂† x in ùìù[‚â•] a, x ‚àà s :=
  @IsLUB.frequently_mem Œ±·µí·µà _ _ _ _ _ ha hs
#align is_glb.frequently_mem IsGLB.frequently_mem
-/

#print IsGLB.frequently_nhds_mem /-
theorem IsGLB.frequently_nhds_mem {a : Œ±} {s : Set Œ±} (ha : IsGLB s a) (hs : s.Nonempty) :
    ‚àÉ·∂† x in ùìù a, x ‚àà s :=
  (ha.frequently_mem hs).filter_mono inf_le_left
#align is_glb.frequently_nhds_mem IsGLB.frequently_nhds_mem
-/

#print IsLUB.mem_closure /-
theorem IsLUB.mem_closure {a : Œ±} {s : Set Œ±} (ha : IsLUB s a) (hs : s.Nonempty) : a ‚àà closure s :=
  (ha.frequently_nhds_mem hs).mem_closure
#align is_lub.mem_closure IsLUB.mem_closure
-/

#print IsGLB.mem_closure /-
theorem IsGLB.mem_closure {a : Œ±} {s : Set Œ±} (ha : IsGLB s a) (hs : s.Nonempty) : a ‚àà closure s :=
  (ha.frequently_nhds_mem hs).mem_closure
#align is_glb.mem_closure IsGLB.mem_closure
-/

#print IsLUB.nhdsWithin_neBot /-
theorem IsLUB.nhdsWithin_neBot {a : Œ±} {s : Set Œ±} (ha : IsLUB s a) (hs : s.Nonempty) :
    NeBot (ùìù[s] a) :=
  mem_closure_iff_nhdsWithin_neBot.1 (ha.mem_closure hs)
#align is_lub.nhds_within_ne_bot IsLUB.nhdsWithin_neBot
-/

#print IsGLB.nhdsWithin_neBot /-
theorem IsGLB.nhdsWithin_neBot : ‚àÄ {a : Œ±} {s : Set Œ±}, IsGLB s a ‚Üí s.Nonempty ‚Üí NeBot (ùìù[s] a) :=
  @IsLUB.nhdsWithin_neBot Œ±·µí·µà _ _ _
#align is_glb.nhds_within_ne_bot IsGLB.nhdsWithin_neBot
-/

/- warning: is_lub_of_mem_nhds -> isLUB_of_mem_nhds is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_3 : LinearOrder.{u1} Œ±] [_inst_5 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_3))))] {s : Set.{u1} Œ±} {a : Œ±} {f : Filter.{u1} Œ±}, (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) a (upperBounds.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_3)))) s)) -> (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s f) -> (forall [_inst_7 : Filter.NeBot.{u1} Œ± (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) f (nhds.{u1} Œ± _inst_1 a))], IsLUB.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_3)))) s a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_3 : LinearOrder.{u1} Œ±] [_inst_5 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_3)))))] {s : Set.{u1} Œ±} {a : Œ±} {f : Filter.{u1} Œ±}, (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) a (upperBounds.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_3))))) s)) -> (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s f) -> (forall [_inst_7 : Filter.NeBot.{u1} Œ± (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) f (nhds.{u1} Œ± _inst_1 a))], IsLUB.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_3))))) s a)
Case conversion may be inaccurate. Consider using '#align is_lub_of_mem_nhds isLUB_of_mem_nhds‚Çì'. -/
theorem isLUB_of_mem_nhds {s : Set Œ±} {a : Œ±} {f : Filter Œ±} (hsa : a ‚àà upperBounds s) (hsf : s ‚àà f)
    [NeBot (f ‚äì ùìù a)] : IsLUB s a :=
  ‚ü®hsa, fun b hb =>
    not_lt.1 fun hba =>
      have : s ‚à© { a | b < a } ‚àà f ‚äì ùìù a := inter_mem_inf hsf (IsOpen.mem_nhds (isOpen_lt' _) hba)
      let ‚ü®x, ‚ü®hxs, hxb‚ü©‚ü© := Filter.nonempty_of_mem this
      have : b < b := lt_of_lt_of_le hxb <| hb hxs
      lt_irrefl b this‚ü©
#align is_lub_of_mem_nhds isLUB_of_mem_nhds

#print isLUB_of_mem_closure /-
theorem isLUB_of_mem_closure {s : Set Œ±} {a : Œ±} (hsa : a ‚àà upperBounds s) (hsf : a ‚àà closure s) :
    IsLUB s a := by
  rw [mem_closure_iff_clusterPt, ClusterPt, inf_comm] at hsf
  haveI : (ùìü s ‚äì ùìù a).ne_bot := hsf
  exact isLUB_of_mem_nhds hsa (mem_principal_self s)
#align is_lub_of_mem_closure isLUB_of_mem_closure
-/

/- warning: is_glb_of_mem_nhds -> isGLB_of_mem_nhds is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_3 : LinearOrder.{u1} Œ±] [_inst_5 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_3))))] {s : Set.{u1} Œ±} {a : Œ±} {f : Filter.{u1} Œ±}, (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) a (lowerBounds.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_3)))) s)) -> (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s f) -> (Filter.NeBot.{u1} Œ± (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.hasInf.{u1} Œ±) f (nhds.{u1} Œ± _inst_1 a))) -> (IsGLB.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_3)))) s a)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_3 : LinearOrder.{u1} Œ±] [_inst_5 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_3)))))] {s : Set.{u1} Œ±} {a : Œ±} {f : Filter.{u1} Œ±}, (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) a (lowerBounds.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_3))))) s)) -> (Membership.mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (instMembershipSetFilter.{u1} Œ±) s f) -> (Filter.NeBot.{u1} Œ± (Inf.inf.{u1} (Filter.{u1} Œ±) (Filter.instInfFilter.{u1} Œ±) f (nhds.{u1} Œ± _inst_1 a))) -> (IsGLB.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_3))))) s a)
Case conversion may be inaccurate. Consider using '#align is_glb_of_mem_nhds isGLB_of_mem_nhds‚Çì'. -/
theorem isGLB_of_mem_nhds :
    ‚àÄ {s : Set Œ±} {a : Œ±} {f : Filter Œ±}, a ‚àà lowerBounds s ‚Üí s ‚àà f ‚Üí NeBot (f ‚äì ùìù a) ‚Üí IsGLB s a :=
  @isLUB_of_mem_nhds Œ±·µí·µà _ _ _
#align is_glb_of_mem_nhds isGLB_of_mem_nhds

#print isGLB_of_mem_closure /-
theorem isGLB_of_mem_closure {s : Set Œ±} {a : Œ±} (hsa : a ‚àà lowerBounds s) (hsf : a ‚àà closure s) :
    IsGLB s a :=
  @isLUB_of_mem_closure Œ±·µí·µà _ _ _ s a hsa hsf
#align is_glb_of_mem_closure isGLB_of_mem_closure
-/

#print IsLUB.mem_upperBounds_of_tendsto /-
theorem IsLUB.mem_upperBounds_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥]
    {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : MonotoneOn f s) (ha : IsLUB s a)
    (hb : Tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà upperBounds (f '' s) :=
  by
  rintro _ ‚ü®x, hx, rfl‚ü©
  replace ha := ha.inter_Ici_of_mem hx
  haveI := ha.nhds_within_ne_bot ‚ü®x, hx, le_rfl‚ü©
  refine' ge_of_tendsto (hb.mono_left (nhdsWithin_mono _ (inter_subset_left s (Ici x)))) _
  exact mem_of_superset self_mem_nhdsWithin fun y hy => hf hx hy.1 hy.2
#align is_lub.mem_upper_bounds_of_tendsto IsLUB.mem_upperBounds_of_tendsto
-/

#print IsLUB.isLUB_of_tendsto /-
-- For a version of this theorem in which the convergence considered on the domain `Œ±` is as `x : Œ±`
-- tends to infinity, rather than tending to a point `x` in `Œ±`, see `is_lub_of_tendsto_at_top`
theorem IsLUB.isLUB_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] {f : Œ± ‚Üí Œ≥}
    {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : MonotoneOn f s) (ha : IsLUB s a) (hs : s.Nonempty)
    (hb : Tendsto f (ùìù[s] a) (ùìù b)) : IsLUB (f '' s) b :=
  haveI := ha.nhds_within_ne_bot hs
  ‚ü®ha.mem_upper_bounds_of_tendsto hf hb, fun b' hb' =>
    le_of_tendsto hb (mem_of_superset self_mem_nhdsWithin fun x hx => hb' <| mem_image_of_mem _ hx)‚ü©
#align is_lub.is_lub_of_tendsto IsLUB.isLUB_of_tendsto
-/

#print IsGLB.mem_lowerBounds_of_tendsto /-
theorem IsGLB.mem_lowerBounds_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥]
    {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : MonotoneOn f s) (ha : IsGLB s a)
    (hb : Tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà lowerBounds (f '' s) :=
  @IsLUB.mem_upperBounds_of_tendsto Œ±·µí·µà Œ≥·µí·µà _ _ _ _ _ _ _ _ _ _ hf.dual ha hb
#align is_glb.mem_lower_bounds_of_tendsto IsGLB.mem_lowerBounds_of_tendsto
-/

#print IsGLB.isGLB_of_tendsto /-
-- For a version of this theorem in which the convergence considered on the domain `Œ±` is as
-- `x : Œ±` tends to negative infinity, rather than tending to a point `x` in `Œ±`, see
-- `is_glb_of_tendsto_at_bot`
theorem IsGLB.isGLB_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] {f : Œ± ‚Üí Œ≥}
    {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : MonotoneOn f s) :
    IsGLB s a ‚Üí s.Nonempty ‚Üí Tendsto f (ùìù[s] a) (ùìù b) ‚Üí IsGLB (f '' s) b :=
  @IsLUB.isLUB_of_tendsto Œ±·µí·µà Œ≥·µí·µà _ _ _ _ _ _ f s a b hf.dual
#align is_glb.is_glb_of_tendsto IsGLB.isGLB_of_tendsto
-/

#print IsLUB.mem_lowerBounds_of_tendsto /-
theorem IsLUB.mem_lowerBounds_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥]
    {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : AntitoneOn f s) (ha : IsLUB s a)
    (hb : Tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà lowerBounds (f '' s) :=
  @IsLUB.mem_upperBounds_of_tendsto Œ± Œ≥·µí·µà _ _ _ _ _ _ _ _ _ _ hf ha hb
#align is_lub.mem_lower_bounds_of_tendsto IsLUB.mem_lowerBounds_of_tendsto
-/

#print IsLUB.isGLB_of_tendsto /-
theorem IsLUB.isGLB_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] :
    ‚àÄ {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥},
      AntitoneOn f s ‚Üí IsLUB s a ‚Üí s.Nonempty ‚Üí Tendsto f (ùìù[s] a) (ùìù b) ‚Üí IsGLB (f '' s) b :=
  @IsLUB.isLUB_of_tendsto Œ± Œ≥·µí·µà _ _ _ _ _ _
#align is_lub.is_glb_of_tendsto IsLUB.isGLB_of_tendsto
-/

#print IsGLB.mem_upperBounds_of_tendsto /-
theorem IsGLB.mem_upperBounds_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥]
    {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : AntitoneOn f s) (ha : IsGLB s a)
    (hb : Tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà upperBounds (f '' s) :=
  @IsGLB.mem_lowerBounds_of_tendsto Œ± Œ≥·µí·µà _ _ _ _ _ _ _ _ _ _ hf ha hb
#align is_glb.mem_upper_bounds_of_tendsto IsGLB.mem_upperBounds_of_tendsto
-/

#print IsGLB.isLUB_of_tendsto /-
theorem IsGLB.isLUB_of_tendsto [Preorder Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] :
    ‚àÄ {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥},
      AntitoneOn f s ‚Üí IsGLB s a ‚Üí s.Nonempty ‚Üí Tendsto f (ùìù[s] a) (ùìù b) ‚Üí IsLUB (f '' s) b :=
  @IsGLB.isGLB_of_tendsto Œ± Œ≥·µí·µà _ _ _ _ _ _
#align is_glb.is_lub_of_tendsto IsGLB.isLUB_of_tendsto
-/

#print IsLUB.mem_of_isClosed /-
theorem IsLUB.mem_of_isClosed {a : Œ±} {s : Set Œ±} (ha : IsLUB s a) (hs : s.Nonempty)
    (sc : IsClosed s) : a ‚àà s :=
  sc.closure_subset <| ha.mem_closure hs
#align is_lub.mem_of_is_closed IsLUB.mem_of_isClosed
-/

alias IsLUB.mem_of_isClosed ‚Üê IsClosed.isLUB_mem
#align is_closed.is_lub_mem IsClosed.isLUB_mem

#print IsGLB.mem_of_isClosed /-
theorem IsGLB.mem_of_isClosed {a : Œ±} {s : Set Œ±} (ha : IsGLB s a) (hs : s.Nonempty)
    (sc : IsClosed s) : a ‚àà s :=
  sc.closure_subset <| ha.mem_closure hs
#align is_glb.mem_of_is_closed IsGLB.mem_of_isClosed
-/

alias IsGLB.mem_of_isClosed ‚Üê IsClosed.isGLB_mem
#align is_closed.is_glb_mem IsClosed.isGLB_mem

/-!
### Existence of sequences tending to Inf or Sup of a given set
-/


#print IsLUB.exists_seq_strictMono_tendsto_of_not_mem /-
theorem IsLUB.exists_seq_strictMono_tendsto_of_not_mem {t : Set Œ±} {x : Œ±}
    [IsCountablyGenerated (ùìù x)] (htx : IsLUB t x) (not_mem : x ‚àâ t) (ht : t.Nonempty) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictMono u ‚àß (‚àÄ n, u n < x) ‚àß Tendsto u atTop (ùìù x) ‚àß ‚àÄ n, u n ‚àà t :=
  by
  rcases ht with ‚ü®l, hl‚ü©
  have hl : l < x := (htx.1 hl).eq_or_lt.resolve_left fun h => (not_mem <| h ‚ñ∏ hl).elim
  obtain ‚ü®s, hs‚ü© : ‚àÉ s : ‚Ñï ‚Üí Set Œ±, (ùìù x).HasBasis (fun _x : ‚Ñï => True) s :=
    let ‚ü®s, hs‚ü© := (ùìù x).exists_antitone_basis
    ‚ü®s, hs.to_hasBasis‚ü©
  have : ‚àÄ n k, k < x ‚Üí ‚àÉ y, Icc y x ‚äÜ s n ‚àß k < y ‚àß y < x ‚àß y ‚àà t :=
    by
    intro n k hk
    obtain ‚ü®L, hL, h‚ü© : ‚àÉ (L : Œ±)(hL : L ‚àà Ico k x), Ioc L x ‚äÜ s n :=
      exists_Ioc_subset_of_mem_nhds' (hs.mem_of_mem trivial) hk
    obtain ‚ü®y, hy‚ü© : ‚àÉ y : Œ±, L < y ‚àß y < x ‚àß y ‚àà t :=
      by
      rcases htx.exists_between' not_mem hL.2 with ‚ü®y, yt, hy‚ü©
      refine' ‚ü®y, hy.1, hy.2, yt‚ü©
    exact ‚ü®y, fun z hz => h ‚ü®hy.1.trans_le hz.1, hz.2‚ü©, hL.1.trans_lt hy.1, hy.2‚ü©
  choose! f hf using this
  let u : ‚Ñï ‚Üí Œ± := fun n => Nat.recOn n (f 0 l) fun n h => f n.succ h
  have I : ‚àÄ n, u n < x := by
    intro n
    induction' n with n IH
    ¬∑ exact (hf 0 l hl).2.2.1
    ¬∑ exact (hf n.succ _ IH).2.2.1
  have S : StrictMono u := strictMono_nat_of_lt_succ fun n => (hf n.succ _ (I n)).2.1
  refine' ‚ü®u, S, I, hs.tendsto_right_iff.2 fun n _ => _, fun n => _‚ü©
  ¬∑ simp only [ge_iff_le, eventually_at_top]
    refine' ‚ü®n, fun p hp => _‚ü©
    have up : u p ‚àà Icc (u n) x := ‚ü®S.monotone hp, (I p).le‚ü©
    have : Icc (u n) x ‚äÜ s n := by
      cases n
      ¬∑ exact (hf 0 l hl).1
      ¬∑ exact (hf n.succ (u n) (I n)).1
    exact this up
  ¬∑ cases n
    ¬∑ exact (hf 0 l hl).2.2.2
    ¬∑ exact (hf n.succ _ (I n)).2.2.2
#align is_lub.exists_seq_strict_mono_tendsto_of_not_mem IsLUB.exists_seq_strictMono_tendsto_of_not_mem
-/

#print IsLUB.exists_seq_monotone_tendsto /-
theorem IsLUB.exists_seq_monotone_tendsto {t : Set Œ±} {x : Œ±} [IsCountablyGenerated (ùìù x)]
    (htx : IsLUB t x) (ht : t.Nonempty) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, Monotone u ‚àß (‚àÄ n, u n ‚â§ x) ‚àß Tendsto u atTop (ùìù x) ‚àß ‚àÄ n, u n ‚àà t :=
  by
  by_cases h : x ‚àà t
  ¬∑ exact ‚ü®fun n => x, monotone_const, fun n => le_rfl, tendsto_const_nhds, fun n => h‚ü©
  ¬∑ rcases htx.exists_seq_strict_mono_tendsto_of_not_mem h ht with ‚ü®u, hu‚ü©
    exact ‚ü®u, hu.1.Monotone, fun n => (hu.2.1 n).le, hu.2.2‚ü©
#align is_lub.exists_seq_monotone_tendsto IsLUB.exists_seq_monotone_tendsto
-/

#print exists_seq_strictMono_tendsto' /-
theorem exists_seq_strictMono_tendsto' {Œ± : Type _} [LinearOrder Œ±] [TopologicalSpace Œ±]
    [DenselyOrdered Œ±] [OrderTopology Œ±] [FirstCountableTopology Œ±] {x y : Œ±} (hy : y < x) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictMono u ‚àß (‚àÄ n, u n ‚àà Ioo y x) ‚àß Tendsto u atTop (ùìù x) :=
  by
  have hx : x ‚àâ Ioo y x := fun h => (lt_irrefl x h.2).elim
  have ht : Set.Nonempty (Ioo y x) := nonempty_Ioo.2 hy
  rcases(isLUB_Ioo hy).exists_seq_strictMono_tendsto_of_not_mem hx ht with ‚ü®u, hu‚ü©
  exact ‚ü®u, hu.1, hu.2.2.symm‚ü©
#align exists_seq_strict_mono_tendsto' exists_seq_strictMono_tendsto'
-/

#print exists_seq_strictMono_tendsto /-
theorem exists_seq_strictMono_tendsto [DenselyOrdered Œ±] [NoMinOrder Œ±] [FirstCountableTopology Œ±]
    (x : Œ±) : ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictMono u ‚àß (‚àÄ n, u n < x) ‚àß Tendsto u atTop (ùìù x) :=
  by
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, y < x := exists_lt x
  rcases exists_seq_strictMono_tendsto' hy with ‚ü®u, hu_mono, hu_mem, hux‚ü©
  exact ‚ü®u, hu_mono, fun n => (hu_mem n).2, hux‚ü©
#align exists_seq_strict_mono_tendsto exists_seq_strictMono_tendsto
-/

#print exists_seq_strictMono_tendsto_nhdsWithin /-
theorem exists_seq_strictMono_tendsto_nhdsWithin [DenselyOrdered Œ±] [NoMinOrder Œ±]
    [FirstCountableTopology Œ±] (x : Œ±) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictMono u ‚àß (‚àÄ n, u n < x) ‚àß Tendsto u atTop (ùìù[<] x) :=
  let ‚ü®u, hu, hx, h‚ü© := exists_seq_strictMono_tendsto x
  ‚ü®u, hu, hx, tendsto_nhdsWithin_mono_right (range_subset_iff.2 hx) <| tendsto_nhdsWithin_range.2 h‚ü©
#align exists_seq_strict_mono_tendsto_nhds_within exists_seq_strictMono_tendsto_nhdsWithin
-/

/- warning: exists_seq_tendsto_Sup -> exists_seq_tendsto_sSup is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_7 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7)))))] [_inst_10 : TopologicalSpace.FirstCountableTopology.{u1} Œ± _inst_8] {S : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± S) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7))))) S) -> (Exists.{succ u1} (Nat -> Œ±) (fun (u : Nat -> Œ±) => And (Monotone.{0, u1} Nat Œ± (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7))))) u) (And (Filter.Tendsto.{0, u1} Nat Œ± u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Œ± _inst_8 (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7)) S))) (forall (n : Nat), Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) (u n) S))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_7 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7)))))] [_inst_10 : TopologicalSpace.FirstCountableTopology.{u1} Œ± _inst_8] {S : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± S) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7))))) S) -> (Exists.{succ u1} (Nat -> Œ±) (fun (u : Nat -> Œ±) => And (Monotone.{0, u1} Nat Œ± (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7))))) u) (And (Filter.Tendsto.{0, u1} Nat Œ± u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Œ± _inst_8 (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7)) S))) (forall (n : Nat), Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) (u n) S))))
Case conversion may be inaccurate. Consider using '#align exists_seq_tendsto_Sup exists_seq_tendsto_sSup‚Çì'. -/
theorem exists_seq_tendsto_sSup {Œ± : Type _} [ConditionallyCompleteLinearOrder Œ±]
    [TopologicalSpace Œ±] [OrderTopology Œ±] [FirstCountableTopology Œ±] {S : Set Œ±} (hS : S.Nonempty)
    (hS' : BddAbove S) : ‚àÉ u : ‚Ñï ‚Üí Œ±, Monotone u ‚àß Tendsto u atTop (ùìù (sSup S)) ‚àß ‚àÄ n, u n ‚àà S :=
  by
  rcases(isLUB_csSup hS hS').exists_seq_monotone_tendsto hS with ‚ü®u, hu‚ü©
  exact ‚ü®u, hu.1, hu.2.2‚ü©
#align exists_seq_tendsto_Sup exists_seq_tendsto_sSup

#print IsGLB.exists_seq_strictAnti_tendsto_of_not_mem /-
theorem IsGLB.exists_seq_strictAnti_tendsto_of_not_mem {t : Set Œ±} {x : Œ±}
    [IsCountablyGenerated (ùìù x)] (htx : IsGLB t x) (not_mem : x ‚àâ t) (ht : t.Nonempty) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, x < u n) ‚àß Tendsto u atTop (ùìù x) ‚àß ‚àÄ n, u n ‚àà t :=
  @IsLUB.exists_seq_strictMono_tendsto_of_not_mem Œ±·µí·µà _ _ _ t x _ htx not_mem ht
#align is_glb.exists_seq_strict_anti_tendsto_of_not_mem IsGLB.exists_seq_strictAnti_tendsto_of_not_mem
-/

#print IsGLB.exists_seq_antitone_tendsto /-
theorem IsGLB.exists_seq_antitone_tendsto {t : Set Œ±} {x : Œ±} [IsCountablyGenerated (ùìù x)]
    (htx : IsGLB t x) (ht : t.Nonempty) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, Antitone u ‚àß (‚àÄ n, x ‚â§ u n) ‚àß Tendsto u atTop (ùìù x) ‚àß ‚àÄ n, u n ‚àà t :=
  @IsLUB.exists_seq_monotone_tendsto Œ±·µí·µà _ _ _ t x _ htx ht
#align is_glb.exists_seq_antitone_tendsto IsGLB.exists_seq_antitone_tendsto
-/

#print exists_seq_strictAnti_tendsto' /-
theorem exists_seq_strictAnti_tendsto' [DenselyOrdered Œ±] [FirstCountableTopology Œ±] {x y : Œ±}
    (hy : x < y) : ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, u n ‚àà Ioo x y) ‚àß Tendsto u atTop (ùìù x) := by
  simpa only [dual_Ioo] using exists_seq_strictMono_tendsto' (OrderDual.toDual_lt_toDual.2 hy)
#align exists_seq_strict_anti_tendsto' exists_seq_strictAnti_tendsto'
-/

#print exists_seq_strictAnti_tendsto /-
theorem exists_seq_strictAnti_tendsto [DenselyOrdered Œ±] [NoMaxOrder Œ±] [FirstCountableTopology Œ±]
    (x : Œ±) : ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, x < u n) ‚àß Tendsto u atTop (ùìù x) :=
  @exists_seq_strictMono_tendsto Œ±·µí·µà _ _ _ _ _ _ x
#align exists_seq_strict_anti_tendsto exists_seq_strictAnti_tendsto
-/

#print exists_seq_strictAnti_tendsto_nhdsWithin /-
theorem exists_seq_strictAnti_tendsto_nhdsWithin [DenselyOrdered Œ±] [NoMaxOrder Œ±]
    [FirstCountableTopology Œ±] (x : Œ±) :
    ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, x < u n) ‚àß Tendsto u atTop (ùìù[>] x) :=
  @exists_seq_strictMono_tendsto_nhdsWithin Œ±·µí·µà _ _ _ _ _ _ _
#align exists_seq_strict_anti_tendsto_nhds_within exists_seq_strictAnti_tendsto_nhdsWithin
-/

#print exists_seq_strictAnti_strictMono_tendsto /-
theorem exists_seq_strictAnti_strictMono_tendsto [DenselyOrdered Œ±] [FirstCountableTopology Œ±]
    {x y : Œ±} (h : x < y) :
    ‚àÉ u v : ‚Ñï ‚Üí Œ±,
      StrictAnti u ‚àß
        StrictMono v ‚àß
          (‚àÄ k, u k ‚àà Ioo x y) ‚àß
            (‚àÄ l, v l ‚àà Ioo x y) ‚àß
              (‚àÄ k l, u k < v l) ‚àß Tendsto u atTop (ùìù x) ‚àß Tendsto v atTop (ùìù y) :=
  by
  rcases exists_seq_strictAnti_tendsto' h with ‚ü®u, hu_anti, hu_mem, hux‚ü©
  rcases exists_seq_strictMono_tendsto' (hu_mem 0).2 with ‚ü®v, hv_mono, hv_mem, hvy‚ü©
  exact
    ‚ü®u, v, hu_anti, hv_mono, hu_mem, fun l => ‚ü®(hu_mem 0).1.trans (hv_mem l).1, (hv_mem l).2‚ü©,
      fun k l => (hu_anti.antitone (zero_le k)).trans_lt (hv_mem l).1, hux, hvy‚ü©
#align exists_seq_strict_anti_strict_mono_tendsto exists_seq_strictAnti_strictMono_tendsto
-/

/- warning: exists_seq_tendsto_Inf -> exists_seq_tendsto_sInf is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_7 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7)))))] [_inst_10 : TopologicalSpace.FirstCountableTopology.{u1} Œ± _inst_8] {S : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± S) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7))))) S) -> (Exists.{succ u1} (Nat -> Œ±) (fun (u : Nat -> Œ±) => And (Antitone.{0, u1} Nat Œ± (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7))))) u) (And (Filter.Tendsto.{0, u1} Nat Œ± u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Œ± _inst_8 (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7)) S))) (forall (n : Nat), Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) (u n) S))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_7 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7)))))] [_inst_10 : TopologicalSpace.FirstCountableTopology.{u1} Œ± _inst_8] {S : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± S) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7))))) S) -> (Exists.{succ u1} (Nat -> Œ±) (fun (u : Nat -> Œ±) => And (Antitone.{0, u1} Nat Œ± (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7))))) u) (And (Filter.Tendsto.{0, u1} Nat Œ± u (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Œ± _inst_8 (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_7)) S))) (forall (n : Nat), Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) (u n) S))))
Case conversion may be inaccurate. Consider using '#align exists_seq_tendsto_Inf exists_seq_tendsto_sInf‚Çì'. -/
theorem exists_seq_tendsto_sInf {Œ± : Type _} [ConditionallyCompleteLinearOrder Œ±]
    [TopologicalSpace Œ±] [OrderTopology Œ±] [FirstCountableTopology Œ±] {S : Set Œ±} (hS : S.Nonempty)
    (hS' : BddBelow S) : ‚àÉ u : ‚Ñï ‚Üí Œ±, Antitone u ‚àß Tendsto u atTop (ùìù (sInf S)) ‚àß ‚àÄ n, u n ‚àà S :=
  @exists_seq_tendsto_sSup Œ±·µí·µà _ _ _ _ S hS hS'
#align exists_seq_tendsto_Inf exists_seq_tendsto_sInf

end OrderTopology

section DenselyOrdered

variable [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [DenselyOrdered Œ±] {a b : Œ±}
  {s : Set Œ±}

#print closure_Ioi' /-
/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`, unless `a` is a top
element. -/
theorem closure_Ioi' {a : Œ±} (h : (Ioi a).Nonempty) : closure (Ioi a) = Ici a :=
  by
  apply subset.antisymm
  ¬∑ exact closure_minimal Ioi_subset_Ici_self isClosed_Ici
  ¬∑ rw [‚Üê diff_subset_closure_iff, Ici_diff_Ioi_same, singleton_subset_iff]
    exact is_glb_Ioi.mem_closure h
#align closure_Ioi' closure_Ioi'
-/

#print closure_Ioi /-
/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`. -/
@[simp]
theorem closure_Ioi (a : Œ±) [NoMaxOrder Œ±] : closure (Ioi a) = Ici a :=
  closure_Ioi' nonempty_Ioi
#align closure_Ioi closure_Ioi
-/

#print closure_Iio' /-
/-- The closure of the interval `(-‚àû, a)` is the closed interval `(-‚àû, a]`, unless `a` is a bottom
element. -/
theorem closure_Iio' (h : (Iio a).Nonempty) : closure (Iio a) = Iic a :=
  @closure_Ioi' Œ±·µí·µà _ _ _ _ _ h
#align closure_Iio' closure_Iio'
-/

#print closure_Iio /-
/-- The closure of the interval `(-‚àû, a)` is the interval `(-‚àû, a]`. -/
@[simp]
theorem closure_Iio (a : Œ±) [NoMinOrder Œ±] : closure (Iio a) = Iic a :=
  closure_Iio' nonempty_Iio
#align closure_Iio closure_Iio
-/

#print closure_Ioo /-
/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ioo {a b : Œ±} (hab : a ‚â† b) : closure (Ioo a b) = Icc a b :=
  by
  apply subset.antisymm
  ¬∑ exact closure_minimal Ioo_subset_Icc_self isClosed_Icc
  ¬∑ cases' hab.lt_or_lt with hab hab
    ¬∑ rw [‚Üê diff_subset_closure_iff, Icc_diff_Ioo_same hab.le]
      have hab' : (Ioo a b).Nonempty := nonempty_Ioo.2 hab
      simp only [insert_subset, singleton_subset_iff]
      exact ‚ü®(isGLB_Ioo hab).mem_closure hab', (isLUB_Ioo hab).mem_closure hab'‚ü©
    ¬∑ rw [Icc_eq_empty_of_lt hab]
      exact empty_subset _
#align closure_Ioo closure_Ioo
-/

#print closure_Ioc /-
/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ioc {a b : Œ±} (hab : a ‚â† b) : closure (Ioc a b) = Icc a b :=
  by
  apply subset.antisymm
  ¬∑ exact closure_minimal Ioc_subset_Icc_self isClosed_Icc
  ¬∑ apply subset.trans _ (closure_mono Ioo_subset_Ioc_self)
    rw [closure_Ioo hab]
#align closure_Ioc closure_Ioc
-/

#print closure_Ico /-
/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ico {a b : Œ±} (hab : a ‚â† b) : closure (Ico a b) = Icc a b :=
  by
  apply subset.antisymm
  ¬∑ exact closure_minimal Ico_subset_Icc_self isClosed_Icc
  ¬∑ apply subset.trans _ (closure_mono Ioo_subset_Ico_self)
    rw [closure_Ioo hab]
#align closure_Ico closure_Ico
-/

#print interior_Ici' /-
@[simp]
theorem interior_Ici' {a : Œ±} (ha : (Iio a).Nonempty) : interior (Ici a) = Ioi a := by
  rw [‚Üê compl_Iio, interior_compl, closure_Iio' ha, compl_Iic]
#align interior_Ici' interior_Ici'
-/

#print interior_Ici /-
theorem interior_Ici [NoMinOrder Œ±] {a : Œ±} : interior (Ici a) = Ioi a :=
  interior_Ici' nonempty_Iio
#align interior_Ici interior_Ici
-/

#print interior_Iic' /-
@[simp]
theorem interior_Iic' {a : Œ±} (ha : (Ioi a).Nonempty) : interior (Iic a) = Iio a :=
  @interior_Ici' Œ±·µí·µà _ _ _ _ _ ha
#align interior_Iic' interior_Iic'
-/

#print interior_Iic /-
theorem interior_Iic [NoMaxOrder Œ±] {a : Œ±} : interior (Iic a) = Iio a :=
  interior_Iic' nonempty_Ioi
#align interior_Iic interior_Iic
-/

#print interior_Icc /-
@[simp]
theorem interior_Icc [NoMinOrder Œ±] [NoMaxOrder Œ±] {a b : Œ±} : interior (Icc a b) = Ioo a b := by
  rw [‚Üê Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]
#align interior_Icc interior_Icc
-/

#print interior_Ico /-
@[simp]
theorem interior_Ico [NoMinOrder Œ±] {a b : Œ±} : interior (Ico a b) = Ioo a b := by
  rw [‚Üê Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]
#align interior_Ico interior_Ico
-/

#print interior_Ioc /-
@[simp]
theorem interior_Ioc [NoMaxOrder Œ±] {a b : Œ±} : interior (Ioc a b) = Ioo a b := by
  rw [‚Üê Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]
#align interior_Ioc interior_Ioc
-/

#print closure_interior_Icc /-
theorem closure_interior_Icc {a b : Œ±} (h : a ‚â† b) : closure (interior (Icc a b)) = Icc a b :=
  (closure_minimal interior_subset isClosed_Icc).antisymm <|
    calc
      Icc a b = closure (Ioo a b) := (closure_Ioo h).symm
      _ ‚äÜ closure (interior (Icc a b)) :=
        closure_mono (interior_maximal Ioo_subset_Icc_self isOpen_Ioo)
      
#align closure_interior_Icc closure_interior_Icc
-/

#print Ioc_subset_closure_interior /-
theorem Ioc_subset_closure_interior (a b : Œ±) : Ioc a b ‚äÜ closure (interior (Ioc a b)) :=
  by
  rcases eq_or_ne a b with (rfl | h)
  ¬∑ simp
  ¬∑
    calc
      Ioc a b ‚äÜ Icc a b := Ioc_subset_Icc_self
      _ = closure (Ioo a b) := (closure_Ioo h).symm
      _ ‚äÜ closure (interior (Ioc a b)) :=
        closure_mono (interior_maximal Ioo_subset_Ioc_self isOpen_Ioo)
      
#align Ioc_subset_closure_interior Ioc_subset_closure_interior
-/

#print Ico_subset_closure_interior /-
theorem Ico_subset_closure_interior (a b : Œ±) : Ico a b ‚äÜ closure (interior (Ico a b)) := by
  simpa only [dual_Ioc] using Ioc_subset_closure_interior (OrderDual.toDual b) (OrderDual.toDual a)
#align Ico_subset_closure_interior Ico_subset_closure_interior
-/

#print frontier_Ici' /-
@[simp]
theorem frontier_Ici' {a : Œ±} (ha : (Iio a).Nonempty) : frontier (Ici a) = {a} := by
  simp [frontier, ha]
#align frontier_Ici' frontier_Ici'
-/

#print frontier_Ici /-
theorem frontier_Ici [NoMinOrder Œ±] {a : Œ±} : frontier (Ici a) = {a} :=
  frontier_Ici' nonempty_Iio
#align frontier_Ici frontier_Ici
-/

#print frontier_Iic' /-
@[simp]
theorem frontier_Iic' {a : Œ±} (ha : (Ioi a).Nonempty) : frontier (Iic a) = {a} := by
  simp [frontier, ha]
#align frontier_Iic' frontier_Iic'
-/

#print frontier_Iic /-
theorem frontier_Iic [NoMaxOrder Œ±] {a : Œ±} : frontier (Iic a) = {a} :=
  frontier_Iic' nonempty_Ioi
#align frontier_Iic frontier_Iic
-/

#print frontier_Ioi' /-
@[simp]
theorem frontier_Ioi' {a : Œ±} (ha : (Ioi a).Nonempty) : frontier (Ioi a) = {a} := by
  simp [frontier, closure_Ioi' ha, Iic_diff_Iio, Icc_self]
#align frontier_Ioi' frontier_Ioi'
-/

#print frontier_Ioi /-
theorem frontier_Ioi [NoMaxOrder Œ±] {a : Œ±} : frontier (Ioi a) = {a} :=
  frontier_Ioi' nonempty_Ioi
#align frontier_Ioi frontier_Ioi
-/

#print frontier_Iio' /-
@[simp]
theorem frontier_Iio' {a : Œ±} (ha : (Iio a).Nonempty) : frontier (Iio a) = {a} := by
  simp [frontier, closure_Iio' ha, Iic_diff_Iio, Icc_self]
#align frontier_Iio' frontier_Iio'
-/

#print frontier_Iio /-
theorem frontier_Iio [NoMinOrder Œ±] {a : Œ±} : frontier (Iio a) = {a} :=
  frontier_Iio' nonempty_Iio
#align frontier_Iio frontier_Iio
-/

#print frontier_Icc /-
@[simp]
theorem frontier_Icc [NoMinOrder Œ±] [NoMaxOrder Œ±] {a b : Œ±} (h : a ‚â§ b) :
    frontier (Icc a b) = {a, b} := by simp [frontier, h, Icc_diff_Ioo_same]
#align frontier_Icc frontier_Icc
-/

#print frontier_Ioo /-
@[simp]
theorem frontier_Ioo {a b : Œ±} (h : a < b) : frontier (Ioo a b) = {a, b} := by
  rw [frontier, closure_Ioo h.ne, interior_Ioo, Icc_diff_Ioo_same h.le]
#align frontier_Ioo frontier_Ioo
-/

#print frontier_Ico /-
@[simp]
theorem frontier_Ico [NoMinOrder Œ±] {a b : Œ±} (h : a < b) : frontier (Ico a b) = {a, b} := by
  rw [frontier, closure_Ico h.ne, interior_Ico, Icc_diff_Ioo_same h.le]
#align frontier_Ico frontier_Ico
-/

#print frontier_Ioc /-
@[simp]
theorem frontier_Ioc [NoMaxOrder Œ±] {a b : Œ±} (h : a < b) : frontier (Ioc a b) = {a, b} := by
  rw [frontier, closure_Ioc h.ne, interior_Ioc, Icc_diff_Ioo_same h.le]
#align frontier_Ioc frontier_Ioc
-/

#print nhdsWithin_Ioi_neBot' /-
theorem nhdsWithin_Ioi_neBot' {a b : Œ±} (H‚ÇÅ : (Ioi a).Nonempty) (H‚ÇÇ : a ‚â§ b) : NeBot (ùìù[Ioi a] b) :=
  mem_closure_iff_nhdsWithin_neBot.1 <| by rwa [closure_Ioi' H‚ÇÅ]
#align nhds_within_Ioi_ne_bot' nhdsWithin_Ioi_neBot'
-/

#print nhdsWithin_Ioi_neBot /-
theorem nhdsWithin_Ioi_neBot [NoMaxOrder Œ±] {a b : Œ±} (H : a ‚â§ b) : NeBot (ùìù[Ioi a] b) :=
  nhdsWithin_Ioi_neBot' nonempty_Ioi H
#align nhds_within_Ioi_ne_bot nhdsWithin_Ioi_neBot
-/

#print nhdsWithin_Ioi_self_neBot' /-
theorem nhdsWithin_Ioi_self_neBot' {a : Œ±} (H : (Ioi a).Nonempty) : NeBot (ùìù[>] a) :=
  nhdsWithin_Ioi_neBot' H (le_refl a)
#align nhds_within_Ioi_self_ne_bot' nhdsWithin_Ioi_self_neBot'
-/

#print nhdsWithin_Ioi_self_neBot /-
@[instance]
theorem nhdsWithin_Ioi_self_neBot [NoMaxOrder Œ±] (a : Œ±) : NeBot (ùìù[>] a) :=
  nhdsWithin_Ioi_neBot (le_refl a)
#align nhds_within_Ioi_self_ne_bot nhdsWithin_Ioi_self_neBot
-/

/- warning: filter.eventually.exists_gt -> Filter.Eventually.exists_gt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] [_inst_5 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {p : Œ± -> Prop}, (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (nhds.{u1} Œ± _inst_1 a)) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => Exists.{0} (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b a) (fun (H : GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b a) => p b)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] [_inst_5 : NoMaxOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {a : Œ±} {p : Œ± -> Prop}, (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (nhds.{u1} Œ± _inst_1 a)) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => And (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) b a) (p b)))
Case conversion may be inaccurate. Consider using '#align filter.eventually.exists_gt Filter.Eventually.exists_gt‚Çì'. -/
theorem Filter.Eventually.exists_gt [NoMaxOrder Œ±] {a : Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in ùìù a, p x) :
    ‚àÉ b > a, p b := by
  simpa only [exists_prop, gt_iff_lt, and_comm'] using
    ((h.filter_mono (@nhdsWithin_le_nhds _ _ a (Ioi a))).And self_mem_nhdsWithin).exists
#align filter.eventually.exists_gt Filter.Eventually.exists_gt

#print nhdsWithin_Iio_neBot' /-
theorem nhdsWithin_Iio_neBot' {b c : Œ±} (H‚ÇÅ : (Iio c).Nonempty) (H‚ÇÇ : b ‚â§ c) : NeBot (ùìù[Iio c] b) :=
  mem_closure_iff_nhdsWithin_neBot.1 <| by rwa [closure_Iio' H‚ÇÅ]
#align nhds_within_Iio_ne_bot' nhdsWithin_Iio_neBot'
-/

#print nhdsWithin_Iio_neBot /-
theorem nhdsWithin_Iio_neBot [NoMinOrder Œ±] {a b : Œ±} (H : a ‚â§ b) : NeBot (ùìù[Iio b] a) :=
  nhdsWithin_Iio_neBot' nonempty_Iio H
#align nhds_within_Iio_ne_bot nhdsWithin_Iio_neBot
-/

#print nhdsWithin_Iio_self_neBot' /-
theorem nhdsWithin_Iio_self_neBot' {b : Œ±} (H : (Iio b).Nonempty) : NeBot (ùìù[<] b) :=
  nhdsWithin_Iio_neBot' H (le_refl b)
#align nhds_within_Iio_self_ne_bot' nhdsWithin_Iio_self_neBot'
-/

#print nhdsWithin_Iio_self_neBot /-
@[instance]
theorem nhdsWithin_Iio_self_neBot [NoMinOrder Œ±] (a : Œ±) : NeBot (ùìù[<] a) :=
  nhdsWithin_Iio_neBot (le_refl a)
#align nhds_within_Iio_self_ne_bot nhdsWithin_Iio_self_neBot
-/

/- warning: filter.eventually.exists_lt -> Filter.Eventually.exists_lt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] [_inst_5 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {p : Œ± -> Prop}, (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (nhds.{u1} Œ± _inst_1 a)) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b a) (fun (H : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b a) => p b)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] [_inst_5 : NoMinOrder.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {a : Œ±} {p : Œ± -> Prop}, (Filter.Eventually.{u1} Œ± (fun (x : Œ±) => p x) (nhds.{u1} Œ± _inst_1 a)) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) b a) (p b)))
Case conversion may be inaccurate. Consider using '#align filter.eventually.exists_lt Filter.Eventually.exists_lt‚Çì'. -/
theorem Filter.Eventually.exists_lt [NoMinOrder Œ±] {a : Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in ùìù a, p x) :
    ‚àÉ b < a, p b :=
  @Filter.Eventually.exists_gt Œ±·µí·µà _ _ _ _ _ _ _ h
#align filter.eventually.exists_lt Filter.Eventually.exists_lt

#print right_nhdsWithin_Ico_neBot /-
theorem right_nhdsWithin_Ico_neBot {a b : Œ±} (H : a < b) : NeBot (ùìù[Ico a b] b) :=
  (isLUB_Ico H).nhdsWithin_neBot (nonempty_Ico.2 H)
#align right_nhds_within_Ico_ne_bot right_nhdsWithin_Ico_neBot
-/

#print left_nhdsWithin_Ioc_neBot /-
theorem left_nhdsWithin_Ioc_neBot {a b : Œ±} (H : a < b) : NeBot (ùìù[Ioc a b] a) :=
  (isGLB_Ioc H).nhdsWithin_neBot (nonempty_Ioc.2 H)
#align left_nhds_within_Ioc_ne_bot left_nhdsWithin_Ioc_neBot
-/

#print left_nhdsWithin_Ioo_neBot /-
theorem left_nhdsWithin_Ioo_neBot {a b : Œ±} (H : a < b) : NeBot (ùìù[Ioo a b] a) :=
  (isGLB_Ioo H).nhdsWithin_neBot (nonempty_Ioo.2 H)
#align left_nhds_within_Ioo_ne_bot left_nhdsWithin_Ioo_neBot
-/

#print right_nhdsWithin_Ioo_neBot /-
theorem right_nhdsWithin_Ioo_neBot {a b : Œ±} (H : a < b) : NeBot (ùìù[Ioo a b] b) :=
  (isLUB_Ioo H).nhdsWithin_neBot (nonempty_Ioo.2 H)
#align right_nhds_within_Ioo_ne_bot right_nhdsWithin_Ioo_neBot
-/

/- warning: comap_coe_nhds_within_Iio_of_Ioo_subset -> comap_coe_nhdsWithin_Iio_of_Ioo_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {b : Œ±} {s : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b)) -> ((Set.Nonempty.{u1} Œ± s) -> (Exists.{succ u1} Œ± (fun (a : Œ±) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) (fun (H : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b) s)))) -> (Eq.{succ u1} (Filter.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s)) (Filter.comap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))))) (nhdsWithin.{u1} Œ± _inst_1 b (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b))) (Filter.atTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {b : Œ±} {s : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) b)) -> ((Set.Nonempty.{u1} Œ± s) -> (Exists.{succ u1} Œ± (fun (a : Œ±) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a b) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b) s)))) -> (Eq.{succ u1} (Filter.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s))) (Filter.comap.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (nhdsWithin.{u1} Œ± _inst_1 b (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) b))) (Filter.atTop.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s))))
Case conversion may be inaccurate. Consider using '#align comap_coe_nhds_within_Iio_of_Ioo_subset comap_coe_nhdsWithin_Iio_of_Ioo_subset‚Çì'. -/
theorem comap_coe_nhdsWithin_Iio_of_Ioo_subset (hb : s ‚äÜ Iio b)
    (hs : s.Nonempty ‚Üí ‚àÉ a < b, Ioo a b ‚äÜ s) : comap (coe : s ‚Üí Œ±) (ùìù[<] b) = atTop :=
  by
  nontriviality
  haveI : Nonempty s := nontrivial_iff_nonempty.1 ‚Äπ_‚Ä∫
  rcases hs (nonempty_subtype.1 ‚Äπ_‚Ä∫) with ‚ü®a, h, hs‚ü©
  ext u; constructor
  ¬∑ rintro ‚ü®t, ht, hts‚ü©
    obtain ‚ü®x, ‚ü®hxa : a ‚â§ x, hxb : x < b‚ü©, hxt : Ioo x b ‚äÜ t‚ü© :=
      (mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht
    obtain ‚ü®y, hxy, hyb‚ü© := exists_between hxb
    refine' mem_of_superset (mem_at_top ‚ü®y, hs ‚ü®hxa.trans_lt hxy, hyb‚ü©‚ü©) _
    rintro ‚ü®z, hzs‚ü© (hyz : y ‚â§ z)
    refine' hts (hxt ‚ü®hxy.trans_le _, hb _‚ü©) <;> assumption
  ¬∑ intro hu
    obtain ‚ü®x : s, hx : ‚àÄ z, x ‚â§ z ‚Üí z ‚àà u‚ü© := mem_at_top_sets.1 hu
    exact ‚ü®Ioo x b, Ioo_mem_nhdsWithin_Iio (right_mem_Ioc.2 <| hb x.2), fun z hz => hx _ hz.1.le‚ü©
#align comap_coe_nhds_within_Iio_of_Ioo_subset comap_coe_nhdsWithin_Iio_of_Ioo_subset

/- warning: comap_coe_nhds_within_Ioi_of_Ioo_subset -> comap_coe_nhdsWithin_Ioi_of_Ioo_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) -> ((Set.Nonempty.{u1} Œ± s) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => Exists.{0} (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b a) (fun (H : GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b a) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b) s)))) -> (Eq.{succ u1} (Filter.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s)) (Filter.comap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))))) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a))) (Filter.atBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {a : Œ±} {s : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) -> ((Set.Nonempty.{u1} Œ± s) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => And (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) b a) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b) s)))) -> (Eq.{succ u1} (Filter.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s))) (Filter.comap.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a))) (Filter.atBot.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s))))
Case conversion may be inaccurate. Consider using '#align comap_coe_nhds_within_Ioi_of_Ioo_subset comap_coe_nhdsWithin_Ioi_of_Ioo_subset‚Çì'. -/
theorem comap_coe_nhdsWithin_Ioi_of_Ioo_subset (ha : s ‚äÜ Ioi a)
    (hs : s.Nonempty ‚Üí ‚àÉ b > a, Ioo a b ‚äÜ s) : comap (coe : s ‚Üí Œ±) (ùìù[>] a) = atBot :=
  comap_coe_nhdsWithin_Iio_of_Ioo_subset (show ofDual ‚Åª¬π' s ‚äÜ Iio (toDual a) from ha) fun h => by
    simpa only [OrderDual.exists, dual_Ioo] using hs h
#align comap_coe_nhds_within_Ioi_of_Ioo_subset comap_coe_nhdsWithin_Ioi_of_Ioo_subset

/- warning: map_coe_at_top_of_Ioo_subset -> map_coe_atTop_of_Ioo_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {b : Œ±} {s : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b)) -> (forall (a' : Œ±), (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a' b) -> (Exists.{succ u1} Œ± (fun (a : Œ±) => Exists.{0} (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) (fun (H : LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) a b) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b) s)))) -> (Eq.{succ u1} (Filter.{u1} Œ±) (Filter.map.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))))) (Filter.atTop.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))) (nhdsWithin.{u1} Œ± _inst_1 b (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) b)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {b : Œ±} {s : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) b)) -> (forall (a' : Œ±), (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a' b) -> (Exists.{succ u1} Œ± (fun (a : Œ±) => And (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) a b) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b) s)))) -> (Eq.{succ u1} (Filter.{u1} Œ±) (Filter.map.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (Filter.atTop.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)))) (nhdsWithin.{u1} Œ± _inst_1 b (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) b)))
Case conversion may be inaccurate. Consider using '#align map_coe_at_top_of_Ioo_subset map_coe_atTop_of_Ioo_subset‚Çì'. -/
theorem map_coe_atTop_of_Ioo_subset (hb : s ‚äÜ Iio b) (hs : ‚àÄ a' < b, ‚àÉ a < b, Ioo a b ‚äÜ s) :
    map (coe : s ‚Üí Œ±) atTop = ùìù[<] b :=
  by
  rcases eq_empty_or_nonempty (Iio b) with (hb' | ‚ü®a, ha‚ü©)
  ¬∑ rw [filter_eq_bot_of_is_empty at_top, Filter.map_bot, hb', nhdsWithin_empty]
    exact ‚ü®fun x => hb'.subset (hb x.2)‚ü©
  ¬∑ rw [‚Üê comap_coe_nhdsWithin_Iio_of_Ioo_subset hb fun _ => hs a ha, map_comap_of_mem]
    rw [Subtype.range_coe]
    exact (mem_nhdsWithin_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha)
#align map_coe_at_top_of_Ioo_subset map_coe_atTop_of_Ioo_subset

/- warning: map_coe_at_bot_of_Ioo_subset -> map_coe_atBot_of_Ioo_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] {a : Œ±} {s : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) s (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)) -> (forall (b' : Œ±), (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b' a) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => Exists.{0} (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b a) (fun (H : GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) b a) => HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a b) s)))) -> (Eq.{succ u1} (Filter.{u1} Œ±) (Filter.map.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (CoeTC‚Çì.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) Œ± (coeSubtype.{succ u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))))) (Filter.atBot.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))) a)))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] {a : Œ±} {s : Set.{u1} Œ±}, (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) s (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)) -> (forall (b' : Œ±), (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) b' a) -> (Exists.{succ u1} Œ± (fun (b : Œ±) => And (GT.gt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) b a) (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) (Set.Ioo.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a b) s)))) -> (Eq.{succ u1} (Filter.{u1} Œ±) (Filter.map.{u1, u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) Œ± (Subtype.val.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (Filter.atBot.{u1} (Subtype.{succ u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)) (Subtype.preorder.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s)))) (nhdsWithin.{u1} Œ± _inst_1 a (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))) a)))
Case conversion may be inaccurate. Consider using '#align map_coe_at_bot_of_Ioo_subset map_coe_atBot_of_Ioo_subset‚Çì'. -/
theorem map_coe_atBot_of_Ioo_subset (ha : s ‚äÜ Ioi a) (hs : ‚àÄ b' > a, ‚àÉ b > a, Ioo a b ‚äÜ s) :
    map (coe : s ‚Üí Œ±) atBot = ùìù[>] a :=
  by
  -- the elaborator gets stuck without `(... : _)`
  refine'
    (map_coe_atTop_of_Ioo_subset (show of_dual ‚Åª¬π' s ‚äÜ Iio (to_dual a) from ha) fun b' hb' => _ : _)
  simpa only [OrderDual.exists, dual_Ioo] using hs b' hb'
#align map_coe_at_bot_of_Ioo_subset map_coe_atBot_of_Ioo_subset

#print comap_coe_Ioo_nhdsWithin_Iio /-
/-- The `at_top` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at
the right endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhdsWithin_Iio (a b : Œ±) : comap (coe : Ioo a b ‚Üí Œ±) (ùìù[<] b) = atTop :=
  comap_coe_nhdsWithin_Iio_of_Ioo_subset Ioo_subset_Iio_self fun h =>
    ‚ü®a, nonempty_Ioo.1 h, Subset.refl _‚ü©
#align comap_coe_Ioo_nhds_within_Iio comap_coe_Ioo_nhdsWithin_Iio
-/

#print comap_coe_Ioo_nhdsWithin_Ioi /-
/-- The `at_bot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at
the left endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhdsWithin_Ioi (a b : Œ±) : comap (coe : Ioo a b ‚Üí Œ±) (ùìù[>] a) = atBot :=
  comap_coe_nhdsWithin_Ioi_of_Ioo_subset Ioo_subset_Ioi_self fun h =>
    ‚ü®b, nonempty_Ioo.1 h, Subset.refl _‚ü©
#align comap_coe_Ioo_nhds_within_Ioi comap_coe_Ioo_nhdsWithin_Ioi
-/

#print comap_coe_Ioi_nhdsWithin_Ioi /-
theorem comap_coe_Ioi_nhdsWithin_Ioi (a : Œ±) : comap (coe : Ioi a ‚Üí Œ±) (ùìù[>] a) = atBot :=
  comap_coe_nhdsWithin_Ioi_of_Ioo_subset (Subset.refl _) fun ‚ü®x, hx‚ü© => ‚ü®x, hx, Ioo_subset_Ioi_self‚ü©
#align comap_coe_Ioi_nhds_within_Ioi comap_coe_Ioi_nhdsWithin_Ioi
-/

#print comap_coe_Iio_nhdsWithin_Iio /-
theorem comap_coe_Iio_nhdsWithin_Iio (a : Œ±) : comap (coe : Iio a ‚Üí Œ±) (ùìù[<] a) = atTop :=
  @comap_coe_Ioi_nhdsWithin_Ioi Œ±·µí·µà _ _ _ _ a
#align comap_coe_Iio_nhds_within_Iio comap_coe_Iio_nhdsWithin_Iio
-/

#print map_coe_Ioo_atTop /-
@[simp]
theorem map_coe_Ioo_atTop {a b : Œ±} (h : a < b) : map (coe : Ioo a b ‚Üí Œ±) atTop = ùìù[<] b :=
  map_coe_atTop_of_Ioo_subset Ioo_subset_Iio_self fun _ _ => ‚ü®_, h, Subset.refl _‚ü©
#align map_coe_Ioo_at_top map_coe_Ioo_atTop
-/

#print map_coe_Ioo_atBot /-
@[simp]
theorem map_coe_Ioo_atBot {a b : Œ±} (h : a < b) : map (coe : Ioo a b ‚Üí Œ±) atBot = ùìù[>] a :=
  map_coe_atBot_of_Ioo_subset Ioo_subset_Ioi_self fun _ _ => ‚ü®_, h, Subset.refl _‚ü©
#align map_coe_Ioo_at_bot map_coe_Ioo_atBot
-/

#print map_coe_Ioi_atBot /-
@[simp]
theorem map_coe_Ioi_atBot (a : Œ±) : map (coe : Ioi a ‚Üí Œ±) atBot = ùìù[>] a :=
  map_coe_atBot_of_Ioo_subset (Subset.refl _) fun b hb => ‚ü®b, hb, Ioo_subset_Ioi_self‚ü©
#align map_coe_Ioi_at_bot map_coe_Ioi_atBot
-/

#print map_coe_Iio_atTop /-
@[simp]
theorem map_coe_Iio_atTop (a : Œ±) : map (coe : Iio a ‚Üí Œ±) atTop = ùìù[<] a :=
  @map_coe_Ioi_atBot Œ±·µí·µà _ _ _ _ _
#align map_coe_Iio_at_top map_coe_Iio_atTop
-/

variable {l : Filter Œ≤} {f : Œ± ‚Üí Œ≤}

#print tendsto_comp_coe_Ioo_atTop /-
@[simp]
theorem tendsto_comp_coe_Ioo_atTop (h : a < b) :
    Tendsto (fun x : Ioo a b => f x) atTop l ‚Üî Tendsto f (ùìù[<] b) l := by
  rw [‚Üê map_coe_Ioo_atTop h, tendsto_map'_iff]
#align tendsto_comp_coe_Ioo_at_top tendsto_comp_coe_Ioo_atTop
-/

#print tendsto_comp_coe_Ioo_atBot /-
@[simp]
theorem tendsto_comp_coe_Ioo_atBot (h : a < b) :
    Tendsto (fun x : Ioo a b => f x) atBot l ‚Üî Tendsto f (ùìù[>] a) l := by
  rw [‚Üê map_coe_Ioo_atBot h, tendsto_map'_iff]
#align tendsto_comp_coe_Ioo_at_bot tendsto_comp_coe_Ioo_atBot
-/

#print tendsto_comp_coe_Ioi_atBot /-
@[simp]
theorem tendsto_comp_coe_Ioi_atBot :
    Tendsto (fun x : Ioi a => f x) atBot l ‚Üî Tendsto f (ùìù[>] a) l := by
  rw [‚Üê map_coe_Ioi_atBot, tendsto_map'_iff]
#align tendsto_comp_coe_Ioi_at_bot tendsto_comp_coe_Ioi_atBot
-/

#print tendsto_comp_coe_Iio_atTop /-
@[simp]
theorem tendsto_comp_coe_Iio_atTop :
    Tendsto (fun x : Iio a => f x) atTop l ‚Üî Tendsto f (ùìù[<] a) l := by
  rw [‚Üê map_coe_Iio_atTop, tendsto_map'_iff]
#align tendsto_comp_coe_Iio_at_top tendsto_comp_coe_Iio_atTop
-/

#print tendsto_Ioo_atTop /-
@[simp]
theorem tendsto_Ioo_atTop {f : Œ≤ ‚Üí Ioo a b} :
    Tendsto f l atTop ‚Üî Tendsto (fun x => (f x : Œ±)) l (ùìù[<] b) := by
  rw [‚Üê comap_coe_Ioo_nhdsWithin_Iio, tendsto_comap_iff]
#align tendsto_Ioo_at_top tendsto_Ioo_atTop
-/

#print tendsto_Ioo_atBot /-
@[simp]
theorem tendsto_Ioo_atBot {f : Œ≤ ‚Üí Ioo a b} :
    Tendsto f l atBot ‚Üî Tendsto (fun x => (f x : Œ±)) l (ùìù[>] a) := by
  rw [‚Üê comap_coe_Ioo_nhdsWithin_Ioi, tendsto_comap_iff]
#align tendsto_Ioo_at_bot tendsto_Ioo_atBot
-/

#print tendsto_Ioi_atBot /-
@[simp]
theorem tendsto_Ioi_atBot {f : Œ≤ ‚Üí Ioi a} :
    Tendsto f l atBot ‚Üî Tendsto (fun x => (f x : Œ±)) l (ùìù[>] a) := by
  rw [‚Üê comap_coe_Ioi_nhdsWithin_Ioi, tendsto_comap_iff]
#align tendsto_Ioi_at_bot tendsto_Ioi_atBot
-/

#print tendsto_Iio_atTop /-
@[simp]
theorem tendsto_Iio_atTop {f : Œ≤ ‚Üí Iio a} :
    Tendsto f l atTop ‚Üî Tendsto (fun x => (f x : Œ±)) l (ùìù[<] a) := by
  rw [‚Üê comap_coe_Iio_nhdsWithin_Iio, tendsto_comap_iff]
#align tendsto_Iio_at_top tendsto_Iio_atTop
-/

instance (x : Œ±) [Nontrivial Œ±] : NeBot (ùìù[‚â†] x) :=
  by
  apply forall_mem_nonempty_iff_ne_bot.1 fun s hs => _
  obtain ‚ü®u, u_open, xu, us‚ü© : ‚àÉ u : Set Œ±, IsOpen u ‚àß x ‚àà u ‚àß u ‚à© {x}·∂ú ‚äÜ s := mem_nhdsWithin.1 hs
  obtain ‚ü®a, b, a_lt_b, hab‚ü© : ‚àÉ a b : Œ±, a < b ‚àß Ioo a b ‚äÜ u := u_open.exists_Ioo_subset ‚ü®x, xu‚ü©
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, a < y ‚àß y < b := exists_between a_lt_b
  rcases ne_or_eq x y with (xy | rfl)
  ¬∑ exact ‚ü®y, us ‚ü®hab hy, xy.symm‚ü©‚ü©
  obtain ‚ü®z, hz‚ü© : ‚àÉ z, a < z ‚àß z < x := exists_between hy.1
  exact ‚ü®z, us ‚ü®hab ‚ü®hz.1, hz.2.trans hy.2‚ü©, hz.2.Ne‚ü©‚ü©

/- warning: dense.exists_countable_dense_subset_no_bot_top -> Dense.exists_countable_dense_subset_no_bot_top is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2)))))] [_inst_5 : Nontrivial.{u1} Œ±] {s : Set.{u1} Œ±} [_inst_6 : TopologicalSpace.SeparableSpace.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} Œ±) Type.{u1} (Set.hasCoeToSort.{u1} Œ±) s) (Subtype.topologicalSpace.{u1} Œ± (fun (x : Œ±) => Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s) _inst_1)], (Dense.{u1} Œ± _inst_1 s) -> (Exists.{succ u1} (Set.{u1} Œ±) (fun (t : Set.{u1} Œ±) => Exists.{0} (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) t s) (fun (H : HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) t s) => And (Set.Countable.{u1} Œ± t) (And (Dense.{u1} Œ± _inst_1 t) (And (forall (x : Œ±), (IsBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) x) -> (Not (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x t))) (forall (x : Œ±), (IsTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_2))))) x) -> (Not (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x t))))))))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : LinearOrder.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_1 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))] [_inst_4 : DenselyOrdered.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2))))))] [_inst_5 : Nontrivial.{u1} Œ±] {s : Set.{u1} Œ±} [_inst_6 : TopologicalSpace.SeparableSpace.{u1} (Set.Elem.{u1} Œ± s) (instTopologicalSpaceSubtype.{u1} Œ± (fun (x : Œ±) => Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x s) _inst_1)], (Dense.{u1} Œ± _inst_1 s) -> (Exists.{succ u1} (Set.{u1} Œ±) (fun (t : Set.{u1} Œ±) => And (HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.instHasSubsetSet.{u1} Œ±) t s) (And (Set.Countable.{u1} Œ± t) (And (Dense.{u1} Œ± _inst_1 t) (And (forall (x : Œ±), (IsBot.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) x) -> (Not (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x t))) (forall (x : Œ±), (IsTop.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (DistribLattice.toLattice.{u1} Œ± (instDistribLattice.{u1} Œ± _inst_2)))))) x) -> (Not (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) x t))))))))
Case conversion may be inaccurate. Consider using '#align dense.exists_countable_dense_subset_no_bot_top Dense.exists_countable_dense_subset_no_bot_top‚Çì'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t ¬´expr ‚äÜ ¬ª s) -/
/-- Let `s` be a dense set in a nontrivial dense linear order `Œ±`. If `s` is a
separable space (e.g., if `Œ±` has a second countable topology), then there exists a countable
dense subset `t ‚äÜ s` such that `t` does not contain bottom/top elements of `Œ±`. -/
theorem Dense.exists_countable_dense_subset_no_bot_top [Nontrivial Œ±] {s : Set Œ±} [SeparableSpace s]
    (hs : Dense s) :
    ‚àÉ (t : _)(_ : t ‚äÜ s), t.Countable ‚àß Dense t ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àâ t) ‚àß ‚àÄ x, IsTop x ‚Üí x ‚àâ t :=
  by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine' ‚ü®t \ ({ x | IsBot x } ‚à™ { x | IsTop x }), _, _, _, _, _‚ü©
  ¬∑ exact (diff_subset _ _).trans hts
  ¬∑ exact htc.mono (diff_subset _ _)
  ¬∑ exact htd.diff_finite ((subsingleton_is_bot Œ±).Finite.union (subsingleton_is_top Œ±).Finite)
  ¬∑ intro x hx
    simp [hx]
  ¬∑ intro x hx
    simp [hx]
#align dense.exists_countable_dense_subset_no_bot_top Dense.exists_countable_dense_subset_no_bot_top

variable (Œ±)

#print exists_countable_dense_no_bot_top /-
/-- If `Œ±` is a nontrivial separable dense linear order, then there exists a
countable dense set `s : set Œ±` that contains neither top nor bottom elements of `Œ±`.
For a dense set containing both bot and top elements, see
`exists_countable_dense_bot_top`. -/
theorem exists_countable_dense_no_bot_top [SeparableSpace Œ±] [Nontrivial Œ±] :
    ‚àÉ s : Set Œ±, s.Countable ‚àß Dense s ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àâ s) ‚àß ‚àÄ x, IsTop x ‚Üí x ‚àâ s := by
  simpa using dense_univ.exists_countable_dense_subset_no_bot_top
#align exists_countable_dense_no_bot_top exists_countable_dense_no_bot_top
-/

end DenselyOrdered

section CompleteLinearOrder

variable [CompleteLinearOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±] [CompleteLinearOrder Œ≤]
  [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] [Nonempty Œ≥]

/- warning: Sup_mem_closure -> sSup_mem_closure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : CompleteLinearOrder.{u1} Œ±] [_inst_10 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))) s) (closure.{u1} Œ± _inst_8 s))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : CompleteLinearOrder.{u1} Œ±] [_inst_10 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_9)))) s) (closure.{u1} Œ± _inst_8 s))
Case conversion may be inaccurate. Consider using '#align Sup_mem_closure sSup_mem_closure‚Çì'. -/
theorem sSup_mem_closure {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±] [OrderTopology Œ±]
    {s : Set Œ±} (hs : s.Nonempty) : sSup s ‚àà closure s :=
  (isLUB_sSup s).mem_closure hs
#align Sup_mem_closure sSup_mem_closure

/- warning: Inf_mem_closure -> sInf_mem_closure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : CompleteLinearOrder.{u1} Œ±] [_inst_10 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))) s) (closure.{u1} Œ± _inst_8 s))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : CompleteLinearOrder.{u1} Œ±] [_inst_10 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_9)))) s) (closure.{u1} Œ± _inst_8 s))
Case conversion may be inaccurate. Consider using '#align Inf_mem_closure sInf_mem_closure‚Çì'. -/
theorem sInf_mem_closure {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±] [OrderTopology Œ±]
    {s : Set Œ±} (hs : s.Nonempty) : sInf s ‚àà closure s :=
  (isGLB_sInf s).mem_closure hs
#align Inf_mem_closure sInf_mem_closure

/- warning: is_closed.Sup_mem -> IsClosed.sSup_mem is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : CompleteLinearOrder.{u1} Œ±] [_inst_10 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (IsClosed.{u1} Œ± _inst_8 s) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))) s) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : CompleteLinearOrder.{u1} Œ±] [_inst_10 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (IsClosed.{u1} Œ± _inst_8 s) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_9)))) s) s)
Case conversion may be inaccurate. Consider using '#align is_closed.Sup_mem IsClosed.sSup_mem‚Çì'. -/
theorem IsClosed.sSup_mem {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±]
    [OrderTopology Œ±] {s : Set Œ±} (hs : s.Nonempty) (hc : IsClosed s) : sSup s ‚àà s :=
  (isLUB_sSup s).mem_of_isClosed hs hc
#align is_closed.Sup_mem IsClosed.sSup_mem

/- warning: is_closed.Inf_mem -> IsClosed.sInf_mem is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : CompleteLinearOrder.{u1} Œ±] [_inst_10 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (IsClosed.{u1} Œ± _inst_8 s) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))) s) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_8 : TopologicalSpace.{u1} Œ±] [_inst_9 : CompleteLinearOrder.{u1} Œ±] [_inst_10 : OrderTopology.{u1} Œ± _inst_8 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_9))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (IsClosed.{u1} Œ± _inst_8 s) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_9)))) s) s)
Case conversion may be inaccurate. Consider using '#align is_closed.Inf_mem IsClosed.sInf_mem‚Çì'. -/
theorem IsClosed.sInf_mem {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±]
    [OrderTopology Œ±] {s : Set Œ±} (hs : s.Nonempty) (hc : IsClosed s) : sInf s ‚àà s :=
  (isGLB_sInf s).mem_of_isClosed hs hc
#align is_closed.Inf_mem IsClosed.sInf_mem

/- warning: monotone.map_Sup_of_continuous_at' -> Monotone.map_sSup_of_continuousAt' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Set.Nonempty.{u1} Œ± s) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Set.Nonempty.{u1} Œ± s) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align monotone.map_Sup_of_continuous_at' Monotone.map_sSup_of_continuousAt'‚Çì'. -/
/-- A monotone function continuous at the supremum of a nonempty set sends this supremum to
the supremum of the image of this set. -/
theorem Monotone.map_sSup_of_continuousAt' {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sSup s))
    (Mf : Monotone f) (hs : s.Nonempty) : f (sSup s) = sSup (f '' s) :=
  ((--This is a particular case of the more general is_lub.is_lub_of_tendsto
              isLUB_sSup
              _).isLUB_of_tendsto
          (fun x hx y hy xy => Mf xy) hs <|
        Cf.mono_left inf_le_left).sSup_eq.symm
#align monotone.map_Sup_of_continuous_at' Monotone.map_sSup_of_continuousAt'

/- warning: monotone.map_Sup_of_continuous_at -> Monotone.map_sSup_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Bot.bot.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toHasBot.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) (Bot.bot.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toHasBot.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Bot.bot.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toBot.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) (Bot.bot.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toBot.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align monotone.map_Sup_of_continuous_at Monotone.map_sSup_of_continuousAt‚Çì'. -/
/-- A monotone function `f` sending `bot` to `bot` and continuous at the supremum of a set sends
this supremum to the supremum of the image of this set. -/
theorem Monotone.map_sSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sSup s))
    (Mf : Monotone f) (fbot : f ‚ä• = ‚ä•) : f (sSup s) = sSup (f '' s) :=
  by
  cases' s.eq_empty_or_nonempty with h h
  ¬∑ simp [h, fbot]
  ¬∑ exact Mf.map_Sup_of_continuous_at' Cf h
#align monotone.map_Sup_of_continuous_at Monotone.map_sSup_of_continuousAt

/- warning: monotone.map_supr_of_continuous_at' -> Monotone.map_iSup_of_continuousAt' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {Œπ : Sort.{u3}} [_inst_8 : Nonempty.{u3} Œπ] {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ g)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ (fun (i : Œπ) => g i))) (iSup.{u2, u3} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) Œπ (fun (i : Œπ) => f (g i))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : CompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u3} Œ≤] [_inst_5 : TopologicalSpace.{u3} Œ≤] [_inst_6 : OrderClosedTopology.{u3} Œ≤ _inst_5 (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4))))] {Œπ : Sort.{u1}} [_inst_8 : Nonempty.{u1} Œπ] {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u2, u3} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u2, u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ g)) -> (Monotone.{u2, u3} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1)))) (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4)))) f) -> (Eq.{succ u3} Œ≤ (f (iSup.{u2, u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ (fun (i : Œπ) => g i))) (iSup.{u3, u1} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u3} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u3} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u3} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u3} Œ≤ _inst_4)))) Œπ (fun (i : Œπ) => f (g i))))
Case conversion may be inaccurate. Consider using '#align monotone.map_supr_of_continuous_at' Monotone.map_iSup_of_continuousAt'‚Çì'. -/
/-- A monotone function continuous at the indexed supremum over a nonempty `Sort` sends this indexed
supremum to the indexed supremum of the composition. -/
theorem Monotone.map_iSup_of_continuousAt' {Œπ : Sort _} [Nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iSup g)) (Mf : Monotone f) : f (‚®Ü i, g i) = ‚®Ü i, f (g i) := by
  rw [iSup, Mf.map_Sup_of_continuous_at' Cf (range_nonempty g), ‚Üê range_comp, iSup]
#align monotone.map_supr_of_continuous_at' Monotone.map_iSup_of_continuousAt'

/- warning: monotone.map_supr_of_continuous_at -> Monotone.map_iSup_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {Œπ : Sort.{u3}} {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ g)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Bot.bot.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toHasBot.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) (Bot.bot.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toHasBot.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ (fun (i : Œπ) => g i))) (iSup.{u2, u3} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) Œπ (fun (i : Œπ) => f (g i))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : CompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u3} Œ≤] [_inst_5 : TopologicalSpace.{u3} Œ≤] [_inst_6 : OrderClosedTopology.{u3} Œ≤ _inst_5 (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4))))] {Œπ : Sort.{u1}} {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u2, u3} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u2, u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ g)) -> (Monotone.{u2, u3} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1)))) (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4)))) f) -> (Eq.{succ u3} Œ≤ (f (Bot.bot.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toBot.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) (Bot.bot.{u3} Œ≤ (ConditionallyCompleteLinearOrderBot.toBot.{u3} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u3} Œ≤ _inst_4)))) -> (Eq.{succ u3} Œ≤ (f (iSup.{u2, u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ (fun (i : Œπ) => g i))) (iSup.{u3, u1} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u3} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u3} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u3} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u3} Œ≤ _inst_4)))) Œπ (fun (i : Œπ) => f (g i))))
Case conversion may be inaccurate. Consider using '#align monotone.map_supr_of_continuous_at Monotone.map_iSup_of_continuousAt‚Çì'. -/
/-- If a monotone function sending `bot` to `bot` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
theorem Monotone.map_iSup_of_continuousAt {Œπ : Sort _} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iSup g)) (Mf : Monotone f) (fbot : f ‚ä• = ‚ä•) :
    f (‚®Ü i, g i) = ‚®Ü i, f (g i) := by
  rw [iSup, Mf.map_Sup_of_continuous_at Cf fbot, ‚Üê range_comp, iSup]
#align monotone.map_supr_of_continuous_at Monotone.map_iSup_of_continuousAt

/- warning: monotone.map_Inf_of_continuous_at' -> Monotone.map_sInf_of_continuousAt' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Set.Nonempty.{u1} Œ± s) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Set.Nonempty.{u1} Œ± s) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align monotone.map_Inf_of_continuous_at' Monotone.map_sInf_of_continuousAt'‚Çì'. -/
/-- A monotone function continuous at the infimum of a nonempty set sends this infimum to
the infimum of the image of this set. -/
theorem Monotone.map_sInf_of_continuousAt' {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sInf s))
    (Mf : Monotone f) (hs : s.Nonempty) : f (sInf s) = sInf (f '' s) :=
  @Monotone.map_sSup_of_continuousAt' Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f s Cf Mf.dual hs
#align monotone.map_Inf_of_continuous_at' Monotone.map_sInf_of_continuousAt'

/- warning: monotone.map_Inf_of_continuous_at -> Monotone.map_sInf_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Top.top.{u1} Œ± (CompleteLattice.toHasTop.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (Top.top.{u2} Œ≤ (CompleteLattice.toHasTop.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Top.top.{u1} Œ± (CompleteLattice.toTop.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (Top.top.{u2} Œ≤ (CompleteLattice.toTop.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align monotone.map_Inf_of_continuous_at Monotone.map_sInf_of_continuousAt‚Çì'. -/
/-- A monotone function `f` sending `top` to `top` and continuous at the infimum of a set sends
this infimum to the infimum of the image of this set. -/
theorem Monotone.map_sInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sInf s))
    (Mf : Monotone f) (ftop : f ‚ä§ = ‚ä§) : f (sInf s) = sInf (f '' s) :=
  @Monotone.map_sSup_of_continuousAt Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f s Cf Mf.dual ftop
#align monotone.map_Inf_of_continuous_at Monotone.map_sInf_of_continuousAt

/- warning: monotone.map_infi_of_continuous_at' -> Monotone.map_iInf_of_continuousAt' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {Œπ : Sort.{u3}} [_inst_8 : Nonempty.{u3} Œπ] {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ g)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ (fun (i : Œπ) => g i))) (iInf.{u2, u3} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) Œπ (fun (i : Œπ) => f (g i))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : CompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u3} Œ≤] [_inst_5 : TopologicalSpace.{u3} Œ≤] [_inst_6 : OrderClosedTopology.{u3} Œ≤ _inst_5 (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4))))] {Œπ : Sort.{u1}} [_inst_8 : Nonempty.{u1} Œπ] {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u2, u3} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u2, u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ g)) -> (Monotone.{u2, u3} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1)))) (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4)))) f) -> (Eq.{succ u3} Œ≤ (f (iInf.{u2, u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ (fun (i : Œπ) => g i))) (iInf.{u3, u1} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u3} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u3} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u3} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u3} Œ≤ _inst_4)))) Œπ (fun (i : Œπ) => f (g i))))
Case conversion may be inaccurate. Consider using '#align monotone.map_infi_of_continuous_at' Monotone.map_iInf_of_continuousAt'‚Çì'. -/
/-- A monotone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed infimum of the composition. -/
theorem Monotone.map_iInf_of_continuousAt' {Œπ : Sort _} [Nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iInf g)) (Mf : Monotone f) : f (‚®Ö i, g i) = ‚®Ö i, f (g i) :=
  @Monotone.map_iSup_of_continuousAt' Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ Œπ _ f g Cf Mf.dual
#align monotone.map_infi_of_continuous_at' Monotone.map_iInf_of_continuousAt'

/- warning: monotone.map_infi_of_continuous_at -> Monotone.map_iInf_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {Œπ : Sort.{u3}} {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ g)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Top.top.{u1} Œ± (CompleteLattice.toHasTop.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (Top.top.{u2} Œ≤ (CompleteLattice.toHasTop.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ g)) (iInf.{u2, u3} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) Œπ (Function.comp.{u3, succ u1, succ u2} Œπ Œ± Œ≤ f g)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : CompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u3} Œ≤] [_inst_5 : TopologicalSpace.{u3} Œ≤] [_inst_6 : OrderClosedTopology.{u3} Œ≤ _inst_5 (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4))))] {Œπ : Sort.{u1}} {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u2, u3} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u2, u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ g)) -> (Monotone.{u2, u3} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1)))) (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4)))) f) -> (Eq.{succ u3} Œ≤ (f (Top.top.{u2} Œ± (CompleteLattice.toTop.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1)))) (Top.top.{u3} Œ≤ (CompleteLattice.toTop.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4)))) -> (Eq.{succ u3} Œ≤ (f (iInf.{u2, u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ g)) (iInf.{u3, u1} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u3} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u3} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u3} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u3} Œ≤ _inst_4)))) Œπ (Function.comp.{u1, succ u2, succ u3} Œπ Œ± Œ≤ f g)))
Case conversion may be inaccurate. Consider using '#align monotone.map_infi_of_continuous_at Monotone.map_iInf_of_continuousAt‚Çì'. -/
/-- If a monotone function sending `top` to `top` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed infimum of the composition. -/
theorem Monotone.map_iInf_of_continuousAt {Œπ : Sort _} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iInf g)) (Mf : Monotone f) (ftop : f ‚ä§ = ‚ä§) : f (iInf g) = iInf (f ‚àò g) :=
  @Monotone.map_iSup_of_continuousAt Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ Œπ f g Cf Mf.dual ftop
#align monotone.map_infi_of_continuous_at Monotone.map_iInf_of_continuousAt

/- warning: antitone.map_Sup_of_continuous_at' -> Antitone.map_sSup_of_continuousAt' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Set.Nonempty.{u1} Œ± s) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Set.Nonempty.{u1} Œ± s) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align antitone.map_Sup_of_continuous_at' Antitone.map_sSup_of_continuousAt'‚Çì'. -/
/-- An antitone function continuous at the supremum of a nonempty set sends this supremum to
the infimum of the image of this set. -/
theorem Antitone.map_sSup_of_continuousAt' {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sSup s))
    (Af : Antitone f) (hs : s.Nonempty) : f (sSup s) = sInf (f '' s) :=
  Monotone.map_sSup_of_continuousAt' (show ContinuousAt (OrderDual.toDual ‚àò f) (sSup s) from Cf) Af
    hs
#align antitone.map_Sup_of_continuous_at' Antitone.map_sSup_of_continuousAt'

/- warning: antitone.map_Sup_of_continuous_at -> Antitone.map_sSup_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Bot.bot.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toHasBot.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) (Top.top.{u2} Œ≤ (CompleteLattice.toHasTop.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Bot.bot.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toBot.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) (Top.top.{u2} Œ≤ (CompleteLattice.toTop.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align antitone.map_Sup_of_continuous_at Antitone.map_sSup_of_continuousAt‚Çì'. -/
/-- An antitone function `f` sending `bot` to `top` and continuous at the supremum of a set sends
this supremum to the infimum of the image of this set. -/
theorem Antitone.map_sSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sSup s))
    (Af : Antitone f) (fbot : f ‚ä• = ‚ä§) : f (sSup s) = sInf (f '' s) :=
  Monotone.map_sSup_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (sSup s) from Cf) Af
    fbot
#align antitone.map_Sup_of_continuous_at Antitone.map_sSup_of_continuousAt

/- warning: antitone.map_supr_of_continuous_at' -> Antitone.map_iSup_of_continuousAt' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {Œπ : Sort.{u3}} [_inst_8 : Nonempty.{u3} Œπ] {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ g)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ (fun (i : Œπ) => g i))) (iInf.{u2, u3} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) Œπ (fun (i : Œπ) => f (g i))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : CompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u3} Œ≤] [_inst_5 : TopologicalSpace.{u3} Œ≤] [_inst_6 : OrderClosedTopology.{u3} Œ≤ _inst_5 (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4))))] {Œπ : Sort.{u1}} [_inst_8 : Nonempty.{u1} Œπ] {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u2, u3} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u2, u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ g)) -> (Antitone.{u2, u3} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1)))) (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4)))) f) -> (Eq.{succ u3} Œ≤ (f (iSup.{u2, u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ (fun (i : Œπ) => g i))) (iInf.{u3, u1} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u3} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u3} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u3} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u3} Œ≤ _inst_4)))) Œπ (fun (i : Œπ) => f (g i))))
Case conversion may be inaccurate. Consider using '#align antitone.map_supr_of_continuous_at' Antitone.map_iSup_of_continuousAt'‚Çì'. -/
/-- An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this
indexed supremum to the indexed infimum of the composition. -/
theorem Antitone.map_iSup_of_continuousAt' {Œπ : Sort _} [Nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) : f (‚®Ü i, g i) = ‚®Ö i, f (g i) :=
  Monotone.map_iSup_of_continuousAt' (show ContinuousAt (OrderDual.toDual ‚àò f) (iSup g) from Cf) Af
#align antitone.map_supr_of_continuous_at' Antitone.map_iSup_of_continuousAt'

/- warning: antitone.map_supr_of_continuous_at -> Antitone.map_iSup_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {Œπ : Sort.{u3}} {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ g)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Bot.bot.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toHasBot.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) (Top.top.{u2} Œ≤ (CompleteLattice.toHasTop.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (iSup.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ (fun (i : Œπ) => g i))) (iInf.{u2, u3} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) Œπ (fun (i : Œπ) => f (g i))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : CompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u3} Œ≤] [_inst_5 : TopologicalSpace.{u3} Œ≤] [_inst_6 : OrderClosedTopology.{u3} Œ≤ _inst_5 (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4))))] {Œπ : Sort.{u1}} {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u2, u3} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u2, u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ g)) -> (Antitone.{u2, u3} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1)))) (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4)))) f) -> (Eq.{succ u3} Œ≤ (f (Bot.bot.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toBot.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) (Top.top.{u3} Œ≤ (CompleteLattice.toTop.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4)))) -> (Eq.{succ u3} Œ≤ (f (iSup.{u2, u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ (fun (i : Œπ) => g i))) (iInf.{u3, u1} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u3} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u3} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u3} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u3} Œ≤ _inst_4)))) Œπ (fun (i : Œπ) => f (g i))))
Case conversion may be inaccurate. Consider using '#align antitone.map_supr_of_continuous_at Antitone.map_iSup_of_continuousAt‚Çì'. -/
/-- An antitone function sending `bot` to `top` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
theorem Antitone.map_iSup_of_continuousAt {Œπ : Sort _} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (fbot : f ‚ä• = ‚ä§) :
    f (‚®Ü i, g i) = ‚®Ö i, f (g i) :=
  Monotone.map_iSup_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (iSup g) from Cf) Af
    fbot
#align antitone.map_supr_of_continuous_at Antitone.map_iSup_of_continuousAt

/- warning: antitone.map_Inf_of_continuous_at' -> Antitone.map_sInf_of_continuousAt' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Set.Nonempty.{u1} Œ± s) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Set.Nonempty.{u1} Œ± s) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align antitone.map_Inf_of_continuous_at' Antitone.map_sInf_of_continuousAt'‚Çì'. -/
/-- An antitone function continuous at the infimum of a nonempty set sends this infimum to
the supremum of the image of this set. -/
theorem Antitone.map_sInf_of_continuousAt' {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sInf s))
    (Af : Antitone f) (hs : s.Nonempty) : f (sInf s) = sSup (f '' s) :=
  Monotone.map_sInf_of_continuousAt' (show ContinuousAt (OrderDual.toDual ‚àò f) (sInf s) from Cf) Af
    hs
#align antitone.map_Inf_of_continuous_at' Antitone.map_sInf_of_continuousAt'

/- warning: antitone.map_Inf_of_continuous_at -> Antitone.map_sInf_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Top.top.{u1} Œ± (CompleteLattice.toHasTop.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (Bot.bot.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toHasBot.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Top.top.{u1} Œ± (CompleteLattice.toTop.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (Bot.bot.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toBot.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u1} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u1} Œ± _inst_1)))) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align antitone.map_Inf_of_continuous_at Antitone.map_sInf_of_continuousAt‚Çì'. -/
/-- An antitone function `f` sending `top` to `bot` and continuous at the infimum of a set sends
this infimum to the supremum of the image of this set. -/
theorem Antitone.map_sInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sInf s))
    (Af : Antitone f) (ftop : f ‚ä§ = ‚ä•) : f (sInf s) = sSup (f '' s) :=
  Monotone.map_sInf_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (sInf s) from Cf) Af
    ftop
#align antitone.map_Inf_of_continuous_at Antitone.map_sInf_of_continuousAt

/- warning: antitone.map_infi_of_continuous_at' -> Antitone.map_iInf_of_continuousAt' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {Œπ : Sort.{u3}} [_inst_8 : Nonempty.{u3} Œπ] {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ g)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ (fun (i : Œπ) => g i))) (iSup.{u2, u3} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) Œπ (fun (i : Œπ) => f (g i))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : CompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u3} Œ≤] [_inst_5 : TopologicalSpace.{u3} Œ≤] [_inst_6 : OrderClosedTopology.{u3} Œ≤ _inst_5 (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4))))] {Œπ : Sort.{u1}} [_inst_8 : Nonempty.{u1} Œπ] {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u2, u3} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u2, u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ g)) -> (Antitone.{u2, u3} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1)))) (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4)))) f) -> (Eq.{succ u3} Œ≤ (f (iInf.{u2, u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ (fun (i : Œπ) => g i))) (iSup.{u3, u1} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u3} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u3} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u3} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u3} Œ≤ _inst_4)))) Œπ (fun (i : Œπ) => f (g i))))
Case conversion may be inaccurate. Consider using '#align antitone.map_infi_of_continuous_at' Antitone.map_iInf_of_continuousAt'‚Çì'. -/
/-- An antitone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed supremum of the composition. -/
theorem Antitone.map_iInf_of_continuousAt' {Œπ : Sort _} [Nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iInf g)) (Af : Antitone f) : f (‚®Ö i, g i) = ‚®Ü i, f (g i) :=
  Monotone.map_iInf_of_continuousAt' (show ContinuousAt (OrderDual.toDual ‚àò f) (iInf g) from Cf) Af
#align antitone.map_infi_of_continuous_at' Antitone.map_iInf_of_continuousAt'

/- warning: antitone.map_infi_of_continuous_at -> Antitone.map_iInf_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : CompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))))] {Œπ : Sort.{u3}} {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ g)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (CompleteSemilatticeInf.toPartialOrder.{u1} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u2} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4)))) f) -> (Eq.{succ u2} Œ≤ (f (Top.top.{u1} Œ± (CompleteLattice.toHasTop.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1)))) (Bot.bot.{u2} Œ≤ (ConditionallyCompleteLinearOrderBot.toHasBot.{u2} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ≤ _inst_4)))) -> (Eq.{succ u2} Œ≤ (f (iInf.{u1, u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (CompleteLattice.toConditionallyCompleteLattice.{u1} Œ± (CompleteLinearOrder.toCompleteLattice.{u1} Œ± _inst_1))) Œπ g)) (iSup.{u2, u3} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (CompleteLattice.toConditionallyCompleteLattice.{u2} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u2} Œ≤ _inst_4))) Œπ (Function.comp.{u3, succ u1, succ u2} Œπ Œ± Œ≤ f g)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u3}} [_inst_1 : CompleteLinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ±] [_inst_3 : OrderTopology.{u2} Œ± _inst_2 (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1))))] [_inst_4 : CompleteLinearOrder.{u3} Œ≤] [_inst_5 : TopologicalSpace.{u3} Œ≤] [_inst_6 : OrderClosedTopology.{u3} Œ≤ _inst_5 (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4))))] {Œπ : Sort.{u1}} {f : Œ± -> Œ≤} {g : Œπ -> Œ±}, (ContinuousAt.{u2, u3} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u2, u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ g)) -> (Antitone.{u2, u3} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (CompleteSemilatticeInf.toPartialOrder.{u2} Œ± (CompleteLattice.toCompleteSemilatticeInf.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1)))) (PartialOrder.toPreorder.{u3} Œ≤ (CompleteSemilatticeInf.toPartialOrder.{u3} Œ≤ (CompleteLattice.toCompleteSemilatticeInf.{u3} Œ≤ (CompleteLinearOrder.toCompleteLattice.{u3} Œ≤ _inst_4)))) f) -> (Eq.{succ u3} Œ≤ (f (Top.top.{u2} Œ± (CompleteLattice.toTop.{u2} Œ± (CompleteLinearOrder.toCompleteLattice.{u2} Œ± _inst_1)))) (Bot.bot.{u3} Œ≤ (ConditionallyCompleteLinearOrderBot.toBot.{u3} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u3} Œ≤ _inst_4)))) -> (Eq.{succ u3} Œ≤ (f (iInf.{u2, u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u2} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ± (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u2} Œ± (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u2} Œ± _inst_1)))) Œπ g)) (iSup.{u3, u1} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u3} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u3} Œ≤ (ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder.{u3} Œ≤ (CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.{u3} Œ≤ _inst_4)))) Œπ (Function.comp.{u1, succ u2, succ u3} Œπ Œ± Œ≤ f g)))
Case conversion may be inaccurate. Consider using '#align antitone.map_infi_of_continuous_at Antitone.map_iInf_of_continuousAt‚Çì'. -/
/-- If an antitone function sending `top` to `bot` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed supremum of the composition. -/
theorem Antitone.map_iInf_of_continuousAt {Œπ : Sort _} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
    (Cf : ContinuousAt f (iInf g)) (Af : Antitone f) (ftop : f ‚ä§ = ‚ä•) : f (iInf g) = iSup (f ‚àò g) :=
  Monotone.map_iInf_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (iInf g) from Cf) Af
    ftop
#align antitone.map_infi_of_continuous_at Antitone.map_iInf_of_continuousAt

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±]
  [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] [Nonempty Œ≥]

/- warning: cSup_mem_closure -> csSup_mem_closure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (closure.{u1} Œ± _inst_2 s))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (closure.{u1} Œ± _inst_2 s))
Case conversion may be inaccurate. Consider using '#align cSup_mem_closure csSup_mem_closure‚Çì'. -/
theorem csSup_mem_closure {s : Set Œ±} (hs : s.Nonempty) (B : BddAbove s) : sSup s ‚àà closure s :=
  (isLUB_csSup hs B).mem_closure hs
#align cSup_mem_closure csSup_mem_closure

/- warning: cInf_mem_closure -> csInf_mem_closure is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (closure.{u1} Œ± _inst_2 s))
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (Set.Nonempty.{u1} Œ± s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) (closure.{u1} Œ± _inst_2 s))
Case conversion may be inaccurate. Consider using '#align cInf_mem_closure csInf_mem_closure‚Çì'. -/
theorem csInf_mem_closure {s : Set Œ±} (hs : s.Nonempty) (B : BddBelow s) : sInf s ‚àà closure s :=
  (isGLB_csInf hs B).mem_closure hs
#align cInf_mem_closure csInf_mem_closure

/- warning: is_closed.cSup_mem -> IsClosed.csSup_mem is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsClosed.{u1} Œ± _inst_2 s) -> (Set.Nonempty.{u1} Œ± s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsClosed.{u1} Œ± _inst_2 s) -> (Set.Nonempty.{u1} Œ± s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) s)
Case conversion may be inaccurate. Consider using '#align is_closed.cSup_mem IsClosed.csSup_mem‚Çì'. -/
theorem IsClosed.csSup_mem {s : Set Œ±} (hc : IsClosed s) (hs : s.Nonempty) (B : BddAbove s) :
    sSup s ‚àà s :=
  (isLUB_csSup hs B).mem_of_isClosed hs hc
#align is_closed.cSup_mem IsClosed.csSup_mem

/- warning: is_closed.cInf_mem -> IsClosed.csInf_mem is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsClosed.{u1} Œ± _inst_2 s) -> (Set.Nonempty.{u1} Œ± s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) s)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] {s : Set.{u1} Œ±}, (IsClosed.{u1} Œ± _inst_2 s) -> (Set.Nonempty.{u1} Œ± s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Membership.mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.instMembershipSet.{u1} Œ±) (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s) s)
Case conversion may be inaccurate. Consider using '#align is_closed.cInf_mem IsClosed.csInf_mem‚Çì'. -/
theorem IsClosed.csInf_mem {s : Set Œ±} (hc : IsClosed s) (hs : s.Nonempty) (B : BddBelow s) :
    sInf s ‚àà s :=
  (isGLB_csInf hs B).mem_of_isClosed hs hc
#align is_closed.cInf_mem IsClosed.csInf_mem

/- warning: monotone.map_cSup_of_continuous_at -> Monotone.map_csSup_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (Set.Nonempty.{u1} Œ± s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (Set.Nonempty.{u1} Œ± s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align monotone.map_cSup_of_continuous_at Monotone.map_csSup_of_continuousAt‚Çì'. -/
/-- If a monotone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the supremum of the image of `s`. -/
theorem Monotone.map_csSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sSup s))
    (Mf : Monotone f) (ne : s.Nonempty) (H : BddAbove s) : f (sSup s) = sSup (f '' s) :=
  by
  refine' ((isLUB_csSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm
  refine' (isLUB_csSup Ne H).isLUB_of_tendsto (fun x hx y hy xy => Mf xy) Ne _
  exact Cf.mono_left inf_le_left
#align monotone.map_cSup_of_continuous_at Monotone.map_csSup_of_continuousAt

/- warning: monotone.map_csupr_of_continuous_at -> Monotone.map_ciSup_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] [_inst_7 : Nonempty.{succ u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≥ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (Set.range.{u1, succ u3} Œ± Œ≥ g)) -> (Eq.{succ u2} Œ≤ (f (iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) (iSup.{u2, succ u3} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) Œ≥ (fun (i : Œ≥) => f (g i))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] [_inst_7 : Nonempty.{succ u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≥ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (Set.range.{u1, succ u3} Œ± Œ≥ g)) -> (Eq.{succ u2} Œ≤ (f (iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) (iSup.{u2, succ u3} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) Œ≥ (fun (i : Œ≥) => f (g i))))
Case conversion may be inaccurate. Consider using '#align monotone.map_csupr_of_continuous_at Monotone.map_ciSup_of_continuousAt‚Çì'. -/
/-- If a monotone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the supremum of the composition. -/
theorem Monotone.map_ciSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : ContinuousAt f (‚®Ü i, g i))
    (Mf : Monotone f) (H : BddAbove (range g)) : f (‚®Ü i, g i) = ‚®Ü i, f (g i) := by
  rw [iSup, Mf.map_cSup_of_continuous_at Cf (range_nonempty _) H, ‚Üê range_comp, iSup]
#align monotone.map_csupr_of_continuous_at Monotone.map_ciSup_of_continuousAt

/- warning: monotone.map_cInf_of_continuous_at -> Monotone.map_csInf_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (Set.Nonempty.{u1} Œ± s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (Set.Nonempty.{u1} Œ± s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align monotone.map_cInf_of_continuous_at Monotone.map_csInf_of_continuousAt‚Çì'. -/
/-- If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the infimum of the image of `s`. -/
theorem Monotone.map_csInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sInf s))
    (Mf : Monotone f) (ne : s.Nonempty) (H : BddBelow s) : f (sInf s) = sInf (f '' s) :=
  @Monotone.map_csSup_of_continuousAt Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f s Cf Mf.dual Ne H
#align monotone.map_cInf_of_continuous_at Monotone.map_csInf_of_continuousAt

/- warning: monotone.map_cinfi_of_continuous_at -> Monotone.map_ciInf_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] [_inst_7 : Nonempty.{succ u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≥ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (Set.range.{u1, succ u3} Œ± Œ≥ g)) -> (Eq.{succ u2} Œ≤ (f (iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) (iInf.{u2, succ u3} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) Œ≥ (fun (i : Œ≥) => f (g i))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] [_inst_7 : Nonempty.{succ u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≥ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (Set.range.{u1, succ u3} Œ± Œ≥ g)) -> (Eq.{succ u2} Œ≤ (f (iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) (iInf.{u2, succ u3} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) Œ≥ (fun (i : Œ≥) => f (g i))))
Case conversion may be inaccurate. Consider using '#align monotone.map_cinfi_of_continuous_at Monotone.map_ciInf_of_continuousAt‚Çì'. -/
/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally
complete linear order, under a boundedness assumption. -/
theorem Monotone.map_ciInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : ContinuousAt f (‚®Ö i, g i))
    (Mf : Monotone f) (H : BddBelow (range g)) : f (‚®Ö i, g i) = ‚®Ö i, f (g i) :=
  @Monotone.map_ciSup_of_continuousAt Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ _ _ _ _ Cf Mf.dual H
#align monotone.map_cinfi_of_continuous_at Monotone.map_ciInf_of_continuousAt

/- warning: antitone.map_cSup_of_continuous_at -> Antitone.map_csSup_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (Set.Nonempty.{u1} Œ± s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (Set.Nonempty.{u1} Œ± s) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Eq.{succ u2} Œ≤ (f (SupSet.sSup.{u1} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align antitone.map_cSup_of_continuous_at Antitone.map_csSup_of_continuousAt‚Çì'. -/
/-- If an antitone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the infimum of the image of `s`. -/
theorem Antitone.map_csSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sSup s))
    (Af : Antitone f) (ne : s.Nonempty) (H : BddAbove s) : f (sSup s) = sInf (f '' s) :=
  Monotone.map_csSup_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (sSup s) from Cf) Af
    Ne H
#align antitone.map_cSup_of_continuous_at Antitone.map_csSup_of_continuousAt

/- warning: antitone.map_csupr_of_continuous_at -> Antitone.map_ciSup_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] [_inst_7 : Nonempty.{succ u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≥ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (Set.range.{u1, succ u3} Œ± Œ≥ g)) -> (Eq.{succ u2} Œ≤ (f (iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasSup.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) (iInf.{u2, succ u3} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) Œ≥ (fun (i : Œ≥) => f (g i))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] [_inst_7 : Nonempty.{succ u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≥ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (BddAbove.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (Set.range.{u1, succ u3} Œ± Œ≥ g)) -> (Eq.{succ u2} Œ≤ (f (iSup.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toSupSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) (iInf.{u2, succ u3} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) Œ≥ (fun (i : Œ≥) => f (g i))))
Case conversion may be inaccurate. Consider using '#align antitone.map_csupr_of_continuous_at Antitone.map_ciSup_of_continuousAt‚Çì'. -/
/-- If an antitone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the infimum of the composition. -/
theorem Antitone.map_ciSup_of_continuousAt {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : ContinuousAt f (‚®Ü i, g i))
    (Af : Antitone f) (H : BddAbove (range g)) : f (‚®Ü i, g i) = ‚®Ö i, f (g i) :=
  Monotone.map_ciSup_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (‚®Ü i, g i) from Cf)
    Af H
#align antitone.map_csupr_of_continuous_at Antitone.map_ciSup_of_continuousAt

/- warning: antitone.map_cInf_of_continuous_at -> Antitone.map_csInf_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (Set.Nonempty.{u1} Œ± s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] {f : Œ± -> Œ≤} {s : Set.{u1} Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (Set.Nonempty.{u1} Œ± s) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) s) -> (Eq.{succ u2} Œ≤ (f (InfSet.sInf.{u1} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) s)) (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) (Set.image.{u1, u2} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align antitone.map_cInf_of_continuous_at Antitone.map_csInf_of_continuousAt‚Çì'. -/
/-- If an antitone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the supremum of the image of `s`. -/
theorem Antitone.map_csInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sInf s))
    (Af : Antitone f) (ne : s.Nonempty) (H : BddBelow s) : f (sInf s) = sSup (f '' s) :=
  Monotone.map_csInf_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (sInf s) from Cf) Af
    Ne H
#align antitone.map_cInf_of_continuous_at Antitone.map_csInf_of_continuousAt

/- warning: antitone.map_cinfi_of_continuous_at -> Antitone.map_ciInf_of_continuousAt is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] [_inst_7 : Nonempty.{succ u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≥ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (Set.range.{u1, succ u3} Œ± Œ≥ g)) -> (Eq.{succ u2} Œ≤ (f (iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toHasInf.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) (iSup.{u2, succ u3} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) Œ≥ (fun (i : Œ≥) => f (g i))))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : ConditionallyCompleteLinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ±] [_inst_3 : OrderTopology.{u1} Œ± _inst_2 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)))))] [_inst_4 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_5 : TopologicalSpace.{u2} Œ≤] [_inst_6 : OrderClosedTopology.{u2} Œ≤ _inst_5 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)))))] [_inst_7 : Nonempty.{succ u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≥ -> Œ±}, (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_2 _inst_5 f (iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4))))) f) -> (BddBelow.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (ConditionallyCompleteLattice.toLattice.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1))))) (Set.range.{u1, succ u3} Œ± Œ≥ g)) -> (Eq.{succ u2} Œ≤ (f (iInf.{u1, succ u3} Œ± (ConditionallyCompleteLattice.toInfSet.{u1} Œ± (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ± _inst_1)) Œ≥ (fun (i : Œ≥) => g i))) (iSup.{u2, succ u3} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_4)) Œ≥ (fun (i : Œ≥) => f (g i))))
Case conversion may be inaccurate. Consider using '#align antitone.map_cinfi_of_continuous_at Antitone.map_ciInf_of_continuousAt‚Çì'. -/
/-- A continuous antitone function sends indexed infimum to indexed supremum in conditionally
complete linear order, under a boundedness assumption. -/
theorem Antitone.map_ciInf_of_continuousAt {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : ContinuousAt f (‚®Ö i, g i))
    (Af : Antitone f) (H : BddBelow (range g)) : f (‚®Ö i, g i) = ‚®Ü i, f (g i) :=
  Monotone.map_ciInf_of_continuousAt (show ContinuousAt (OrderDual.toDual ‚àò f) (‚®Ö i, g i) from Cf)
    Af H
#align antitone.map_cinfi_of_continuous_at Antitone.map_ciInf_of_continuousAt

/- warning: monotone.tendsto_nhds_within_Iio -> Monotone.tendsto_nhdsWithin_Iio is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_8 : LinearOrder.{u1} Œ±] [_inst_9 : TopologicalSpace.{u1} Œ±] [_inst_10 : OrderTopology.{u1} Œ± _inst_9 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_8))))] [_inst_11 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_12 : TopologicalSpace.{u2} Œ≤] [_inst_13 : OrderTopology.{u2} Œ≤ _inst_12 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_11)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_8)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_11))))) f) -> (forall (x : Œ±), Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± _inst_9 x (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_8)))) x)) (nhds.{u2} Œ≤ _inst_12 (SupSet.sSup.{u2} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_11)) (Set.image.{u1, u2} Œ± Œ≤ f (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_8)))) x)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_8 : LinearOrder.{u2} Œ±] [_inst_9 : TopologicalSpace.{u2} Œ±] [_inst_10 : OrderTopology.{u2} Œ± _inst_9 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_8)))))] [_inst_11 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_12 : TopologicalSpace.{u1} Œ≤] [_inst_13 : OrderTopology.{u1} Œ≤ _inst_12 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_11)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_8))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_11))))) f) -> (forall (x : Œ±), Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± _inst_9 x (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_8))))) x)) (nhds.{u1} Œ≤ _inst_12 (SupSet.sSup.{u1} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_11)) (Set.image.{u2, u1} Œ± Œ≤ f (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_8))))) x)))))
Case conversion may be inaccurate. Consider using '#align monotone.tendsto_nhds_within_Iio Monotone.tendsto_nhdsWithin_Iio‚Çì'. -/
/-- A monotone map has a limit to the left of any point `x`, equal to `Sup (f '' (Iio x))`. -/
theorem Monotone.tendsto_nhdsWithin_Iio {Œ± Œ≤ : Type _} [LinearOrder Œ±] [TopologicalSpace Œ±]
    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderTopology Œ≤]
    {f : Œ± ‚Üí Œ≤} (Mf : Monotone f) (x : Œ±) : Tendsto f (ùìù[<] x) (ùìù (sSup (f '' Iio x))) :=
  by
  rcases eq_empty_or_nonempty (Iio x) with (h | h); ¬∑ simp [h]
  refine' tendsto_order.2 ‚ü®fun l hl => _, fun m hm => _‚ü©
  ¬∑ obtain ‚ü®z, zx, lz‚ü© : ‚àÉ a : Œ±, a < x ‚àß l < f a := by
      simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using
        exists_lt_of_lt_csSup (nonempty_image_iff.2 h) hl
    exact
      (mem_nhdsWithin_Iio_iff_exists_Ioo_subset' zx).2 ‚ü®z, zx, fun y hy => lz.trans_le (Mf hy.1.le)‚ü©
  ¬∑ filter_upwards [self_mem_nhdsWithin]with _ hy
    apply lt_of_le_of_lt _ hm
    exact le_csSup (Mf.map_bdd_above bddAbove_Iio) (mem_image_of_mem _ hy)
#align monotone.tendsto_nhds_within_Iio Monotone.tendsto_nhdsWithin_Iio

/- warning: monotone.tendsto_nhds_within_Ioi -> Monotone.tendsto_nhdsWithin_Ioi is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_8 : LinearOrder.{u1} Œ±] [_inst_9 : TopologicalSpace.{u1} Œ±] [_inst_10 : OrderTopology.{u1} Œ± _inst_9 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_8))))] [_inst_11 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_12 : TopologicalSpace.{u2} Œ≤] [_inst_13 : OrderTopology.{u2} Œ≤ _inst_12 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_11)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_8)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_11))))) f) -> (forall (x : Œ±), Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± _inst_9 x (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_8)))) x)) (nhds.{u2} Œ≤ _inst_12 (InfSet.sInf.{u2} Œ≤ (ConditionallyCompleteLattice.toHasInf.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_11)) (Set.image.{u1, u2} Œ± Œ≤ f (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_8)))) x)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_8 : LinearOrder.{u2} Œ±] [_inst_9 : TopologicalSpace.{u2} Œ±] [_inst_10 : OrderTopology.{u2} Œ± _inst_9 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_8)))))] [_inst_11 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_12 : TopologicalSpace.{u1} Œ≤] [_inst_13 : OrderTopology.{u1} Œ≤ _inst_12 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_11)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_8))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_11))))) f) -> (forall (x : Œ±), Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± _inst_9 x (Set.Ioi.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_8))))) x)) (nhds.{u1} Œ≤ _inst_12 (InfSet.sInf.{u1} Œ≤ (ConditionallyCompleteLattice.toInfSet.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_11)) (Set.image.{u2, u1} Œ± Œ≤ f (Set.Ioi.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_8))))) x)))))
Case conversion may be inaccurate. Consider using '#align monotone.tendsto_nhds_within_Ioi Monotone.tendsto_nhdsWithin_Ioi‚Çì'. -/
/-- A monotone map has a limit to the right of any point `x`, equal to `Inf (f '' (Ioi x))`. -/
theorem Monotone.tendsto_nhdsWithin_Ioi {Œ± Œ≤ : Type _} [LinearOrder Œ±] [TopologicalSpace Œ±]
    [OrderTopology Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤] [OrderTopology Œ≤]
    {f : Œ± ‚Üí Œ≤} (Mf : Monotone f) (x : Œ±) : Tendsto f (ùìù[>] x) (ùìù (sInf (f '' Ioi x))) :=
  @Monotone.tendsto_nhdsWithin_Iio Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f Mf.dual x
#align monotone.tendsto_nhds_within_Ioi Monotone.tendsto_nhdsWithin_Ioi

end ConditionallyCompleteLinearOrder

section NhdsWithPos

section LinearOrderedAddCommGroup

variable [LinearOrder Œ±] [Zero Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±]

#print eventually_nhdsWithin_pos_mem_Ioo /-
theorem eventually_nhdsWithin_pos_mem_Ioo {Œµ : Œ±} (h : 0 < Œµ) : ‚àÄ·∂† x in ùìù[>] 0, x ‚àà Ioo 0 Œµ :=
  Ioo_mem_nhdsWithin_Ioi (left_mem_Ico.2 h)
#align eventually_nhds_within_pos_mem_Ioo eventually_nhdsWithin_pos_mem_Ioo
-/

#print eventually_nhdsWithin_pos_mem_Ioc /-
theorem eventually_nhdsWithin_pos_mem_Ioc {Œµ : Œ±} (h : 0 < Œµ) : ‚àÄ·∂† x in ùìù[>] 0, x ‚àà Ioc 0 Œµ :=
  Ioc_mem_nhdsWithin_Ioi (left_mem_Ico.2 h)
#align eventually_nhds_within_pos_mem_Ioc eventually_nhdsWithin_pos_mem_Ioc
-/

end LinearOrderedAddCommGroup

end NhdsWithPos

end OrderTopology

