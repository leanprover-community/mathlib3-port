/-
Copyright (c) 2021 Shing Tak Lam. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shing Tak Lam

! This file was ported from Lean 3 source module topology.homotopy.path
! leanprover-community/mathlib commit dbdf71cee7bb20367cb7e37279c08b0c218cf967
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Homotopy.Basic
import Mathbin.Topology.PathConnected
import Mathbin.Analysis.Convex.Basic

/-!
# Homotopy between paths

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file, we define a `homotopy` between two `path`s. In addition, we define a relation
`homotopic` on `path`s, and prove that it is an equivalence relation.

## Definitions

* `path.homotopy p₀ p₁` is the type of homotopies between paths `p₀` and `p₁`
* `path.homotopy.refl p` is the constant homotopy between `p` and itself
* `path.homotopy.symm F` is the `path.homotopy p₁ p₀` defined by reversing the homotopy
* `path.homotopy.trans F G`, where `F : path.homotopy p₀ p₁`, `G : path.homotopy p₁ p₂` is the
  `path.homotopy p₀ p₂` defined by putting the first homotopy on `[0, 1/2]` and the second on
  `[1/2, 1]`
* `path.homotopy.hcomp F G`, where `F : path.homotopy p₀ q₀` and `G : path.homotopy p₁ q₁` is
  a `path.homotopy (p₀.trans p₁) (q₀.trans q₁)`
* `path.homotopic p₀ p₁` is the relation saying that there is a homotopy between `p₀` and `p₁`
* `path.homotopic.setoid x₀ x₁` is the setoid on `path`s from `path.homotopic`
* `path.homotopic.quotient x₀ x₁` is the quotient type from `path x₀ x₀` by `path.homotopic.setoid`

-/


universe u v

variable {X : Type u} {Y : Type v} [TopologicalSpace X] [TopologicalSpace Y]

variable {x₀ x₁ x₂ x₃ : X}

noncomputable section

open unitInterval

namespace Path

#print Path.Homotopy /-
/-- The type of homotopies between two paths.
-/
abbrev Homotopy (p₀ p₁ : Path x₀ x₁) :=
  ContinuousMap.HomotopyRel p₀.toContinuousMap p₁.toContinuousMap {0, 1}
#align path.homotopy Path.Homotopy
-/

namespace Homotopy

section

variable {p₀ p₁ : Path x₀ x₁}

instance : CoeFun (Homotopy p₀ p₁) fun _ => I × I → X :=
  ⟨fun F => F.toFun⟩

/- warning: path.homotopy.coe_fn_injective -> Path.Homotopy.coeFn_injective is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₀ x₁}, Function.Injective.{succ u1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) ((Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)) -> X) (coeFn.{succ u1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (fun (ᾰ : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) => (Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)) -> X) (Path.Homotopy.hasCoeToFun.{u1} X _inst_1 x₀ x₁ p₀ p₁))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₀ x₁}, Function.Injective.{succ u1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) ((Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) -> X) (FunLike.coe.{succ u1, 1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) (fun (ᾰ : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) ᾰ) (ContinuousMapClass.toFunLike.{u1, 0, u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) X (instTopologicalSpaceProd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) _inst_1 (ContinuousMap.HomotopyLike.toContinuousMapClass.{0, u1, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) (ContinuousMap.HomotopyWith.instHomotopyLikeHomotopyWith.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) (fun (f : ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) => forall (x : Set.Elem.{0} Real unitInterval), (Membership.mem.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instMembershipSet.{0} (Set.Elem.{0} Real unitInterval)) x (Insert.insert.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instInsertSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 0 (Zero.toOfNat0.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasZero)) (Singleton.singleton.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instSingletonSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 1 (One.toOfNat1.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasOne))))) -> (And (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) x)) (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) x))))))))
Case conversion may be inaccurate. Consider using '#align path.homotopy.coe_fn_injective Path.Homotopy.coeFn_injectiveₓ'. -/
theorem coeFn_injective : @Function.Injective (Homotopy p₀ p₁) (I × I → X) coeFn :=
  ContinuousMap.HomotopyWith.coeFn_injective
#align path.homotopy.coe_fn_injective Path.Homotopy.coeFn_injective

/- warning: path.homotopy.source -> Path.Homotopy.source is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₀ x₁} (F : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (t : coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval), Eq.{succ u1} X (coeFn.{succ u1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (fun (_x : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) => (Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)) -> X) (Path.Homotopy.hasCoeToFun.{u1} X _inst_1 x₀ x₁ p₀ p₁) F (Prod.mk.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) t (OfNat.ofNat.{0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) 0 (OfNat.mk.{0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) 0 (Zero.zero.{0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) unitInterval.hasZero))))) x₀
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₀ x₁} (F : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (t : Set.Elem.{0} Real unitInterval), Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) (Prod.mk.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) t (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 0 (Zero.toOfNat0.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasZero)))) (FunLike.coe.{succ u1, 1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) (fun (_x : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) _x) (ContinuousMapClass.toFunLike.{u1, 0, u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) X (instTopologicalSpaceProd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) _inst_1 (ContinuousMap.HomotopyLike.toContinuousMapClass.{0, u1, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) (ContinuousMap.HomotopyWith.instHomotopyLikeHomotopyWith.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) (fun (f : ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) => forall (x : Set.Elem.{0} Real unitInterval), (Membership.mem.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instMembershipSet.{0} (Set.Elem.{0} Real unitInterval)) x (Insert.insert.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instInsertSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 0 (Zero.toOfNat0.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasZero)) (Singleton.singleton.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instSingletonSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 1 (One.toOfNat1.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasOne))))) -> (And (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) x)) (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) x))))))) F (Prod.mk.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) t (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 0 (Zero.toOfNat0.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasZero)))) x₀
Case conversion may be inaccurate. Consider using '#align path.homotopy.source Path.Homotopy.sourceₓ'. -/
@[simp]
theorem source (F : Homotopy p₀ p₁) (t : I) : F (t, 0) = x₀ :=
  by
  simp_rw [← p₀.source]
  apply ContinuousMap.HomotopyRel.eq_fst
  simp
#align path.homotopy.source Path.Homotopy.source

/- warning: path.homotopy.target -> Path.Homotopy.target is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₀ x₁} (F : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (t : coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval), Eq.{succ u1} X (coeFn.{succ u1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (fun (_x : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) => (Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)) -> X) (Path.Homotopy.hasCoeToFun.{u1} X _inst_1 x₀ x₁ p₀ p₁) F (Prod.mk.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) t (OfNat.ofNat.{0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) 1 (OfNat.mk.{0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) 1 (One.one.{0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) unitInterval.hasOne))))) x₁
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₀ x₁} (F : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (t : Set.Elem.{0} Real unitInterval), Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) (Prod.mk.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) t (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 1 (One.toOfNat1.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasOne)))) (FunLike.coe.{succ u1, 1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) (fun (_x : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) _x) (ContinuousMapClass.toFunLike.{u1, 0, u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) X (instTopologicalSpaceProd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) _inst_1 (ContinuousMap.HomotopyLike.toContinuousMapClass.{0, u1, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) (ContinuousMap.HomotopyWith.instHomotopyLikeHomotopyWith.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) (fun (f : ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) => forall (x : Set.Elem.{0} Real unitInterval), (Membership.mem.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instMembershipSet.{0} (Set.Elem.{0} Real unitInterval)) x (Insert.insert.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instInsertSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 0 (Zero.toOfNat0.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasZero)) (Singleton.singleton.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instSingletonSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 1 (One.toOfNat1.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasOne))))) -> (And (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) x)) (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) x))))))) F (Prod.mk.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) t (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 1 (One.toOfNat1.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasOne)))) x₁
Case conversion may be inaccurate. Consider using '#align path.homotopy.target Path.Homotopy.targetₓ'. -/
@[simp]
theorem target (F : Homotopy p₀ p₁) (t : I) : F (t, 1) = x₁ :=
  by
  simp_rw [← p₁.target]
  apply ContinuousMap.HomotopyRel.eq_snd
  simp
#align path.homotopy.target Path.Homotopy.target

#print Path.Homotopy.eval /-
/-- Evaluating a path homotopy at an intermediate point, giving us a `path`.
-/
def eval (F : Homotopy p₀ p₁) (t : I) : Path x₀ x₁
    where
  toFun := F.toHomotopy.curry t
  source' := by simp
  target' := by simp
#align path.homotopy.eval Path.Homotopy.eval
-/

#print Path.Homotopy.eval_zero /-
@[simp]
theorem eval_zero (F : Homotopy p₀ p₁) : F.eval 0 = p₀ :=
  by
  ext t
  simp [eval]
#align path.homotopy.eval_zero Path.Homotopy.eval_zero
-/

#print Path.Homotopy.eval_one /-
@[simp]
theorem eval_one (F : Homotopy p₀ p₁) : F.eval 1 = p₁ :=
  by
  ext t
  simp [eval]
#align path.homotopy.eval_one Path.Homotopy.eval_one
-/

end

section

variable {p₀ p₁ p₂ : Path x₀ x₁}

#print Path.Homotopy.refl /-
/-- Given a path `p`, we can define a `homotopy p p` by `F (t, x) = p x`
-/
@[simps]
def refl (p : Path x₀ x₁) : Homotopy p p :=
  ContinuousMap.HomotopyRel.refl p.toContinuousMap {0, 1}
#align path.homotopy.refl Path.Homotopy.refl
-/

#print Path.Homotopy.symm /-
/-- Given a `homotopy p₀ p₁`, we can define a `homotopy p₁ p₀` by reversing the homotopy.
-/
@[simps]
def symm (F : Homotopy p₀ p₁) : Homotopy p₁ p₀ :=
  ContinuousMap.HomotopyRel.symm F
#align path.homotopy.symm Path.Homotopy.symm
-/

#print Path.Homotopy.symm_symm /-
@[simp]
theorem symm_symm (F : Homotopy p₀ p₁) : F.symm.symm = F :=
  ContinuousMap.HomotopyRel.symm_symm F
#align path.homotopy.symm_symm Path.Homotopy.symm_symm
-/

#print Path.Homotopy.trans /-
/--
Given `homotopy p₀ p₁` and `homotopy p₁ p₂`, we can define a `homotopy p₀ p₂` by putting the first
homotopy on `[0, 1/2]` and the second on `[1/2, 1]`.
-/
def trans (F : Homotopy p₀ p₁) (G : Homotopy p₁ p₂) : Homotopy p₀ p₂ :=
  ContinuousMap.HomotopyRel.trans F G
#align path.homotopy.trans Path.Homotopy.trans
-/

/- warning: path.homotopy.trans_apply -> Path.Homotopy.trans_apply is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₀ x₁} {p₂ : Path.{u1} X _inst_1 x₀ x₁} (F : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (G : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₁ p₂) (x : Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)), Eq.{succ u1} X (coeFn.{succ u1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₂) (fun (_x : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₂) => (Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)) -> X) (Path.Homotopy.hasCoeToFun.{u1} X _inst_1 x₀ x₁ p₀ p₂) (Path.Homotopy.trans.{u1} X _inst_1 x₀ x₁ p₀ p₁ p₂ F G) x) (dite.{succ u1} X (LE.le.{0} Real Real.hasLe ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) (Real.decidableLE ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) (fun (h : LE.le.{0} Real Real.hasLe ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) => coeFn.{succ u1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (fun (_x : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) => (Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)) -> X) (Path.Homotopy.hasCoeToFun.{u1} X _inst_1 x₀ x₁ p₀ p₁) F (Prod.mk.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (Subtype.mk.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (Iff.mpr (Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real (AddZeroClass.toHasAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real (AddMonoidWithOne.toAddMonoid.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))) (One.one.{0} Real (AddMonoidWithOne.toOne.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) unitInterval) (Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (Set.Icc.{0} Real Real.preorder (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real (AddZeroClass.toHasAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real (AddMonoidWithOne.toAddMonoid.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))) (One.one.{0} Real (AddMonoidWithOne.toOne.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring))))))))))) (unitInterval.mul_pos_mem_iff (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real (AddZeroClass.toHasAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real (AddMonoidWithOne.toAddMonoid.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))) (One.one.{0} Real (AddMonoidWithOne.toOne.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (zero_lt_two.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring))) Real.partialOrder (OrderedSemiring.zeroLEOneClass.{0} Real Real.orderedSemiring) (NeZero.one.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring))) Real.nontrivial) (OrderedAddCommGroup.to_covariantClass_left_le.{0} Real Real.orderedAddCommGroup))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real (AddZeroClass.toHasAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real (AddMonoidWithOne.toAddMonoid.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))) (One.one.{0} Real (AddMonoidWithOne.toOne.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))))))) (And.left (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (Subtype.val.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (Subtype.val.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (Subtype.property.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) h))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (fun (h : Not (LE.le.{0} Real Real.hasLe ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))))) => coeFn.{succ u1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₁ p₂) (fun (_x : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₁ p₂) => (Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)) -> X) (Path.Homotopy.hasCoeToFun.{u1} X _inst_1 x₀ x₁ p₁ p₂) G (Prod.mk.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (Subtype.mk.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (Iff.mpr (Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) unitInterval) (Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (Set.Icc.{0} Real Real.preorder (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (unitInterval.two_mul_sub_one_mem_iff ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (LT.lt.le.{0} Real Real.preorder (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (Iff.mp (Not (LE.le.{0} Real (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (LinearOrder.toPartialOrder.{0} Real Real.linearOrder))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))))) (LT.lt.{0} Real (Preorder.toLT.{0} Real (PartialOrder.toPreorder.{0} Real (LinearOrder.toPartialOrder.{0} Real Real.linearOrder))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (not_le.{0} Real Real.linearOrder ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) h)) (And.right (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (Subtype.val.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (Subtype.val.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (Subtype.property.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₀ x₁} {p₂ : Path.{u1} X _inst_1 x₀ x₁} (F : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (G : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₁ p₂) (x : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)), Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₂) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) (fun (_x : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) _x) (ContinuousMapClass.toFunLike.{u1, 0, u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₂) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) X (instTopologicalSpaceProd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) _inst_1 (ContinuousMap.HomotopyLike.toContinuousMapClass.{0, u1, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₂) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₂) (ContinuousMap.HomotopyWith.instHomotopyLikeHomotopyWith.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₂) (fun (f : ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) => forall (x : Set.Elem.{0} Real unitInterval), (Membership.mem.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instMembershipSet.{0} (Set.Elem.{0} Real unitInterval)) x (Insert.insert.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instInsertSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 0 (Zero.toOfNat0.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasZero)) (Singleton.singleton.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instSingletonSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 1 (One.toOfNat1.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasOne))))) -> (And (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) x)) (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₂) x))))))) (Path.Homotopy.trans.{u1} X _inst_1 x₀ x₁ p₀ p₁ p₂ F G) x) (dite.{succ u1} X (LE.le.{0} Real Real.instLEReal (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (Real.decidableLE (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (fun (h : LE.le.{0} Real Real.instLEReal (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) => FunLike.coe.{succ u1, 1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) (fun (_x : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) _x) (ContinuousMapClass.toFunLike.{u1, 0, u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) X (instTopologicalSpaceProd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) _inst_1 (ContinuousMap.HomotopyLike.toContinuousMapClass.{0, u1, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ p₁) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) (ContinuousMap.HomotopyWith.instHomotopyLikeHomotopyWith.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) (fun (f : ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) => forall (x : Set.Elem.{0} Real unitInterval), (Membership.mem.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instMembershipSet.{0} (Set.Elem.{0} Real unitInterval)) x (Insert.insert.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instInsertSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 0 (Zero.toOfNat0.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasZero)) (Singleton.singleton.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instSingletonSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 1 (One.toOfNat1.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasOne))))) -> (And (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₀) x)) (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) x))))))) F (Prod.mk.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) (Subtype.mk.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (Iff.mpr (Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) unitInterval) (Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (Set.Icc.{0} Real Real.instPreorderReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))))) (unitInterval.mul_pos_mem_iff (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (zero_lt_two.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) Real.partialOrder (OrderedSemiring.zeroLEOneClass.{0} Real Real.orderedSemiring) (NeZero.one.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (Semiring.toNonAssocSemiring.{0} Real Real.semiring)) Real.nontrivial) (OrderedAddCommGroup.to_covariantClass_left_le.{0} Real Real.orderedAddCommGroup))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (And.left (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (Subtype.property.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) h))) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (fun (h : Not (LE.le.{0} Real Real.instLEReal (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))))) => FunLike.coe.{succ u1, 1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₁ p₂) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) (fun (_x : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) _x) (ContinuousMapClass.toFunLike.{u1, 0, u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₁ p₂) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) X (instTopologicalSpaceProd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) _inst_1 (ContinuousMap.HomotopyLike.toContinuousMapClass.{0, u1, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₁ p₂) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₂) (ContinuousMap.HomotopyWith.instHomotopyLikeHomotopyWith.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₂) (fun (f : ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) => forall (x : Set.Elem.{0} Real unitInterval), (Membership.mem.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instMembershipSet.{0} (Set.Elem.{0} Real unitInterval)) x (Insert.insert.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instInsertSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 0 (Zero.toOfNat0.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasZero)) (Singleton.singleton.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instSingletonSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 1 (One.toOfNat1.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasOne))))) -> (And (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₁) x)) (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₁ p₂) x))))))) G (Prod.mk.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) (Subtype.mk.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (Iff.mpr (Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) unitInterval) (Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (Set.Icc.{0} Real Real.instPreorderReal (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (unitInterval.two_mul_sub_one_mem_iff (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (LT.lt.le.{0} Real Real.instPreorderReal (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (Iff.mp (Not (LE.le.{0} Real (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (LinearOrder.toPartialOrder.{0} Real Real.linearOrder))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))))) (LT.lt.{0} Real (Preorder.toLT.{0} Real (PartialOrder.toPreorder.{0} Real (LinearOrder.toPartialOrder.{0} Real Real.linearOrder))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (not_le.{0} Real Real.linearOrder (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) h)) (And.right (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (Subtype.property.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)))))) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))))
Case conversion may be inaccurate. Consider using '#align path.homotopy.trans_apply Path.Homotopy.trans_applyₓ'. -/
theorem trans_apply (F : Homotopy p₀ p₁) (G : Homotopy p₁ p₂) (x : I × I) :
    (F.trans G) x =
      if h : (x.1 : ℝ) ≤ 1 / 2 then
        F (⟨2 * x.1, (unitInterval.mul_pos_mem_iff zero_lt_two).2 ⟨x.1.2.1, h⟩⟩, x.2)
      else
        G (⟨2 * x.1 - 1, unitInterval.two_mul_sub_one_mem_iff.2 ⟨(not_le.1 h).le, x.1.2.2⟩⟩, x.2) :=
  ContinuousMap.HomotopyRel.trans_apply _ _ _
#align path.homotopy.trans_apply Path.Homotopy.trans_apply

#print Path.Homotopy.symm_trans /-
theorem symm_trans (F : Homotopy p₀ p₁) (G : Homotopy p₁ p₂) :
    (F.trans G).symm = G.symm.trans F.symm :=
  ContinuousMap.HomotopyRel.symm_trans _ _
#align path.homotopy.symm_trans Path.Homotopy.symm_trans
-/

#print Path.Homotopy.cast /-
/-- Casting a `homotopy p₀ p₁` to a `homotopy q₀ q₁` where `p₀ = q₀` and `p₁ = q₁`.
-/
@[simps]
def cast {p₀ p₁ q₀ q₁ : Path x₀ x₁} (F : Homotopy p₀ p₁) (h₀ : p₀ = q₀) (h₁ : p₁ = q₁) :
    Homotopy q₀ q₁ :=
  ContinuousMap.HomotopyRel.cast F (congr_arg _ h₀) (congr_arg _ h₁)
#align path.homotopy.cast Path.Homotopy.cast
-/

end

section

variable {p₀ q₀ : Path x₀ x₁} {p₁ q₁ : Path x₁ x₂}

#print Path.Homotopy.hcomp /-
/-- Suppose `p₀` and `q₀` are paths from `x₀` to `x₁`, `p₁` and `q₁` are paths from `x₁` to `x₂`.
Furthermore, suppose `F : homotopy p₀ q₀` and `G : homotopy p₁ q₁`. Then we can define a homotopy
from `p₀.trans p₁` to `q₀.trans q₁`.
-/
def hcomp (F : Homotopy p₀ q₀) (G : Homotopy p₁ q₁) : Homotopy (p₀.trans p₁) (q₀.trans q₁)
    where
  toFun x :=
    if (x.2 : ℝ) ≤ 1 / 2 then (F.eval x.1).extend (2 * x.2) else (G.eval x.1).extend (2 * x.2 - 1)
  continuous_toFun :=
    by
    refine'
      continuous_if_le (continuous_induced_dom.comp continuous_snd) continuous_const
        (F.to_homotopy.continuous.comp (by continuity)).ContinuousOn
        (G.to_homotopy.continuous.comp (by continuity)).ContinuousOn _
    intro x hx
    norm_num [hx]
  map_zero_left' x := by norm_num [Path.trans]
  map_one_left' x := by norm_num [Path.trans]
  prop' := by
    rintro x t ht
    cases ht
    · rw [ht]
      simp
    · rw [Set.mem_singleton_iff] at ht
      rw [ht]
      norm_num
#align path.homotopy.hcomp Path.Homotopy.hcomp
-/

/- warning: path.homotopy.hcomp_apply -> Path.Homotopy.hcomp_apply is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {x₂ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {q₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₁ x₂} {q₁ : Path.{u1} X _inst_1 x₁ x₂} (F : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ q₀) (G : Path.Homotopy.{u1} X _inst_1 x₁ x₂ p₁ q₁) (x : Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)), Eq.{succ u1} X (coeFn.{succ u1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (fun (_x : Path.Homotopy.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) => (Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)) -> X) (Path.Homotopy.hasCoeToFun.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (Path.Homotopy.hcomp.{u1} X _inst_1 x₀ x₁ x₂ p₀ q₀ p₁ q₁ F G) x) (dite.{succ u1} X (LE.le.{0} Real Real.hasLe ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) (Real.decidableLE ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) (fun (h : LE.le.{0} Real Real.hasLe ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) => coeFn.{succ u1, succ u1} (Path.{u1} X _inst_1 x₀ x₁) (fun (_x : Path.{u1} X _inst_1 x₀ x₁) => (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) -> X) (Path.hasCoeToFun.{u1} X _inst_1 x₀ x₁) (Path.Homotopy.eval.{u1} X _inst_1 x₀ x₁ p₀ q₀ F (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (Subtype.mk.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (Iff.mpr (Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real (AddZeroClass.toHasAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real (AddMonoidWithOne.toAddMonoid.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))) (One.one.{0} Real (AddMonoidWithOne.toOne.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) unitInterval) (Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (Set.Icc.{0} Real Real.preorder (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real (AddZeroClass.toHasAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real (AddMonoidWithOne.toAddMonoid.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))) (One.one.{0} Real (AddMonoidWithOne.toOne.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring))))))))))) (unitInterval.mul_pos_mem_iff (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real (AddZeroClass.toHasAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real (AddMonoidWithOne.toAddMonoid.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))) (One.one.{0} Real (AddMonoidWithOne.toOne.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (zero_lt_two.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring))) Real.partialOrder (OrderedSemiring.zeroLEOneClass.{0} Real Real.orderedSemiring) (NeZero.one.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring))) Real.nontrivial) (OrderedAddCommGroup.to_covariantClass_left_le.{0} Real Real.orderedAddCommGroup))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real (AddZeroClass.toHasAdd.{0} Real (AddMonoid.toAddZeroClass.{0} Real (AddMonoidWithOne.toAddMonoid.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))) (One.one.{0} Real (AddMonoidWithOne.toOne.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (AddCommGroupWithOne.toAddGroupWithOne.{0} Real (Ring.toAddCommGroupWithOne.{0} Real Real.ring)))))))))) (And.left (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (Subtype.val.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (Subtype.val.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (Subtype.property.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) h)))) (fun (h : Not (LE.le.{0} Real Real.hasLe ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))))) => coeFn.{succ u1, succ u1} (Path.{u1} X _inst_1 x₁ x₂) (fun (_x : Path.{u1} X _inst_1 x₁ x₂) => (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) -> X) (Path.hasCoeToFun.{u1} X _inst_1 x₁ x₂) (Path.Homotopy.eval.{u1} X _inst_1 x₁ x₂ p₁ q₁ G (Prod.fst.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (Subtype.mk.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (Iff.mpr (Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) unitInterval) (Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (Set.Icc.{0} Real Real.preorder (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (unitInterval.two_mul_sub_one_mem_iff ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (LT.lt.le.{0} Real Real.preorder (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (Iff.mp (Not (LE.le.{0} Real (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (LinearOrder.toPartialOrder.{0} Real Real.linearOrder))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))))) (LT.lt.{0} Real (Preorder.toLT.{0} Real (PartialOrder.toPreorder.{0} Real (LinearOrder.toPartialOrder.{0} Real Real.linearOrder))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (not_le.{0} Real Real.linearOrder ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (HasLiftT.mk.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (CoeTCₓ.coe.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeBase.{1, 1} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) Real (coeSubtype.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval))))) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) h)) (And.right (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (Subtype.val.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (Subtype.val.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (Subtype.property.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (Prod.snd.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) x))))))))
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {x₂ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {q₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₁ x₂} {q₁ : Path.{u1} X _inst_1 x₁ x₂} (F : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ q₀) (G : Path.Homotopy.{u1} X _inst_1 x₁ x₂ p₁ q₁) (x : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)), Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) (fun (_x : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) _x) (ContinuousMapClass.toFunLike.{u1, 0, u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) X (instTopologicalSpaceProd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) _inst_1 (ContinuousMap.HomotopyLike.toContinuousMapClass.{0, u1, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.Homotopy.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (ContinuousMap.HomotopyWith.instHomotopyLikeHomotopyWith.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (fun (f : ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) => forall (x : Set.Elem.{0} Real unitInterval), (Membership.mem.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instMembershipSet.{0} (Set.Elem.{0} Real unitInterval)) x (Insert.insert.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instInsertSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 0 (Zero.toOfNat0.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasZero)) (Singleton.singleton.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instSingletonSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 1 (One.toOfNat1.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasOne))))) -> (And (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁)) x)) (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) x))))))) (Path.Homotopy.hcomp.{u1} X _inst_1 x₀ x₁ x₂ p₀ q₀ p₁ q₁ F G) x) (dite.{succ u1} X (LE.le.{0} Real Real.instLEReal (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (Real.decidableLE (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (fun (h : LE.le.{0} Real Real.instLEReal (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) => FunLike.coe.{succ u1, 1, succ u1} (Path.{u1} X _inst_1 x₀ x₁) (Set.Elem.{0} Real unitInterval) (fun (_x : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) _x) (ContinuousMapClass.toFunLike.{u1, 0, u1} (Path.{u1} X _inst_1 x₀ x₁) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.continuousMapClass.{u1} X _inst_1 x₀ x₁)) (Path.Homotopy.eval.{u1} X _inst_1 x₀ x₁ p₀ q₀ F (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (Subtype.mk.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (Iff.mpr (Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) unitInterval) (Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (Set.Icc.{0} Real Real.instPreorderReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))))) (unitInterval.mul_pos_mem_iff (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (zero_lt_two.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) Real.partialOrder (OrderedSemiring.zeroLEOneClass.{0} Real Real.orderedSemiring) (NeZero.one.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (Semiring.toNonAssocSemiring.{0} Real Real.semiring)) Real.nontrivial) (OrderedAddCommGroup.to_covariantClass_left_le.{0} Real Real.orderedAddCommGroup))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (And.left (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (Subtype.property.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) h)))) (fun (h : Not (LE.le.{0} Real Real.instLEReal (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))))) => FunLike.coe.{succ u1, 1, succ u1} (Path.{u1} X _inst_1 x₁ x₂) (Set.Elem.{0} Real unitInterval) (fun (_x : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) _x) (ContinuousMapClass.toFunLike.{u1, 0, u1} (Path.{u1} X _inst_1 x₁ x₂) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.continuousMapClass.{u1} X _inst_1 x₁ x₂)) (Path.Homotopy.eval.{u1} X _inst_1 x₁ x₂ p₁ q₁ G (Prod.fst.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (Subtype.mk.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (Iff.mpr (Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.instSubReal) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) unitInterval) (Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (Set.Icc.{0} Real Real.instPreorderReal (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)))) (unitInterval.two_mul_sub_one_mem_iff (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (LT.lt.le.{0} Real Real.instPreorderReal (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (Iff.mp (Not (LE.le.{0} Real (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (LinearOrder.toPartialOrder.{0} Real Real.linearOrder))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))))) (LT.lt.{0} Real (Preorder.toLT.{0} Real (PartialOrder.toPreorder.{0} Real (LinearOrder.toPartialOrder.{0} Real Real.linearOrder))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (not_le.{0} Real Real.linearOrder (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) h)) (And.right (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (Subtype.val.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (Subtype.property.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (Prod.snd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) x))))))))
Case conversion may be inaccurate. Consider using '#align path.homotopy.hcomp_apply Path.Homotopy.hcomp_applyₓ'. -/
theorem hcomp_apply (F : Homotopy p₀ q₀) (G : Homotopy p₁ q₁) (x : I × I) :
    F.hcomp G x =
      if h : (x.2 : ℝ) ≤ 1 / 2 then
        F.eval x.1 ⟨2 * x.2, (unitInterval.mul_pos_mem_iff zero_lt_two).2 ⟨x.2.2.1, h⟩⟩
      else
        G.eval x.1
          ⟨2 * x.2 - 1, unitInterval.two_mul_sub_one_mem_iff.2 ⟨(not_le.1 h).le, x.2.2.2⟩⟩ :=
  show ite _ _ _ = _ by split_ifs <;> exact Path.extend_extends _ _
#align path.homotopy.hcomp_apply Path.Homotopy.hcomp_apply

/- warning: path.homotopy.hcomp_half -> Path.Homotopy.hcomp_half is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {x₂ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {q₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₁ x₂} {q₁ : Path.{u1} X _inst_1 x₁ x₂} (F : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ q₀) (G : Path.Homotopy.{u1} X _inst_1 x₁ x₂ p₁ q₁) (t : coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval), Eq.{succ u1} X (coeFn.{succ u1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (fun (_x : Path.Homotopy.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) => (Prod.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval)) -> X) (Path.Homotopy.hasCoeToFun.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (Path.Homotopy.hcomp.{u1} X _inst_1 x₀ x₁ x₂ p₀ q₀ p₁ q₁ F G) (Prod.mk.{0, 0} (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) (coeSort.{1, 2} (Set.{0} Real) Type (Set.hasCoeToSort.{0} Real) unitInterval) t (Subtype.mk.{1} Real (fun (x : Real) => Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) x unitInterval) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (Eq.mpr.{0} (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) True (id_tag Unit.unit (Eq.{1} Prop (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) True) (eq_true (LE.le.{0} Real (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedCancelAddCommMonoid.toPartialOrder.{0} Real Real.orderedCancelAddCommMonoid))) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real (AddZeroClass.toHasZero.{0} Real (AddMonoid.toAddZeroClass.{0} Real (AddRightCancelMonoid.toAddMonoid.{0} Real (AddCancelMonoid.toAddRightCancelMonoid.{0} Real (AddCancelCommMonoid.toAddCancelMonoid.{0} Real (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{0} Real Real.orderedCancelAddCommMonoid))))))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))))) (NormNum.nonneg_pos.{0} Real Real.orderedCancelAddCommMonoid (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (div_pos.{0} Real (LinearOrderedField.toLinearOrderedSemifield.{0} Real Real.linearOrderedField) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (NormNum.zero_lt_one.{0} Real Real.linearOrderedSemiring) (bit0_pos.{0} Real Real.orderedAddCommMonoid (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (NormNum.zero_lt_one.{0} Real Real.linearOrderedSemiring)))))) trivial) (Eq.mpr.{0} (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) True (id_tag Unit.unit (Eq.{1} Prop (LE.le.{0} Real (Preorder.toLE.{0} Real Real.preorder) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) True) (eq_true (LE.le.{0} Real (Preorder.toLE.{0} Real (PartialOrder.toPreorder.{0} Real (OrderedCancelAddCommMonoid.toPartialOrder.{0} Real (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Real (LinearOrderedSemiring.toStrictOrderedSemiring.{0} Real Real.linearOrderedSemiring))))) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) (NormNum.clear_denom_le.{0} Real Real.linearOrderedSemiring (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (DivInvMonoid.toHasDiv.{0} Real (DivisionRing.toDivInvMonoid.{0} Real Real.divisionRing))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (bit0_pos.{0} Real Real.orderedAddCommMonoid (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (NormNum.zero_lt_one.{0} Real Real.linearOrderedSemiring)) (NormNum.clear_denom_div.{0} Real Real.divisionRing (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (NormNum.ne_zero_of_pos.{0} Real Real.orderedAddCommGroup (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (bit0_pos.{0} Real Real.orderedAddCommMonoid (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (NormNum.zero_lt_one.{0} Real Real.linearOrderedSemiring))) (mul_one.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (one_mul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))) (one_mul.{0} Real (MulZeroOneClass.toMulOneClass.{0} Real (NonAssocSemiring.toMulZeroOneClass.{0} Real (NonAssocRing.toNonAssocSemiring.{0} Real (Ring.toNonAssocRing.{0} Real Real.ring)))) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne))))) (NormNum.le_one_bit0.{0} Real Real.linearOrderedSemiring (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (le_refl.{0} Real Real.preorder (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))))))) trivial))))) x₁
but is expected to have type
  forall {X : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} X] {x₀ : X} {x₁ : X} {x₂ : X} {p₀ : Path.{u1} X _inst_1 x₀ x₁} {q₀ : Path.{u1} X _inst_1 x₀ x₁} {p₁ : Path.{u1} X _inst_1 x₁ x₂} {q₁ : Path.{u1} X _inst_1 x₁ x₂} (F : Path.Homotopy.{u1} X _inst_1 x₀ x₁ p₀ q₀) (G : Path.Homotopy.{u1} X _inst_1 x₁ x₂ p₁ q₁) (t : Set.Elem.{0} Real unitInterval), Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) (Prod.mk.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) t (Subtype.mk.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (of_eq_true (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (eq_true (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (Mathlib.Meta.NormNum.isRat_le_true.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Int.ofNat 0) (Int.ofNat 1) 1 2 (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real (Field.toDivisionRing.{0} Real (LinearOrderedField.toField.{0} Real Real.instLinearOrderedFieldReal))) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) 0 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) 0 (Nat.cast_zero.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))))) (Mathlib.Meta.NormNum.isRat_div.{0} Real Real.instDivisionRingReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Int.ofNat 1) 2 (Mathlib.Meta.NormNum.isRat_mul.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Inv.inv.{0} Real (DivisionRing.toInv.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Int.ofNat 1) (Int.ofNat 1) (Int.ofNat 1) 1 2 2 1 (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Nat.cast_one.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))))) (Mathlib.Meta.NormNum.isRat_inv_pos.{0} Real Real.instDivisionRingReal (StrictOrderedSemiring.to_charZero.{0} Real Real.strictOrderedSemiring) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 1 1 (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 2 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 2 (Eq.refl.{1} Real (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat 0))))))) (Eq.refl.{1} Int (Int.mul (Int.ofNat 1) (Int.ofNat 1))) (Eq.refl.{1} Nat 2))) (Eq.refl.{1} Bool Bool.true)))) (of_eq_true (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (eq_true (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (Mathlib.Meta.NormNum.isRat_le_true.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.instLinearOrderedFieldReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Int.ofNat 1) (Int.ofNat 1) 2 1 (Mathlib.Meta.NormNum.isRat_div.{0} Real Real.instDivisionRingReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Int.ofNat 1) 2 (Mathlib.Meta.NormNum.isRat_mul.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Inv.inv.{0} Real (DivisionRing.toInv.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Int.ofNat 1) (Int.ofNat 1) (Int.ofNat 1) 1 2 2 1 (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Nat.cast_one.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))))) (Mathlib.Meta.NormNum.isRat_inv_pos.{0} Real Real.instDivisionRingReal (StrictOrderedSemiring.to_charZero.{0} Real Real.strictOrderedSemiring) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 1 1 (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 2 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 2 (Eq.refl.{1} Real (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat 0))))))) (Eq.refl.{1} Int (Int.mul (Int.ofNat 1) (Int.ofNat 1))) (Eq.refl.{1} Nat 2))) (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real (Field.toDivisionRing.{0} Real (LinearOrderedField.toField.{0} Real Real.instLinearOrderedFieldReal))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Nat.cast_one.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))))) (Eq.refl.{1} Bool Bool.true)))))))) (FunLike.coe.{succ u1, 1, succ u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) (fun (_x : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) => X) _x) (ContinuousMapClass.toFunLike.{u1, 0, u1} (Path.Homotopy.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (Prod.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval)) X (instTopologicalSpaceProd.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) _inst_1 (ContinuousMap.HomotopyLike.toContinuousMapClass.{0, u1, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.Homotopy.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁) (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (ContinuousMap.HomotopyWith.instHomotopyLikeHomotopyWith.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) (fun (f : ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) => forall (x : Set.Elem.{0} Real unitInterval), (Membership.mem.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instMembershipSet.{0} (Set.Elem.{0} Real unitInterval)) x (Insert.insert.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instInsertSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 0 (Zero.toOfNat0.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasZero)) (Singleton.singleton.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.{0} (Set.Elem.{0} Real unitInterval)) (Set.instSingletonSet.{0} (Set.Elem.{0} Real unitInterval)) (OfNat.ofNat.{0} (Set.Elem.{0} Real unitInterval) 1 (One.toOfNat1.{0} (Set.Elem.{0} Real unitInterval) unitInterval.hasOne))))) -> (And (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ p₀ p₁)) x)) (Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) f x) (FunLike.coe.{succ u1, 1, succ u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) (fun (a : Set.Elem.{0} Real unitInterval) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{0} Real unitInterval) => X) a) (ContinuousMapClass.toFunLike.{u1, 0, u1} (ContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1) (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1 (ContinuousMap.instContinuousMapClassContinuousMap.{0, u1} (Set.Elem.{0} Real unitInterval) X (instTopologicalSpaceSubtype.{0} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) _inst_1)) (Path.toContinuousMap.{u1} X _inst_1 x₀ x₂ (Path.trans.{u1} X _inst_1 x₀ x₁ x₂ q₀ q₁)) x))))))) (Path.Homotopy.hcomp.{u1} X _inst_1 x₀ x₁ x₂ p₀ q₀ p₁ q₁ F G) (Prod.mk.{0, 0} (Set.Elem.{0} Real unitInterval) (Set.Elem.{0} Real unitInterval) t (Subtype.mk.{1} Real (fun (x : Real) => Membership.mem.{0, 0} Real (Set.{0} Real) (Set.instMembershipSet.{0} Real) x unitInterval) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (And.intro (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (of_eq_true (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (eq_true (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))) (Mathlib.Meta.NormNum.isRat_le_true.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Int.ofNat 0) (Int.ofNat 1) 1 2 (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real (Field.toDivisionRing.{0} Real (LinearOrderedField.toField.{0} Real Real.instLinearOrderedFieldReal))) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) 0 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) 0 (Nat.cast_zero.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))))) (Mathlib.Meta.NormNum.isRat_div.{0} Real Real.instDivisionRingReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Int.ofNat 1) 2 (Mathlib.Meta.NormNum.isRat_mul.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Inv.inv.{0} Real (DivisionRing.toInv.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Int.ofNat 1) (Int.ofNat 1) (Int.ofNat 1) 1 2 2 1 (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Nat.cast_one.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))))) (Mathlib.Meta.NormNum.isRat_inv_pos.{0} Real Real.instDivisionRingReal (StrictOrderedSemiring.to_charZero.{0} Real Real.strictOrderedSemiring) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 1 1 (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 2 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 2 (Eq.refl.{1} Real (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat 0))))))) (Eq.refl.{1} Int (Int.mul (Int.ofNat 1) (Int.ofNat 1))) (Eq.refl.{1} Nat 2))) (Eq.refl.{1} Bool Bool.true)))) (of_eq_true (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (eq_true (LE.le.{0} Real (Preorder.toLE.{0} Real Real.instPreorderReal) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) (Mathlib.Meta.NormNum.isRat_le_true.{0} Real (LinearOrderedCommRing.toLinearOrderedRing.{0} Real (LinearOrderedField.toLinearOrderedCommRing.{0} Real Real.instLinearOrderedFieldReal)) (HDiv.hDiv.{0, 0, 0} Real Real Real (instHDiv.{0} Real (LinearOrderedField.toDiv.{0} Real Real.instLinearOrderedFieldReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Int.ofNat 1) (Int.ofNat 1) 2 1 (Mathlib.Meta.NormNum.isRat_div.{0} Real Real.instDivisionRingReal (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Int.ofNat 1) 2 (Mathlib.Meta.NormNum.isRat_mul.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (Inv.inv.{0} Real (DivisionRing.toInv.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Int.ofNat 1) (Int.ofNat 1) (Int.ofNat 1) 1 2 2 1 (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Nat.cast_one.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))))) (Mathlib.Meta.NormNum.isRat_inv_pos.{0} Real Real.instDivisionRingReal (StrictOrderedSemiring.to_charZero.{0} Real Real.strictOrderedSemiring) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 1 1 (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real Real.instDivisionRingReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 2 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) 2 (Eq.refl.{1} Real (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 (AddMonoidWithOne.toNatCast.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat 0))))))) (Eq.refl.{1} Int (Int.mul (Int.ofNat 1) (Int.ofNat 1))) (Eq.refl.{1} Nat 2))) (Mathlib.Meta.NormNum.IsNat.to_isRat.{0} Real (DivisionRing.toRing.{0} Real (Field.toDivisionRing.{0} Real (LinearOrderedField.toField.{0} Real Real.instLinearOrderedFieldReal))) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Mathlib.Meta.NormNum.isNat_ofNat.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) 1 (Nat.cast_one.{0} Real (AddGroupWithOne.toAddMonoidWithOne.{0} Real (Ring.toAddGroupWithOne.{0} Real Real.instRingReal))))) (Eq.refl.{1} Bool Bool.true)))))))) x₁
Case conversion may be inaccurate. Consider using '#align path.homotopy.hcomp_half Path.Homotopy.hcomp_halfₓ'. -/
theorem hcomp_half (F : Homotopy p₀ q₀) (G : Homotopy p₁ q₁) (t : I) :
    F.hcomp G (t, ⟨1 / 2, by norm_num, by norm_num⟩) = x₁ :=
  show ite _ _ _ = _ by norm_num
#align path.homotopy.hcomp_half Path.Homotopy.hcomp_half

end

#print Path.Homotopy.reparam /-
/--
Suppose `p` is a path, then we have a homotopy from `p` to `p.reparam f` by the convexity of `I`.
-/
def reparam (p : Path x₀ x₁) (f : I → I) (hf : Continuous f) (hf₀ : f 0 = 0) (hf₁ : f 1 = 1) :
    Homotopy p (p.reparam f hf hf₀ hf₁)
    where
  toFun x :=
    p
      ⟨σ x.1 * x.2 + x.1 * f x.2,
        show (σ x.1 : ℝ) • (x.2 : ℝ) + (x.1 : ℝ) • (f x.2 : ℝ) ∈ I from
          convex_Icc _ _ x.2.2 (f x.2).2 (by unit_interval) (by unit_interval) (by simp)⟩
  map_zero_left' x := by norm_num
  map_one_left' x := by norm_num
  prop' t x hx := by
    cases hx
    · rw [hx]
      norm_num [hf₀]
    · rw [Set.mem_singleton_iff] at hx
      rw [hx]
      norm_num [hf₁]
#align path.homotopy.reparam Path.Homotopy.reparam
-/

#print Path.Homotopy.symm₂ /-
/-- Suppose `F : homotopy p q`. Then we have a `homotopy p.symm q.symm` by reversing the second
argument.
-/
@[simps]
def symm₂ {p q : Path x₀ x₁} (F : p.Homotopy q) : p.symm.Homotopy q.symm
    where
  toFun x := F ⟨x.1, σ x.2⟩
  map_zero_left' := by simp [Path.symm]
  map_one_left' := by simp [Path.symm]
  prop' t x hx := by
    cases hx
    · rw [hx]
      simp
    · rw [Set.mem_singleton_iff] at hx
      rw [hx]
      simp
#align path.homotopy.symm₂ Path.Homotopy.symm₂
-/

/- warning: path.homotopy.map -> Path.Homotopy.map is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {x₀ : X} {x₁ : X} {p : Path.{u1} X _inst_1 x₀ x₁} {q : Path.{u1} X _inst_1 x₀ x₁}, (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p q) -> (forall (f : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2), Path.Homotopy.{u2} Y _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₀) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₁) (Path.map.{u1, u2} X _inst_1 x₀ x₁ p Y _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f) (ContinuousMap.continuous.{u1, u2} X Y _inst_1 _inst_2 f)) (Path.map.{u1, u2} X _inst_1 x₀ x₁ q Y _inst_2 (fun {x₀ : X} => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₀) (ContinuousMap.continuous.{u1, u2} X Y _inst_1 _inst_2 f)))
but is expected to have type
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {x₀ : X} {x₁ : X} {p : Path.{u1} X _inst_1 x₀ x₁} {q : Path.{u1} X _inst_1 x₀ x₁}, (Path.Homotopy.{u1} X _inst_1 x₀ x₁ p q) -> (forall (f : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2), Path.Homotopy.{u2} Y _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₀) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₁) (Path.map.{u1, u2} X _inst_1 x₀ x₁ p Y _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f) (ContinuousMap.continuous.{u2, u1} X Y _inst_1 _inst_2 f)) (Path.map.{u1, u2} X _inst_1 x₀ x₁ q Y _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (a : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) a) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f) (ContinuousMap.continuous.{u2, u1} X Y _inst_1 _inst_2 f)))
Case conversion may be inaccurate. Consider using '#align path.homotopy.map Path.Homotopy.mapₓ'. -/
/--
Given `F : homotopy p q`, and `f : C(X, Y)`, we can define a homotopy from `p.map f.continuous` to
`q.map f.continuous`.
-/
@[simps]
def map {p q : Path x₀ x₁} (F : p.Homotopy q) (f : C(X, Y)) :
    Homotopy (p.map f.Continuous) (q.map f.Continuous)
    where
  toFun := f ∘ F
  map_zero_left' := by simp
  map_one_left' := by simp
  prop' t x hx := by
    cases hx
    · simp [hx]
    · rw [Set.mem_singleton_iff] at hx
      simp [hx]
#align path.homotopy.map Path.Homotopy.map

end Homotopy

#print Path.Homotopic /-
/-- Two paths `p₀` and `p₁` are `path.homotopic` if there exists a `homotopy` between them.
-/
def Homotopic (p₀ p₁ : Path x₀ x₁) : Prop :=
  Nonempty (p₀.Homotopy p₁)
#align path.homotopic Path.Homotopic
-/

namespace homotopic

#print Path.Homotopic.refl /-
@[refl]
theorem refl (p : Path x₀ x₁) : p.Homotopic p :=
  ⟨Homotopy.refl p⟩
#align path.homotopic.refl Path.Homotopic.refl
-/

#print Path.Homotopic.symm /-
@[symm]
theorem symm ⦃p₀ p₁ : Path x₀ x₁⦄ (h : p₀.Homotopic p₁) : p₁.Homotopic p₀ :=
  h.map Homotopy.symm
#align path.homotopic.symm Path.Homotopic.symm
-/

#print Path.Homotopic.trans /-
@[trans]
theorem trans ⦃p₀ p₁ p₂ : Path x₀ x₁⦄ (h₀ : p₀.Homotopic p₁) (h₁ : p₁.Homotopic p₂) :
    p₀.Homotopic p₂ :=
  h₀.map2 Homotopy.trans h₁
#align path.homotopic.trans Path.Homotopic.trans
-/

#print Path.Homotopic.equivalence /-
theorem equivalence : Equivalence (@Homotopic X _ x₀ x₁) :=
  ⟨refl, symm, trans⟩
#align path.homotopic.equivalence Path.Homotopic.equivalence
-/

/- warning: path.homotopic.map -> Path.Homotopic.map is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {x₀ : X} {x₁ : X} {p : Path.{u1} X _inst_1 x₀ x₁} {q : Path.{u1} X _inst_1 x₀ x₁}, (Path.Homotopic.{u1} X _inst_1 x₀ x₁ p q) -> (forall (f : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2), Path.Homotopic.{u2} Y _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₀) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₁) (Path.map.{u1, u2} X _inst_1 x₀ x₁ p Y _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f) (ContinuousMap.continuous.{u1, u2} X Y _inst_1 _inst_2 f)) (Path.map.{u1, u2} X _inst_1 x₀ x₁ q Y _inst_2 (fun {x₀ : X} => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₀) (ContinuousMap.continuous.{u1, u2} X Y _inst_1 _inst_2 f)))
but is expected to have type
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {x₀ : X} {x₁ : X} {p : Path.{u1} X _inst_1 x₀ x₁} {q : Path.{u1} X _inst_1 x₀ x₁}, (Path.Homotopic.{u1} X _inst_1 x₀ x₁ p q) -> (forall (f : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2), Path.Homotopic.{u2} Y _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₀) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₁) (Path.map.{u1, u2} X _inst_1 x₀ x₁ p Y _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f) (ContinuousMap.continuous.{u2, u1} X Y _inst_1 _inst_2 f)) (Path.map.{u1, u2} X _inst_1 x₀ x₁ q Y _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (a : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) a) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f) (ContinuousMap.continuous.{u2, u1} X Y _inst_1 _inst_2 f)))
Case conversion may be inaccurate. Consider using '#align path.homotopic.map Path.Homotopic.mapₓ'. -/
theorem map {p q : Path x₀ x₁} (h : p.Homotopic q) (f : C(X, Y)) :
    Homotopic (p.map f.Continuous) (q.map f.Continuous) :=
  h.map fun F => F.map f
#align path.homotopic.map Path.Homotopic.map

#print Path.Homotopic.hcomp /-
theorem hcomp {p₀ p₁ : Path x₀ x₁} {q₀ q₁ : Path x₁ x₂} (hp : p₀.Homotopic p₁)
    (hq : q₀.Homotopic q₁) : (p₀.trans q₀).Homotopic (p₁.trans q₁) :=
  hp.map2 Homotopy.hcomp hq
#align path.homotopic.hcomp Path.Homotopic.hcomp
-/

#print Path.Homotopic.setoid /-
/--
The setoid on `path`s defined by the equivalence relation `path.homotopic`. That is, two paths are
equivalent if there is a `homotopy` between them.
-/
protected def setoid (x₀ x₁ : X) : Setoid (Path x₀ x₁) :=
  ⟨Homotopic, equivalence⟩
#align path.homotopic.setoid Path.Homotopic.setoid
-/

#print Path.Homotopic.Quotient /-
/-- The quotient on `path x₀ x₁` by the equivalence relation `path.homotopic`.
-/
protected def Quotient (x₀ x₁ : X) :=
  Quotient (Homotopic.setoid x₀ x₁)
#align path.homotopic.quotient Path.Homotopic.Quotient
-/

attribute [local instance] homotopic.setoid

instance : Inhabited (Homotopic.Quotient () ()) :=
  ⟨Quotient.mk' <| Path.refl ()⟩

#print Path.Homotopic.Quotient.comp /-
/-- The composition of path homotopy classes. This is `path.trans` descended to the quotient. -/
def Quotient.comp (P₀ : Path.Homotopic.Quotient x₀ x₁) (P₁ : Path.Homotopic.Quotient x₁ x₂) :
    Path.Homotopic.Quotient x₀ x₂ :=
  Quotient.map₂ Path.trans (fun (p₀ : Path x₀ x₁) p₁ hp (q₀ : Path x₁ x₂) q₁ hq => hcomp hp hq) P₀
    P₁
#align path.homotopic.quotient.comp Path.Homotopic.Quotient.comp
-/

#print Path.Homotopic.comp_lift /-
theorem comp_lift (P₀ : Path x₀ x₁) (P₁ : Path x₁ x₂) : ⟦P₀.trans P₁⟧ = Quotient.comp ⟦P₀⟧ ⟦P₁⟧ :=
  rfl
#align path.homotopic.comp_lift Path.Homotopic.comp_lift
-/

/- warning: path.homotopic.quotient.map_fn -> Path.Homotopic.Quotient.mapFn is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {x₀ : X} {x₁ : X}, (Path.Homotopic.Quotient.{u1} X _inst_1 x₀ x₁) -> (forall (f : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2), Path.Homotopic.Quotient.{u2} Y _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₀) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₁))
but is expected to have type
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {x₀ : X} {x₁ : X}, (Path.Homotopic.Quotient.{u1} X _inst_1 x₀ x₁) -> (forall (f : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2), Path.Homotopic.Quotient.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) x₀) _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₀) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₁))
Case conversion may be inaccurate. Consider using '#align path.homotopic.quotient.map_fn Path.Homotopic.Quotient.mapFnₓ'. -/
/-- The image of a path homotopy class `P₀` under a map `f`.
    This is `path.map` descended to the quotient -/
def Quotient.mapFn (P₀ : Path.Homotopic.Quotient x₀ x₁) (f : C(X, Y)) :
    Path.Homotopic.Quotient (f x₀) (f x₁) :=
  Quotient.map (fun q : Path x₀ x₁ => q.map f.Continuous) (fun p₀ p₁ h => Path.Homotopic.map h f) P₀
#align path.homotopic.quotient.map_fn Path.Homotopic.Quotient.mapFn

/- warning: path.homotopic.map_lift -> Path.Homotopic.map_lift is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {x₀ : X} {x₁ : X} (P₀ : Path.{u1} X _inst_1 x₀ x₁) (f : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2), Eq.{succ u2} (Quotient.{succ u2} (Path.{u2} Y _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₀) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₁)) (Path.Homotopic.setoid.{u2} Y _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₀) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₁))) (Quotient.mk'.{succ u2} (Path.{u2} Y _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₀) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₁)) (Path.Homotopic.setoid.{u2} Y _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₀) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f x₁)) (Path.map.{u1, u2} X _inst_1 x₀ x₁ P₀ Y _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_1 _inst_2) f) (ContinuousMap.continuous.{u1, u2} X Y _inst_1 _inst_2 f))) (Path.Homotopic.Quotient.mapFn.{u1, u2} X Y _inst_1 _inst_2 x₀ x₁ (Quotient.mk'.{succ u1} (Path.{u1} X _inst_1 x₀ x₁) (Path.Homotopic.setoid.{u1} X _inst_1 x₀ x₁) P₀) f)
but is expected to have type
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : TopologicalSpace.{u2} Y] {x₀ : X} {x₁ : X} (P₀ : Path.{u1} X _inst_1 x₀ x₁) (f : ContinuousMap.{u1, u2} X Y _inst_1 _inst_2), Eq.{succ u2} (Quotient.{succ u2} (Path.{u2} Y _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₀) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₁)) (Path.Homotopic.setoid.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) x₀) _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₀) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₁))) (Quotient.mk.{succ u2} (Path.{u2} Y _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₀) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₁)) (Path.Homotopic.setoid.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) x₀) _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₀) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f x₁)) (Path.map.{u1, u2} X _inst_1 x₀ x₁ P₀ Y _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_1 _inst_2) X Y _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_1 _inst_2)) f) (ContinuousMap.continuous.{u2, u1} X Y _inst_1 _inst_2 f))) (Path.Homotopic.Quotient.mapFn.{u1, u2} X Y _inst_1 _inst_2 x₀ x₁ (Quotient.mk.{succ u1} (Path.{u1} X _inst_1 x₀ x₁) (Path.Homotopic.setoid.{u1} X _inst_1 x₀ x₁) P₀) f)
Case conversion may be inaccurate. Consider using '#align path.homotopic.map_lift Path.Homotopic.map_liftₓ'. -/
theorem map_lift (P₀ : Path x₀ x₁) (f : C(X, Y)) : ⟦P₀.map f.Continuous⟧ = Quotient.mapFn ⟦P₀⟧ f :=
  rfl
#align path.homotopic.map_lift Path.Homotopic.map_lift

#print Path.Homotopic.hpath_hext /-
theorem hpath_hext {p₁ : Path x₀ x₁} {p₂ : Path x₂ x₃} (hp : ∀ t, p₁ t = p₂ t) : HEq ⟦p₁⟧ ⟦p₂⟧ :=
  by
  obtain rfl : x₀ = x₂ := by convert hp 0 <;> simp
  obtain rfl : x₁ = x₃ := by convert hp 1 <;> simp
  rw [heq_iff_eq]; congr ; ext t; exact hp t
#align path.homotopic.hpath_hext Path.Homotopic.hpath_hext
-/

end homotopic

end Path

namespace ContinuousMap.Homotopy

/- warning: continuous_map.homotopy.eval_at -> ContinuousMap.Homotopy.evalAt is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} X] [_inst_4 : TopologicalSpace.{u2} Y] {f : ContinuousMap.{u1, u2} X Y _inst_3 _inst_4} {g : ContinuousMap.{u1, u2} X Y _inst_3 _inst_4}, (ContinuousMap.Homotopy.{u1, u2} X Y _inst_3 _inst_4 f g) -> (forall (x : X), Path.{u2} Y _inst_4 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_3 _inst_4) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_3 _inst_4) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_3 _inst_4) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} X Y _inst_3 _inst_4) (fun (_x : ContinuousMap.{u1, u2} X Y _inst_3 _inst_4) => X -> Y) (ContinuousMap.hasCoeToFun.{u1, u2} X Y _inst_3 _inst_4) g x))
but is expected to have type
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_3 : TopologicalSpace.{u1} X] [_inst_4 : TopologicalSpace.{u2} Y] {f : ContinuousMap.{u1, u2} X Y _inst_3 _inst_4} {g : ContinuousMap.{u1, u2} X Y _inst_3 _inst_4}, (ContinuousMap.Homotopy.{u1, u2} X Y _inst_3 _inst_4 f g) -> (forall (x : X), Path.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) x) _inst_4 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_3 _inst_4) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_3 _inst_4) X Y _inst_3 _inst_4 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_3 _inst_4)) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} X Y _inst_3 _inst_4) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Y) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} X Y _inst_3 _inst_4) X Y _inst_3 _inst_4 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} X Y _inst_3 _inst_4)) g x))
Case conversion may be inaccurate. Consider using '#align continuous_map.homotopy.eval_at ContinuousMap.Homotopy.evalAtₓ'. -/
/-- Given a homotopy H: f ∼ g, get the path traced by the point `x` as it moves from
`f x` to `g x`
-/
def evalAt {X : Type _} {Y : Type _} [TopologicalSpace X] [TopologicalSpace Y] {f g : C(X, Y)}
    (H : ContinuousMap.Homotopy f g) (x : X) : Path (f x) (g x)
    where
  toFun t := H (t, x)
  source' := H.apply_zero x
  target' := H.apply_one x
#align continuous_map.homotopy.eval_at ContinuousMap.Homotopy.evalAt

end ContinuousMap.Homotopy

