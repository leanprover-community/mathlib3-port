/-
Copyright ¬© 2022 Heather Macbeth. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Heather Macbeth, Floris van Doorn
-/
import Mathbin.Topology.VectorBundle.Basic

/-!
# Direct sum of two vector bundles

If `E‚ÇÅ : B ‚Üí Type*` and `E‚ÇÇ : B ‚Üí Type*` define two topological vector bundles over `R` with fiber
models `F‚ÇÅ` and `F‚ÇÇ`, we define the bundle of direct sums `E‚ÇÅ √ó·µá E‚ÇÇ := Œª x, E‚ÇÅ x √ó E‚ÇÇ x`.
We can endow `E‚ÇÅ √ó·µá E‚ÇÇ` with a topological vector bundle structure:
`bundle.prod.topological_vector_bundle`.

A similar construction (which is yet to be formalized) can be done for the vector bundle of
continuous linear maps from `E‚ÇÅ x` to `E‚ÇÇ x` with fiber a type synonym
`vector_bundle_continuous_linear_map R F‚ÇÅ E‚ÇÅ F‚ÇÇ E‚ÇÇ x := (E‚ÇÅ x ‚ÜíL[R] E‚ÇÇ x)` (and with the
topology inherited from the norm-topology on `F‚ÇÅ ‚ÜíL[R] F‚ÇÇ`, without the need to define the strong
topology on continuous linear maps between general topological vector spaces).  Likewise for tensor
products of topological vector bundles, exterior algebras, and so on, where the topology can be
defined using a norm on the fiber model if this helps.

## Tags
Vector bundle
-/


noncomputable section

open Bundle Set

open Classical Bundle

variable (R ùïú : Type _) {B : Type _} (F : Type _) (E : B ‚Üí Type _)

section Defs

variable (E‚ÇÅ : B ‚Üí Type _) (E‚ÇÇ : B ‚Üí Type _)

variable [TopologicalSpace (TotalSpace E‚ÇÅ)] [TopologicalSpace (TotalSpace E‚ÇÇ)]

/-- Equip the total space of the fibrewise product of two topological vector bundles `E‚ÇÅ`, `E‚ÇÇ` with
the induced topology from the diagonal embedding into `total_space E‚ÇÅ √ó total_space E‚ÇÇ`. -/
instance TopologicalVectorBundle.Prod.topologicalSpace : TopologicalSpace (TotalSpace (E‚ÇÅ √ó·µá E‚ÇÇ)) :=
  TopologicalSpace.induced (fun p => ((‚ü®p.1, p.2.1‚ü© : TotalSpace E‚ÇÅ), (‚ü®p.1, p.2.2‚ü© : TotalSpace E‚ÇÇ)))
    (by infer_instance : TopologicalSpace (TotalSpace E‚ÇÅ √ó TotalSpace E‚ÇÇ))
#align topological_vector_bundle.prod.topological_space TopologicalVectorBundle.Prod.topologicalSpace

/-- The diagonal map from the total space of the fibrewise product of two topological vector bundles
`E‚ÇÅ`, `E‚ÇÇ` into `total_space E‚ÇÅ √ó total_space E‚ÇÇ` is `inducing`. -/
theorem TopologicalVectorBundle.Prod.inducing_diag :
    Inducing (fun p => (‚ü®p.1, p.2.1‚ü©, ‚ü®p.1, p.2.2‚ü©) : TotalSpace (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí TotalSpace E‚ÇÅ √ó TotalSpace E‚ÇÇ) :=
  ‚ü®rfl‚ü©
#align topological_vector_bundle.prod.inducing_diag TopologicalVectorBundle.Prod.inducing_diag

end Defs

open TopologicalVectorBundle

variable [NontriviallyNormedField R] [TopologicalSpace B]

variable (F‚ÇÅ : Type _) [NormedAddCommGroup F‚ÇÅ] [NormedSpace R F‚ÇÅ] (E‚ÇÅ : B ‚Üí Type _) [TopologicalSpace (TotalSpace E‚ÇÅ)]

variable (F‚ÇÇ : Type _) [NormedAddCommGroup F‚ÇÇ] [NormedSpace R F‚ÇÇ] (E‚ÇÇ : B ‚Üí Type _) [TopologicalSpace (TotalSpace E‚ÇÇ)]

namespace Trivialization

variable (e‚ÇÅ : Trivialization F‚ÇÅ (œÄ E‚ÇÅ)) (e‚ÇÇ : Trivialization F‚ÇÇ (œÄ E‚ÇÇ))

include e‚ÇÅ e‚ÇÇ

variable {R F‚ÇÅ E‚ÇÅ F‚ÇÇ E‚ÇÇ}

/-- Given trivializations `e‚ÇÅ`, `e‚ÇÇ` for vector bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the forward
function for the construction `topological_vector_bundle.trivialization.prod`, the induced
trivialization for the direct sum of `E‚ÇÅ` and `E‚ÇÇ`. -/
def Prod.toFun' : TotalSpace (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí B √ó F‚ÇÅ √ó F‚ÇÇ := fun p => ‚ü®p.1, (e‚ÇÅ ‚ü®p.1, p.2.1‚ü©).2, (e‚ÇÇ ‚ü®p.1, p.2.2‚ü©).2‚ü©
#align trivialization.prod.to_fun' Trivialization.Prod.toFun'

variable {e‚ÇÅ e‚ÇÇ}

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem Prod.continuous_to_fun :
    ContinuousOn (Prod.toFun' e‚ÇÅ e‚ÇÇ) (@TotalSpace.proj B (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Åª¬π' (e‚ÇÅ.BaseSet ‚à© e‚ÇÇ.BaseSet)) := by
  let f‚ÇÅ : total_space (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí total_space E‚ÇÅ √ó total_space E‚ÇÇ := fun p =>
    ((‚ü®p.1, p.2.1‚ü© : total_space E‚ÇÅ), (‚ü®p.1, p.2.2‚ü© : total_space E‚ÇÇ))
  let f‚ÇÇ : total_space E‚ÇÅ √ó total_space E‚ÇÇ ‚Üí (B √ó F‚ÇÅ) √ó B √ó F‚ÇÇ := fun p => ‚ü®e‚ÇÅ p.1, e‚ÇÇ p.2‚ü©
  let f‚ÇÉ : (B √ó F‚ÇÅ) √ó B √ó F‚ÇÇ ‚Üí B √ó F‚ÇÅ √ó F‚ÇÇ := fun p => ‚ü®p.1.1, p.1.2, p.2.2‚ü©
  have hf‚ÇÅ : Continuous f‚ÇÅ := (prod.inducing_diag E‚ÇÅ E‚ÇÇ).Continuous
  have hf‚ÇÇ : ContinuousOn f‚ÇÇ (e‚ÇÅ.source √óÀ¢ e‚ÇÇ.source) :=
    e‚ÇÅ.to_local_homeomorph.continuous_on.prod_map e‚ÇÇ.to_local_homeomorph.continuous_on
  have hf‚ÇÉ : Continuous f‚ÇÉ := (continuous_fst.comp continuous_fst).prod_mk (continuous_snd.prod_map continuous_snd)
  refine' ((hf‚ÇÉ.comp_continuous_on hf‚ÇÇ).comp hf‚ÇÅ.continuous_on _).congr _
  ¬∑ rw [e‚ÇÅ.source_eq, e‚ÇÇ.source_eq]
    exact maps_to_preimage _ _
    
  rintro ‚ü®b, v‚ÇÅ, v‚ÇÇ‚ü© ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©
  simp only [prod.to_fun', Prod.mk.inj_iff, eq_self_iff_true, and_true_iff]
  rw [e‚ÇÅ.coe_fst]
  rw [e‚ÇÅ.source_eq, mem_preimage]
  exact hb‚ÇÅ
#align trivialization.prod.continuous_to_fun Trivialization.Prod.continuous_to_fun

variable (e‚ÇÅ e‚ÇÇ) [‚àÄ x, AddCommMonoid (E‚ÇÅ x)] [‚àÄ x, Module R (E‚ÇÅ x)] [‚àÄ x, AddCommMonoid (E‚ÇÇ x)] [‚àÄ x, Module R (E‚ÇÇ x)]

/-- Given trivializations `e‚ÇÅ`, `e‚ÇÇ` for vector bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the inverse
function for the construction `topological_vector_bundle.trivialization.prod`, the induced
trivialization for the direct sum of `E‚ÇÅ` and `E‚ÇÇ`. -/
def Prod.invFun' (p : B √ó F‚ÇÅ √ó F‚ÇÇ) : TotalSpace (E‚ÇÅ √ó·µá E‚ÇÇ) :=
  ‚ü®p.1, e‚ÇÅ.symm p.1 p.2.1, e‚ÇÇ.symm p.1 p.2.2‚ü©
#align trivialization.prod.inv_fun' Trivialization.Prod.invFun'

variable {e‚ÇÅ e‚ÇÇ}

theorem Prod.left_inv {x : TotalSpace (E‚ÇÅ √ó·µá E‚ÇÇ)}
    (h : x ‚àà @TotalSpace.proj B (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Åª¬π' (e‚ÇÅ.BaseSet ‚à© e‚ÇÇ.BaseSet)) :
    Prod.invFun' e‚ÇÅ e‚ÇÇ (Prod.toFun' e‚ÇÅ e‚ÇÇ x) = x := by
  obtain ‚ü®x, v‚ÇÅ, v‚ÇÇ‚ü© := x
  obtain ‚ü®h‚ÇÅ : x ‚àà e‚ÇÅ.base_set, h‚ÇÇ : x ‚àà e‚ÇÇ.base_set‚ü© := h
  simp only [prod.to_fun', prod.inv_fun', symm_apply_apply_mk, h‚ÇÅ, h‚ÇÇ]
#align trivialization.prod.left_inv Trivialization.Prod.left_inv

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem Prod.right_inv {x : B √ó F‚ÇÅ √ó F‚ÇÇ} (h : x ‚àà (e‚ÇÅ.BaseSet ‚à© e‚ÇÇ.BaseSet) √óÀ¢ (Univ : Set (F‚ÇÅ √ó F‚ÇÇ))) :
    Prod.toFun' e‚ÇÅ e‚ÇÇ (Prod.invFun' e‚ÇÅ e‚ÇÇ x) = x := by
  obtain ‚ü®x, w‚ÇÅ, w‚ÇÇ‚ü© := x
  obtain ‚ü®‚ü®h‚ÇÅ : x ‚àà e‚ÇÅ.base_set, h‚ÇÇ : x ‚àà e‚ÇÇ.base_set‚ü©, -‚ü© := h
  simp only [prod.to_fun', prod.inv_fun', apply_mk_symm, h‚ÇÅ, h‚ÇÇ]
#align trivialization.prod.right_inv Trivialization.Prod.right_inv

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem Prod.continuous_inv_fun : ContinuousOn (Prod.invFun' e‚ÇÅ e‚ÇÇ) ((e‚ÇÅ.BaseSet ‚à© e‚ÇÇ.BaseSet) √óÀ¢ univ) := by
  rw [(prod.inducing_diag E‚ÇÅ E‚ÇÇ).continuous_on_iff]
  have H‚ÇÅ : Continuous fun p : B √ó F‚ÇÅ √ó F‚ÇÇ => ((p.1, p.2.1), (p.1, p.2.2)) :=
    (continuous_id.prod_map continuous_fst).prod_mk (continuous_id.prod_map continuous_snd)
  refine' (e‚ÇÅ.continuous_on_symm.prod_map e‚ÇÇ.continuous_on_symm).comp H‚ÇÅ.continuous_on _
  exact fun x h => ‚ü®‚ü®h.1.1, mem_univ _‚ü©, ‚ü®h.1.2, mem_univ _‚ü©‚ü©
#align trivialization.prod.continuous_inv_fun Trivialization.Prod.continuous_inv_fun

variable (e‚ÇÅ e‚ÇÇ R)

variable [‚àÄ x : B, TopologicalSpace (E‚ÇÅ x)] [‚àÄ x : B, TopologicalSpace (E‚ÇÇ x)] [TopologicalVectorBundle R F‚ÇÅ E‚ÇÅ]
  [TopologicalVectorBundle R F‚ÇÇ E‚ÇÇ]

include R

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Given trivializations `e‚ÇÅ`, `e‚ÇÇ` for vector bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the induced
trivialization for the direct sum of `E‚ÇÅ` and `E‚ÇÇ`, whose base set is `e‚ÇÅ.base_set ‚à© e‚ÇÇ.base_set`.
-/
@[nolint unused_arguments]
def prod : Trivialization (F‚ÇÅ √ó F‚ÇÇ) (œÄ (E‚ÇÅ √ó·µá E‚ÇÇ)) where
  toFun := Prod.toFun' e‚ÇÅ e‚ÇÇ
  invFun := Prod.invFun' e‚ÇÅ e‚ÇÇ
  Source := @TotalSpace.proj B (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Åª¬π' (e‚ÇÅ.BaseSet ‚à© e‚ÇÇ.BaseSet)
  Target := (e‚ÇÅ.BaseSet ‚à© e‚ÇÇ.BaseSet) √óÀ¢ Set.Univ
  map_source' x h := ‚ü®h, Set.mem_univ _‚ü©
  map_target' x h := h.1
  left_inv' x := Prod.left_inv
  right_inv' x := Prod.right_inv
  open_source := by
    refine' (e‚ÇÅ.open_base_set.inter e‚ÇÇ.open_base_set).Preimage _
    have : Continuous (@total_space.proj B E‚ÇÅ) := continuous_proj R B F‚ÇÅ
    exact this.comp (prod.inducing_diag E‚ÇÅ E‚ÇÇ).Continuous.fst
  open_target := (e‚ÇÅ.open_base_set.inter e‚ÇÇ.open_base_set).Prod is_open_univ
  continuous_to_fun := Prod.continuous_to_fun
  continuous_inv_fun := Prod.continuous_inv_fun
  BaseSet := e‚ÇÅ.BaseSet ‚à© e‚ÇÇ.BaseSet
  open_base_set := e‚ÇÅ.open_base_set.inter e‚ÇÇ.open_base_set
  source_eq := rfl
  target_eq := rfl
  proj_to_fun x h := rfl
#align trivialization.prod Trivialization.prod

omit R

instance prod.is_linear [e‚ÇÅ.is_linear R] [e‚ÇÇ.is_linear R] :
    (e‚ÇÅ.Prod R e‚ÇÇ).is_linear
      R where linear := fun x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => (((e‚ÇÅ.linear R h‚ÇÅ).mk' _).prod_map ((e‚ÇÇ.linear R h‚ÇÇ).mk' _)).is_linear
#align trivialization.prod.is_linear Trivialization.prod.is_linear

@[simp]
theorem base_set_prod : (prod R e‚ÇÅ e‚ÇÇ).BaseSet = e‚ÇÅ.BaseSet ‚à© e‚ÇÇ.BaseSet :=
  rfl
#align trivialization.base_set_prod Trivialization.base_set_prod

variable {e‚ÇÅ e‚ÇÇ}

variable (R)

theorem prod_apply [e‚ÇÅ.is_linear R] [e‚ÇÇ.is_linear R] {x : B} (hx‚ÇÅ : x ‚àà e‚ÇÅ.BaseSet) (hx‚ÇÇ : x ‚àà e‚ÇÇ.BaseSet) (v‚ÇÅ : E‚ÇÅ x)
    (v‚ÇÇ : E‚ÇÇ x) :
    prod R e‚ÇÅ e‚ÇÇ ‚ü®x, (v‚ÇÅ, v‚ÇÇ)‚ü© = ‚ü®x, e‚ÇÅ.continuousLinearEquivAt R x hx‚ÇÅ v‚ÇÅ, e‚ÇÇ.continuousLinearEquivAt R x hx‚ÇÇ v‚ÇÇ‚ü© :=
  rfl
#align trivialization.prod_apply Trivialization.prod_apply

variable {R}

theorem prod_symm_apply (x : B) (w‚ÇÅ : F‚ÇÅ) (w‚ÇÇ : F‚ÇÇ) :
    (prod R e‚ÇÅ e‚ÇÇ).toLocalEquiv.symm (x, w‚ÇÅ, w‚ÇÇ) = ‚ü®x, e‚ÇÅ.symm x w‚ÇÅ, e‚ÇÇ.symm x w‚ÇÇ‚ü© :=
  rfl
#align trivialization.prod_symm_apply Trivialization.prod_symm_apply

end Trivialization

open Trivialization

variable [‚àÄ x, AddCommMonoid (E‚ÇÅ x)] [‚àÄ x, Module R (E‚ÇÅ x)] [‚àÄ x, AddCommMonoid (E‚ÇÇ x)] [‚àÄ x, Module R (E‚ÇÇ x)]

variable [‚àÄ x : B, TopologicalSpace (E‚ÇÅ x)] [‚àÄ x : B, TopologicalSpace (E‚ÇÇ x)] [TopologicalVectorBundle R F‚ÇÅ E‚ÇÅ]
  [TopologicalVectorBundle R F‚ÇÇ E‚ÇÇ]

/-- The product of two vector bundles is a vector bundle. -/
instance _root_.bundle.prod.topological_vector_bundle : TopologicalVectorBundle R (F‚ÇÅ √ó F‚ÇÇ) (E‚ÇÅ √ó·µá E‚ÇÇ) where
  total_space_mk_inducing b := by
    rw [(prod.inducing_diag E‚ÇÅ E‚ÇÇ).inducing_iff]
    exact (total_space_mk_inducing R F‚ÇÅ E‚ÇÅ b).prod_mk (total_space_mk_inducing R F‚ÇÇ E‚ÇÇ b)
  TrivializationAtlas :=
    { e |
      ‚àÉ (e‚ÇÅ : Trivialization F‚ÇÅ (œÄ E‚ÇÅ))(e‚ÇÇ : Trivialization F‚ÇÇ (œÄ E‚ÇÇ))(_ : MemTrivializationAtlas R e‚ÇÅ)(_ :
        MemTrivializationAtlas R e‚ÇÇ), e = Trivialization.prod R e‚ÇÅ e‚ÇÇ }
  trivialization_linear' := by
    rintro _ ‚ü®e‚ÇÅ, e‚ÇÇ, he‚ÇÅ, he‚ÇÇ, rfl‚ü©
    skip
    infer_instance
  trivializationAt b := (trivializationAt R F‚ÇÅ E‚ÇÅ b).Prod R (trivializationAt R F‚ÇÇ E‚ÇÇ b)
  mem_base_set_trivialization_at b :=
    ‚ü®mem_base_set_trivialization_at R F‚ÇÅ E‚ÇÅ b, mem_base_set_trivialization_at R F‚ÇÇ E‚ÇÇ b‚ü©
  trivialization_mem_atlas b :=
    ‚ü®trivializationAt R F‚ÇÅ E‚ÇÅ b, trivializationAt R F‚ÇÇ E‚ÇÇ b, by infer_instance, by infer_instance, rfl‚ü©
  continuous_on_coord_change' := by
    rintro _ _ ‚ü®e‚ÇÅ, e‚ÇÇ, he‚ÇÅ, he‚ÇÇ, rfl‚ü© ‚ü®e‚ÇÅ', e‚ÇÇ', he‚ÇÅ', he‚ÇÇ', rfl‚ü©
    skip
    refine'
        (((continuous_on_coord_change R e‚ÇÅ e‚ÇÅ').mono _).prodMapL R ((continuous_on_coord_change R e‚ÇÇ e‚ÇÇ').mono _)).congr
          _ <;>
      dsimp only [base_set_prod, mfld_simps]
    ¬∑ mfld_set_tac
      
    ¬∑ mfld_set_tac
      
    ¬∑ rintro b hb
      rw [ContinuousLinearMap.ext_iff]
      rintro ‚ü®v‚ÇÅ, v‚ÇÇ‚ü©
      show
        (e‚ÇÅ.prod R e‚ÇÇ).coordChangeL R (e‚ÇÅ'.prod R e‚ÇÇ') b (v‚ÇÅ, v‚ÇÇ) =
          (e‚ÇÅ.coord_changeL R e‚ÇÅ' b v‚ÇÅ, e‚ÇÇ.coord_changeL R e‚ÇÇ' b v‚ÇÇ)
      rw [e‚ÇÅ.coord_changeL_apply e‚ÇÅ', e‚ÇÇ.coord_changeL_apply e‚ÇÇ', (e‚ÇÅ.prod R e‚ÇÇ).coord_changeL_apply']
      exacts[rfl, hb, ‚ü®hb.1.2, hb.2.2‚ü©, ‚ü®hb.1.1, hb.2.1‚ü©]
      
#align _root_.bundle.prod.topological_vector_bundle _root_.bundle.prod.topological_vector_bundle

instance _root_.bundle.prod.mem_trivialization_atlas {e‚ÇÅ : Trivialization F‚ÇÅ (œÄ E‚ÇÅ)} {e‚ÇÇ : Trivialization F‚ÇÇ (œÄ E‚ÇÇ)}
    [MemTrivializationAtlas R e‚ÇÅ] [MemTrivializationAtlas R e‚ÇÇ] :
    MemTrivializationAtlas R
      (e‚ÇÅ.Prod R e‚ÇÇ :
        Trivialization (F‚ÇÅ √ó F‚ÇÇ) (œÄ (E‚ÇÅ √ó·µá E‚ÇÇ))) where out := ‚ü®e‚ÇÅ, e‚ÇÇ, by infer_instance, by infer_instance, rfl‚ü©
#align _root_.bundle.prod.mem_trivialization_atlas _root_.bundle.prod.mem_trivialization_atlas

variable {R F‚ÇÅ E‚ÇÅ F‚ÇÇ E‚ÇÇ}

@[simp]
theorem Trivialization.continuous_linear_equiv_at_prod {e‚ÇÅ : Trivialization F‚ÇÅ (œÄ E‚ÇÅ)} {e‚ÇÇ : Trivialization F‚ÇÇ (œÄ E‚ÇÇ)}
    [e‚ÇÅ.is_linear R] [e‚ÇÇ.is_linear R] {x : B} (hx‚ÇÅ : x ‚àà e‚ÇÅ.BaseSet) (hx‚ÇÇ : x ‚àà e‚ÇÇ.BaseSet) :
    (e‚ÇÅ.Prod R e‚ÇÇ).continuousLinearEquivAt R x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü© =
      (e‚ÇÅ.continuousLinearEquivAt R x hx‚ÇÅ).Prod (e‚ÇÇ.continuousLinearEquivAt R x hx‚ÇÇ) :=
  by
  ext1
  funext v
  obtain ‚ü®v‚ÇÅ, v‚ÇÇ‚ü© := v
  rw [(e‚ÇÅ.prod R e‚ÇÇ).continuous_linear_equiv_at_apply R, Trivialization.prod]
  exact (congr_arg Prod.snd (prod_apply R hx‚ÇÅ hx‚ÇÇ v‚ÇÅ v‚ÇÇ) : _)
#align trivialization.continuous_linear_equiv_at_prod Trivialization.continuous_linear_equiv_at_prod

