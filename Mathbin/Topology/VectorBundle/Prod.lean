/-
Copyright ¬© 2022 Heather Macbeth. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Heather Macbeth, Floris van Doorn
-/
import Mathbin.Topology.VectorBundle.Basic

/-!
# Fiberwise product of two vector bundles

If `E‚ÇÅ : B ‚Üí Type*` and `E‚ÇÇ : B ‚Üí Type*` define two fiber bundles over `R` with fiber
models `F‚ÇÅ` and `F‚ÇÇ`, we define the bundle of fibrewise products `E‚ÇÅ √ó·µá E‚ÇÇ := Œª x, E‚ÇÅ x √ó E‚ÇÇ x`.

If moreover `E‚ÇÅ` and `E‚ÇÇ` are vector bundles over `R`, we can endow `E‚ÇÅ √ó·µá E‚ÇÇ` with a vector bundle
structure: `bundle.prod.vector_bundle`, the direct sum of the two vector bundles.

A similar construction (which is yet to be formalized) can be done for the vector bundle of
continuous linear maps from `E‚ÇÅ x` to `E‚ÇÇ x` with fiber a type synonym
`vector_bundle_continuous_linear_map R F‚ÇÅ E‚ÇÅ F‚ÇÇ E‚ÇÇ x := (E‚ÇÅ x ‚ÜíL[R] E‚ÇÇ x)` (and with the
topology inherited from the norm-topology on `F‚ÇÅ ‚ÜíL[R] F‚ÇÇ`, without the need to define the strong
topology on continuous linear maps between general topological vector spaces).  Likewise for tensor
products of topological vector bundles, exterior algebras, and so on, where the topology can be
defined using a norm on the fiber model if this helps.

## Tags
Vector bundle, fiberwise product, direct sum
-/


noncomputable section

open Bundle Set

open Classical Bundle

variable (R ùïú : Type _) {B : Type _} (F : Type _) (E : B ‚Üí Type _)

section Defs

variable (E‚ÇÅ : B ‚Üí Type _) (E‚ÇÇ : B ‚Üí Type _)

variable [TopologicalSpace (TotalSpace E‚ÇÅ)] [TopologicalSpace (TotalSpace E‚ÇÇ)]

/-- Equip the total space of the fibrewise product of two fiber bundles `E‚ÇÅ`, `E‚ÇÇ` with
the induced topology from the diagonal embedding into `total_space E‚ÇÅ √ó total_space E‚ÇÇ`. -/
instance FiberBundle.Prod.topologicalSpace : TopologicalSpace (TotalSpace (E‚ÇÅ √ó·µá E‚ÇÇ)) :=
  TopologicalSpace.induced (fun p => ((‚ü®p.1, p.2.1‚ü© : TotalSpace E‚ÇÅ), (‚ü®p.1, p.2.2‚ü© : TotalSpace E‚ÇÇ)))
    (by infer_instance : TopologicalSpace (TotalSpace E‚ÇÅ √ó TotalSpace E‚ÇÇ))
#align fiber_bundle.prod.topological_space FiberBundle.Prod.topologicalSpace

/-- The diagonal map from the total space of the fibrewise product of two fiber bundles
`E‚ÇÅ`, `E‚ÇÇ` into `total_space E‚ÇÅ √ó total_space E‚ÇÇ` is `inducing`. -/
theorem FiberBundle.Prod.inducing_diag :
    Inducing (fun p => (‚ü®p.1, p.2.1‚ü©, ‚ü®p.1, p.2.2‚ü©) : TotalSpace (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí TotalSpace E‚ÇÅ √ó TotalSpace E‚ÇÇ) :=
  ‚ü®rfl‚ü©
#align fiber_bundle.prod.inducing_diag FiberBundle.Prod.inducing_diag

end Defs

open FiberBundle

variable [NontriviallyNormedField R] [TopologicalSpace B]

variable (F‚ÇÅ' : Type _) [TopologicalSpace F‚ÇÅ'] (F‚ÇÅ : Type _) [NormedAddCommGroup F‚ÇÅ] [NormedSpace R F‚ÇÅ]
  (E‚ÇÅ : B ‚Üí Type _) [TopologicalSpace (TotalSpace E‚ÇÅ)]

variable (F‚ÇÇ' : Type _) [TopologicalSpace F‚ÇÇ'] (F‚ÇÇ : Type _) [NormedAddCommGroup F‚ÇÇ] [NormedSpace R F‚ÇÇ]
  (E‚ÇÇ : B ‚Üí Type _) [TopologicalSpace (TotalSpace E‚ÇÇ)]

namespace Trivialization

variable (Œµ‚ÇÅ : Trivialization F‚ÇÅ' (œÄ E‚ÇÅ)) (Œµ‚ÇÇ : Trivialization F‚ÇÇ' (œÄ E‚ÇÇ))

variable (e‚ÇÅ : Trivialization F‚ÇÅ (œÄ E‚ÇÅ)) (e‚ÇÇ : Trivialization F‚ÇÇ (œÄ E‚ÇÇ))

include Œµ‚ÇÅ Œµ‚ÇÇ

variable {R F‚ÇÅ' F‚ÇÅ E‚ÇÅ F‚ÇÇ' F‚ÇÇ E‚ÇÇ}

/-- Given trivializations `e‚ÇÅ`, `e‚ÇÇ` for fiber bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the forward
function for the construction `trivialization.prod`, the induced
trivialization for the fibrewise product of `E‚ÇÅ` and `E‚ÇÇ`. -/
def Prod.toFun' : TotalSpace (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí B √ó F‚ÇÅ' √ó F‚ÇÇ' := fun p => ‚ü®p.1, (Œµ‚ÇÅ ‚ü®p.1, p.2.1‚ü©).2, (Œµ‚ÇÇ ‚ü®p.1, p.2.2‚ü©).2‚ü©
#align trivialization.prod.to_fun' Trivialization.Prod.toFun'

variable {Œµ‚ÇÅ Œµ‚ÇÇ}

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem Prod.continuous_to_fun :
    ContinuousOn (Prod.toFun' Œµ‚ÇÅ Œµ‚ÇÇ) (@TotalSpace.proj B (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Åª¬π' (Œµ‚ÇÅ.baseSet ‚à© Œµ‚ÇÇ.baseSet)) := by
  let f‚ÇÅ : total_space (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí total_space E‚ÇÅ √ó total_space E‚ÇÇ := fun p =>
    ((‚ü®p.1, p.2.1‚ü© : total_space E‚ÇÅ), (‚ü®p.1, p.2.2‚ü© : total_space E‚ÇÇ))
  let f‚ÇÇ : total_space E‚ÇÅ √ó total_space E‚ÇÇ ‚Üí (B √ó F‚ÇÅ') √ó B √ó F‚ÇÇ' := fun p => ‚ü®Œµ‚ÇÅ p.1, Œµ‚ÇÇ p.2‚ü©
  let f‚ÇÉ : (B √ó F‚ÇÅ') √ó B √ó F‚ÇÇ' ‚Üí B √ó F‚ÇÅ' √ó F‚ÇÇ' := fun p => ‚ü®p.1.1, p.1.2, p.2.2‚ü©
  have hf‚ÇÅ : Continuous f‚ÇÅ := (prod.inducing_diag E‚ÇÅ E‚ÇÇ).Continuous
  have hf‚ÇÇ : ContinuousOn f‚ÇÇ (Œµ‚ÇÅ.source √óÀ¢ Œµ‚ÇÇ.source) :=
    Œµ‚ÇÅ.to_local_homeomorph.continuous_on.prod_map Œµ‚ÇÇ.to_local_homeomorph.continuous_on
  have hf‚ÇÉ : Continuous f‚ÇÉ := (continuous_fst.comp continuous_fst).prod_mk (continuous_snd.prod_map continuous_snd)
  refine' ((hf‚ÇÉ.comp_continuous_on hf‚ÇÇ).comp hf‚ÇÅ.continuous_on _).congr _
  ¬∑ rw [Œµ‚ÇÅ.source_eq, Œµ‚ÇÇ.source_eq]
    exact maps_to_preimage _ _
    
  rintro ‚ü®b, v‚ÇÅ, v‚ÇÇ‚ü© ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©
  simp only [prod.to_fun', Prod.mk.inj_iff, eq_self_iff_true, and_true_iff]
  rw [Œµ‚ÇÅ.coe_fst]
  rw [Œµ‚ÇÅ.source_eq, mem_preimage]
  exact hb‚ÇÅ
#align trivialization.prod.continuous_to_fun Trivialization.Prod.continuous_to_fun

variable (Œµ‚ÇÅ Œµ‚ÇÇ) [nz‚ÇÅ : ‚àÄ x, Zero (E‚ÇÅ x)] [nz‚ÇÇ : ‚àÄ x, Zero (E‚ÇÇ x)] [mnd‚ÇÅ : ‚àÄ x, AddCommMonoid (E‚ÇÅ x)]
  [mdl‚ÇÅ : ‚àÄ x, Module R (E‚ÇÅ x)] [mnd‚ÇÇ : ‚àÄ x, AddCommMonoid (E‚ÇÇ x)] [mdl‚ÇÇ : ‚àÄ x, Module R (E‚ÇÇ x)]

include nz‚ÇÅ nz‚ÇÇ

/-- Given trivializations `Œµ‚ÇÅ`, `Œµ‚ÇÇ` for fiber bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the inverse
function for the construction `trivialization.prod`, the induced
trivialization for the fibrewise product of `E‚ÇÅ` and `E‚ÇÇ`. -/
def Prod.invFun' (p : B √ó F‚ÇÅ' √ó F‚ÇÇ') : TotalSpace (E‚ÇÅ √ó·µá E‚ÇÇ) :=
  ‚ü®p.1, Œµ‚ÇÅ.symm p.1 p.2.1, Œµ‚ÇÇ.symm p.1 p.2.2‚ü©
#align trivialization.prod.inv_fun' Trivialization.Prod.invFun'

variable {Œµ‚ÇÅ Œµ‚ÇÇ}

theorem Prod.left_inv {x : TotalSpace (E‚ÇÅ √ó·µá E‚ÇÇ)}
    (h : x ‚àà @TotalSpace.proj B (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Åª¬π' (Œµ‚ÇÅ.baseSet ‚à© Œµ‚ÇÇ.baseSet)) :
    Prod.invFun' Œµ‚ÇÅ Œµ‚ÇÇ (Prod.toFun' Œµ‚ÇÅ Œµ‚ÇÇ x) = x := by
  obtain ‚ü®x, v‚ÇÅ, v‚ÇÇ‚ü© := x
  obtain ‚ü®h‚ÇÅ : x ‚àà Œµ‚ÇÅ.base_set, h‚ÇÇ : x ‚àà Œµ‚ÇÇ.base_set‚ü© := h
  simp only [prod.to_fun', prod.inv_fun', symm_apply_apply_mk, h‚ÇÅ, h‚ÇÇ]
#align trivialization.prod.left_inv Trivialization.Prod.left_inv

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem Prod.right_inv {x : B √ó F‚ÇÅ' √ó F‚ÇÇ'} (h : x ‚àà (Œµ‚ÇÅ.baseSet ‚à© Œµ‚ÇÇ.baseSet) √óÀ¢ (univ : Set (F‚ÇÅ' √ó F‚ÇÇ'))) :
    Prod.toFun' Œµ‚ÇÅ Œµ‚ÇÇ (Prod.invFun' Œµ‚ÇÅ Œµ‚ÇÇ x) = x := by
  obtain ‚ü®x, w‚ÇÅ, w‚ÇÇ‚ü© := x
  obtain ‚ü®‚ü®h‚ÇÅ : x ‚àà Œµ‚ÇÅ.base_set, h‚ÇÇ : x ‚àà Œµ‚ÇÇ.base_set‚ü©, -‚ü© := h
  simp only [prod.to_fun', prod.inv_fun', apply_mk_symm, h‚ÇÅ, h‚ÇÇ]
#align trivialization.prod.right_inv Trivialization.Prod.right_inv

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem Prod.continuous_inv_fun : ContinuousOn (Prod.invFun' Œµ‚ÇÅ Œµ‚ÇÇ) ((Œµ‚ÇÅ.baseSet ‚à© Œµ‚ÇÇ.baseSet) √óÀ¢ univ) := by
  rw [(prod.inducing_diag E‚ÇÅ E‚ÇÇ).continuous_on_iff]
  have H‚ÇÅ : Continuous fun p : B √ó F‚ÇÅ' √ó F‚ÇÇ' => ((p.1, p.2.1), (p.1, p.2.2)) :=
    (continuous_id.prod_map continuous_fst).prod_mk (continuous_id.prod_map continuous_snd)
  refine' (Œµ‚ÇÅ.continuous_on_symm.prod_map Œµ‚ÇÇ.continuous_on_symm).comp H‚ÇÅ.continuous_on _
  exact fun x h => ‚ü®‚ü®h.1.1, mem_univ _‚ü©, ‚ü®h.1.2, mem_univ _‚ü©‚ü©
#align trivialization.prod.continuous_inv_fun Trivialization.Prod.continuous_inv_fun

variable (e‚ÇÅ e‚ÇÇ Œµ‚ÇÅ Œµ‚ÇÇ R)

variable [‚àÄ x : B, TopologicalSpace (E‚ÇÅ x)] [‚àÄ x : B, TopologicalSpace (E‚ÇÇ x)] [FiberBundle F‚ÇÅ' E‚ÇÅ] [FiberBundle F‚ÇÇ' E‚ÇÇ]
  [FiberBundle F‚ÇÅ E‚ÇÅ] [FiberBundle F‚ÇÇ E‚ÇÇ]

/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- Given trivializations `Œµ‚ÇÅ`, `Œµ‚ÇÇ` for fiber bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the induced
trivialization for the fibrewise product of `E‚ÇÅ` and `E‚ÇÇ`, whose base set is
`Œµ‚ÇÅ.base_set ‚à© Œµ‚ÇÇ.base_set`. -/
@[nolint unused_arguments]
def prod : Trivialization (F‚ÇÅ' √ó F‚ÇÇ') (œÄ (E‚ÇÅ √ó·µá E‚ÇÇ)) where
  toFun := Prod.toFun' Œµ‚ÇÅ Œµ‚ÇÇ
  invFun := Prod.invFun' Œµ‚ÇÅ Œµ‚ÇÇ
  source := @TotalSpace.proj B (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Åª¬π' (Œµ‚ÇÅ.baseSet ‚à© Œµ‚ÇÇ.baseSet)
  target := (Œµ‚ÇÅ.baseSet ‚à© Œµ‚ÇÇ.baseSet) √óÀ¢ Set.univ
  map_source' x h := ‚ü®h, Set.mem_univ _‚ü©
  map_target' x h := h.1
  left_inv' x := Prod.left_inv
  right_inv' x := Prod.right_inv
  open_source := by
    refine' (Œµ‚ÇÅ.open_base_set.inter Œµ‚ÇÇ.open_base_set).Preimage _
    have : Continuous (@total_space.proj B E‚ÇÅ) := continuous_proj F‚ÇÅ' E‚ÇÅ
    exact this.comp (prod.inducing_diag E‚ÇÅ E‚ÇÇ).Continuous.fst
  open_target := (Œµ‚ÇÅ.open_base_set.inter Œµ‚ÇÇ.open_base_set).Prod is_open_univ
  continuous_to_fun := Prod.continuous_to_fun
  continuous_inv_fun := Prod.continuous_inv_fun
  baseSet := Œµ‚ÇÅ.baseSet ‚à© Œµ‚ÇÇ.baseSet
  open_base_set := Œµ‚ÇÅ.open_base_set.inter Œµ‚ÇÇ.open_base_set
  source_eq := rfl
  target_eq := rfl
  proj_to_fun x h := rfl
#align trivialization.prod Trivialization.prod

omit nz‚ÇÅ nz‚ÇÇ Œµ‚ÇÅ Œµ‚ÇÇ

include mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

instance prod.is_linear [e‚ÇÅ.is_linear R] [e‚ÇÇ.is_linear R] :
    (e‚ÇÅ.Prod e‚ÇÇ).is_linear
      R where linear := fun x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => (((e‚ÇÅ.linear R h‚ÇÅ).mk' _).prod_map ((e‚ÇÇ.linear R h‚ÇÇ).mk' _)).is_linear
#align trivialization.prod.is_linear Trivialization.prod.is_linear

omit mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

include nz‚ÇÅ nz‚ÇÇ

@[simp]
theorem base_set_prod : (prod Œµ‚ÇÅ Œµ‚ÇÇ).baseSet = Œµ‚ÇÅ.baseSet ‚à© Œµ‚ÇÇ.baseSet :=
  rfl
#align trivialization.base_set_prod Trivialization.base_set_prod

omit nz‚ÇÅ nz‚ÇÇ

include mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

variable {e‚ÇÅ e‚ÇÇ Œµ‚ÇÅ Œµ‚ÇÇ}

variable (R)

theorem prod_apply [e‚ÇÅ.is_linear R] [e‚ÇÇ.is_linear R] {x : B} (hx‚ÇÅ : x ‚àà e‚ÇÅ.baseSet) (hx‚ÇÇ : x ‚àà e‚ÇÇ.baseSet) (v‚ÇÅ : E‚ÇÅ x)
    (v‚ÇÇ : E‚ÇÇ x) :
    prod e‚ÇÅ e‚ÇÇ ‚ü®x, (v‚ÇÅ, v‚ÇÇ)‚ü© = ‚ü®x, e‚ÇÅ.continuousLinearEquivAt R x hx‚ÇÅ v‚ÇÅ, e‚ÇÇ.continuousLinearEquivAt R x hx‚ÇÇ v‚ÇÇ‚ü© :=
  rfl
#align trivialization.prod_apply Trivialization.prod_apply

omit mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

include nz‚ÇÅ nz‚ÇÇ

theorem prod_symm_apply (x : B) (w‚ÇÅ : F‚ÇÅ') (w‚ÇÇ : F‚ÇÇ') :
    (prod Œµ‚ÇÅ Œµ‚ÇÇ).toLocalEquiv.symm (x, w‚ÇÅ, w‚ÇÇ) = ‚ü®x, Œµ‚ÇÅ.symm x w‚ÇÅ, Œµ‚ÇÇ.symm x w‚ÇÇ‚ü© :=
  rfl
#align trivialization.prod_symm_apply Trivialization.prod_symm_apply

end Trivialization

open Trivialization

variable [nz‚ÇÅ : ‚àÄ x, Zero (E‚ÇÅ x)] [nz‚ÇÇ : ‚àÄ x, Zero (E‚ÇÇ x)] [mnd‚ÇÅ : ‚àÄ x, AddCommMonoid (E‚ÇÅ x)]
  [mdl‚ÇÅ : ‚àÄ x, Module R (E‚ÇÅ x)] [mnd‚ÇÇ : ‚àÄ x, AddCommMonoid (E‚ÇÇ x)] [mdl‚ÇÇ : ‚àÄ x, Module R (E‚ÇÇ x)]

variable [‚àÄ x : B, TopologicalSpace (E‚ÇÅ x)] [‚àÄ x : B, TopologicalSpace (E‚ÇÇ x)] [FiberBundle F‚ÇÅ' E‚ÇÅ] [FiberBundle F‚ÇÇ' E‚ÇÇ]
  [FiberBundle F‚ÇÅ E‚ÇÅ] [FiberBundle F‚ÇÇ E‚ÇÇ]

include nz‚ÇÅ nz‚ÇÇ

/-- The product of two fiber bundles is a fiber bundle. -/
instance _root_.bundle.prod.fiber_bundle : FiberBundle (F‚ÇÅ' √ó F‚ÇÇ') (E‚ÇÅ √ó·µá E‚ÇÇ) where
  total_space_mk_inducing b := by
    rw [(prod.inducing_diag E‚ÇÅ E‚ÇÇ).inducing_iff]
    exact (total_space_mk_inducing F‚ÇÅ' E‚ÇÅ b).prod_mk (total_space_mk_inducing F‚ÇÇ' E‚ÇÇ b)
  trivializationAtlas :=
    { e |
      ‚àÉ (e‚ÇÅ : Trivialization F‚ÇÅ' (œÄ E‚ÇÅ))(e‚ÇÇ : Trivialization F‚ÇÇ' (œÄ E‚ÇÇ))(_ : MemTrivializationAtlas e‚ÇÅ)(_ :
        MemTrivializationAtlas e‚ÇÇ), e = Trivialization.prod e‚ÇÅ e‚ÇÇ }
  trivializationAt b := (trivializationAt F‚ÇÅ' E‚ÇÅ b).Prod (trivializationAt F‚ÇÇ' E‚ÇÇ b)
  mem_base_set_trivialization_at b := ‚ü®mem_base_set_trivialization_at F‚ÇÅ' E‚ÇÅ b, mem_base_set_trivialization_at F‚ÇÇ' E‚ÇÇ b‚ü©
  trivialization_mem_atlas b :=
    ‚ü®trivializationAt F‚ÇÅ' E‚ÇÅ b, trivializationAt F‚ÇÇ' E‚ÇÇ b, by infer_instance, by infer_instance, rfl‚ü©
#align _root_.bundle.prod.fiber_bundle _root_.bundle.prod.fiber_bundle

omit nz‚ÇÅ nz‚ÇÇ

include mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

/-- The product of two vector bundles is a vector bundle. -/
instance _root_.bundle.prod.vector_bundle [VectorBundle R F‚ÇÅ E‚ÇÅ] [VectorBundle R F‚ÇÇ E‚ÇÇ] :
    VectorBundle R (F‚ÇÅ √ó F‚ÇÇ) (E‚ÇÅ √ó·µá E‚ÇÇ) where
  trivialization_linear' := by
    rintro _ ‚ü®e‚ÇÅ, e‚ÇÇ, he‚ÇÅ, he‚ÇÇ, rfl‚ü©
    skip
    infer_instance
  continuous_on_coord_change' := by
    rintro _ _ ‚ü®e‚ÇÅ, e‚ÇÇ, he‚ÇÅ, he‚ÇÇ, rfl‚ü© ‚ü®e‚ÇÅ', e‚ÇÇ', he‚ÇÅ', he‚ÇÇ', rfl‚ü©
    skip
    refine'
        (((continuous_on_coord_change R e‚ÇÅ e‚ÇÅ').mono _).prodMapL R ((continuous_on_coord_change R e‚ÇÇ e‚ÇÇ').mono _)).congr
          _ <;>
      dsimp only [base_set_prod, mfld_simps]
    ¬∑ mfld_set_tac
      
    ¬∑ mfld_set_tac
      
    ¬∑ rintro b hb
      rw [ContinuousLinearMap.ext_iff]
      rintro ‚ü®v‚ÇÅ, v‚ÇÇ‚ü©
      show
        (e‚ÇÅ.prod e‚ÇÇ).coordChangeL R (e‚ÇÅ'.prod e‚ÇÇ') b (v‚ÇÅ, v‚ÇÇ) =
          (e‚ÇÅ.coord_changeL R e‚ÇÅ' b v‚ÇÅ, e‚ÇÇ.coord_changeL R e‚ÇÇ' b v‚ÇÇ)
      rw [e‚ÇÅ.coord_changeL_apply e‚ÇÅ', e‚ÇÇ.coord_changeL_apply e‚ÇÇ', (e‚ÇÅ.prod e‚ÇÇ).coord_changeL_apply']
      exacts[rfl, hb, ‚ü®hb.1.2, hb.2.2‚ü©, ‚ü®hb.1.1, hb.2.1‚ü©]
      
#align _root_.bundle.prod.vector_bundle _root_.bundle.prod.vector_bundle

omit mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

include nz‚ÇÅ nz‚ÇÇ

instance _root_.bundle.prod.mem_trivialization_atlas {e‚ÇÅ : Trivialization F‚ÇÅ' (œÄ E‚ÇÅ)} {e‚ÇÇ : Trivialization F‚ÇÇ' (œÄ E‚ÇÇ)}
    [MemTrivializationAtlas e‚ÇÅ] [MemTrivializationAtlas e‚ÇÇ] :
    MemTrivializationAtlas
      (e‚ÇÅ.Prod e‚ÇÇ :
        Trivialization (F‚ÇÅ' √ó F‚ÇÇ') (œÄ (E‚ÇÅ √ó·µá E‚ÇÇ))) where out := ‚ü®e‚ÇÅ, e‚ÇÇ, by infer_instance, by infer_instance, rfl‚ü©
#align _root_.bundle.prod.mem_trivialization_atlas _root_.bundle.prod.mem_trivialization_atlas

variable {R F‚ÇÅ E‚ÇÅ F‚ÇÇ E‚ÇÇ}

omit nz‚ÇÅ nz‚ÇÇ

include mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

@[simp]
theorem Trivialization.continuous_linear_equiv_at_prod {e‚ÇÅ : Trivialization F‚ÇÅ (œÄ E‚ÇÅ)} {e‚ÇÇ : Trivialization F‚ÇÇ (œÄ E‚ÇÇ)}
    [e‚ÇÅ.is_linear R] [e‚ÇÇ.is_linear R] {x : B} (hx‚ÇÅ : x ‚àà e‚ÇÅ.baseSet) (hx‚ÇÇ : x ‚àà e‚ÇÇ.baseSet) :
    (e‚ÇÅ.Prod e‚ÇÇ).continuousLinearEquivAt R x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü© =
      (e‚ÇÅ.continuousLinearEquivAt R x hx‚ÇÅ).Prod (e‚ÇÇ.continuousLinearEquivAt R x hx‚ÇÇ) :=
  by
  ext1
  funext v
  obtain ‚ü®v‚ÇÅ, v‚ÇÇ‚ü© := v
  rw [(e‚ÇÅ.prod e‚ÇÇ).continuous_linear_equiv_at_apply R, Trivialization.prod]
  exact (congr_arg Prod.snd (prod_apply R hx‚ÇÅ hx‚ÇÇ v‚ÇÅ v‚ÇÇ) : _)
#align trivialization.continuous_linear_equiv_at_prod Trivialization.continuous_linear_equiv_at_prod

