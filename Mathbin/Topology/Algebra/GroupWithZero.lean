import Mathbin.Topology.Algebra.Monoid 
import Mathbin.Algebra.Group.Pi 
import Mathbin.Topology.Homeomorph

/-!
# Topological group with zero

In this file we define `has_continuous_inv'` to be a mixin typeclass a type with `has_inv` and
`has_zero` (e.g., a `group_with_zero`) such that `Œª x, x‚Åª¬π` is continuous at all nonzero points. Any
normed (semi)field has this property. Currently the only example of `has_continuous_inv'` in
`mathlib` which is not a normed field is the type `nnnreal` (a.k.a. `‚Ñù‚â•0`) of nonnegative real
numbers.

Then we prove lemmas about continuity of `x ‚Ü¶ x‚Åª¬π` and `f / g` providing dot-style `*.inv'` and
`*.div` operations on `filter.tendsto`, `continuous_at`, `continuous_within_at`, `continuous_on`,
and `continuous`. As a special case, we provide `*.div_const` operations that require only
`group_with_zero` and `has_continuous_mul` instances.

All lemmas about `(‚Åª¬π)` use `inv'` in their names because lemmas without `'` are used for
`topological_group`s. We also use `'` in the typeclass name `has_continuous_inv'` for the sake of
consistency of notation.

On a `group_with_zero` with continuous multiplication, we also define left and right multiplication
as homeomorphisms.
-/


open_locale TopologicalSpace Filter

open Filter Function

/-!
### A group with zero with continuous multiplication

If `G‚ÇÄ` is a group with zero with continuous `(*)`, then `(/y)` is continuous for any `y`. In this
section we prove lemmas that immediately follow from this fact providing `*.div_const` dot-style
operations on `filter.tendsto`, `continuous_at`, `continuous_within_at`, `continuous_on`, and
`continuous`.
-/


variable{Œ± Œ≤ G‚ÇÄ : Type _}

section DivConst

variable[GroupWithZero‚Çì G‚ÇÄ][TopologicalSpace G‚ÇÄ][HasContinuousMul G‚ÇÄ]{f : Œ± ‚Üí G‚ÇÄ}{s : Set Œ±}{l : Filter Œ±}

theorem Filter.Tendsto.div_const {x y : G‚ÇÄ} (hf : tendsto f l (ùìù x)) : tendsto (fun a => f a / y) l (ùìù (x / y)) :=
  by 
    simpa only [div_eq_mul_inv] using hf.mul tendsto_const_nhds

variable[TopologicalSpace Œ±]

theorem ContinuousAt.div_const {a : Œ±} (hf : ContinuousAt f a) {y : G‚ÇÄ} : ContinuousAt (fun x => f x / y) a :=
  by 
    simpa only [div_eq_mul_inv] using hf.mul continuous_at_const

theorem ContinuousWithinAt.div_const {a} (hf : ContinuousWithinAt f s a) {y : G‚ÇÄ} :
  ContinuousWithinAt (fun x => f x / y) s a :=
  hf.div_const

theorem ContinuousOn.div_const (hf : ContinuousOn f s) {y : G‚ÇÄ} : ContinuousOn (fun x => f x / y) s :=
  by 
    simpa only [div_eq_mul_inv] using hf.mul continuous_on_const

@[continuity]
theorem Continuous.div_const (hf : Continuous f) {y : G‚ÇÄ} : Continuous fun x => f x / y :=
  by 
    simpa only [div_eq_mul_inv] using hf.mul continuous_const

end DivConst

/-- A type with `0` and `has_inv` such that `Œª x, x‚Åª¬π` is continuous at all nonzero points. Any
normed (semi)field has this property. -/
class HasContinuousInv‚ÇÄ(G‚ÇÄ : Type _)[HasZero G‚ÇÄ][HasInv G‚ÇÄ][TopologicalSpace G‚ÇÄ] where 
  continuous_at_inv‚ÇÄ : ‚àÄ ‚¶Éx : G‚ÇÄ‚¶Ñ, x ‚â† 0 ‚Üí ContinuousAt HasInv.inv x

export HasContinuousInv‚ÇÄ(continuous_at_inv‚ÇÄ)

section Inv‚ÇÄ

variable[HasZero G‚ÇÄ][HasInv G‚ÇÄ][TopologicalSpace G‚ÇÄ][HasContinuousInv‚ÇÄ G‚ÇÄ]{l : Filter Œ±}{f : Œ± ‚Üí G‚ÇÄ}{s : Set Œ±}{a : Œ±}

/-!
### Continuity of `Œª x, x‚Åª¬π` at a non-zero point

We define `topological_group_with_zero` to be a `group_with_zero` such that the operation `x ‚Ü¶ x‚Åª¬π`
is continuous at all nonzero points. In this section we prove dot-style `*.inv'` lemmas for
`filter.tendsto`, `continuous_at`, `continuous_within_at`, `continuous_on`, and `continuous`.
-/


theorem tendsto_inv‚ÇÄ {x : G‚ÇÄ} (hx : x ‚â† 0) : tendsto HasInv.inv (ùìù x) (ùìù (x‚Åª¬π)) :=
  continuous_at_inv‚ÇÄ hx

theorem continuous_on_inv‚ÇÄ : ContinuousOn (HasInv.inv : G‚ÇÄ ‚Üí G‚ÇÄ) (¬´expr ·∂ú¬ª {0}) :=
  fun x hx => (continuous_at_inv‚ÇÄ hx).ContinuousWithinAt

/-- If a function converges to a nonzero value, its inverse converges to the inverse of this value.
We use the name `tendsto.inv‚ÇÄ` as `tendsto.inv` is already used in multiplicative topological
groups. -/
theorem Filter.Tendsto.inv‚ÇÄ {a : G‚ÇÄ} (hf : tendsto f l (ùìù a)) (ha : a ‚â† 0) : tendsto (fun x => f x‚Åª¬π) l (ùìù (a‚Åª¬π)) :=
  (tendsto_inv‚ÇÄ ha).comp hf

variable[TopologicalSpace Œ±]

theorem ContinuousWithinAt.inv‚ÇÄ (hf : ContinuousWithinAt f s a) (ha : f a ‚â† 0) :
  ContinuousWithinAt (fun x => f x‚Åª¬π) s a :=
  hf.inv‚ÇÄ ha

theorem ContinuousAt.inv‚ÇÄ (hf : ContinuousAt f a) (ha : f a ‚â† 0) : ContinuousAt (fun x => f x‚Åª¬π) a :=
  hf.inv‚ÇÄ ha

@[continuity]
theorem Continuous.inv‚ÇÄ (hf : Continuous f) (h0 : ‚àÄ x, f x ‚â† 0) : Continuous fun x => f x‚Åª¬π :=
  continuous_iff_continuous_at.2$ fun x => (hf.tendsto x).inv‚ÇÄ (h0 x)

theorem ContinuousOn.inv‚ÇÄ (hf : ContinuousOn f s) (h0 : ‚àÄ x (_ : x ‚àà s), f x ‚â† 0) : ContinuousOn (fun x => f x‚Åª¬π) s :=
  fun x hx => (hf x hx).inv‚ÇÄ (h0 x hx)

end Inv‚ÇÄ

/-!
### Continuity of division

If `G‚ÇÄ` is a `group_with_zero` with `x ‚Ü¶ x‚Åª¬π` continuous at all nonzero points and `(*)`, then
division `(/)` is continuous at any point where the denominator is continuous.
-/


section Div

variable[GroupWithZero‚Çì G‚ÇÄ][TopologicalSpace G‚ÇÄ][HasContinuousInv‚ÇÄ G‚ÇÄ][HasContinuousMul G‚ÇÄ]{f g : Œ± ‚Üí G‚ÇÄ}

theorem Filter.Tendsto.div {l : Filter Œ±} {a b : G‚ÇÄ} (hf : tendsto f l (ùìù a)) (hg : tendsto g l (ùìù b)) (hy : b ‚â† 0) :
  tendsto (f / g) l (ùìù (a / b)) :=
  by 
    simpa only [div_eq_mul_inv] using hf.mul (hg.inv‚ÇÄ hy)

variable[TopologicalSpace Œ±][TopologicalSpace Œ≤]{s : Set Œ±}{a : Œ±}

theorem ContinuousWithinAt.div (hf : ContinuousWithinAt f s a) (hg : ContinuousWithinAt g s a) (h‚ÇÄ : g a ‚â† 0) :
  ContinuousWithinAt (f / g) s a :=
  hf.div hg h‚ÇÄ

theorem ContinuousOn.div (hf : ContinuousOn f s) (hg : ContinuousOn g s) (h‚ÇÄ : ‚àÄ x (_ : x ‚àà s), g x ‚â† 0) :
  ContinuousOn (f / g) s :=
  fun x hx => (hf x hx).div (hg x hx) (h‚ÇÄ x hx)

/-- Continuity at a point of the result of dividing two functions continuous at that point, where
the denominator is nonzero. -/
theorem ContinuousAt.div (hf : ContinuousAt f a) (hg : ContinuousAt g a) (h‚ÇÄ : g a ‚â† 0) : ContinuousAt (f / g) a :=
  hf.div hg h‚ÇÄ

@[continuity]
theorem Continuous.div (hf : Continuous f) (hg : Continuous g) (h‚ÇÄ : ‚àÄ x, g x ‚â† 0) : Continuous (f / g) :=
  by 
    simpa only [div_eq_mul_inv] using hf.mul (hg.inv‚ÇÄ h‚ÇÄ)

-- error in Topology.Algebra.GroupWithZero: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_on_div : continuous_on (Œª p : ¬´expr √ó ¬ª(G‚ÇÄ, G‚ÇÄ), ¬´expr / ¬ª(p.1, p.2)) {p | ¬´expr ‚â† ¬ª(p.2, 0)} :=
¬´expr $ ¬ª(continuous_on_fst.div continuous_on_snd, Œª _, id)

/-- The function `f x / g x` is discontinuous when `g x = 0`.
However, under appropriate conditions, `h x (f x / g x)` is still continuous.
The condition is that if `g a = 0` then `h x y` must tend to `h a 0` when `x` tends to `a`,
with no information about `y`. This is represented by the `‚ä§` filter.
Note: `filter.tendsto_prod_top_iff` characterizes this convergence in uniform spaces.
See also `filter.prod_top` and `filter.mem_prod_top`. -/
theorem ContinuousAt.comp_div_cases {f g : Œ± ‚Üí G‚ÇÄ} (h : Œ± ‚Üí G‚ÇÄ ‚Üí Œ≤) (hf : ContinuousAt f a) (hg : ContinuousAt g a)
  (hh : g a ‚â† 0 ‚Üí ContinuousAt (¬´expr‚Üø ¬ª h) (a, f a / g a))
  (h2h : g a = 0 ‚Üí tendsto (¬´expr‚Üø ¬ª h) (ùìù a √ó·∂† ‚ä§) (ùìù (h a 0))) : ContinuousAt (fun x => h x (f x / g x)) a :=
  by 
    show ContinuousAt (¬´expr‚Üø ¬ª h ‚àò fun x => (x, f x / g x)) a 
    byCases' hga : g a = 0
    ¬∑
      rw [ContinuousAt]
      simpRw [comp_app, hga, div_zero]
      exact (h2h hga).comp (continuous_at_id.prod_mk tendsto_top)
    ¬∑
      exact ContinuousAt.comp (hh hga) (continuous_at_id.prod (hf.div hg hga))

/-- `h x (f x / g x)` is continuous under certain conditions, even if the denominator is sometimes
  `0`. See docstring of `continuous_at.comp_div_cases`. -/
theorem Continuous.comp_div_cases {f g : Œ± ‚Üí G‚ÇÄ} (h : Œ± ‚Üí G‚ÇÄ ‚Üí Œ≤) (hf : Continuous f) (hg : Continuous g)
  (hh : ‚àÄ a, g a ‚â† 0 ‚Üí ContinuousAt (¬´expr‚Üø ¬ª h) (a, f a / g a))
  (h2h : ‚àÄ a, g a = 0 ‚Üí tendsto (¬´expr‚Üø ¬ª h) (ùìù a √ó·∂† ‚ä§) (ùìù (h a 0))) : Continuous fun x => h x (f x / g x) :=
  continuous_iff_continuous_at.mpr$ fun a => hf.continuous_at.comp_div_cases _ hg.continuous_at (hh a) (h2h a)

end Div

/-! ### Left and right multiplication as homeomorphisms -/


namespace Homeomorph

variable[TopologicalSpace Œ±][GroupWithZero‚Çì Œ±][HasContinuousMul Œ±]

/-- Left multiplication by a nonzero element in a `group_with_zero` with continuous multiplication
is a homeomorphism of the underlying type. -/
protected def mul_left‚ÇÄ (c : Œ±) (hc : c ‚â† 0) : Œ± ‚âÉ‚Çú Œ± :=
  { Equiv.mulLeft‚ÇÄ c hc with continuous_to_fun := continuous_mul_left _, continuous_inv_fun := continuous_mul_left _ }

/-- Right multiplication by a nonzero element in a `group_with_zero` with continuous multiplication
is a homeomorphism of the underlying type. -/
protected def mul_right‚ÇÄ (c : Œ±) (hc : c ‚â† 0) : Œ± ‚âÉ‚Çú Œ± :=
  { Equiv.mulRight‚ÇÄ c hc with continuous_to_fun := continuous_mul_right _,
    continuous_inv_fun := continuous_mul_right _ }

@[simp]
theorem coe_mul_left‚ÇÄ (c : Œ±) (hc : c ‚â† 0) : ¬´expr‚áë ¬ª (Homeomorph.mulLeft‚ÇÄ c hc) = (¬∑*¬∑) c :=
  rfl

@[simp]
theorem mul_left‚ÇÄ_symm_apply (c : Œ±) (hc : c ‚â† 0) : ((Homeomorph.mulLeft‚ÇÄ c hc).symm : Œ± ‚Üí Œ±) = (¬∑*¬∑) (c‚Åª¬π) :=
  rfl

@[simp]
theorem coe_mul_right‚ÇÄ (c : Œ±) (hc : c ‚â† 0) : ¬´expr‚áë ¬ª (Homeomorph.mulRight‚ÇÄ c hc) = fun x => x*c :=
  rfl

@[simp]
theorem mul_right‚ÇÄ_symm_apply (c : Œ±) (hc : c ‚â† 0) : ((Homeomorph.mulRight‚ÇÄ c hc).symm : Œ± ‚Üí Œ±) = fun x => x*c‚Åª¬π :=
  rfl

end Homeomorph

section Zpow

variable[GroupWithZero‚Çì G‚ÇÄ][TopologicalSpace G‚ÇÄ][HasContinuousInv‚ÇÄ G‚ÇÄ][HasContinuousMul G‚ÇÄ]

-- error in Topology.Algebra.GroupWithZero: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem continuous_at_zpow
(x : G‚ÇÄ)
(m : expr‚Ñ§())
(h : ¬´expr ‚à® ¬ª(¬´expr ‚â† ¬ª(x, 0), ¬´expr ‚â§ ¬ª(0, m))) : continuous_at (Œª x, ¬´expr ^ ¬ª(x, m)) x :=
begin
  cases [expr m] [],
  { simpa [] [] ["only"] ["[", expr zpow_of_nat, "]"] [] ["using", expr continuous_at_pow x m] },
  { simp [] [] ["only"] ["[", expr zpow_neg_succ_of_nat, "]"] [] [],
    have [ident hx] [":", expr ¬´expr ‚â† ¬ª(x, 0)] [],
    from [expr h.resolve_right (int.neg_succ_of_nat_lt_zero m).not_le],
    exact [expr (continuous_at_pow x ¬´expr + ¬ª(m, 1)).inv‚ÇÄ (pow_ne_zero _ hx)] }
end

-- error in Topology.Algebra.GroupWithZero: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_on_zpow (m : expr‚Ñ§()) : continuous_on (Œª x : G‚ÇÄ, ¬´expr ^ ¬ª(x, m)) ¬´expr ·∂ú¬ª({0}) :=
Œª x hx, (continuous_at_zpow _ _ (or.inl hx)).continuous_within_at

theorem Filter.Tendsto.zpow {f : Œ± ‚Üí G‚ÇÄ} {l : Filter Œ±} {a : G‚ÇÄ} (hf : tendsto f l (ùìù a)) (m : ‚Ñ§) (h : a ‚â† 0 ‚à® 0 ‚â§ m) :
  tendsto (fun x => f x ^ m) l (ùìù (a ^ m)) :=
  (continuous_at_zpow _ m h).Tendsto.comp hf

variable{X : Type _}[TopologicalSpace X]{a : X}{s : Set X}{f : X ‚Üí G‚ÇÄ}

theorem ContinuousAt.zpow (hf : ContinuousAt f a) (m : ‚Ñ§) (h : f a ‚â† 0 ‚à® 0 ‚â§ m) : ContinuousAt (fun x => f x ^ m) a :=
  hf.zpow m h

theorem ContinuousWithinAt.zpow (hf : ContinuousWithinAt f s a) (m : ‚Ñ§) (h : f a ‚â† 0 ‚à® 0 ‚â§ m) :
  ContinuousWithinAt (fun x => f x ^ m) s a :=
  hf.zpow m h

theorem ContinuousOn.zpow (hf : ContinuousOn f s) (m : ‚Ñ§) (h : ‚àÄ a (_ : a ‚àà s), f a ‚â† 0 ‚à® 0 ‚â§ m) :
  ContinuousOn (fun x => f x ^ m) s :=
  fun a ha => (hf a ha).zpow m (h a ha)

@[continuity]
theorem Continuous.zpow (hf : Continuous f) (m : ‚Ñ§) (h0 : ‚àÄ a, f a ‚â† 0 ‚à® 0 ‚â§ m) : Continuous fun x => f x ^ m :=
  continuous_iff_continuous_at.2$ fun x => (hf.tendsto x).zpow m (h0 x)

end Zpow

