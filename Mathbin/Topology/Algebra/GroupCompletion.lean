/-
Copyright (c) 2018 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Johannes Hölzl

! This file was ported from Lean 3 source module topology.algebra.group_completion
! leanprover-community/mathlib commit f47581155c818e6361af4e4fda60d27d020c226b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Algebra.UniformGroup
import Mathbin.Topology.Algebra.UniformMulAction
import Mathbin.Topology.UniformSpace.Completion

/-!
# Completion of topological groups:

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This files endows the completion of a topological abelian group with a group structure.
More precisely the instance `uniform_space.completion.add_group` builds an abelian group structure
on the completion of an abelian group endowed with a compatible uniform structure.
Then the instance `uniform_space.completion.uniform_add_group` proves this group structure is
compatible with the completed uniform structure. The compatibility condition is `uniform_add_group`.

## Main declarations:

Beyond the instances explained above (that don't have to be explicitly invoked),
the main constructions deal with continuous group morphisms.

* `add_monoid_hom.extension`: extends a continuous group morphism from `G`
  to a complete separated group `H` to `completion G`.
* `add_monoid_hom.completion`: promotes a continuous group morphism
  from `G` to `H` into a continuous group morphism
  from `completion G` to `completion H`.
-/


noncomputable section

variable {M R α β : Type _}

section Group

open UniformSpace CauchyFilter Filter Set

variable [UniformSpace α]

instance [Zero α] : Zero (Completion α) :=
  ⟨(0 : α)⟩

instance [Neg α] : Neg (Completion α) :=
  ⟨Completion.map (fun a => -a : α → α)⟩

instance [Add α] : Add (Completion α) :=
  ⟨Completion.map₂ (· + ·)⟩

instance [Sub α] : Sub (Completion α) :=
  ⟨Completion.map₂ Sub.sub⟩

/- warning: uniform_space.completion.coe_zero -> UniformSpace.Completion.coe_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : Zero.{u1} α], Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α _inst_2)))) (OfNat.ofNat.{u1} (UniformSpace.Completion.{u1} α _inst_1) 0 (OfNat.mk.{u1} (UniformSpace.Completion.{u1} α _inst_1) 0 (Zero.zero.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasZero.{u1} α _inst_1 _inst_2))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : Zero.{u1} α], Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.coe'.{u1} α _inst_1 (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α _inst_2))) (OfNat.ofNat.{u1} (UniformSpace.Completion.{u1} α _inst_1) 0 (Zero.toOfNat0.{u1} (UniformSpace.Completion.{u1} α _inst_1) (instZeroCompletion.{u1} α _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.coe_zero UniformSpace.Completion.coe_zeroₓ'. -/
@[norm_cast]
theorem UniformSpace.Completion.coe_zero [Zero α] : ((0 : α) : Completion α) = 0 :=
  rfl
#align uniform_space.completion.coe_zero UniformSpace.Completion.coe_zero

end Group

namespace UniformSpace.Completion

open UniformSpace

section Zero

instance [UniformSpace α] [MonoidWithZero M] [Zero α] [MulActionWithZero M α]
    [UniformContinuousConstSMul M α] : MulActionWithZero M (Completion α) :=
  { Completion.mulAction M α with
    smul := (· • ·)
    smul_zero := fun r => by rw [← coe_zero, ← coe_smul, MulActionWithZero.smul_zero r]
    zero_smul :=
      ext' (continuous_const_smul _) continuous_const fun a => by
        rw [← coe_smul, zero_smul, coe_zero] }

end Zero

section UniformAddGroup

variable [UniformSpace α] [AddGroup α] [UniformAddGroup α]

/- warning: uniform_space.completion.coe_neg -> UniformSpace.Completion.coe_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] (a : α), Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)) a)) (Neg.neg.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasNeg.{u1} α _inst_1 (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] (a : α), Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.coe'.{u1} α _inst_1 (Neg.neg.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (AddGroup.toSubtractionMonoid.{u1} α _inst_2)))) a)) (Neg.neg.{u1} (UniformSpace.Completion.{u1} α _inst_1) (instNegCompletion.{u1} α _inst_1 (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (AddGroup.toSubtractionMonoid.{u1} α _inst_2))))) (UniformSpace.Completion.coe'.{u1} α _inst_1 a))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.coe_neg UniformSpace.Completion.coe_negₓ'. -/
@[norm_cast]
theorem coe_neg (a : α) : ((-a : α) : Completion α) = -a :=
  (map_coe uniformContinuous_neg a).symm
#align uniform_space.completion.coe_neg UniformSpace.Completion.coe_neg

/- warning: uniform_space.completion.coe_sub -> UniformSpace.Completion.coe_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] (a : α) (b : α), Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) a b)) (HSub.hSub.{u1, u1, u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u1} α _inst_1) (instHSub.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasSub.{u1} α _inst_1 (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) a) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] (a : α) (b : α), Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.coe'.{u1} α _inst_1 (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) a b)) (HSub.hSub.{u1, u1, u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u1} α _inst_1) (instHSub.{u1} (UniformSpace.Completion.{u1} α _inst_1) (instSubCompletion.{u1} α _inst_1 (SubNegMonoid.toSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (UniformSpace.Completion.coe'.{u1} α _inst_1 a) (UniformSpace.Completion.coe'.{u1} α _inst_1 b))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.coe_sub UniformSpace.Completion.coe_subₓ'. -/
@[norm_cast]
theorem coe_sub (a b : α) : ((a - b : α) : Completion α) = a - b :=
  (map₂_coe_coe a b Sub.sub uniformContinuous_sub).symm
#align uniform_space.completion.coe_sub UniformSpace.Completion.coe_sub

/- warning: uniform_space.completion.coe_add -> UniformSpace.Completion.coe_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] (a : α) (b : α), Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))))) a b)) (HAdd.hAdd.{u1, u1, u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u1} α _inst_1) (instHAdd.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasAdd.{u1} α _inst_1 (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) a) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] (a : α) (b : α), Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.coe'.{u1} α _inst_1 (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))))) a b)) (HAdd.hAdd.{u1, u1, u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u1} α _inst_1) (instHAdd.{u1} (UniformSpace.Completion.{u1} α _inst_1) (instAddCompletion.{u1} α _inst_1 (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))))) (UniformSpace.Completion.coe'.{u1} α _inst_1 a) (UniformSpace.Completion.coe'.{u1} α _inst_1 b))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.coe_add UniformSpace.Completion.coe_addₓ'. -/
@[norm_cast]
theorem coe_add (a b : α) : ((a + b : α) : Completion α) = a + b :=
  (map₂_coe_coe a b (· + ·) uniformContinuous_add).symm
#align uniform_space.completion.coe_add UniformSpace.Completion.coe_add

instance : AddMonoid (Completion α) :=
  { Completion.hasZero,
    Completion.hasAdd with
    zero_add := fun a =>
      Completion.induction_on a
        (isClosed_eq (continuous_map₂ continuous_const continuous_id) continuous_id) fun a =>
        show 0 + (a : Completion α) = a by rw_mod_cast [zero_add]
    add_zero := fun a =>
      Completion.induction_on a
        (isClosed_eq (continuous_map₂ continuous_id continuous_const) continuous_id) fun a =>
        show (a : Completion α) + 0 = a by rw_mod_cast [add_zero]
    add_assoc := fun a b c =>
      Completion.induction_on₃ a b c
        (isClosed_eq
          (continuous_map₂ (continuous_map₂ continuous_fst (continuous_fst.comp continuous_snd))
            (continuous_snd.comp continuous_snd))
          (continuous_map₂ continuous_fst
            (continuous_map₂ (continuous_fst.comp continuous_snd)
              (continuous_snd.comp continuous_snd))))
        fun a b c =>
        show (a : Completion α) + b + c = a + (b + c) by repeat' rw_mod_cast [add_assoc]
    nsmul := (· • ·)
    nsmul_zero := fun a =>
      Completion.induction_on a (isClosed_eq continuous_map continuous_const) fun a => by
        rw [← coe_smul, ← coe_zero, zero_smul]
    nsmul_succ := fun n a =>
      Completion.induction_on a
        (isClosed_eq continuous_map <| continuous_map₂ continuous_id continuous_map) fun a => by
        rw_mod_cast [succ_nsmul] }

instance : SubNegMonoid (Completion α) :=
  { Completion.addMonoid, Completion.hasNeg,
    Completion.hasSub with
    sub_eq_add_neg := fun a b =>
      Completion.induction_on₂ a b
        (isClosed_eq (continuous_map₂ continuous_fst continuous_snd)
          (continuous_map₂ continuous_fst (Completion.continuous_map.comp continuous_snd)))
        fun a b => by exact_mod_cast congr_arg coe (sub_eq_add_neg a b)
    zsmul := (· • ·)
    zsmul_zero' := fun a =>
      Completion.induction_on a (isClosed_eq continuous_map continuous_const) fun a =>
        by
        rw_mod_cast [zero_smul]
        rfl
    zsmul_succ' := fun n a =>
      Completion.induction_on a
        (isClosed_eq continuous_map <| continuous_map₂ continuous_id continuous_map) fun a => by
        rw_mod_cast [show Int.ofNat n.succ • a = a + Int.ofNat n • a from
            SubNegMonoid.zsmul_succ' n a]
    zsmul_neg' := fun n a =>
      Completion.induction_on a
        (isClosed_eq continuous_map <| Completion.continuous_map.comp continuous_map) fun a => by
        rw [← coe_smul, ← coe_smul, ← coe_neg,
          show -[n+1] • a = -((n.succ : ℤ) • a) from SubNegMonoid.zsmul_neg' n a] }

instance : AddGroup (Completion α) :=
  { Completion.subNegMonoid with
    add_left_neg := fun a =>
      Completion.induction_on a
        (isClosed_eq (continuous_map₂ Completion.continuous_map continuous_id) continuous_const)
        fun a =>
        show -(a : Completion α) + a = 0
          by
          rw_mod_cast [add_left_neg]
          rfl }

instance : UniformAddGroup (Completion α) :=
  ⟨uniformContinuous_map₂ Sub.sub⟩

instance {M} [Monoid M] [DistribMulAction M α] [UniformContinuousConstSMul M α] :
    DistribMulAction M (Completion α) :=
  { Completion.mulAction M α with
    smul := (· • ·)
    smul_add := fun r x y =>
      induction_on₂ x y
        (isClosed_eq ((continuous_fst.add continuous_snd).const_smul _)
          ((continuous_fst.const_smul _).add (continuous_snd.const_smul _)))
        fun a b => by simp only [← coe_add, ← coe_smul, smul_add]
    smul_zero := fun r => by rw [← coe_zero, ← coe_smul, smul_zero r] }

/- warning: uniform_space.completion.to_compl -> UniformSpace.Completion.toCompl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2], AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2], AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.to_compl UniformSpace.Completion.toComplₓ'. -/
/-- The map from a group to its completion as a group hom. -/
@[simps]
def toCompl : α →+ Completion α where
  toFun := coe
  map_add' := coe_add
  map_zero' := coe_zero
#align uniform_space.completion.to_compl UniformSpace.Completion.toCompl

/- warning: uniform_space.completion.continuous_to_compl -> UniformSpace.Completion.continuous_toCompl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2], Continuous.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.uniformSpace.{u1} α _inst_1)) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3))) (fun (_x : AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3))) => α -> (UniformSpace.Completion.{u1} α _inst_1)) (AddMonoidHom.hasCoeToFun.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3))) (UniformSpace.Completion.toCompl.{u1} α _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2], Continuous.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.uniformSpace.{u1} α _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => UniformSpace.Completion.{u1} α _inst_1) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))) α (UniformSpace.Completion.{u1} α _inst_1) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u1} (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))) α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoidHom.addMonoidHomClass.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))))) (UniformSpace.Completion.toCompl.{u1} α _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.continuous_to_compl UniformSpace.Completion.continuous_toComplₓ'. -/
theorem continuous_toCompl : Continuous (toCompl : α → Completion α) :=
  continuous_coe α
#align uniform_space.completion.continuous_to_compl UniformSpace.Completion.continuous_toCompl

variable (α)

/- warning: uniform_space.completion.dense_inducing_to_compl -> UniformSpace.Completion.denseInducing_toCompl is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2], DenseInducing.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.uniformSpace.{u1} α _inst_1)) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3))) (fun (_x : AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3))) => α -> (UniformSpace.Completion.{u1} α _inst_1)) (AddMonoidHom.hasCoeToFun.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3))) (UniformSpace.Completion.toCompl.{u1} α _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2], DenseInducing.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.uniformSpace.{u1} α _inst_1)) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => UniformSpace.Completion.{u1} α _inst_1) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))) α (UniformSpace.Completion.{u1} α _inst_1) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u1} (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))) α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoidHom.addMonoidHomClass.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))))) (UniformSpace.Completion.toCompl.{u1} α _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.dense_inducing_to_compl UniformSpace.Completion.denseInducing_toComplₓ'. -/
theorem denseInducing_toCompl : DenseInducing (toCompl : α → Completion α) :=
  denseInducing_coe
#align uniform_space.completion.dense_inducing_to_compl UniformSpace.Completion.denseInducing_toCompl

variable {α}

end UniformAddGroup

section UniformAddCommGroup

variable [UniformSpace α] [AddCommGroup α] [UniformAddGroup α]

instance : AddCommGroup (Completion α) :=
  { Completion.addGroup with
    add_comm := fun a b =>
      Completion.induction_on₂ a b
        (isClosed_eq (continuous_map₂ continuous_fst continuous_snd)
          (continuous_map₂ continuous_snd continuous_fst))
        fun x y => by
        change ↑x + ↑y = ↑y + ↑x
        rw [← coe_add, ← coe_add, add_comm] }

instance [Semiring R] [Module R α] [UniformContinuousConstSMul R α] : Module R (Completion α) :=
  { Completion.distribMulAction,
    Completion.mulActionWithZero with
    smul := (· • ·)
    add_smul := fun a b =>
      ext' (continuous_const_smul _) ((continuous_const_smul _).add (continuous_const_smul _))
        fun x => by
        norm_cast
        rw [add_smul] }

end UniformAddCommGroup

end UniformSpace.Completion

section AddMonoidHom

variable [UniformSpace α] [AddGroup α] [UniformAddGroup α] [UniformSpace β] [AddGroup β]
  [UniformAddGroup β]

open UniformSpace UniformSpace.Completion

/- warning: add_monoid_hom.extension -> AddMonoidHom.extension is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5] [_inst_7 : CompleteSpace.{u2} β _inst_4] [_inst_8 : SeparatedSpace.{u2} β _inst_4] (f : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))), (Continuous.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (fun (_x : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) => α -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) f)) -> (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5] [_inst_7 : CompleteSpace.{u2} β _inst_4] [_inst_8 : SeparatedSpace.{u2} β _inst_4] (f : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))), (Continuous.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α β (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))) (AddMonoidHom.addMonoidHomClass.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))))) f)) -> (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.extension AddMonoidHom.extensionₓ'. -/
/-- Extension to the completion of a continuous group hom. -/
def AddMonoidHom.extension [CompleteSpace β] [SeparatedSpace β] (f : α →+ β) (hf : Continuous f) :
    Completion α →+ β :=
  have hf : UniformContinuous f := uniformContinuous_addMonoidHom_of_continuous hf
  { toFun := Completion.extension f
    map_zero' := by rw [← coe_zero, extension_coe hf, f.map_zero]
    map_add' := fun a b =>
      Completion.induction_on₂ a b
        (isClosed_eq (continuous_extension.comp continuous_add)
          ((continuous_extension.comp continuous_fst).add
            (continuous_extension.comp continuous_snd)))
        fun a b => by
        rw_mod_cast [extension_coe hf, extension_coe hf, extension_coe hf, f.map_add] }
#align add_monoid_hom.extension AddMonoidHom.extension

/- warning: add_monoid_hom.extension_coe -> AddMonoidHom.extension_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5] [_inst_7 : CompleteSpace.{u2} β _inst_4] [_inst_8 : SeparatedSpace.{u2} β _inst_4] (f : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (hf : Continuous.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (fun (_x : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) => α -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) f)) (a : α), Eq.{succ u2} β (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (fun (_x : AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) => (UniformSpace.Completion.{u1} α _inst_1) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (AddMonoidHom.extension.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 f hf) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) a)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (fun (_x : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) => α -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) f a)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5] [_inst_7 : CompleteSpace.{u2} β _inst_4] [_inst_8 : SeparatedSpace.{u2} β _inst_4] (f : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (hf : Continuous.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α β (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))) (AddMonoidHom.addMonoidHomClass.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))))) f)) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : UniformSpace.Completion.{u1} α _inst_1) => β) (UniformSpace.Completion.coe'.{u1} α _inst_1 a)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (UniformSpace.Completion.{u1} α _inst_1) (fun (_x : UniformSpace.Completion.{u1} α _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : UniformSpace.Completion.{u1} α _inst_1) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (UniformSpace.Completion.{u1} α _inst_1) β (AddZeroClass.toAdd.{u1} (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))) (AddMonoidHom.addMonoidHomClass.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))))) (AddMonoidHom.extension.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 f hf) (UniformSpace.Completion.coe'.{u1} α _inst_1 a)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α β (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))) (AddMonoidHom.addMonoidHomClass.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))))) f a)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.extension_coe AddMonoidHom.extension_coeₓ'. -/
theorem AddMonoidHom.extension_coe [CompleteSpace β] [SeparatedSpace β] (f : α →+ β)
    (hf : Continuous f) (a : α) : f.extension hf a = f a :=
  extension_coe (uniformContinuous_addMonoidHom_of_continuous hf) a
#align add_monoid_hom.extension_coe AddMonoidHom.extension_coe

/- warning: add_monoid_hom.continuous_extension -> AddMonoidHom.continuous_extension is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5] [_inst_7 : CompleteSpace.{u2} β _inst_4] [_inst_8 : SeparatedSpace.{u2} β _inst_4] (f : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (hf : Continuous.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (fun (_x : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) => α -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) f)), Continuous.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.uniformSpace.{u1} α _inst_1)) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (fun (_x : AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) => (UniformSpace.Completion.{u1} α _inst_1) -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (AddMonoidHom.extension.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 f hf))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5] [_inst_7 : CompleteSpace.{u2} β _inst_4] [_inst_8 : SeparatedSpace.{u2} β _inst_4] (f : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (hf : Continuous.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α β (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))) (AddMonoidHom.addMonoidHomClass.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))))) f)), Continuous.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.uniformSpace.{u1} α _inst_1)) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (UniformSpace.Completion.{u1} α _inst_1) (fun (_x : UniformSpace.Completion.{u1} α _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : UniformSpace.Completion.{u1} α _inst_1) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (UniformSpace.Completion.{u1} α _inst_1) β (AddZeroClass.toAdd.{u1} (UniformSpace.Completion.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))) (AddMonoidHom.addMonoidHomClass.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) β (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))))) (AddMonoidHom.extension.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 f hf))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.continuous_extension AddMonoidHom.continuous_extensionₓ'. -/
@[continuity]
theorem AddMonoidHom.continuous_extension [CompleteSpace β] [SeparatedSpace β] (f : α →+ β)
    (hf : Continuous f) : Continuous (f.extension hf) :=
  continuous_extension
#align add_monoid_hom.continuous_extension AddMonoidHom.continuous_extension

/- warning: add_monoid_hom.completion -> AddMonoidHom.completion is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5] (f : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))), (Continuous.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (fun (_x : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) => α -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) f)) -> (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5] (f : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))), (Continuous.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => β) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α β (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))) (AddMonoidHom.addMonoidHomClass.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))))) f)) -> (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u2} β _inst_4 _inst_5 _inst_6)))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.completion AddMonoidHom.completionₓ'. -/
/-- Completion of a continuous group hom, as a group hom. -/
def AddMonoidHom.completion (f : α →+ β) (hf : Continuous f) : Completion α →+ Completion β :=
  (toCompl.comp f).extension (continuous_toCompl.comp hf)
#align add_monoid_hom.completion AddMonoidHom.completion

/- warning: add_monoid_hom.continuous_completion -> AddMonoidHom.continuous_completion is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5] (f : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (hf : Continuous.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (fun (_x : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) => α -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) f)), Continuous.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.uniformSpace.{u1} α _inst_1)) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.uniformSpace.{u2} β _inst_4)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))) (fun (_x : AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))) => (UniformSpace.Completion.{u1} α _inst_1) -> (UniformSpace.Completion.{u2} β _inst_4)) (AddMonoidHom.hasCoeToFun.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))) (AddMonoidHom.completion.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f hf))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : UniformSpace.{u2} α] [_inst_2 : AddGroup.{u2} α] [_inst_3 : UniformAddGroup.{u2} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u1} β] [_inst_5 : AddGroup.{u1} β] [_inst_6 : UniformAddGroup.{u1} β _inst_4 _inst_5] (f : AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) (hf : Continuous.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} β _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => β) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2)))) (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5))) (AddMonoidHom.addMonoidHomClass.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))))) f)), Continuous.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.toTopologicalSpace.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.uniformSpace.{u2} α _inst_1)) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.uniformSpace.{u1} β _inst_4)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) (UniformSpace.Completion.{u2} α _inst_1) (fun (_x : UniformSpace.Completion.{u2} α _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : UniformSpace.Completion.{u2} α _inst_1) => UniformSpace.Completion.{u1} β _inst_4) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddZeroClass.toAdd.{u2} (UniformSpace.Completion.{u2} α _inst_1) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3))) (AddZeroClass.toAdd.{u1} (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6)) (AddMonoidHom.addMonoidHomClass.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))))) (AddMonoidHom.completion.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f hf))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.continuous_completion AddMonoidHom.continuous_completionₓ'. -/
@[continuity]
theorem AddMonoidHom.continuous_completion (f : α →+ β) (hf : Continuous f) :
    Continuous (f.Completion hf : Completion α → Completion β) :=
  ContinuousMap
#align add_monoid_hom.continuous_completion AddMonoidHom.continuous_completion

/- warning: add_monoid_hom.completion_coe -> AddMonoidHom.completion_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5] (f : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (hf : Continuous.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (fun (_x : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) => α -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) f)) (a : α), Eq.{succ u2} (UniformSpace.Completion.{u2} β _inst_4) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))) (fun (_x : AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))) => (UniformSpace.Completion.{u1} α _inst_1) -> (UniformSpace.Completion.{u2} β _inst_4)) (AddMonoidHom.hasCoeToFun.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))) (AddMonoidHom.completion.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f hf) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_1) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.hasCoeT.{u1} α _inst_1))) a)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) β (UniformSpace.Completion.{u2} β _inst_4) (HasLiftT.mk.{succ u2, succ u2} β (UniformSpace.Completion.{u2} β _inst_4) (CoeTCₓ.coe.{succ u2, succ u2} β (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.hasCoeT.{u2} β _inst_4))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (fun (_x : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) => α -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) f a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : UniformSpace.{u2} α] [_inst_2 : AddGroup.{u2} α] [_inst_3 : UniformAddGroup.{u2} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u1} β] [_inst_5 : AddGroup.{u1} β] [_inst_6 : UniformAddGroup.{u1} β _inst_4 _inst_5] (f : AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) (hf : Continuous.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} β _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => β) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2)))) (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5))) (AddMonoidHom.addMonoidHomClass.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))))) f)) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : UniformSpace.Completion.{u2} α _inst_1) => UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.coe'.{u2} α _inst_1 a)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) (UniformSpace.Completion.{u2} α _inst_1) (fun (_x : UniformSpace.Completion.{u2} α _inst_1) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : UniformSpace.Completion.{u2} α _inst_1) => UniformSpace.Completion.{u1} β _inst_4) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddZeroClass.toAdd.{u2} (UniformSpace.Completion.{u2} α _inst_1) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3))) (AddZeroClass.toAdd.{u1} (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6)) (AddMonoidHom.addMonoidHomClass.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))))) (AddMonoidHom.completion.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f hf) (UniformSpace.Completion.coe'.{u2} α _inst_1 a)) (UniformSpace.Completion.coe'.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => β) a) _inst_4 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => β) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2)))) (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5))) (AddMonoidHom.addMonoidHomClass.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))))) f a))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.completion_coe AddMonoidHom.completion_coeₓ'. -/
theorem AddMonoidHom.completion_coe (f : α →+ β) (hf : Continuous f) (a : α) :
    f.Completion hf a = f a :=
  map_coe (uniformContinuous_addMonoidHom_of_continuous hf) a
#align add_monoid_hom.completion_coe AddMonoidHom.completion_coe

/- warning: add_monoid_hom.completion_zero -> AddMonoidHom.completion_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u2} β] [_inst_5 : AddGroup.{u2} β] [_inst_6 : UniformAddGroup.{u2} β _inst_4 _inst_5], Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))) (AddMonoidHom.completion.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OfNat.ofNat.{max u2 u1} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) 0 (OfNat.mk.{max u2 u1} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) 0 (Zero.zero.{max u2 u1} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5)))) (AddMonoidHom.hasZero.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))))))) (continuous_const.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} β _inst_4) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_5))))))))) (OfNat.ofNat.{max u2 u1} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))) 0 (OfNat.mk.{max u2 u1} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))) 0 (Zero.zero.{max u2 u1} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))) (AddMonoidHom.hasZero.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} β _inst_4) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} β _inst_4) (UniformSpace.Completion.addMonoid.{u2} β _inst_4 _inst_5 _inst_6))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : UniformSpace.{u2} α] [_inst_2 : AddGroup.{u2} α] [_inst_3 : UniformAddGroup.{u2} α _inst_1 _inst_2] [_inst_4 : UniformSpace.{u1} β] [_inst_5 : AddGroup.{u1} β] [_inst_6 : UniformAddGroup.{u1} β _inst_4 _inst_5], Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) (AddMonoidHom.completion.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OfNat.ofNat.{max u2 u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) 0 (Zero.toOfNat0.{max u2 u1} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))) (instZeroAddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_2))) (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))))) (continuous_const.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u2} α _inst_1) (UniformSpace.toTopologicalSpace.{u1} β _inst_4) ((AddZeroClass.toZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_5)))).0))) (OfNat.ofNat.{max u2 u1} (AddMonoidHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) 0 (Zero.toOfNat0.{max u2 u1} (AddMonoidHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6))) (instZeroAddMonoidHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.{u1} β _inst_4) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u2} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} β _inst_4) (UniformSpace.Completion.instAddMonoidCompletion.{u1} β _inst_4 _inst_5 _inst_6)))))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.completion_zero AddMonoidHom.completion_zeroₓ'. -/
theorem AddMonoidHom.completion_zero : (0 : α →+ β).Completion continuous_const = 0 :=
  by
  ext x
  apply completion.induction_on x
  · apply isClosed_eq ((0 : α →+ β).continuous_completion continuous_const)
    simp [continuous_const]
  · intro a
    simp [(0 : α →+ β).completion_coe continuous_const, coe_zero]
#align add_monoid_hom.completion_zero AddMonoidHom.completion_zero

/- warning: add_monoid_hom.completion_add -> AddMonoidHom.completion_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] {γ : Type.{u2}} [_inst_7 : AddCommGroup.{u2} γ] [_inst_8 : UniformSpace.{u2} γ] [_inst_9 : UniformAddGroup.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7)] (f : AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (g : AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (hf : Continuous.{u1, u2} α γ (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} γ _inst_8) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (fun (_x : AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) => α -> γ) (AddMonoidHom.hasCoeToFun.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) f)) (hg : Continuous.{u1, u2} α γ (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} γ _inst_8) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (fun (_x : AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) => α -> γ) (AddMonoidHom.hasCoeToFun.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) g)), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.addMonoid.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9))) (AddMonoidHom.completion.{u1, u2} α γ _inst_1 _inst_2 _inst_3 _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9 (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (instHAdd.{max u2 u1} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (AddMonoidHom.hasAdd.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7))) f g) (Continuous.add.{u1, u2} α γ (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} γ _inst_8) (AddZeroClass.toHasAdd.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (TopologicalAddGroup.to_continuousAdd.{u2} γ (UniformSpace.toTopologicalSpace.{u2} γ _inst_8) (AddCommGroup.toAddGroup.{u2} γ _inst_7) (UniformAddGroup.to_topologicalAddGroup.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (fun (_x : AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) => α -> γ) (AddMonoidHom.hasCoeToFun.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) f) (fun (x : α) => coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7)))) (fun (_x : AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7)))) => α -> γ) (AddMonoidHom.hasCoeToFun.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7)))) g x) hf hg)) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.addMonoid.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9))) (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.addMonoid.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9))) (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.addMonoid.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9))) (instHAdd.{max u2 u1} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.addMonoid.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9))) (AddMonoidHom.hasAdd.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.addMonoid.{u1} α _inst_1 _inst_2 _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.addCommGroup.{u2} γ _inst_8 _inst_7 _inst_9)))) (AddMonoidHom.completion.{u1, u2} α γ _inst_1 _inst_2 _inst_3 _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9 f hf) (AddMonoidHom.completion.{u1, u2} α γ _inst_1 _inst_2 _inst_3 _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9 g hg))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : AddGroup.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_1 _inst_2] {γ : Type.{u2}} [_inst_7 : AddCommGroup.{u2} γ] [_inst_8 : UniformSpace.{u2} γ] [_inst_9 : UniformAddGroup.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7)] (f : AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (g : AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (hf : Continuous.{u1, u2} α γ (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} γ _inst_8) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => γ) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) α γ (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7)))) (AddMonoidHom.addMonoidHomClass.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))))) f)) (hg : Continuous.{u1, u2} α γ (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} γ _inst_8) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => γ) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) α γ (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7)))) (AddMonoidHom.addMonoidHomClass.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))))) g)), Eq.{max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.instAddMonoidCompletion.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9))) (AddMonoidHom.completion.{u1, u2} α γ _inst_1 _inst_2 _inst_3 _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (instHAdd.{max u1 u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (AddMonoidHom.add.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7))) f g) (Continuous.add.{u2, u1} α γ (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (UniformSpace.toTopologicalSpace.{u2} γ _inst_8) (AddZeroClass.toAdd.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (TopologicalAddGroup.toContinuousAdd.{u2} γ (UniformSpace.toTopologicalSpace.{u2} γ _inst_8) (AddCommGroup.toAddGroup.{u2} γ _inst_7) (UniformAddGroup.to_topologicalAddGroup.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α) => γ) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) α γ (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))) α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7)))) (AddMonoidHom.addMonoidHomClass.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (SubNegMonoid.toAddMonoid.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_7))))))) f) (fun (x : α) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2397 : α) => γ) _x) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7)))) α γ (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2)))) (AddZeroClass.toAdd.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7)))) α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7))) (AddMonoidHom.addMonoidHomClass.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_2))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (AddCommGroup.toAddCommMonoid.{u2} γ _inst_7)))))) g x) hf hg)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.instAddMonoidCompletion.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9))) (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.instAddMonoidCompletion.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9))) (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.instAddMonoidCompletion.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9))) (instHAdd.{max u1 u2} (AddMonoidHom.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddMonoid.toAddZeroClass.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.instAddMonoidCompletion.{u2} γ _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9))) (AddMonoidHom.add.{u1, u2} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.{u2} γ _inst_8) (AddMonoid.toAddZeroClass.{u1} (UniformSpace.Completion.{u1} α _inst_1) (UniformSpace.Completion.instAddMonoidCompletion.{u1} α _inst_1 _inst_2 _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} (UniformSpace.Completion.{u2} γ _inst_8) (UniformSpace.Completion.instAddCommGroupCompletion.{u2} γ _inst_8 _inst_7 _inst_9)))) (AddMonoidHom.completion.{u1, u2} α γ _inst_1 _inst_2 _inst_3 _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9 f hf) (AddMonoidHom.completion.{u1, u2} α γ _inst_1 _inst_2 _inst_3 _inst_8 (AddCommGroup.toAddGroup.{u2} γ _inst_7) _inst_9 g hg))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.completion_add AddMonoidHom.completion_addₓ'. -/
theorem AddMonoidHom.completion_add {γ : Type _} [AddCommGroup γ] [UniformSpace γ]
    [UniformAddGroup γ] (f g : α →+ γ) (hf : Continuous f) (hg : Continuous g) :
    (f + g).Completion (hf.add hg) = f.Completion hf + g.Completion hg :=
  by
  have hfg := hf.add hg
  ext x
  apply completion.induction_on x
  ·
    exact
      isClosed_eq ((f + g).continuous_completion hfg)
        ((f.continuous_completion hf).add (g.continuous_completion hg))
  · intro a
    simp [(f + g).completion_coe hfg, coe_add, f.completion_coe hf, g.completion_coe hg]
#align add_monoid_hom.completion_add AddMonoidHom.completion_add

end AddMonoidHom

