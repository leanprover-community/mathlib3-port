/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module topology.algebra.algebra
! leanprover-community/mathlib commit 43afc5ad87891456c57b5a183e3e617d67c2b1db
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Algebra.Subalgebra.Basic
import Mathbin.Topology.Algebra.Module.Basic
import Mathbin.RingTheory.Adjoin.Basic

/-!
# Topological (sub)algebras

A topological algebra over a topological semiring `R` is a topological semiring with a compatible
continuous scalar multiplication by elements of `R`. We reuse typeclass `has_continuous_smul` for
topological algebras.

## Results

This is just a minimal stub for now!

The topological closure of a subalgebra is still a subalgebra,
which as an algebra is a topological algebra.
-/


open Classical Set TopologicalSpace Algebra

open Classical

universe u v w

section TopologicalAlgebra

variable (R : Type _) (A : Type u)

variable [CommSemiring R] [Semiring A] [Algebra R A]

variable [TopologicalSpace R] [TopologicalSpace A] [TopologicalSemiring A]

/- warning: continuous_algebra_map_iff_smul -> continuous_algebraMap_iff_smul is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u2}) (A : Type.{u1}) [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Semiring.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} R] [_inst_5 : TopologicalSpace.{u1} A] [_inst_6 : TopologicalSemiring.{u1} A _inst_5 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))], Iff (Continuous.{u2, u1} R A _inst_4 _inst_5 (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (fun (_x : RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) => R -> A) (RingHom.hasCoeToFun.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (algebraMap.{u2, u1} R A _inst_1 _inst_2 _inst_3))) (Continuous.{max u2 u1, u1} (Prod.{u2, u1} R A) A (Prod.topologicalSpace.{u2, u1} R A _inst_4 _inst_5) _inst_5 (fun (p : Prod.{u2, u1} R A) => SMul.smul.{u2, u1} R A (SMulZeroClass.toHasSmul.{u2, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u1} R A (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R A (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3))))) (Prod.fst.{u2, u1} R A p) (Prod.snd.{u2, u1} R A p)))
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u1} R] [_inst_5 : TopologicalSpace.{u2} A] [_inst_6 : TopologicalSemiring.{u2} A _inst_5 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))], Iff (Continuous.{u1, u2} R A _inst_4 _inst_5 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_3))) (Continuous.{max u2 u1, u2} (Prod.{u1, u2} R A) A (instTopologicalSpaceProd.{u1, u2} R A _inst_4 _inst_5) _inst_5 (fun (p : Prod.{u1, u2} R A) => HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_2 _inst_3)) (Prod.fst.{u1, u2} R A p) (Prod.snd.{u1, u2} R A p)))
Case conversion may be inaccurate. Consider using '#align continuous_algebra_map_iff_smul continuous_algebraMap_iff_smulₓ'. -/
theorem continuous_algebraMap_iff_smul :
    Continuous (algebraMap R A) ↔ Continuous fun p : R × A => p.1 • p.2 :=
  by
  refine' ⟨fun h => _, fun h => _⟩
  · simp only [Algebra.smul_def]
    exact (h.comp continuous_fst).mul continuous_snd
  · rw [algebra_map_eq_smul_one']
    exact h.comp (continuous_id.prod_mk continuous_const)
#align continuous_algebra_map_iff_smul continuous_algebraMap_iff_smul

/- warning: continuous_algebra_map -> continuous_algebraMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u2}) (A : Type.{u1}) [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Semiring.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} R] [_inst_5 : TopologicalSpace.{u1} A] [_inst_6 : TopologicalSemiring.{u1} A _inst_5 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))] [_inst_7 : ContinuousSMul.{u2, u1} R A (SMulZeroClass.toHasSmul.{u2, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u1} R A (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R A (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3))))) _inst_4 _inst_5], Continuous.{u2, u1} R A _inst_4 _inst_5 (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (fun (_x : RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) => R -> A) (RingHom.hasCoeToFun.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (algebraMap.{u2, u1} R A _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u1} R] [_inst_5 : TopologicalSpace.{u2} A] [_inst_6 : TopologicalSemiring.{u2} A _inst_5 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))] [_inst_7 : ContinuousSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_2 _inst_3) _inst_4 _inst_5], Continuous.{u1, u2} R A _inst_4 _inst_5 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align continuous_algebra_map continuous_algebraMapₓ'. -/
@[continuity]
theorem continuous_algebraMap [ContinuousSMul R A] : Continuous (algebraMap R A) :=
  (continuous_algebraMap_iff_smul R A).2 continuous_smul
#align continuous_algebra_map continuous_algebraMap

/- warning: has_continuous_smul_of_algebra_map -> continuousSMul_of_algebraMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u2}) (A : Type.{u1}) [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Semiring.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} R] [_inst_5 : TopologicalSpace.{u1} A] [_inst_6 : TopologicalSemiring.{u1} A _inst_5 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))], (Continuous.{u2, u1} R A _inst_4 _inst_5 (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (fun (_x : RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) => R -> A) (RingHom.hasCoeToFun.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (algebraMap.{u2, u1} R A _inst_1 _inst_2 _inst_3))) -> (ContinuousSMul.{u2, u1} R A (SMulZeroClass.toHasSmul.{u2, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u1} R A (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R A (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3))))) _inst_4 _inst_5)
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u1} R] [_inst_5 : TopologicalSpace.{u2} A] [_inst_6 : TopologicalSemiring.{u2} A _inst_5 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))], (Continuous.{u1, u2} R A _inst_4 _inst_5 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_3))) -> (ContinuousSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_2 _inst_3) _inst_4 _inst_5)
Case conversion may be inaccurate. Consider using '#align has_continuous_smul_of_algebra_map continuousSMul_of_algebraMapₓ'. -/
theorem continuousSMul_of_algebraMap (h : Continuous (algebraMap R A)) : ContinuousSMul R A :=
  ⟨(continuous_algebraMap_iff_smul R A).1 h⟩
#align has_continuous_smul_of_algebra_map continuousSMul_of_algebraMap

variable [ContinuousSMul R A]

#print algebraMapClm /-
/-- The inclusion of the base ring in a topological algebra as a continuous linear map. -/
@[simps]
def algebraMapClm : R →L[R] A :=
  { Algebra.linearMap R A with
    toFun := algebraMap R A
    cont := continuous_algebraMap R A }
#align algebra_map_clm algebraMapClm
-/

/- warning: algebra_map_clm_coe -> algebraMapClm_coe is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u2}) (A : Type.{u1}) [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Semiring.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} R] [_inst_5 : TopologicalSpace.{u1} A] [_inst_6 : TopologicalSemiring.{u1} A _inst_5 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))] [_inst_7 : ContinuousSMul.{u2, u1} R A (SMulZeroClass.toHasSmul.{u2, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u1} R A (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R A (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3))))) _inst_4 _inst_5], Eq.{max (succ u2) (succ u1)} (R -> A) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousLinearMap.{u2, u2, u2, u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) A _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3)) (fun (_x : ContinuousLinearMap.{u2, u2, u2, u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) A _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3)) => R -> A) (ContinuousLinearMap.toFun.{u2, u2, u2, u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) A _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3)) (algebraMapClm.{u1, u2} R A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (fun (_x : RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) => R -> A) (RingHom.hasCoeToFun.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (algebraMap.{u2, u1} R A _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u1} R] [_inst_5 : TopologicalSpace.{u2} A] [_inst_6 : TopologicalSemiring.{u2} A _inst_5 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))] [_inst_7 : ContinuousSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_2 _inst_3) _inst_4 _inst_5], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : R), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : R) => A) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (ContinuousLinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) A _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : R) => A) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u1, u2} (ContinuousLinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) A _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3)) R A _inst_4 _inst_5 (ContinuousSemilinearMapClass.toContinuousMapClass.{max u2 u1, u1, u1, u1, u2} (ContinuousLinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) A _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3)) R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) A _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) A _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3)))) (algebraMapClm.{u2, u1} R A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align algebra_map_clm_coe algebraMapClm_coeₓ'. -/
theorem algebraMapClm_coe : ⇑(algebraMapClm R A) = algebraMap R A :=
  rfl
#align algebra_map_clm_coe algebraMapClm_coe

/- warning: algebra_map_clm_to_linear_map -> algebraMapClm_toLinearMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u2}) (A : Type.{u1}) [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Semiring.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} R] [_inst_5 : TopologicalSpace.{u1} A] [_inst_6 : TopologicalSemiring.{u1} A _inst_5 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))] [_inst_7 : ContinuousSMul.{u2, u1} R A (SMulZeroClass.toHasSmul.{u2, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u1} R A (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R A (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3))))) _inst_4 _inst_5], Eq.{max (succ u2) (succ u1)} (LinearMap.{u2, u2, u2, u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3)) (ContinuousLinearMap.toLinearMap.{u2, u2, u2, u1} R R (CommSemiring.toSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) A _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3) (algebraMapClm.{u1, u2} R A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (Algebra.linearMap.{u2, u1} R A _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u1} R] [_inst_5 : TopologicalSpace.{u2} A] [_inst_6 : TopologicalSemiring.{u2} A _inst_5 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))] [_inst_7 : ContinuousSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_2 _inst_3) _inst_4 _inst_5], Eq.{max (succ u2) (succ u1)} (LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3)) (ContinuousLinearMap.toLinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) A _inst_5 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (algebraMapClm.{u2, u1} R A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (Algebra.linearMap.{u1, u2} R A _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align algebra_map_clm_to_linear_map algebraMapClm_toLinearMapₓ'. -/
theorem algebraMapClm_toLinearMap : (algebraMapClm R A).toLinearMap = Algebra.linearMap R A :=
  rfl
#align algebra_map_clm_to_linear_map algebraMapClm_toLinearMap

end TopologicalAlgebra

section TopologicalAlgebra

variable {R : Type _} [CommSemiring R]

variable {A : Type u} [TopologicalSpace A]

variable [Semiring A] [Algebra R A]

/- warning: subalgebra.has_continuous_smul -> Subalgebra.continuousSMul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSpace.{u2} R] [_inst_6 : ContinuousSMul.{u2, u1} R A (SMulZeroClass.toHasSmul.{u2, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u2, u1} R A (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R A (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3)))))) (Module.toMulActionWithZero.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_3 _inst_4))))) _inst_5 _inst_2] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4), ContinuousSMul.{u2, u1} R (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (SMulZeroClass.toHasSmul.{u2, u1} R (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (AddZeroClass.toHasZero.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (AddCommMonoid.toAddMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Subalgebra.toSemiring.{u2, u1} R A _inst_1 _inst_3 _inst_4 s))))))) (SMulWithZero.toSmulZeroClass.{u2, u1} R (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (AddCommMonoid.toAddMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Subalgebra.toSemiring.{u2, u1} R A _inst_1 _inst_3 _inst_4 s))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (AddCommMonoid.toAddMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Subalgebra.toSemiring.{u2, u1} R A _inst_1 _inst_3 _inst_4 s))))))) (Module.toMulActionWithZero.{u2, u1} R (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Subalgebra.toSemiring.{u2, u1} R A _inst_1 _inst_3 _inst_4 s)))) (Subalgebra.module.{u2, u1} R A _inst_1 _inst_3 _inst_4 s))))) _inst_5 (Subtype.topologicalSpace.{u1} A (fun (x : A) => Membership.Mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s) _inst_2)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSpace.{u2} R] [_inst_6 : ContinuousSMul.{u2, u1} R A (Algebra.toSMul.{u2, u1} R A _inst_1 _inst_3 _inst_4) _inst_5 _inst_2] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4), ContinuousSMul.{u2, u1} R (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (Algebra.toSMul.{u2, u1} R (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) _inst_1 (Subalgebra.toSemiring.{u2, u1} R A _inst_1 _inst_3 _inst_4 s) (Subalgebra.instAlgebraSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiring.{u2, u1} R A _inst_1 _inst_3 _inst_4 s)) _inst_5 (instTopologicalSpaceSubtype.{u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s) _inst_2)
Case conversion may be inaccurate. Consider using '#align subalgebra.has_continuous_smul Subalgebra.continuousSMulₓ'. -/
instance Subalgebra.continuousSMul [TopologicalSpace R] [ContinuousSMul R A] (s : Subalgebra R A) :
    ContinuousSMul R s :=
  s.toSubmodule.ContinuousSMul
#align subalgebra.has_continuous_smul Subalgebra.continuousSMul

variable [TopologicalSemiring A]

#print Subalgebra.topologicalClosure /-
/-- The closure of a subalgebra in a topological algebra as a subalgebra. -/
def Subalgebra.topologicalClosure (s : Subalgebra R A) : Subalgebra R A :=
  {
    s.toSubsemiring.topologicalClosure with
    carrier := closure (s : Set A)
    algebraMap_mem' := fun r => s.toSubsemiring.le_topologicalClosure (s.algebraMap_mem r) }
#align subalgebra.topological_closure Subalgebra.topologicalClosure
-/

/- warning: subalgebra.topological_closure_coe -> Subalgebra.topologicalClosure_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u1} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4), Eq.{succ u1} (Set.{u1} A) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (HasLiftT.mk.{succ u1, succ u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (CoeTCₓ.coe.{succ u1, succ u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (SetLike.Set.hasCoeT.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)))) (Subalgebra.topologicalClosure.{u1, u2} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s)) (closure.{u1} A _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (HasLiftT.mk.{succ u1, succ u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (CoeTCₓ.coe.{succ u1, succ u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (SetLike.Set.hasCoeT.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)))) s))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {A : Type.{u2}} [_inst_2 : TopologicalSpace.{u2} A] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u2} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))] (s : Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4), Eq.{succ u2} (Set.{u2} A) (SetLike.coe.{u2, u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (Subalgebra.topologicalClosure.{u2, u1} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s)) (closure.{u2} A _inst_2 (SetLike.coe.{u2, u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) s))
Case conversion may be inaccurate. Consider using '#align subalgebra.topological_closure_coe Subalgebra.topologicalClosure_coeₓ'. -/
@[simp]
theorem Subalgebra.topologicalClosure_coe (s : Subalgebra R A) :
    (s.topologicalClosure : Set A) = closure (s : Set A) :=
  rfl
#align subalgebra.topological_closure_coe Subalgebra.topologicalClosure_coe

/- warning: subalgebra.topological_semiring -> Subalgebra.topologicalSemiring is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u1} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4), TopologicalSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Subtype.topologicalSpace.{u1} A (fun (x : A) => Membership.Mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s) _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (Subalgebra.toSemiring.{u2, u1} R A _inst_1 _inst_3 _inst_4 s)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u1} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4), TopologicalSemiring.{u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (instTopologicalSpaceSubtype.{u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s) _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (Subsemiring.toNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3) (Subalgebra.toSubsemiring.{u2, u1} R A _inst_1 _inst_3 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align subalgebra.topological_semiring Subalgebra.topologicalSemiringₓ'. -/
instance Subalgebra.topologicalSemiring (s : Subalgebra R A) : TopologicalSemiring s :=
  s.toSubsemiring.TopologicalSemiring
#align subalgebra.topological_semiring Subalgebra.topologicalSemiring

/- warning: subalgebra.le_topological_closure -> Subalgebra.le_topologicalClosure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u1} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4), LE.le.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Algebra.Subalgebra.completeLattice.{u2, u1} R A _inst_1 _inst_3 _inst_4))))) s (Subalgebra.topologicalClosure.{u1, u2} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {A : Type.{u2}} [_inst_2 : TopologicalSpace.{u2} A] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u2} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))] (s : Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4), LE.le.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) s (Subalgebra.topologicalClosure.{u2, u1} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s)
Case conversion may be inaccurate. Consider using '#align subalgebra.le_topological_closure Subalgebra.le_topologicalClosureₓ'. -/
theorem Subalgebra.le_topologicalClosure (s : Subalgebra R A) : s ≤ s.topologicalClosure :=
  subset_closure
#align subalgebra.le_topological_closure Subalgebra.le_topologicalClosure

/- warning: subalgebra.is_closed_topological_closure -> Subalgebra.isClosed_topologicalClosure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u1} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4), IsClosed.{u1} A _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (HasLiftT.mk.{succ u1, succ u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (CoeTCₓ.coe.{succ u1, succ u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (SetLike.Set.hasCoeT.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)))) (Subalgebra.topologicalClosure.{u1, u2} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {A : Type.{u2}} [_inst_2 : TopologicalSpace.{u2} A] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u2} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))] (s : Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4), IsClosed.{u2} A _inst_2 (SetLike.coe.{u2, u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (Subalgebra.topologicalClosure.{u2, u1} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s))
Case conversion may be inaccurate. Consider using '#align subalgebra.is_closed_topological_closure Subalgebra.isClosed_topologicalClosureₓ'. -/
theorem Subalgebra.isClosed_topologicalClosure (s : Subalgebra R A) :
    IsClosed (s.topologicalClosure : Set A) := by convert isClosed_closure
#align subalgebra.is_closed_topological_closure Subalgebra.isClosed_topologicalClosure

/- warning: subalgebra.topological_closure_minimal -> Subalgebra.topologicalClosure_minimal is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u1} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) {t : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4}, (LE.le.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Algebra.Subalgebra.completeLattice.{u2, u1} R A _inst_1 _inst_3 _inst_4))))) s t) -> (IsClosed.{u1} A _inst_2 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (HasLiftT.mk.{succ u1, succ u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (CoeTCₓ.coe.{succ u1, succ u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Set.{u1} A) (SetLike.Set.hasCoeT.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)))) t)) -> (LE.le.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (CompleteSemilatticeInf.toPartialOrder.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Algebra.Subalgebra.completeLattice.{u2, u1} R A _inst_1 _inst_3 _inst_4))))) (Subalgebra.topologicalClosure.{u1, u2} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s) t)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {A : Type.{u2}} [_inst_2 : TopologicalSpace.{u2} A] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u2} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))] (s : Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) {t : Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4}, (LE.le.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) s t) -> (IsClosed.{u2} A _inst_2 (SetLike.coe.{u2, u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) t)) -> (LE.le.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Subalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) (Subalgebra.topologicalClosure.{u2, u1} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s) t)
Case conversion may be inaccurate. Consider using '#align subalgebra.topological_closure_minimal Subalgebra.topologicalClosure_minimalₓ'. -/
theorem Subalgebra.topologicalClosure_minimal (s : Subalgebra R A) {t : Subalgebra R A} (h : s ≤ t)
    (ht : IsClosed (t : Set A)) : s.topologicalClosure ≤ t :=
  closure_minimal h ht
#align subalgebra.topological_closure_minimal Subalgebra.topologicalClosure_minimal

/- warning: subalgebra.comm_semiring_topological_closure -> Subalgebra.commSemiringTopologicalClosure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u1} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))] [_inst_6 : T2Space.{u1} A _inst_2] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4), (forall (x : coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (y : coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s), Eq.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (MulMemClass.mul.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (MulOneClass.toHasMul.{u1} A (MulZeroOneClass.toMulOneClass.{u1} A (NonAssocSemiring.toMulZeroOneClass.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3)))) (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Subalgebra.commSemiringTopologicalClosure._proof_1.{u1, u2} R _inst_1 A _inst_3 _inst_4) s)) x y) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) s) (MulMemClass.mul.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (MulOneClass.toHasMul.{u1} A (MulZeroOneClass.toMulOneClass.{u1} A (NonAssocSemiring.toMulZeroOneClass.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3)))) (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4) (Subalgebra.commSemiringTopologicalClosure._proof_1.{u1, u2} R _inst_1 A _inst_3 _inst_4) s)) y x)) -> (CommSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.setLike.{u2, u1} R A _inst_1 _inst_3 _inst_4)) (Subalgebra.topologicalClosure.{u1, u2} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u1} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))] [_inst_6 : T2Space.{u1} A _inst_2] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4), (forall (x : Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (y : Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)), Eq.{succ u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (instHMul.{u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (Submonoid.mul.{u1} A (MulZeroOneClass.toMulOneClass.{u1} A (NonAssocSemiring.toMulZeroOneClass.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))) (Subsemiring.toSubmonoid.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3) (Subalgebra.toSubsemiring.{u2, u1} R A _inst_1 _inst_3 _inst_4 s)))) x y) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (instHMul.{u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x s)) (Submonoid.mul.{u1} A (MulZeroOneClass.toMulOneClass.{u1} A (NonAssocSemiring.toMulZeroOneClass.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))) (Subsemiring.toSubmonoid.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3) (Subalgebra.toSubsemiring.{u2, u1} R A _inst_1 _inst_3 _inst_4 s)))) y x)) -> (CommSemiring.{u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4)) x (Subalgebra.topologicalClosure.{u1, u2} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s))))
Case conversion may be inaccurate. Consider using '#align subalgebra.comm_semiring_topological_closure Subalgebra.commSemiringTopologicalClosureₓ'. -/
/-- If a subalgebra of a topological algebra is commutative, then so is its topological closure. -/
def Subalgebra.commSemiringTopologicalClosure [T2Space A] (s : Subalgebra R A)
    (hs : ∀ x y : s, x * y = y * x) : CommSemiring s.topologicalClosure :=
  { s.topologicalClosure.toSemiring, s.toSubmonoid.commMonoidTopologicalClosure hs with }
#align subalgebra.comm_semiring_topological_closure Subalgebra.commSemiringTopologicalClosure

/- warning: subalgebra.topological_closure_comap_homeomorph -> Subalgebra.topologicalClosure_comap_homeomorph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Semiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u1} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_3))] (s : Subalgebra.{u2, u1} R A _inst_1 _inst_3 _inst_4) {B : Type.{u3}} [_inst_6 : TopologicalSpace.{u3} B] [_inst_7 : Ring.{u3} B] [_inst_8 : TopologicalRing.{u3} B _inst_6 (NonAssocRing.toNonUnitalNonAssocRing.{u3} B (Ring.toNonAssocRing.{u3} B _inst_7))] [_inst_9 : Algebra.{u2, u3} R B _inst_1 (Ring.toSemiring.{u3} B _inst_7)] (f : AlgHom.{u2, u3, u1} R B A _inst_1 (Ring.toSemiring.{u3} B _inst_7) _inst_3 _inst_9 _inst_4) (f' : Homeomorph.{u3, u1} B A _inst_6 _inst_2), (Eq.{max (succ u3) (succ u1)} ((fun (_x : AlgHom.{u2, u3, u1} R B A _inst_1 (Ring.toSemiring.{u3} B _inst_7) _inst_3 _inst_9 _inst_4) => B -> A) f) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (AlgHom.{u2, u3, u1} R B A _inst_1 (Ring.toSemiring.{u3} B _inst_7) _inst_3 _inst_9 _inst_4) (fun (_x : AlgHom.{u2, u3, u1} R B A _inst_1 (Ring.toSemiring.{u3} B _inst_7) _inst_3 _inst_9 _inst_4) => B -> A) ([anonymous].{u2, u3, u1} R B A _inst_1 (Ring.toSemiring.{u3} B _inst_7) _inst_3 _inst_9 _inst_4) f) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Homeomorph.{u3, u1} B A _inst_6 _inst_2) (fun (_x : Homeomorph.{u3, u1} B A _inst_6 _inst_2) => B -> A) (Homeomorph.hasCoeToFun.{u3, u1} B A _inst_6 _inst_2) f')) -> (Eq.{succ u3} (Subalgebra.{u2, u3} R B _inst_1 (Ring.toSemiring.{u3} B _inst_7) _inst_9) (Subalgebra.comap.{u2, u3, u1} R B A _inst_1 (Ring.toSemiring.{u3} B _inst_7) _inst_9 _inst_3 _inst_4 f (Subalgebra.topologicalClosure.{u1, u2} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s)) (Subalgebra.topologicalClosure.{u3, u2} R _inst_1 B _inst_6 (Ring.toSemiring.{u3} B _inst_7) _inst_9 (TopologicalRing.to_topologicalSemiring.{u3} B _inst_6 (NonAssocRing.toNonUnitalNonAssocRing.{u3} B (Ring.toNonAssocRing.{u3} B _inst_7)) _inst_8) (Subalgebra.comap.{u2, u3, u1} R B A _inst_1 (Ring.toSemiring.{u3} B _inst_7) _inst_9 _inst_3 _inst_4 f s)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {A : Type.{u3}} [_inst_2 : TopologicalSpace.{u3} A] [_inst_3 : Semiring.{u3} A] [_inst_4 : Algebra.{u2, u3} R A _inst_1 _inst_3] [_inst_5 : TopologicalSemiring.{u3} A _inst_2 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3))] (s : Subalgebra.{u2, u3} R A _inst_1 _inst_3 _inst_4) {B : Type.{u1}} [_inst_6 : TopologicalSpace.{u1} B] [_inst_7 : Ring.{u1} B] [_inst_8 : TopologicalRing.{u1} B _inst_6 (NonAssocRing.toNonUnitalNonAssocRing.{u1} B (Ring.toNonAssocRing.{u1} B _inst_7))] [_inst_9 : Algebra.{u2, u1} R B _inst_1 (Ring.toSemiring.{u1} B _inst_7)] (f : AlgHom.{u2, u1, u3} R B A _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_3 _inst_9 _inst_4) (f' : Homeomorph.{u1, u3} B A _inst_6 _inst_2), (Eq.{max (succ u3) (succ u1)} (forall (a : B), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : B) => A) a) (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (AlgHom.{u2, u1, u3} R B A _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_3 _inst_9 _inst_4) B (fun (_x : B) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : B) => A) _x) (SMulHomClass.toFunLike.{max u3 u1, u2, u1, u3} (AlgHom.{u2, u1, u3} R B A _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_3 _inst_9 _inst_4) R B A (SMulZeroClass.toSMul.{u2, u1} R B (AddMonoid.toZero.{u1} B (AddCommMonoid.toAddMonoid.{u1} B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B (Ring.toSemiring.{u1} B _inst_7)))))) (DistribSMul.toSMulZeroClass.{u2, u1} R B (AddMonoid.toAddZeroClass.{u1} B (AddCommMonoid.toAddMonoid.{u1} B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B (Ring.toSemiring.{u1} B _inst_7)))))) (DistribMulAction.toDistribSMul.{u2, u1} R B (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u1} B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B (Ring.toSemiring.{u1} B _inst_7))))) (Module.toDistribMulAction.{u2, u1} R B (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B (Ring.toSemiring.{u1} B _inst_7)))) (Algebra.toModule.{u2, u1} R B _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_9))))) (SMulZeroClass.toSMul.{u2, u3} R A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3))))) (DistribSMul.toSMulZeroClass.{u2, u3} R A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3))))) (DistribMulAction.toDistribSMul.{u2, u3} R A (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u3} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3)))) (Module.toDistribMulAction.{u2, u3} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3))) (Algebra.toModule.{u2, u3} R A _inst_1 _inst_3 _inst_4))))) (DistribMulActionHomClass.toSMulHomClass.{max u3 u1, u2, u1, u3} (AlgHom.{u2, u1, u3} R B A _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_3 _inst_9 _inst_4) R B A (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u1} B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B (Ring.toSemiring.{u1} B _inst_7))))) (AddCommMonoid.toAddMonoid.{u3} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3)))) (Module.toDistribMulAction.{u2, u1} R B (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B (Ring.toSemiring.{u1} B _inst_7)))) (Algebra.toModule.{u2, u1} R B _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_9)) (Module.toDistribMulAction.{u2, u3} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3))) (Algebra.toModule.{u2, u3} R A _inst_1 _inst_3 _inst_4)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u3 u1, u2, u1, u3} (AlgHom.{u2, u1, u3} R B A _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_3 _inst_9 _inst_4) R B A (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B (Ring.toSemiring.{u1} B _inst_7))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3)) (Module.toDistribMulAction.{u2, u1} R B (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B (Ring.toSemiring.{u1} B _inst_7)))) (Algebra.toModule.{u2, u1} R B _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_9)) (Module.toDistribMulAction.{u2, u3} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3))) (Algebra.toModule.{u2, u3} R A _inst_1 _inst_3 _inst_4)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, u1, u3, max u3 u1} R B A _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_3 _inst_9 _inst_4 (AlgHom.{u2, u1, u3} R B A _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_3 _inst_9 _inst_4) (AlgHom.algHomClass.{u2, u1, u3} R B A _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_3 _inst_9 _inst_4))))) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Homeomorph.{u1, u3} B A _inst_6 _inst_2) B (fun (_x : B) => A) (EmbeddingLike.toFunLike.{max (succ u1) (succ u3), succ u1, succ u3} (Homeomorph.{u1, u3} B A _inst_6 _inst_2) B A (EquivLike.toEmbeddingLike.{max (succ u1) (succ u3), succ u1, succ u3} (Homeomorph.{u1, u3} B A _inst_6 _inst_2) B A (Homeomorph.instEquivLikeHomeomorph.{u1, u3} B A _inst_6 _inst_2))) f')) -> (Eq.{succ u1} (Subalgebra.{u2, u1} R B _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_9) (Subalgebra.comap.{u2, u1, u3} R B A _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_9 _inst_3 _inst_4 f (Subalgebra.topologicalClosure.{u3, u2} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 s)) (Subalgebra.topologicalClosure.{u1, u2} R _inst_1 B _inst_6 (Ring.toSemiring.{u1} B _inst_7) _inst_9 (TopologicalRing.toTopologicalSemiring.{u1} B _inst_6 (NonAssocRing.toNonUnitalNonAssocRing.{u1} B (Ring.toNonAssocRing.{u1} B _inst_7)) _inst_8) (Subalgebra.comap.{u2, u1, u3} R B A _inst_1 (Ring.toSemiring.{u1} B _inst_7) _inst_9 _inst_3 _inst_4 f s)))
Case conversion may be inaccurate. Consider using '#align subalgebra.topological_closure_comap_homeomorph Subalgebra.topologicalClosure_comap_homeomorphₓ'. -/
/-- This is really a statement about topological algebra isomorphisms,
but we don't have those, so we use the clunky approach of talking about
an algebra homomorphism, and a separate homeomorphism,
along with a witness that as functions they are the same.
-/
theorem Subalgebra.topologicalClosure_comap_homeomorph (s : Subalgebra R A) {B : Type _}
    [TopologicalSpace B] [Ring B] [TopologicalRing B] [Algebra R B] (f : B →ₐ[R] A) (f' : B ≃ₜ A)
    (w : (f : B → A) = f') : s.topologicalClosure.comap f = (s.comap f).topologicalClosure :=
  by
  apply SetLike.ext'
  simp only [Subalgebra.topologicalClosure_coe]
  simp only [Subalgebra.coe_comap, Subsemiring.coe_comap, AlgHom.coe_toRingHom]
  rw [w]
  exact f'.preimage_closure _
#align subalgebra.topological_closure_comap_homeomorph Subalgebra.topologicalClosure_comap_homeomorph

end TopologicalAlgebra

section Ring

variable {R : Type _} [CommRing R]

variable {A : Type u} [TopologicalSpace A]

variable [Ring A]

variable [Algebra R A] [TopologicalRing A]

/- warning: subalgebra.comm_ring_topological_closure -> Subalgebra.commRingTopologicalClosure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Ring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3)] [_inst_5 : TopologicalRing.{u1} A _inst_2 (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A _inst_3))] [_inst_6 : T2Space.{u1} A _inst_2] (s : Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4), (forall (x : coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s) (y : coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s), Eq.{succ u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s) (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s) (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s) (MulMemClass.mul.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (MulOneClass.toHasMul.{u1} A (MulZeroOneClass.toMulOneClass.{u1} A (NonAssocSemiring.toMulZeroOneClass.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_3))))) (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (Subalgebra.commRingTopologicalClosure._proof_1.{u1, u2} R _inst_1 A _inst_3 _inst_4) s)) x y) (HMul.hMul.{u1, u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s) (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s) (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s) (instHMul.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) s) (MulMemClass.mul.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (MulOneClass.toHasMul.{u1} A (MulZeroOneClass.toMulOneClass.{u1} A (NonAssocSemiring.toMulZeroOneClass.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_3))))) (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (Subalgebra.commRingTopologicalClosure._proof_1.{u1, u2} R _inst_1 A _inst_3 _inst_4) s)) y x)) -> (CommRing.{u1} (coeSort.{succ u1, succ (succ u1)} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) (Subalgebra.topologicalClosure.{u1, u2} R (CommRing.toCommSemiring.{u2} R _inst_1) A _inst_2 (Ring.toSemiring.{u1} A _inst_3) _inst_4 (Subalgebra.commRingTopologicalClosure._proof_2.{u1} A _inst_2 _inst_3 _inst_5) s)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Ring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3)] [_inst_5 : TopologicalRing.{u1} A _inst_2 (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A _inst_3))] [_inst_6 : T2Space.{u1} A _inst_2] (s : Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4), (forall (x : Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)) (y : Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)), Eq.{succ u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)) (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)) (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)) (instHMul.{u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)) (Submonoid.mul.{u1} A (MulZeroOneClass.toMulOneClass.{u1} A (NonAssocSemiring.toMulZeroOneClass.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_3)))) (Subsemiring.toSubmonoid.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_3)) (Subalgebra.toSubsemiring.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4 s)))) x y) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)) (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)) (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)) (instHMul.{u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x s)) (Submonoid.mul.{u1} A (MulZeroOneClass.toMulOneClass.{u1} A (NonAssocSemiring.toMulZeroOneClass.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_3)))) (Subsemiring.toSubmonoid.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_3)) (Subalgebra.toSubsemiring.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4 s)))) y x)) -> (CommRing.{u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x (Subalgebra.topologicalClosure.{u1, u2} R (CommRing.toCommSemiring.{u2} R _inst_1) A _inst_2 (Ring.toSemiring.{u1} A _inst_3) _inst_4 (TopologicalRing.toTopologicalSemiring.{u1} A _inst_2 (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A _inst_3)) _inst_5) s))))
Case conversion may be inaccurate. Consider using '#align subalgebra.comm_ring_topological_closure Subalgebra.commRingTopologicalClosureₓ'. -/
/-- If a subalgebra of a topological algebra is commutative, then so is its topological closure.
See note [reducible non-instances]. -/
@[reducible]
def Subalgebra.commRingTopologicalClosure [T2Space A] (s : Subalgebra R A)
    (hs : ∀ x y : s, x * y = y * x) : CommRing s.topologicalClosure :=
  { s.topologicalClosure.toRing, s.toSubmonoid.commMonoidTopologicalClosure hs with }
#align subalgebra.comm_ring_topological_closure Subalgebra.commRingTopologicalClosure

variable (R)

#print Algebra.elementalAlgebra /-
/-- The topological closure of the subalgebra generated by a single element. -/
def Algebra.elementalAlgebra (x : A) : Subalgebra R A :=
  (Algebra.adjoin R ({x} : Set A)).topologicalClosure
#align algebra.elemental_algebra Algebra.elementalAlgebra
-/

/- warning: algebra.self_mem_elemental_algebra -> Algebra.self_mem_elementalAlgebra is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u2}) [_inst_1 : CommRing.{u2} R] {A : Type.{u1}} [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : Ring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3)] [_inst_5 : TopologicalRing.{u1} A _inst_2 (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A _inst_3))] (x : A), Membership.Mem.{u1, u1} A (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) (SetLike.hasMem.{u1, u1} (Subalgebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4) A (Subalgebra.setLike.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_4)) x (Algebra.elementalAlgebra.{u1, u2} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 x)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : CommRing.{u1} R] {A : Type.{u2}} [_inst_2 : TopologicalSpace.{u2} A] [_inst_3 : Ring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_3)] [_inst_5 : TopologicalRing.{u2} A _inst_2 (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_3))] (x : A), Membership.mem.{u2, u2} A (Subalgebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_3) _inst_4) (SetLike.instMembership.{u2, u2} (Subalgebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_3) _inst_4) A (Subalgebra.instSetLikeSubalgebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_3) _inst_4)) x (Algebra.elementalAlgebra.{u2, u1} R _inst_1 A _inst_2 _inst_3 _inst_4 _inst_5 x)
Case conversion may be inaccurate. Consider using '#align algebra.self_mem_elemental_algebra Algebra.self_mem_elementalAlgebraₓ'. -/
theorem Algebra.self_mem_elementalAlgebra (x : A) : x ∈ Algebra.elementalAlgebra R x :=
  SetLike.le_def.mp (Subalgebra.le_topologicalClosure (Algebra.adjoin R ({x} : Set A))) <|
    Algebra.self_mem_adjoin_singleton R x
#align algebra.self_mem_elemental_algebra Algebra.self_mem_elementalAlgebra

variable {R}

instance [T2Space A] {x : A} : CommRing (Algebra.elementalAlgebra R x) :=
  Subalgebra.commRingTopologicalClosure _
    letI : CommRing (Algebra.adjoin R ({x} : Set A)) :=
      Algebra.adjoinCommRingOfComm R fun y hy z hz =>
        by
        rw [mem_singleton_iff] at hy hz
        rw [hy, hz]
    fun _ _ => mul_comm _ _

end Ring

section DivisionRing

/- warning: division_ring.has_continuous_const_smul_rat -> DivisionRing.continuousConstSMul_rat is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : DivisionRing.{u1} A] [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : ContinuousMul.{u1} A _inst_2 (Distrib.toHasMul.{u1} A (Ring.toDistrib.{u1} A (DivisionRing.toRing.{u1} A _inst_1)))] [_inst_4 : CharZero.{u1} A (AddGroupWithOne.toAddMonoidWithOne.{u1} A (AddCommGroupWithOne.toAddGroupWithOne.{u1} A (Ring.toAddCommGroupWithOne.{u1} A (DivisionRing.toRing.{u1} A _inst_1))))], ContinuousConstSMul.{0, u1} Rat A _inst_2 (Rat.smulDivisionRing.{u1} A _inst_1)
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : DivisionRing.{u1} A] [_inst_2 : TopologicalSpace.{u1} A] [_inst_3 : ContinuousMul.{u1} A _inst_2 (NonUnitalNonAssocRing.toMul.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (DivisionRing.toRing.{u1} A _inst_1))))] [_inst_4 : CharZero.{u1} A (AddGroupWithOne.toAddMonoidWithOne.{u1} A (Ring.toAddGroupWithOne.{u1} A (DivisionRing.toRing.{u1} A _inst_1)))], ContinuousConstSMul.{0, u1} Rat A _inst_2 (Algebra.toSMul.{0, u1} Rat A Rat.commSemiring (DivisionSemiring.toSemiring.{u1} A (DivisionRing.toDivisionSemiring.{u1} A _inst_1)) (algebraRat.{u1} A _inst_1 _inst_4))
Case conversion may be inaccurate. Consider using '#align division_ring.has_continuous_const_smul_rat DivisionRing.continuousConstSMul_ratₓ'. -/
/-- The action induced by `algebra_rat` is continuous. -/
instance DivisionRing.continuousConstSMul_rat {A} [DivisionRing A] [TopologicalSpace A]
    [ContinuousMul A] [CharZero A] : ContinuousConstSMul ℚ A :=
  ⟨fun r => by simpa only [Algebra.smul_def] using continuous_const.mul continuous_id⟩
#align division_ring.has_continuous_const_smul_rat DivisionRing.continuousConstSMul_rat

end DivisionRing

