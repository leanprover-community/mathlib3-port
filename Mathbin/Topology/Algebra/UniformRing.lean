/-
Copyright (c) 2018 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Johannes Hölzl

! This file was ported from Lean 3 source module topology.algebra.uniform_ring
! leanprover-community/mathlib commit 8ef6f08ff8c781c5c07a8b12843710e1a0d8a688
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Algebra.Basic
import Mathbin.Topology.Algebra.GroupCompletion
import Mathbin.Topology.Algebra.Ring.Ideal

/-!
# Completion of topological rings:

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This files endows the completion of a topological ring with a ring structure.
More precisely the instance `uniform_space.completion.ring` builds a ring structure
on the completion of a ring endowed with a compatible uniform structure in the sense of
`uniform_add_group`. There is also a commutative version when the original ring is commutative.
Moreover, if a topological ring is an algebra over a commutative semiring, then so is its
`uniform_space.completion`.

The last part of the file builds a ring structure on the biggest separated quotient of a ring.

## Main declarations:

Beyond the instances explained above (that don't have to be explicitly invoked),
the main constructions deal with continuous ring morphisms.

* `uniform_space.completion.extension_hom`: extends a continuous ring morphism from `R`
  to a complete separated group `S` to `completion R`.
* `uniform_space.completion.map_ring_hom` : promotes a continuous ring morphism
  from `R` to `S` into a continuous ring morphism from `completion R` to `completion S`.

TODO: Generalise the results here from the concrete `completion` to any `abstract_completion`.
-/


open Classical Set Filter TopologicalSpace AddCommGroup

open Classical

noncomputable section

universe u

namespace UniformSpace.Completion

open DenseInducing UniformSpace Function

variable (α : Type _) [Ring α] [UniformSpace α]

instance : One (Completion α) :=
  ⟨(1 : α)⟩

instance : Mul (Completion α) :=
  ⟨curry <| (denseInducing_coe.Prod denseInducing_coe).extend (coe ∘ uncurry (· * ·))⟩

/- warning: uniform_space.completion.coe_one -> UniformSpace.Completion.coe_one is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α], Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_2) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_2) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.hasCoeT.{u1} α _inst_2))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))))) (OfNat.ofNat.{u1} (UniformSpace.Completion.{u1} α _inst_2) 1 (OfNat.mk.{u1} (UniformSpace.Completion.{u1} α _inst_2) 1 (One.one.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.hasOne.{u1} α _inst_1 _inst_2))))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α], Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.coe'.{u1} α _inst_2 (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) (OfNat.ofNat.{u1} (UniformSpace.Completion.{u1} α _inst_2) 1 (One.toOfNat1.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.one.{u1} α _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.coe_one UniformSpace.Completion.coe_oneₓ'. -/
@[norm_cast]
theorem coe_one : ((1 : α) : Completion α) = 1 :=
  rfl
#align uniform_space.completion.coe_one UniformSpace.Completion.coe_one

variable {α} [TopologicalRing α]

/- warning: uniform_space.completion.coe_mul -> UniformSpace.Completion.coe_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] (a : α) (b : α), Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_2) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_2) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.hasCoeT.{u1} α _inst_2))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) a b)) (HMul.hMul.{u1, u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (instHMul.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.hasMul.{u1} α _inst_1 _inst_2)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_2) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.hasCoeT.{u1} α _inst_2))) a) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (UniformSpace.Completion.{u1} α _inst_2) (HasLiftT.mk.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} α (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.hasCoeT.{u1} α _inst_2))) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] (a : α) (b : α), Eq.{succ u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.coe'.{u1} α _inst_2 (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))) a b)) (HMul.hMul.{u1, u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (instHMul.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.mul.{u1} α _inst_1 _inst_2)) (UniformSpace.Completion.coe'.{u1} α _inst_2 a) (UniformSpace.Completion.coe'.{u1} α _inst_2 b))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.coe_mul UniformSpace.Completion.coe_mulₓ'. -/
@[norm_cast]
theorem coe_mul (a b : α) : ((a * b : α) : Completion α) = a * b :=
  ((denseInducing_coe.Prod denseInducing_coe).extend_eq
      ((continuous_coe α).comp (@continuous_mul α _ _ _)) (a, b)).symm
#align uniform_space.completion.coe_mul UniformSpace.Completion.coe_mul

variable [UniformAddGroup α]

/- warning: uniform_space.completion.continuous_mul -> UniformSpace.Completion.continuous_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] [_inst_4 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))], Continuous.{u1, u1} (Prod.{u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2)) (UniformSpace.Completion.{u1} α _inst_2) (Prod.topologicalSpace.{u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2))) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) (fun (p : Prod.{u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2)) => HMul.hMul.{u1, u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (instHMul.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.hasMul.{u1} α _inst_1 _inst_2)) (Prod.fst.{u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) p) (Prod.snd.{u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) p))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] [_inst_4 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α _inst_1))], Continuous.{u1, u1} (Prod.{u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2)) (UniformSpace.Completion.{u1} α _inst_2) (instTopologicalSpaceProd.{u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2))) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) (fun (p : Prod.{u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2)) => HMul.hMul.{u1, u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (instHMul.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.mul.{u1} α _inst_1 _inst_2)) (Prod.fst.{u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) p) (Prod.snd.{u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) p))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.continuous_mul UniformSpace.Completion.continuous_mulₓ'. -/
theorem continuous_mul : Continuous fun p : Completion α × Completion α => p.1 * p.2 :=
  by
  let m := (AddMonoidHom.mul : α →+ α →+ α).compr₂ to_compl
  have : Continuous fun p : α × α => m p.1 p.2 := (continuous_coe α).comp continuous_mul
  have di : DenseInducing (to_compl : α → completion α) := dense_inducing_coe
  convert di.extend_Z_bilin di this
  ext ⟨x, y⟩
  rfl
#align uniform_space.completion.continuous_mul UniformSpace.Completion.continuous_mul

/- warning: uniform_space.completion.continuous.mul -> UniformSpace.Completion.Continuous.mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] [_inst_4 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))] {β : Type.{u2}} [_inst_5 : TopologicalSpace.{u2} β] {f : β -> (UniformSpace.Completion.{u1} α _inst_2)} {g : β -> (UniformSpace.Completion.{u1} α _inst_2)}, (Continuous.{u2, u1} β (UniformSpace.Completion.{u1} α _inst_2) _inst_5 (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) f) -> (Continuous.{u2, u1} β (UniformSpace.Completion.{u1} α _inst_2) _inst_5 (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) g) -> (Continuous.{u2, u1} β (UniformSpace.Completion.{u1} α _inst_2) _inst_5 (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) (fun (b : β) => HMul.hMul.{u1, u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (instHMul.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.hasMul.{u1} α _inst_1 _inst_2)) (f b) (g b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] [_inst_4 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α _inst_1))] {β : Type.{u2}} [_inst_5 : TopologicalSpace.{u2} β] {f : β -> (UniformSpace.Completion.{u1} α _inst_2)} {g : β -> (UniformSpace.Completion.{u1} α _inst_2)}, (Continuous.{u2, u1} β (UniformSpace.Completion.{u1} α _inst_2) _inst_5 (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) f) -> (Continuous.{u2, u1} β (UniformSpace.Completion.{u1} α _inst_2) _inst_5 (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) g) -> (Continuous.{u2, u1} β (UniformSpace.Completion.{u1} α _inst_2) _inst_5 (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) (fun (b : β) => HMul.hMul.{u1, u1, u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.{u1} α _inst_2) (instHMul.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.mul.{u1} α _inst_1 _inst_2)) (f b) (g b)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.continuous.mul UniformSpace.Completion.Continuous.mulₓ'. -/
theorem Continuous.mul {β : Type _} [TopologicalSpace β] {f g : β → Completion α}
    (hf : Continuous f) (hg : Continuous g) : Continuous fun b => f b * g b :=
  continuous_mul.comp (hf.prod_mk hg : _)
#align uniform_space.completion.continuous.mul UniformSpace.Completion.Continuous.mul

instance : Ring (Completion α) :=
  { AddMonoidWithOne.unary, Completion.addCommGroup, Completion.hasMul α,
    Completion.hasOne
      α with
    one_mul := fun a =>
      Completion.induction_on a
        (isClosed_eq (Continuous.mul continuous_const continuous_id) continuous_id) fun a => by
        rw [← coe_one, ← coe_mul, one_mul]
    mul_one := fun a =>
      Completion.induction_on a
        (isClosed_eq (Continuous.mul continuous_id continuous_const) continuous_id) fun a => by
        rw [← coe_one, ← coe_mul, mul_one]
    mul_assoc := fun a b c =>
      Completion.induction_on₃ a b c
        (isClosed_eq
          (Continuous.mul (Continuous.mul continuous_fst (continuous_fst.comp continuous_snd))
            (continuous_snd.comp continuous_snd))
          (Continuous.mul continuous_fst
            (Continuous.mul (continuous_fst.comp continuous_snd)
              (continuous_snd.comp continuous_snd))))
        fun a b c => by rw [← coe_mul, ← coe_mul, ← coe_mul, ← coe_mul, mul_assoc]
    left_distrib := fun a b c =>
      Completion.induction_on₃ a b c
        (isClosed_eq
          (Continuous.mul continuous_fst
            (Continuous.add (continuous_fst.comp continuous_snd)
              (continuous_snd.comp continuous_snd)))
          (Continuous.add (Continuous.mul continuous_fst (continuous_fst.comp continuous_snd))
            (Continuous.mul continuous_fst (continuous_snd.comp continuous_snd))))
        fun a b c => by rw [← coe_add, ← coe_mul, ← coe_mul, ← coe_mul, ← coe_add, mul_add]
    right_distrib := fun a b c =>
      Completion.induction_on₃ a b c
        (isClosed_eq
          (Continuous.mul (Continuous.add continuous_fst (continuous_fst.comp continuous_snd))
            (continuous_snd.comp continuous_snd))
          (Continuous.add (Continuous.mul continuous_fst (continuous_snd.comp continuous_snd))
            (Continuous.mul (continuous_fst.comp continuous_snd)
              (continuous_snd.comp continuous_snd))))
        fun a b c => by rw [← coe_add, ← coe_mul, ← coe_mul, ← coe_mul, ← coe_add, add_mul] }

/- warning: uniform_space.completion.coe_ring_hom -> UniformSpace.Completion.coeRingHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] [_inst_4 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))], RingHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] [_inst_4 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α _inst_1))], RingHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.coe_ring_hom UniformSpace.Completion.coeRingHomₓ'. -/
/-- The map from a uniform ring to its completion, as a ring homomorphism. -/
def coeRingHom : α →+* Completion α :=
  ⟨coe, coe_one α, fun a b => coe_mul a b, coe_zero, fun a b => coe_add a b⟩
#align uniform_space.completion.coe_ring_hom UniformSpace.Completion.coeRingHom

/- warning: uniform_space.completion.continuous_coe_ring_hom -> UniformSpace.Completion.continuous_coeRingHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] [_inst_4 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))], Continuous.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))) (fun (_x : RingHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))) => α -> (UniformSpace.Completion.{u1} α _inst_2)) (RingHom.hasCoeToFun.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))) (UniformSpace.Completion.coeRingHom.{u1} α _inst_1 _inst_2 _inst_3 _inst_4))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] [_inst_4 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α _inst_1))], Continuous.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => UniformSpace.Completion.{u1} α _inst_2) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))) α (UniformSpace.Completion.{u1} α _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} (UniformSpace.Completion.{u1} α _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))) α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))) α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4))) (RingHom.instRingHomClassRingHom.{u1, u1} α (UniformSpace.Completion.{u1} α _inst_2) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4))))))) (UniformSpace.Completion.coeRingHom.{u1} α _inst_1 _inst_2 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.continuous_coe_ring_hom UniformSpace.Completion.continuous_coeRingHomₓ'. -/
theorem continuous_coeRingHom : Continuous (coeRingHom : α → Completion α) :=
  continuous_coe α
#align uniform_space.completion.continuous_coe_ring_hom UniformSpace.Completion.continuous_coeRingHom

variable {β : Type u} [UniformSpace β] [Ring β] [UniformAddGroup β] [TopologicalRing β]
  (f : α →+* β) (hf : Continuous f)

/- warning: uniform_space.completion.extension_hom -> UniformSpace.Completion.extensionHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} [_inst_1 : Ring.{u2} α] [_inst_2 : UniformSpace.{u2} α] [_inst_3 : TopologicalRing.{u2} α (UniformSpace.toTopologicalSpace.{u2} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))] [_inst_4 : UniformAddGroup.{u2} α _inst_2 (AddGroupWithOne.toAddGroup.{u2} α (NonAssocRing.toAddGroupWithOne.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))] {β : Type.{u1}} [_inst_5 : UniformSpace.{u1} β] [_inst_6 : Ring.{u1} β] [_inst_7 : UniformAddGroup.{u1} β _inst_5 (AddGroupWithOne.toAddGroup.{u1} β (NonAssocRing.toAddGroupWithOne.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6)))] [_inst_8 : TopologicalRing.{u1} β (UniformSpace.toTopologicalSpace.{u1} β _inst_5) (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))] (f : RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))), (Continuous.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} β _inst_5) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) (fun (_x : RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) => α -> β) (RingHom.hasCoeToFun.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) f)) -> (forall [_inst_9 : CompleteSpace.{u1} β _inst_5] [_inst_10 : SeparatedSpace.{u1} β _inst_5], RingHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_2) β (NonAssocRing.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} α _inst_2) (Ring.toNonAssocRing.{u2} (UniformSpace.Completion.{u2} α _inst_2) (UniformSpace.Completion.ring.{u2} α _inst_1 _inst_2 _inst_3 _inst_4))) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6)))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : Ring.{u2} α] [_inst_2 : UniformSpace.{u2} α] [_inst_3 : TopologicalRing.{u2} α (UniformSpace.toTopologicalSpace.{u2} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))] [_inst_4 : UniformAddGroup.{u2} α _inst_2 (AddGroupWithOne.toAddGroup.{u2} α (Ring.toAddGroupWithOne.{u2} α _inst_1))] {β : Type.{u1}} [_inst_5 : UniformSpace.{u1} β] [_inst_6 : Ring.{u1} β] [_inst_7 : UniformAddGroup.{u1} β _inst_5 (AddGroupWithOne.toAddGroup.{u1} β (Ring.toAddGroupWithOne.{u1} β _inst_6))] [_inst_8 : TopologicalRing.{u1} β (UniformSpace.toTopologicalSpace.{u1} β _inst_5) (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))] (f : RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))), (Continuous.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} β _inst_5) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6)) (RingHom.instRingHomClassRingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6)))))) f)) -> (forall [_inst_9 : CompleteSpace.{u1} β _inst_5] [_inst_10 : SeparatedSpace.{u1} β _inst_5], RingHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_2) β (NonAssocRing.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} α _inst_2) (Ring.toNonAssocRing.{u2} (UniformSpace.Completion.{u2} α _inst_2) (UniformSpace.Completion.ring.{u2} α _inst_1 _inst_2 _inst_3 _inst_4))) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.extension_hom UniformSpace.Completion.extensionHomₓ'. -/
/-- The completion extension as a ring morphism. -/
def extensionHom [CompleteSpace β] [SeparatedSpace β] : Completion α →+* β :=
  have hf' : Continuous (f : α →+ β) := hf
  -- helping the elaborator
  have hf : UniformContinuous f := uniformContinuous_addMonoidHom_of_continuous hf'
  { toFun := Completion.extension f
    map_zero' := by rw [← coe_zero, extension_coe hf, f.map_zero]
    map_add' := fun a b =>
      Completion.induction_on₂ a b
        (isClosed_eq (continuous_extension.comp continuous_add)
          ((continuous_extension.comp continuous_fst).add
            (continuous_extension.comp continuous_snd)))
        fun a b => by
        rw [← coe_add, extension_coe hf, extension_coe hf, extension_coe hf, f.map_add]
    map_one' := by rw [← coe_one, extension_coe hf, f.map_one]
    map_mul' := fun a b =>
      Completion.induction_on₂ a b
        (isClosed_eq (continuous_extension.comp continuous_mul)
          ((continuous_extension.comp continuous_fst).mul
            (continuous_extension.comp continuous_snd)))
        fun a b => by
        rw [← coe_mul, extension_coe hf, extension_coe hf, extension_coe hf, f.map_mul] }
#align uniform_space.completion.extension_hom UniformSpace.Completion.extensionHom

/- warning: uniform_space.completion.top_ring_compl -> UniformSpace.Completion.topologicalRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] [_inst_4 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))], TopologicalRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Ring.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))] [_inst_4 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α _inst_1))], TopologicalRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.uniformSpace.{u1} α _inst_2)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} α _inst_2) (UniformSpace.Completion.ring.{u1} α _inst_1 _inst_2 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.top_ring_compl UniformSpace.Completion.topologicalRingₓ'. -/
instance topologicalRing : TopologicalRing (Completion α)
    where
  continuous_add := continuous_add
  continuous_mul := continuous_mul
#align uniform_space.completion.top_ring_compl UniformSpace.Completion.topologicalRing

/- warning: uniform_space.completion.map_ring_hom -> UniformSpace.Completion.mapRingHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} [_inst_1 : Ring.{u2} α] [_inst_2 : UniformSpace.{u2} α] [_inst_3 : TopologicalRing.{u2} α (UniformSpace.toTopologicalSpace.{u2} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))] [_inst_4 : UniformAddGroup.{u2} α _inst_2 (AddGroupWithOne.toAddGroup.{u2} α (NonAssocRing.toAddGroupWithOne.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))] {β : Type.{u1}} [_inst_5 : UniformSpace.{u1} β] [_inst_6 : Ring.{u1} β] [_inst_7 : UniformAddGroup.{u1} β _inst_5 (AddGroupWithOne.toAddGroup.{u1} β (NonAssocRing.toAddGroupWithOne.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6)))] [_inst_8 : TopologicalRing.{u1} β (UniformSpace.toTopologicalSpace.{u1} β _inst_5) (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))] (f : RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))), (Continuous.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} β _inst_5) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) (fun (_x : RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) => α -> β) (RingHom.hasCoeToFun.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) f)) -> (RingHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_2) (UniformSpace.Completion.{u1} β _inst_5) (NonAssocRing.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} α _inst_2) (Ring.toNonAssocRing.{u2} (UniformSpace.Completion.{u2} α _inst_2) (UniformSpace.Completion.ring.{u2} α _inst_1 _inst_2 _inst_3 _inst_4))) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} β _inst_5) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} β _inst_5) (UniformSpace.Completion.ring.{u1} β _inst_6 _inst_5 _inst_8 _inst_7))))
but is expected to have type
  forall {α : Type.{u2}} [_inst_1 : Ring.{u2} α] [_inst_2 : UniformSpace.{u2} α] [_inst_3 : TopologicalRing.{u2} α (UniformSpace.toTopologicalSpace.{u2} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))] [_inst_4 : UniformAddGroup.{u2} α _inst_2 (AddGroupWithOne.toAddGroup.{u2} α (Ring.toAddGroupWithOne.{u2} α _inst_1))] {β : Type.{u1}} [_inst_5 : UniformSpace.{u1} β] [_inst_6 : Ring.{u1} β] [_inst_7 : UniformAddGroup.{u1} β _inst_5 (AddGroupWithOne.toAddGroup.{u1} β (Ring.toAddGroupWithOne.{u1} β _inst_6))] [_inst_8 : TopologicalRing.{u1} β (UniformSpace.toTopologicalSpace.{u1} β _inst_5) (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))] (f : RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))), (Continuous.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} β _inst_5) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6))) α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6)) (RingHom.instRingHomClassRingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_6)))))) f)) -> (RingHom.{u2, u1} (UniformSpace.Completion.{u2} α _inst_2) (UniformSpace.Completion.{u1} β _inst_5) (NonAssocRing.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} α _inst_2) (Ring.toNonAssocRing.{u2} (UniformSpace.Completion.{u2} α _inst_2) (UniformSpace.Completion.ring.{u2} α _inst_1 _inst_2 _inst_3 _inst_4))) (NonAssocRing.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} β _inst_5) (Ring.toNonAssocRing.{u1} (UniformSpace.Completion.{u1} β _inst_5) (UniformSpace.Completion.ring.{u1} β _inst_6 _inst_5 _inst_8 _inst_7))))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.map_ring_hom UniformSpace.Completion.mapRingHomₓ'. -/
/-- The completion map as a ring morphism. -/
def mapRingHom (hf : Continuous f) : Completion α →+* Completion β :=
  extensionHom (coeRingHom.comp f) (continuous_coeRingHom.comp hf)
#align uniform_space.completion.map_ring_hom UniformSpace.Completion.mapRingHom

section Algebra

variable (A : Type _) [Ring A] [UniformSpace A] [UniformAddGroup A] [TopologicalRing A] (R : Type _)
  [CommSemiring R] [Algebra R A] [UniformContinuousConstSMul R A]

/- warning: uniform_space.completion.map_smul_eq_mul_coe -> UniformSpace.Completion.map_smul_eq_mul_coe is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_9 : Ring.{u1} A] [_inst_10 : UniformSpace.{u1} A] [_inst_11 : UniformAddGroup.{u1} A _inst_10 (AddGroupWithOne.toAddGroup.{u1} A (NonAssocRing.toAddGroupWithOne.{u1} A (Ring.toNonAssocRing.{u1} A _inst_9)))] [_inst_12 : TopologicalRing.{u1} A (UniformSpace.toTopologicalSpace.{u1} A _inst_10) (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A _inst_9))] (R : Type.{u2}) [_inst_13 : CommSemiring.{u2} R] [_inst_14 : Algebra.{u2, u1} R A _inst_13 (Ring.toSemiring.{u1} A _inst_9)] [_inst_15 : UniformContinuousConstSMul.{u2, u1} R A _inst_10 (SMulZeroClass.toHasSmul.{u2, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))))))) (SMulWithZero.toSmulZeroClass.{u2, u1} R A (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R A (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))))))) (Module.toMulActionWithZero.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_13) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9)))) (Algebra.toModule.{u2, u1} R A _inst_13 (Ring.toSemiring.{u1} A _inst_9) _inst_14)))))] (r : R), Eq.{succ u1} ((UniformSpace.Completion.{u1} A _inst_10) -> (UniformSpace.Completion.{u1} A _inst_10)) (UniformSpace.Completion.map.{u1, u1} A _inst_10 A _inst_10 (SMul.smul.{u2, u1} R A (SMulZeroClass.toHasSmul.{u2, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))))))) (SMulWithZero.toSmulZeroClass.{u2, u1} R A (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R A (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))))))) (Module.toMulActionWithZero.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_13) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9)))) (Algebra.toModule.{u2, u1} R A _inst_13 (Ring.toSemiring.{u1} A _inst_9) _inst_14))))) r)) (HMul.hMul.{u1, u1, u1} (UniformSpace.Completion.{u1} A _inst_10) (UniformSpace.Completion.{u1} A _inst_10) (UniformSpace.Completion.{u1} A _inst_10) (instHMul.{u1} (UniformSpace.Completion.{u1} A _inst_10) (UniformSpace.Completion.hasMul.{u1} A _inst_9 _inst_10)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) A (UniformSpace.Completion.{u1} A _inst_10) (HasLiftT.mk.{succ u1, succ u1} A (UniformSpace.Completion.{u1} A _inst_10) (CoeTCₓ.coe.{succ u1, succ u1} A (UniformSpace.Completion.{u1} A _inst_10) (UniformSpace.Completion.hasCoeT.{u1} A _inst_10))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))) (fun (_x : RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))) => R -> A) (RingHom.hasCoeToFun.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))) (algebraMap.{u2, u1} R A _inst_13 (Ring.toSemiring.{u1} A _inst_9) _inst_14) r)))
but is expected to have type
  forall (A : Type.{u2}) [_inst_9 : Ring.{u2} A] [_inst_10 : UniformSpace.{u2} A] [_inst_11 : UniformAddGroup.{u2} A _inst_10 (AddGroupWithOne.toAddGroup.{u2} A (Ring.toAddGroupWithOne.{u2} A _inst_9))] [_inst_12 : TopologicalRing.{u2} A (UniformSpace.toTopologicalSpace.{u2} A _inst_10) (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_9))] (R : Type.{u1}) [_inst_13 : CommSemiring.{u1} R] [_inst_14 : Algebra.{u1, u2} R A _inst_13 (Ring.toSemiring.{u2} A _inst_9)] [_inst_15 : UniformContinuousConstSMul.{u1, u2} R A _inst_10 (Algebra.toSMul.{u1, u2} R A _inst_13 (Ring.toSemiring.{u2} A _inst_9) _inst_14)] (r : R), Eq.{succ u2} ((UniformSpace.Completion.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10) -> (UniformSpace.Completion.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10)) (UniformSpace.Completion.map.{u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10 ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10 ((fun (x._@.Mathlib.Topology.Algebra.UniformRing._hyg.1706 : R) (x._@.Mathlib.Topology.Algebra.UniformRing._hyg.1708 : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) => HSMul.hSMul.{u1, u2, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (instHSMul.{u1, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Algebra.toSMul.{u1, u2} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_13 (Ring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_9) _inst_14)) x._@.Mathlib.Topology.Algebra.UniformRing._hyg.1706 x._@.Mathlib.Topology.Algebra.UniformRing._hyg.1708) r)) ((fun (x._@.Mathlib.Topology.Algebra.UniformRing._hyg.1723 : UniformSpace.Completion.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10) (x._@.Mathlib.Topology.Algebra.UniformRing._hyg.1725 : UniformSpace.Completion.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10) => HMul.hMul.{u2, u2, u2} (UniformSpace.Completion.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10) (UniformSpace.Completion.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10) (UniformSpace.Completion.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10) (instHMul.{u2} (UniformSpace.Completion.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10) (UniformSpace.Completion.mul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_9 _inst_10)) x._@.Mathlib.Topology.Algebra.UniformRing._hyg.1723 x._@.Mathlib.Topology.Algebra.UniformRing._hyg.1725) (UniformSpace.Completion.coe'.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9))) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9))) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9)) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9)))))) (algebraMap.{u1, u2} R A _inst_13 (Ring.toSemiring.{u2} A _inst_9) _inst_14) r)))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.map_smul_eq_mul_coe UniformSpace.Completion.map_smul_eq_mul_coeₓ'. -/
@[simp]
theorem map_smul_eq_mul_coe (r : R) :
    Completion.map ((· • ·) r) = (· * ·) (algebraMap R A r : Completion A) :=
  by
  ext x
  refine' completion.induction_on x _ fun a => _
  · exact isClosed_eq completion.continuous_map (continuous_mul_left _)
  · rw [map_coe (uniform_continuous_const_smul r) a, Algebra.smul_def, coe_mul]
#align uniform_space.completion.map_smul_eq_mul_coe UniformSpace.Completion.map_smul_eq_mul_coe

instance : Algebra R (Completion A) :=
  {
    (UniformSpace.Completion.coeRingHom : A →+* Completion A).comp
      (algebraMap R
        A) with
    commutes' := fun r x =>
      Completion.induction_on x (isClosed_eq (continuous_mul_left _) (continuous_mul_right _))
        fun a => by
        simpa only [coe_mul] using congr_arg (coe : A → completion A) (Algebra.commutes r a)
    smul_def' := fun r x => congr_fun (map_smul_eq_mul_coe A R r) x }

/- warning: uniform_space.completion.algebra_map_def -> UniformSpace.Completion.algebraMap_def is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_9 : Ring.{u1} A] [_inst_10 : UniformSpace.{u1} A] [_inst_11 : UniformAddGroup.{u1} A _inst_10 (AddGroupWithOne.toAddGroup.{u1} A (NonAssocRing.toAddGroupWithOne.{u1} A (Ring.toNonAssocRing.{u1} A _inst_9)))] [_inst_12 : TopologicalRing.{u1} A (UniformSpace.toTopologicalSpace.{u1} A _inst_10) (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A _inst_9))] (R : Type.{u2}) [_inst_13 : CommSemiring.{u2} R] [_inst_14 : Algebra.{u2, u1} R A _inst_13 (Ring.toSemiring.{u1} A _inst_9)] [_inst_15 : UniformContinuousConstSMul.{u2, u1} R A _inst_10 (SMulZeroClass.toHasSmul.{u2, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))))))) (SMulWithZero.toSmulZeroClass.{u2, u1} R A (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R A (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))))))) (Module.toMulActionWithZero.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_13) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9)))) (Algebra.toModule.{u2, u1} R A _inst_13 (Ring.toSemiring.{u1} A _inst_9) _inst_14)))))] (r : R), Eq.{succ u1} (UniformSpace.Completion.{u1} A _inst_10) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} R (UniformSpace.Completion.{u1} A _inst_10) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (Semiring.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} A _inst_10) (Ring.toSemiring.{u1} (UniformSpace.Completion.{u1} A _inst_10) (UniformSpace.Completion.ring.{u1} A _inst_9 _inst_10 _inst_12 _inst_11)))) (fun (_x : RingHom.{u2, u1} R (UniformSpace.Completion.{u1} A _inst_10) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (Semiring.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} A _inst_10) (Ring.toSemiring.{u1} (UniformSpace.Completion.{u1} A _inst_10) (UniformSpace.Completion.ring.{u1} A _inst_9 _inst_10 _inst_12 _inst_11)))) => R -> (UniformSpace.Completion.{u1} A _inst_10)) (RingHom.hasCoeToFun.{u2, u1} R (UniformSpace.Completion.{u1} A _inst_10) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (Semiring.toNonAssocSemiring.{u1} (UniformSpace.Completion.{u1} A _inst_10) (Ring.toSemiring.{u1} (UniformSpace.Completion.{u1} A _inst_10) (UniformSpace.Completion.ring.{u1} A _inst_9 _inst_10 _inst_12 _inst_11)))) (algebraMap.{u2, u1} R (UniformSpace.Completion.{u1} A _inst_10) _inst_13 (Ring.toSemiring.{u1} (UniformSpace.Completion.{u1} A _inst_10) (UniformSpace.Completion.ring.{u1} A _inst_9 _inst_10 _inst_12 _inst_11)) (UniformSpace.Completion.algebra.{u1, u2} A _inst_9 _inst_10 _inst_11 _inst_12 R _inst_13 _inst_14 _inst_15)) r) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) A (UniformSpace.Completion.{u1} A _inst_10) (HasLiftT.mk.{succ u1, succ u1} A (UniformSpace.Completion.{u1} A _inst_10) (CoeTCₓ.coe.{succ u1, succ u1} A (UniformSpace.Completion.{u1} A _inst_10) (UniformSpace.Completion.hasCoeT.{u1} A _inst_10))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))) (fun (_x : RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))) => R -> A) (RingHom.hasCoeToFun.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_13)) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_9))) (algebraMap.{u2, u1} R A _inst_13 (Ring.toSemiring.{u1} A _inst_9) _inst_14) r))
but is expected to have type
  forall (A : Type.{u2}) [_inst_9 : Ring.{u2} A] [_inst_10 : UniformSpace.{u2} A] [_inst_11 : UniformAddGroup.{u2} A _inst_10 (AddGroupWithOne.toAddGroup.{u2} A (Ring.toAddGroupWithOne.{u2} A _inst_9))] [_inst_12 : TopologicalRing.{u2} A (UniformSpace.toTopologicalSpace.{u2} A _inst_10) (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_9))] (R : Type.{u1}) [_inst_13 : CommSemiring.{u1} R] [_inst_14 : Algebra.{u1, u2} R A _inst_13 (Ring.toSemiring.{u2} A _inst_9)] [_inst_15 : UniformContinuousConstSMul.{u1, u2} R A _inst_10 (Algebra.toSMul.{u1, u2} R A _inst_13 (Ring.toSemiring.{u2} A _inst_9) _inst_14)] (r : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => UniformSpace.Completion.{u2} A _inst_10) r) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} R (UniformSpace.Completion.{u2} A _inst_10) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (Ring.toSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (UniformSpace.Completion.ring.{u2} A _inst_9 _inst_10 _inst_12 _inst_11)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => UniformSpace.Completion.{u2} A _inst_10) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} R (UniformSpace.Completion.{u2} A _inst_10) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (Ring.toSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (UniformSpace.Completion.ring.{u2} A _inst_9 _inst_10 _inst_12 _inst_11)))) R (UniformSpace.Completion.{u2} A _inst_10) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)))) (NonUnitalNonAssocSemiring.toMul.{u2} (UniformSpace.Completion.{u2} A _inst_10) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (Semiring.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (Ring.toSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (UniformSpace.Completion.ring.{u2} A _inst_9 _inst_10 _inst_12 _inst_11))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R (UniformSpace.Completion.{u2} A _inst_10) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (Ring.toSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (UniformSpace.Completion.ring.{u2} A _inst_9 _inst_10 _inst_12 _inst_11)))) R (UniformSpace.Completion.{u2} A _inst_10) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (Semiring.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (Ring.toSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (UniformSpace.Completion.ring.{u2} A _inst_9 _inst_10 _inst_12 _inst_11)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R (UniformSpace.Completion.{u2} A _inst_10) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (Ring.toSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (UniformSpace.Completion.ring.{u2} A _inst_9 _inst_10 _inst_12 _inst_11)))) R (UniformSpace.Completion.{u2} A _inst_10) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (Ring.toSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (UniformSpace.Completion.ring.{u2} A _inst_9 _inst_10 _inst_12 _inst_11))) (RingHom.instRingHomClassRingHom.{u1, u2} R (UniformSpace.Completion.{u2} A _inst_10) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (Ring.toSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (UniformSpace.Completion.ring.{u2} A _inst_9 _inst_10 _inst_12 _inst_11))))))) (algebraMap.{u1, u2} R (UniformSpace.Completion.{u2} A _inst_10) _inst_13 (Ring.toSemiring.{u2} (UniformSpace.Completion.{u2} A _inst_10) (UniformSpace.Completion.ring.{u2} A _inst_9 _inst_10 _inst_12 _inst_11)) (UniformSpace.Completion.algebra.{u2, u1} A _inst_9 _inst_10 _inst_11 _inst_12 R _inst_13 _inst_14 _inst_15)) r) (UniformSpace.Completion.coe'.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_10 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9))) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9))) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9)) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_13)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_9)))))) (algebraMap.{u1, u2} R A _inst_13 (Ring.toSemiring.{u2} A _inst_9) _inst_14) r))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.algebra_map_def UniformSpace.Completion.algebraMap_defₓ'. -/
theorem algebraMap_def (r : R) :
    algebraMap R (Completion A) r = (algebraMap R A r : Completion A) :=
  rfl
#align uniform_space.completion.algebra_map_def UniformSpace.Completion.algebraMap_def

end Algebra

section CommRing

variable (R : Type _) [CommRing R] [UniformSpace R] [UniformAddGroup R] [TopologicalRing R]

instance : CommRing (Completion R) :=
  { Completion.ring with
    mul_comm := fun a b =>
      Completion.induction_on₂ a b
        (isClosed_eq (continuous_fst.mul continuous_snd) (continuous_snd.mul continuous_fst))
        fun a b => by rw [← coe_mul, ← coe_mul, mul_comm] }

/- warning: uniform_space.completion.algebra' -> UniformSpace.Completion.algebra' is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_9 : CommRing.{u1} R] [_inst_10 : UniformSpace.{u1} R] [_inst_11 : UniformAddGroup.{u1} R _inst_10 (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_9))))] [_inst_12 : TopologicalRing.{u1} R (UniformSpace.toTopologicalSpace.{u1} R _inst_10) (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_9)))], Algebra.{u1, u1} R (UniformSpace.Completion.{u1} R _inst_10) (CommRing.toCommSemiring.{u1} R _inst_9) (Ring.toSemiring.{u1} (UniformSpace.Completion.{u1} R _inst_10) (UniformSpace.Completion.ring.{u1} R (CommRing.toRing.{u1} R _inst_9) _inst_10 _inst_12 _inst_11))
but is expected to have type
  forall (R : Type.{u1}) [_inst_9 : CommRing.{u1} R] [_inst_10 : UniformSpace.{u1} R] [_inst_11 : UniformAddGroup.{u1} R _inst_10 (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_9)))] [_inst_12 : TopologicalRing.{u1} R (UniformSpace.toTopologicalSpace.{u1} R _inst_10) (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_9)))], Algebra.{u1, u1} R (UniformSpace.Completion.{u1} R _inst_10) (CommRing.toCommSemiring.{u1} R _inst_9) (Ring.toSemiring.{u1} (UniformSpace.Completion.{u1} R _inst_10) (UniformSpace.Completion.ring.{u1} R (CommRing.toRing.{u1} R _inst_9) _inst_10 _inst_12 _inst_11))
Case conversion may be inaccurate. Consider using '#align uniform_space.completion.algebra' UniformSpace.Completion.algebra'ₓ'. -/
/-- A shortcut instance for the common case -/
instance algebra' : Algebra R (Completion R) := by infer_instance
#align uniform_space.completion.algebra' UniformSpace.Completion.algebra'

end CommRing

end UniformSpace.Completion

namespace UniformSpace

variable {α : Type _}

/- warning: uniform_space.ring_sep_rel -> UniformSpace.ring_sep_rel is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : CommRing.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))] [_inst_4 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))], Eq.{succ u1} (Setoid.{succ u1} α) (UniformSpace.separationSetoid.{u1} α _inst_2) (Submodule.quotientRel.{u1, u1} α α (CommRing.toRing.{u1} α _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (Semiring.toModule.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1))) (Ideal.closure.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (CommRing.toRing.{u1} α _inst_1) _inst_4 (Bot.bot.{u1} (Ideal.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1))) (Submodule.hasBot.{u1, u1} α α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1))))) (Semiring.toModule.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : CommRing.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))] [_inst_4 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))], Eq.{succ u1} (Setoid.{succ u1} α) (UniformSpace.separationSetoid.{u1} α _inst_2) (Submodule.quotientRel.{u1, u1} α α (CommRing.toRing.{u1} α _inst_1) (Ring.toAddCommGroup.{u1} α (CommRing.toRing.{u1} α _inst_1)) (Semiring.toModule.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1))) (Ideal.closure.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (CommRing.toRing.{u1} α _inst_1) _inst_4 (Bot.bot.{u1} (Ideal.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1))) (Submodule.instBotSubmodule.{u1, u1} α α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1))))) (Semiring.toModule.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align uniform_space.ring_sep_rel UniformSpace.ring_sep_relₓ'. -/
theorem ring_sep_rel (α) [CommRing α] [UniformSpace α] [UniformAddGroup α] [TopologicalRing α] :
    separationSetoid α = Submodule.quotientRel (Ideal.closure ⊥) :=
  Setoid.ext fun x y =>
    (addGroup_separationRel x y).trans <| Iff.trans (by rfl) (Submodule.quotientRel_r_def _).symm
#align uniform_space.ring_sep_rel UniformSpace.ring_sep_rel

/- warning: uniform_space.ring_sep_quot -> UniformSpace.ring_sep_quot is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [r : CommRing.{u1} α] [_inst_1 : UniformSpace.{u1} α] [_inst_2 : UniformAddGroup.{u1} α _inst_1 (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α r))))] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α r)))], Eq.{succ (succ u1)} Type.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_1)) (HasQuotient.Quotient.{u1, u1} α (Ideal.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))) (Ideal.hasQuotient.{u1} α r) (Ideal.closure.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (CommRing.toRing.{u1} α r) _inst_3 (Bot.bot.{u1} (Ideal.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))) (Submodule.hasBot.{u1, u1} α α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))))) (Semiring.toModule.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r)))))))
but is expected to have type
  forall (α : Type.{u1}) [r : CommRing.{u1} α] [_inst_1 : UniformSpace.{u1} α] [_inst_2 : UniformAddGroup.{u1} α _inst_1 (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α r)))] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α r)))], Eq.{succ (succ u1)} Type.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_1)) (HasQuotient.Quotient.{u1, u1} α (Ideal.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))) (Ideal.instHasQuotientIdealToSemiringToRing.{u1} α r) (Ideal.closure.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (CommRing.toRing.{u1} α r) _inst_3 (Bot.bot.{u1} (Ideal.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))) (Submodule.instBotSubmodule.{u1, u1} α α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))))) (Semiring.toModule.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r)))))))
Case conversion may be inaccurate. Consider using '#align uniform_space.ring_sep_quot UniformSpace.ring_sep_quotₓ'. -/
theorem ring_sep_quot (α : Type u) [r : CommRing α] [UniformSpace α] [UniformAddGroup α]
    [TopologicalRing α] : Quotient (separationSetoid α) = (α ⧸ (⊥ : Ideal α).closure) := by
  rw [@ring_sep_rel α r] <;> rfl
#align uniform_space.ring_sep_quot UniformSpace.ring_sep_quot

/- warning: uniform_space.sep_quot_equiv_ring_quot -> UniformSpace.sepQuotEquivRingQuot is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [r : CommRing.{u1} α] [_inst_1 : UniformSpace.{u1} α] [_inst_2 : UniformAddGroup.{u1} α _inst_1 (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α r))))] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α r)))], Equiv.{succ u1, succ u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_1)) (HasQuotient.Quotient.{u1, u1} α (Ideal.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))) (Ideal.hasQuotient.{u1} α r) (Ideal.closure.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (CommRing.toRing.{u1} α r) _inst_3 (Bot.bot.{u1} (Ideal.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))) (Submodule.hasBot.{u1, u1} α α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))))) (Semiring.toModule.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r)))))))
but is expected to have type
  forall (α : Type.{u1}) [r : CommRing.{u1} α] [_inst_1 : UniformSpace.{u1} α] [_inst_2 : UniformAddGroup.{u1} α _inst_1 (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α r)))] [_inst_3 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α r)))], Equiv.{succ u1, succ u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_1)) (HasQuotient.Quotient.{u1, u1} α (Ideal.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))) (Ideal.instHasQuotientIdealToSemiringToRing.{u1} α r) (Ideal.closure.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_1) (CommRing.toRing.{u1} α r) _inst_3 (Bot.bot.{u1} (Ideal.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))) (Submodule.instBotSubmodule.{u1, u1} α α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r))))) (Semiring.toModule.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α r)))))))
Case conversion may be inaccurate. Consider using '#align uniform_space.sep_quot_equiv_ring_quot UniformSpace.sepQuotEquivRingQuotₓ'. -/
/-- Given a topological ring `α` equipped with a uniform structure that makes subtraction uniformly
continuous, get an equivalence between the separated quotient of `α` and the quotient ring
corresponding to the closure of zero. -/
def sepQuotEquivRingQuot (α) [r : CommRing α] [UniformSpace α] [UniformAddGroup α]
    [TopologicalRing α] : Quotient (separationSetoid α) ≃ α ⧸ (⊥ : Ideal α).closure :=
  Quotient.congrRight fun x y =>
    (addGroup_separationRel x y).trans <| Iff.trans (by rfl) (Submodule.quotientRel_r_def _).symm
#align uniform_space.sep_quot_equiv_ring_quot UniformSpace.sepQuotEquivRingQuot

/- warning: uniform_space.comm_ring -> UniformSpace.commRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CommRing.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))] [_inst_4 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))], CommRing.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_2))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CommRing.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))] [_inst_4 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))], CommRing.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_2))
Case conversion may be inaccurate. Consider using '#align uniform_space.comm_ring UniformSpace.commRingₓ'. -/
-- TODO: use a form of transport a.k.a. lift definition a.k.a. transfer
instance commRing [CommRing α] [UniformSpace α] [UniformAddGroup α] [TopologicalRing α] :
    CommRing (Quotient (separationSetoid α)) := by rw [ring_sep_quot α] <;> infer_instance
#align uniform_space.comm_ring UniformSpace.commRing

/- warning: uniform_space.topological_ring -> UniformSpace.topologicalRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CommRing.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))] [_inst_4 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))], TopologicalRing.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_2)) (Quotient.topologicalSpace.{u1} α (UniformSpace.separationSetoid.{u1} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} α _inst_2)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_2)) (Ring.toNonAssocRing.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_2)) (CommRing.toRing.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_2)) (UniformSpace.commRing.{u1} α _inst_1 _inst_2 _inst_3 _inst_4))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CommRing.{u1} α] [_inst_2 : UniformSpace.{u1} α] [_inst_3 : UniformAddGroup.{u1} α _inst_2 (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))] [_inst_4 : TopologicalRing.{u1} α (UniformSpace.toTopologicalSpace.{u1} α _inst_2) (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))], TopologicalRing.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_2)) (instTopologicalSpaceQuotient.{u1} α (UniformSpace.separationSetoid.{u1} α _inst_2) (UniformSpace.toTopologicalSpace.{u1} α _inst_2)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_2)) (Ring.toNonAssocRing.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_2)) (CommRing.toRing.{u1} (Quotient.{succ u1} α (UniformSpace.separationSetoid.{u1} α _inst_2)) (UniformSpace.commRing.{u1} α _inst_1 _inst_2 _inst_3 _inst_4))))
Case conversion may be inaccurate. Consider using '#align uniform_space.topological_ring UniformSpace.topologicalRingₓ'. -/
instance topologicalRing [CommRing α] [UniformSpace α] [UniformAddGroup α] [TopologicalRing α] :
    TopologicalRing (Quotient (separationSetoid α)) :=
  by
  convert topologicalRing_quotient (⊥ : Ideal α).closure <;> try apply ring_sep_rel
  simp [UniformSpace.commRing]
#align uniform_space.topological_ring UniformSpace.topologicalRing

end UniformSpace

section UniformExtension

variable {α : Type _} [UniformSpace α] [Semiring α]

variable {β : Type _} [UniformSpace β] [Semiring β] [TopologicalSemiring β]

variable {γ : Type _} [UniformSpace γ] [Semiring γ] [TopologicalSemiring γ]

variable [T2Space γ] [CompleteSpace γ]

/- warning: dense_inducing.extend_ring_hom -> DenseInducing.extendRingHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : Semiring.{u1} α] {β : Type.{u2}} [_inst_3 : UniformSpace.{u2} β] [_inst_4 : Semiring.{u2} β] [_inst_5 : TopologicalSemiring.{u2} β (UniformSpace.toTopologicalSpace.{u2} β _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β _inst_4))] {γ : Type.{u3}} [_inst_6 : UniformSpace.{u3} γ] [_inst_7 : Semiring.{u3} γ] [_inst_8 : TopologicalSemiring.{u3} γ (UniformSpace.toTopologicalSpace.{u3} γ _inst_6) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} γ (Semiring.toNonAssocSemiring.{u3} γ _inst_7))] [_inst_9 : T2Space.{u3} γ (UniformSpace.toTopologicalSpace.{u3} γ _inst_6)] [_inst_10 : CompleteSpace.{u3} γ _inst_6] {i : RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)} {f : RingHom.{u1, u3} α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7)}, (UniformInducing.{u1, u2} α β _inst_1 _inst_3 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) (fun (_x : RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) i)) -> (DenseRange.{u2, u1} β (UniformSpace.toTopologicalSpace.{u2} β _inst_3) α (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) (fun (_x : RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) i)) -> (UniformContinuous.{u1, u3} α γ _inst_1 _inst_6 (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7)) (fun (_x : RingHom.{u1, u3} α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7)) => α -> γ) (RingHom.hasCoeToFun.{u1, u3} α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7)) f)) -> (RingHom.{u2, u3} β γ (Semiring.toNonAssocSemiring.{u2} β _inst_4) (Semiring.toNonAssocSemiring.{u3} γ _inst_7))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : UniformSpace.{u1} α] [_inst_2 : Semiring.{u1} α] {β : Type.{u2}} [_inst_3 : UniformSpace.{u2} β] [_inst_4 : Semiring.{u2} β] [_inst_5 : TopologicalSemiring.{u2} β (UniformSpace.toTopologicalSpace.{u2} β _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β _inst_4))] {γ : Type.{u3}} [_inst_6 : UniformSpace.{u3} γ] [_inst_7 : Semiring.{u3} γ] [_inst_8 : TopologicalSemiring.{u3} γ (UniformSpace.toTopologicalSpace.{u3} γ _inst_6) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} γ (Semiring.toNonAssocSemiring.{u3} γ _inst_7))] [_inst_9 : T2Space.{u3} γ (UniformSpace.toTopologicalSpace.{u3} γ _inst_6)] [_inst_10 : CompleteSpace.{u3} γ _inst_6] {i : RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)} {f : RingHom.{u1, u3} α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7)}, (UniformInducing.{u1, u2} α β _inst_1 _inst_3 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β _inst_4))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β _inst_4)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4) (RingHom.instRingHomClassRingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4))))) i)) -> (DenseRange.{u2, u1} β (UniformSpace.toTopologicalSpace.{u2} β _inst_3) α (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β _inst_4))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β _inst_4)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4)) α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4) (RingHom.instRingHomClassRingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u2} β _inst_4))))) i)) -> (UniformContinuous.{u1, u3} α γ _inst_1 _inst_6 (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (RingHom.{u1, u3} α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => γ) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (RingHom.{u1, u3} α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7)) α γ (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_2))) (NonUnitalNonAssocSemiring.toMul.{u3} γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} γ (Semiring.toNonAssocSemiring.{u3} γ _inst_7))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7)) α γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_2)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} γ (Semiring.toNonAssocSemiring.{u3} γ _inst_7)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7)) α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7) (RingHom.instRingHomClassRingHom.{u1, u3} α γ (Semiring.toNonAssocSemiring.{u1} α _inst_2) (Semiring.toNonAssocSemiring.{u3} γ _inst_7))))) f)) -> (RingHom.{u2, u3} β γ (Semiring.toNonAssocSemiring.{u2} β _inst_4) (Semiring.toNonAssocSemiring.{u3} γ _inst_7))
Case conversion may be inaccurate. Consider using '#align dense_inducing.extend_ring_hom DenseInducing.extendRingHomₓ'. -/
/-- The dense inducing extension as a ring homomorphism. -/
noncomputable def DenseInducing.extendRingHom {i : α →+* β} {f : α →+* γ} (ue : UniformInducing i)
    (dr : DenseRange i) (hf : UniformContinuous f) : β →+* γ
    where
  toFun := (ue.DenseInducing dr).extend f
  map_one' := by
    convert DenseInducing.extend_eq (ue.dense_inducing dr) hf.continuous 1
    exacts[i.map_one.symm, f.map_one.symm]
  map_zero' := by
    convert DenseInducing.extend_eq (ue.dense_inducing dr) hf.continuous 0
    exacts[i.map_zero.symm, f.map_zero.symm]
  map_add' := by
    have h := (uniformContinuous_uniformly_extend ue dr hf).Continuous
    refine' fun x y => DenseRange.induction_on₂ dr _ (fun a b => _) x y
    ·
      exact
        isClosed_eq (Continuous.comp h continuous_add)
          ((h.comp continuous_fst).add (h.comp continuous_snd))
    ·
      simp_rw [← i.map_add, DenseInducing.extend_eq (ue.dense_inducing dr) hf.continuous _, ←
        f.map_add]
  map_mul' := by
    have h := (uniformContinuous_uniformly_extend ue dr hf).Continuous
    refine' fun x y => DenseRange.induction_on₂ dr _ (fun a b => _) x y
    ·
      exact
        isClosed_eq (Continuous.comp h continuous_mul)
          ((h.comp continuous_fst).mul (h.comp continuous_snd))
    ·
      simp_rw [← i.map_mul, DenseInducing.extend_eq (ue.dense_inducing dr) hf.continuous _, ←
        f.map_mul]
#align dense_inducing.extend_ring_hom DenseInducing.extendRingHom

end UniformExtension

