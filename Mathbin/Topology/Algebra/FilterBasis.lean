import Mathbin.Order.Filter.Bases 
import Mathbin.Topology.Algebra.Module

/-!
# Group and ring filter bases

A `group_filter_basis` is a `filter_basis` on a group with some properties relating
the basis to the group structure. The main theorem is that a `group_filter_basis`
on a group gives a topology on the group which makes it into a topological group
with neighborhoods of the neutral element generated by the given basis.

## Main definitions and results

Given a group `G` and a ring `R`:

* `group_filter_basis G`: the type of filter bases that will become neighborhood of `1`
  for a topology on `G` compatible with the group structure
* `group_filter_basis.topology`: the associated topology
* `group_filter_basis.is_topological_group`: the compatibility between the above topology
  and the group structure
* `ring_filter_basis R`: the type of filter bases that will become neighborhood of `0`
  for a topology on `R` compatible with the ring structure
* `ring_filter_basis.topology`: the associated topology
* `ring_filter_basis.is_topological_ring`: the compatibility between the above topology
  and the ring structure

## References

* [N. Bourbaki, *General Topology*][bourbaki1966]
-/


open Filter Set TopologicalSpace Function

open_locale TopologicalSpace Filter Pointwise

universe u

/-- A `group_filter_basis` on a group is a `filter_basis` satisfying some additional axioms.
  Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `group_filter_basis`. Conversely given a `group_filter_basis` one can define a topology
  compatible with the group structure on `G`.  -/
class GroupFilterBasis(G : Type u)[Groupₓ G] extends FilterBasis G where 
  one' : ∀ {U}, U ∈ sets → (1 : G) ∈ U 
  mul' : ∀ {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ sets), (V*V) ⊆ U 
  inv' : ∀ {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ sets), V ⊆ (fun x => x⁻¹) ⁻¹' U 
  conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ sets), V ⊆ (fun x => (x₀*x)*x₀⁻¹) ⁻¹' U

/-- A `add_group_filter_basis` on an additive group is a `filter_basis` satisfying some additional
  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `add_group_filter_basis`. Conversely given a `add_group_filter_basis` one can define a topology
  compatible with the group structure on `G`. -/
class AddGroupFilterBasis(A : Type u)[AddGroupₓ A] extends FilterBasis A where 
  zero' : ∀ {U}, U ∈ sets → (0 : A) ∈ U 
  add' : ∀ {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ sets), (V+V) ⊆ U 
  neg' : ∀ {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ sets), V ⊆ (fun x => -x) ⁻¹' U 
  conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ sets), V ⊆ (fun x => (x₀+x)+-x₀) ⁻¹' U

attribute [toAdditive] GroupFilterBasis

attribute [toAdditive] GroupFilterBasis.one'

attribute [toAdditive] GroupFilterBasis.mul'

attribute [toAdditive] GroupFilterBasis.inv'

attribute [toAdditive] GroupFilterBasis.conj'

attribute [toAdditive] GroupFilterBasis.toFilterBasis

/-- `group_filter_basis` constructor in the commutative group case. -/
@[toAdditive "`add_group_filter_basis` constructor in the commutative group case."]
def groupFilterBasisOfComm {G : Type _} [CommGroupₓ G] (sets : Set (Set G)) (nonempty : sets.nonempty)
  (inter_sets : ∀ x y, x ∈ sets → y ∈ sets → ∃ (z : _)(_ : z ∈ sets), z ⊆ x ∩ y) (one : ∀ U (_ : U ∈ sets), (1 : G) ∈ U)
  (mul : ∀ U (_ : U ∈ sets), ∃ (V : _)(_ : V ∈ sets), (V*V) ⊆ U)
  (inv : ∀ U (_ : U ∈ sets), ∃ (V : _)(_ : V ∈ sets), V ⊆ (fun x => x⁻¹) ⁻¹' U) : GroupFilterBasis G :=
  { Sets, Nonempty, inter_sets, one' := one, mul' := mul, inv' := inv,
    conj' :=
      fun x U U_in =>
        ⟨U, U_in,
          by 
            simp ⟩ }

namespace GroupFilterBasis

variable{G : Type u}[Groupₓ G]{B : GroupFilterBasis G}

@[toAdditive]
instance  : HasMem (Set G) (GroupFilterBasis G) :=
  ⟨fun s f => s ∈ f.sets⟩

@[toAdditive]
theorem one {U : Set G} : U ∈ B → (1 : G) ∈ U :=
  GroupFilterBasis.one'

@[toAdditive]
theorem mul {U : Set G} : U ∈ B → ∃ (V : _)(_ : V ∈ B), (V*V) ⊆ U :=
  GroupFilterBasis.mul'

@[toAdditive]
theorem inv {U : Set G} : U ∈ B → ∃ (V : _)(_ : V ∈ B), V ⊆ (fun x => x⁻¹) ⁻¹' U :=
  GroupFilterBasis.inv'

@[toAdditive]
theorem conj : ∀ x₀, ∀ {U}, U ∈ B → ∃ (V : _)(_ : V ∈ B), V ⊆ (fun x => (x₀*x)*x₀⁻¹) ⁻¹' U :=
  GroupFilterBasis.conj'

/-- The trivial group filter basis consists of `{1}` only. The associated topology
is discrete. -/
@[toAdditive "The trivial additive group filter basis consists of `{0}` only. The associated\ntopology is discrete."]
instance  : Inhabited (GroupFilterBasis G) :=
  ⟨by 
      refine' { Sets := {{1}}, Nonempty := singleton_nonempty _, .. }
      all_goals 
        simp only [exists_prop, mem_singleton_iff]
      ·
        rintro - - rfl rfl 
        use {1}
        simp 
      ·
        simp 
      ·
        rintro - rfl 
        use {1}
        simp 
      ·
        rintro - rfl 
        use {1}
        simp 
      ·
        rintro x₀ - rfl 
        use {1}
        simp ⟩

@[toAdditive]
theorem prod_subset_self (B : GroupFilterBasis G) {U : Set G} (h : U ∈ B) : U ⊆ U*U :=
  fun x x_in => ⟨1, x, one h, x_in, one_mulₓ x⟩

/-- The neighborhood function of a `group_filter_basis` -/
@[toAdditive "The neighborhood function of a `add_group_filter_basis`"]
def N (B : GroupFilterBasis G) : G → Filter G :=
  fun x => map (fun y => x*y) B.to_filter_basis.filter

@[simp, toAdditive]
theorem N_one (B : GroupFilterBasis G) : B.N 1 = B.to_filter_basis.filter :=
  by 
    simp only [N, one_mulₓ, map_id']

-- error in Topology.Algebra.FilterBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[]]
protected
theorem has_basis
(B : group_filter_basis G)
(x : G) : has_basis (B.N x) (λ V : set G, «expr ∈ »(V, B)) (λ V, «expr '' »(λ y, «expr * »(x, y), V)) :=
has_basis.map (λ y, «expr * »(x, y)) to_filter_basis.has_basis

/-- The topological space structure coming from a group filter basis. -/
@[toAdditive "The topological space structure coming from an additive group filter basis."]
def topology (B : GroupFilterBasis G) : TopologicalSpace G :=
  TopologicalSpace.mkOfNhds B.N

@[toAdditive]
theorem nhds_eq (B : GroupFilterBasis G) {x₀ : G} : @nhds G B.topology x₀ = B.N x₀ :=
  by 
    rw [TopologicalSpace.nhds_mk_of_nhds]
    ·
      intro x U U_in 
      rw [(B.has_basis x).mem_iff] at U_in 
      rcases U_in with ⟨V, V_in, H⟩
      simpa [mem_pure] using H (mem_image_of_mem _ (GroupFilterBasis.one V_in))
    ·
      intro x U U_in 
      rw [(B.has_basis x).mem_iff] at U_in 
      rcases U_in with ⟨V, V_in, H⟩
      rcases GroupFilterBasis.mul V_in with ⟨W, W_in, hW⟩
      use (fun y => x*y) '' W, image_mem_map (FilterBasis.mem_filter_of_mem _ W_in)
      split 
      ·
        rw [image_subset_iff] at H⊢
        exact ((B.prod_subset_self W_in).trans hW).trans H
      ·
        rintro y ⟨t, tW, rfl⟩
        rw [(B.has_basis _).mem_iff]
        use W, W_in 
        apply subset.trans _ H 
        clear H 
        rintro z ⟨w, wW, rfl⟩
        exact
          ⟨t*w, hW (mul_mem_mul tW wW),
            by 
              simp [mul_assocₓ]⟩

@[toAdditive]
theorem nhds_one_eq (B : GroupFilterBasis G) : @nhds G B.topology (1 : G) = B.to_filter_basis.filter :=
  by 
    rw [B.nhds_eq]
    simp only [N, one_mulₓ]
    exact map_id

-- error in Topology.Algebra.FilterBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[]]
theorem nhds_has_basis
(B : group_filter_basis G)
(x₀ : G) : has_basis (@nhds G B.topology x₀) (λ
 V : set G, «expr ∈ »(V, B)) (λ V, «expr '' »(λ y, «expr * »(x₀, y), V)) :=
by { rw [expr B.nhds_eq] [],
  apply [expr B.has_basis] }

-- error in Topology.Algebra.FilterBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[]]
theorem nhds_one_has_basis
(B : group_filter_basis G) : has_basis (@nhds G B.topology 1) (λ V : set G, «expr ∈ »(V, B)) id :=
by { rw [expr B.nhds_one_eq] [],
  exact [expr B.to_filter_basis.has_basis] }

@[toAdditive]
theorem mem_nhds_one (B : GroupFilterBasis G) {U : Set G} (hU : U ∈ B) : U ∈ @nhds G B.topology 1 :=
  by 
    rw [B.nhds_one_has_basis.mem_iff]
    exact ⟨U, hU, rfl.subset⟩

-- error in Topology.Algebra.FilterBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If a group is endowed with a topological structure coming from
a group filter basis then it's a topological group. -/
@[to_additive #[], priority 100]
instance is_topological_group (B : group_filter_basis G) : @topological_group G B.topology _ :=
begin
  letI [] [] [":=", expr B.topology],
  have [ident basis] [] [":=", expr B.nhds_one_has_basis],
  have [ident basis'] [] [":=", expr basis.prod basis],
  refine [expr topological_group.of_nhds_one _ _ _ _],
  { rw [expr basis'.tendsto_iff basis] [],
    suffices [] [":", expr ∀
     U «expr ∈ » B, «expr∃ , »((V
       W), «expr ∧ »(«expr ∧ »(«expr ∈ »(V, B), «expr ∈ »(W, B)), ∀
       a b, «expr ∈ »(a, V) → «expr ∈ »(b, W) → «expr ∈ »(«expr * »(a, b), U)))],
    by simpa [] [] [] [] [] [],
    intros [ident U, ident U_in],
    rcases [expr mul U_in, "with", "⟨", ident V, ",", ident V_in, ",", ident hV, "⟩"],
    use ["[", expr V, ",", expr V, ",", expr V_in, ",", expr V_in, "]"],
    intros [ident a, ident b, ident a_in, ident b_in],
    exact [expr hV ⟨a, b, a_in, b_in, rfl⟩] },
  { rw [expr basis.tendsto_iff basis] [],
    intros [ident U, ident U_in],
    simpa [] [] [] [] [] ["using", expr inv U_in] },
  { intro [ident x₀],
    rw ["[", expr nhds_eq, ",", expr nhds_one_eq, "]"] [],
    refl },
  { intro [ident x₀],
    rw [expr basis.tendsto_iff basis] [],
    intros [ident U, ident U_in],
    exact [expr conj x₀ U_in] }
end

end GroupFilterBasis

/-- A `ring_filter_basis` on a ring is a `filter_basis` satisfying some additional axioms.
  Example : if `R` is a topological ring then the neighbourhoods of the identity are a
  `ring_filter_basis`. Conversely given a `ring_filter_basis` on a ring `R`, one can define a
  topology on `R` which is compatible with the ring structure.  -/
class RingFilterBasis(R : Type u)[Ringₓ R] extends AddGroupFilterBasis R where 
  mul' : ∀ {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ sets), (V*V) ⊆ U 
  mul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ sets), V ⊆ (fun x => x₀*x) ⁻¹' U 
  mul_right' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ sets), V ⊆ (fun x => x*x₀) ⁻¹' U

namespace RingFilterBasis

variable{R : Type u}[Ringₓ R](B : RingFilterBasis R)

instance  : HasMem (Set R) (RingFilterBasis R) :=
  ⟨fun s B => s ∈ B.sets⟩

theorem mul {U : Set R} (hU : U ∈ B) : ∃ (V : _)(_ : V ∈ B), (V*V) ⊆ U :=
  mul' hU

theorem mul_left (x₀ : R) {U : Set R} (hU : U ∈ B) : ∃ (V : _)(_ : V ∈ B), V ⊆ (fun x => x₀*x) ⁻¹' U :=
  mul_left' x₀ hU

theorem mul_right (x₀ : R) {U : Set R} (hU : U ∈ B) : ∃ (V : _)(_ : V ∈ B), V ⊆ (fun x => x*x₀) ⁻¹' U :=
  mul_right' x₀ hU

/-- The topology associated to a ring filter basis.
It has the given basis as a basis of neighborhoods of zero. -/
def topology : TopologicalSpace R :=
  B.to_add_group_filter_basis.topology

-- error in Topology.Algebra.FilterBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If a ring is endowed with a topological structure coming from
a ring filter basis then it's a topological ring. -/
@[priority 100]
instance is_topological_ring {R : Type u} [ring R] (B : ring_filter_basis R) : @topological_ring R B.topology _ :=
begin
  let [ident B'] [] [":=", expr B.to_add_group_filter_basis],
  letI [] [] [":=", expr B'.topology],
  have [ident basis] [] [":=", expr B'.nhds_zero_has_basis],
  have [ident basis'] [] [":=", expr basis.prod basis],
  haveI [] [] [":=", expr B'.is_topological_add_group],
  apply [expr topological_ring.of_add_group_of_nhds_zero],
  { rw [expr basis'.tendsto_iff basis] [],
    suffices [] [":", expr ∀
     U «expr ∈ » B', «expr∃ , »((V
       W), «expr ∧ »(«expr ∧ »(«expr ∈ »(V, B'), «expr ∈ »(W, B')), ∀
       a b, «expr ∈ »(a, V) → «expr ∈ »(b, W) → «expr ∈ »(«expr * »(a, b), U)))],
    by simpa [] [] [] [] [] [],
    intros [ident U, ident U_in],
    rcases [expr B.mul U_in, "with", "⟨", ident V, ",", ident V_in, ",", ident hV, "⟩"],
    use ["[", expr V, ",", expr V, ",", expr V_in, ",", expr V_in, "]"],
    intros [ident a, ident b, ident a_in, ident b_in],
    exact [expr hV ⟨a, b, a_in, b_in, rfl⟩] },
  { intro [ident x₀],
    rw [expr basis.tendsto_iff basis] [],
    intros [ident U],
    simpa [] [] [] [] [] ["using", expr B.mul_left x₀] },
  { intro [ident x₀],
    rw [expr basis.tendsto_iff basis] [],
    intros [ident U],
    simpa [] [] [] [] [] ["using", expr B.mul_right x₀] }
end

end RingFilterBasis

/-- A `module_filter_basis` on a module is a `filter_basis` satisfying some additional axioms.
  Example : if `M` is a topological module then the neighbourhoods of zero are a
  `module_filter_basis`. Conversely given a `module_filter_basis` one can define a topology
  compatible with the module structure on `M`.  -/
structure ModuleFilterBasis(R M : Type _)[CommRingₓ R][TopologicalSpace R][AddCommGroupₓ M][Module R M] extends
  AddGroupFilterBasis M where 
  smul' : ∀ {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ 𝓝 (0 : R))(W : _)(_ : W ∈ sets), V • W ⊆ U 
  smul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ (V : _)(_ : V ∈ sets), V ⊆ (fun x => x₀ • x) ⁻¹' U 
  smul_right' : ∀ (m₀ : M) {U}, U ∈ sets → ∀ᶠx in 𝓝 (0 : R), x • m₀ ∈ U

namespace ModuleFilterBasis

variable{R M : Type _}[CommRingₓ R][TopologicalSpace R][AddCommGroupₓ M][Module R M](B : ModuleFilterBasis R M)

instance GroupFilterBasis.hasMem : HasMem (Set M) (ModuleFilterBasis R M) :=
  ⟨fun s B => s ∈ B.sets⟩

theorem smul {U : Set M} (hU : U ∈ B) : ∃ (V : _)(_ : V ∈ 𝓝 (0 : R))(W : _)(_ : W ∈ B), V • W ⊆ U :=
  B.smul' hU

theorem smul_left (x₀ : R) {U : Set M} (hU : U ∈ B) : ∃ (V : _)(_ : V ∈ B), V ⊆ (fun x => x₀ • x) ⁻¹' U :=
  B.smul_left' x₀ hU

theorem smul_right (m₀ : M) {U : Set M} (hU : U ∈ B) : ∀ᶠx in 𝓝 (0 : R), x • m₀ ∈ U :=
  B.smul_right' m₀ hU

/-- If `R` is discrete then the trivial additive group filter basis on any `R`-module is a
module filter basis. -/
instance  [DiscreteTopology R] : Inhabited (ModuleFilterBasis R M) :=
  ⟨{ default$ AddGroupFilterBasis M with
      smul' :=
        by 
          rintro U (h : U ∈ {{(0 : M)}})
          rw [mem_singleton_iff] at h 
          use univ, univ_mem, {0}, rfl 
          rintro a ⟨x, m, -, hm, rfl⟩
          simp [mem_singleton_iff.1 hm, h],
      smul_left' :=
        by 
          rintro x₀ U (h : U ∈ {{(0 : M)}})
          rw [mem_singleton_iff] at h 
          use {0}, rfl 
          simp [h],
      smul_right' :=
        by 
          rintro m₀ U (h : U ∈ {{(0 : M)}})
          rw [mem_singleton_iff] at h 
          simp [h, nhds_discrete] }⟩

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. -/
def topology : TopologicalSpace M :=
  B.to_add_group_filter_basis.topology

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. This version gets the ring
topology by unification instead of type class inference. -/
def topology' {R M : Type _} [CommRingₓ R] {tR : TopologicalSpace R} [AddCommGroupₓ M] [Module R M]
  (B : ModuleFilterBasis R M) : TopologicalSpace M :=
  B.to_add_group_filter_basis.topology

-- error in Topology.Algebra.FilterBasis: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If a module is endowed with a topological structure coming from
a module filter basis then it's a topological module. -/
@[priority 100]
instance has_continuous_smul [topological_ring R] : @has_continuous_smul R M _ _ B.topology :=
begin
  let [ident B'] [] [":=", expr B.to_add_group_filter_basis],
  letI [] [] [":=", expr B'.topology],
  have [ident basis] [] [":=", expr B'.nhds_zero_has_basis],
  haveI [] [] [":=", expr B'.is_topological_add_group],
  apply [expr has_continuous_smul.of_nhds_zero],
  { rw [expr basis.tendsto_right_iff] [],
    intros [ident U, ident U_in],
    rcases [expr B.smul U_in, "with", "⟨", ident V, ",", ident V_in, ",", ident W, ",", ident W_in, ",", ident H, "⟩"],
    apply [expr mem_of_superset «expr $ »(prod_mem_prod V_in, B'.mem_nhds_zero W_in)],
    rintros ["⟨", ident v, ",", ident w, "⟩", "⟨", ident v_in, ":", expr «expr ∈ »(v, V), ",", ident w_in, ":", expr «expr ∈ »(w, W), "⟩"],
    exact [expr H (set.mem_smul_of_mem v_in w_in)] },
  { intro [ident m₀],
    rw [expr basis.tendsto_right_iff] [],
    intros [ident U, ident U_in],
    exact [expr B.smul_right m₀ U_in] },
  { intro [ident x₀],
    rw [expr basis.tendsto_right_iff] [],
    intros [ident U, ident U_in],
    rcases [expr B.smul_left x₀ U_in, "with", "⟨", ident V, ",", ident V_in, ",", ident hV, "⟩"],
    exact [expr mem_of_superset (B'.mem_nhds_zero V_in) hV] }
end

/-- Build a module filter basis from compatible ring and additive group filter bases. -/
def of_bases {R M : Type _} [CommRingₓ R] [AddCommGroupₓ M] [Module R M] (BR : RingFilterBasis R)
  (BM : AddGroupFilterBasis M) (smul : ∀ {U}, U ∈ BM → ∃ (V : _)(_ : V ∈ BR)(W : _)(_ : W ∈ BM), V • W ⊆ U)
  (smul_left : ∀ (x₀ : R) {U}, U ∈ BM → ∃ (V : _)(_ : V ∈ BM), V ⊆ (fun x => x₀ • x) ⁻¹' U)
  (smul_right : ∀ (m₀ : M) {U}, U ∈ BM → ∃ (V : _)(_ : V ∈ BR), V ⊆ (fun x => x • m₀) ⁻¹' U) :
  @ModuleFilterBasis R M _ BR.topology _ _ :=
  { BM with
    smul' :=
      by 
        intro U U_in 
        rcases smul U_in with ⟨V, V_in, W, W_in, H⟩
        exact ⟨V, BR.to_add_group_filter_basis.mem_nhds_zero V_in, W, W_in, H⟩,
    smul_left' := smul_left,
    smul_right' :=
      by 
        intro m₀ U U_in 
        rcases smul_right m₀ U_in with ⟨V, V_in, H⟩
        exact mem_of_superset (BR.to_add_group_filter_basis.mem_nhds_zero V_in) H }

end ModuleFilterBasis

