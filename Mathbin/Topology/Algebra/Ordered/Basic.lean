import Mathbin.Algebra.GroupWithZero.Power 
import Mathbin.Data.Set.Intervals.Pi 
import Mathbin.Order.Filter.Interval 
import Mathbin.Topology.Algebra.Group 
import Mathbin.Tactic.Linarith.Default 
import Mathbin.Tactic.Tfae

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-‚àû, a)` and `(b, +‚àû)`). We define it as `preorder.topology Œ±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `preorder.topology Œ±`). Instead,
we introduce a class `order_topology Œ±` (which is a `Prop`, also known as a mixin) saying that on
the type `Œ±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We also introduce another (mixin) class `order_closed_topology Œ±` saying that the set of points
`(x, y)` with `x ‚â§ y` is closed in the product space. This is automatically satisfied on a linear
order with the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`order_closed_topology` vs `order_topology`, `preorder` vs `partial_order` vs `linear_order` etc)
see their statements.

### Open / closed sets

* `is_open_lt` : if `f` and `g` are continuous functions, then `{x | f x < g x}` is open;
* `is_open_Iio`, `is_open_Ioi`, `is_open_Ioo` : open intervals are open;
* `is_closed_le` : if `f` and `g` are continuous functions, then `{x | f x ‚â§ g x}` is closed;
* `is_closed_Iic`, `is_closed_Ici`, `is_closed_Icc` : closed intervals are closed;
* `frontier_le_subset_eq`, `frontier_lt_subset_eq` : frontiers of both `{x | f x ‚â§ g x}`
  and `{x | f x < g x}` are included by `{x | f x = g x}`;
* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z ‚àà (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z ‚àà [x, y)`.

### Convergence and inequalities

* `le_of_tendsto_of_tendsto` : if `f` converges to `a`, `g` converges to `b`, and eventually
  `f x ‚â§ g x`, then `a ‚â§ b`
* `le_of_tendsto`, `ge_of_tendsto` : if `f` converges to `a` and eventually `f x ‚â§ b`
  (resp., `b ‚â§ f x`), then `a ‚â§ b` (resp., `b ‚â§ a); we also provide primed versions
  that assume the inequalities to hold for all `x`.

### Min, max, `Sup` and `Inf`

* `continuous.min`, `continuous.max`: pointwise `min`/`max` of two continuous functions is
  continuous.
* `tendsto.min`, `tendsto.max` : if `f` tends to `a` and `g` tends to `b`, then their pointwise
  `min`/`max` tend to `min a b` and `max a b`, respectively.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x ‚â§ f x ‚â§ h x`, then `f` converges to `a`.

## Implementation notes

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `‚Ñï` or `‚Ñ§`, or `‚Ñù` that could inherit a topology as the completion of `‚Ñö`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `preorder.topology Œ±` though, that can be registered as an instance when necessary, or
for specific types.
-/


open Classical Set Filter TopologicalSpace

open Function

open order_dual(toDual ofDual)

open_locale TopologicalSpace Classical Filter

universe u v w

variable{Œ± : Type u}{Œ≤ : Type v}{Œ≥ : Type w}

/-- A topology on a set which is both a topological space and a preorder is _order-closed_ if the
set of points `(x, y)` with `x ‚â§ y` is closed in the product space. We introduce this as a mixin.
This property is satisfied for the order topology on a linear order, but it can be satisfied more
generally, and suffices to derive many interesting properties relating order and topology. -/
class OrderClosedTopology(Œ± : Type _)[TopologicalSpace Œ±][Preorder‚Çì Œ±] : Prop where 
  is_closed_le' : IsClosed { p:Œ± √ó Œ± | p.1 ‚â§ p.2 }

instance  : ‚àÄ [TopologicalSpace Œ±], TopologicalSpace (OrderDual Œ±) :=
  id

instance  [TopologicalSpace Œ±] [h : first_countable_topology Œ±] : first_countable_topology (OrderDual Œ±) :=
  h

instance  [TopologicalSpace Œ±] [h : second_countable_topology Œ±] : second_countable_topology (OrderDual Œ±) :=
  h

@[toAdditive]
instance  [TopologicalSpace Œ±] [Mul Œ±] [h : HasContinuousMul Œ±] : HasContinuousMul (OrderDual Œ±) :=
  h

theorem Dense.order_dual [TopologicalSpace Œ±] {s : Set Œ±} (hs : Dense s) : Dense (OrderDual.ofDual ‚Åª¬π' s) :=
  hs

section OrderClosedTopology

section Preorder‚Çì

variable[TopologicalSpace Œ±][Preorder‚Çì Œ±][t : OrderClosedTopology Œ±]

include t

namespace Subtype

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
instance {p : Œ± ‚Üí exprProp()} : order_closed_topology (subtype p) :=
have this : continuous (Œª
 p : ¬´expr √ó ¬ª(subtype p, subtype p), ((p.fst : Œ±), (p.snd : Œ±))) := (continuous_subtype_coe.comp continuous_fst).prod_mk (continuous_subtype_coe.comp continuous_snd),
order_closed_topology.mk (t.is_closed_le'.preimage this)

end Subtype

theorem is_closed_le_prod : IsClosed { p:Œ± √ó Œ± | p.1 ‚â§ p.2 } :=
  t.is_closed_le'

theorem is_closed_le [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) :
  IsClosed { b | f b ‚â§ g b } :=
  continuous_iff_is_closed.mp (hf.prod_mk hg) _ is_closed_le_prod

theorem is_closed_le' (a : Œ±) : IsClosed { b | b ‚â§ a } :=
  is_closed_le continuous_id continuous_const

theorem is_closed_Iic {a : Œ±} : IsClosed (Iic a) :=
  is_closed_le' a

theorem is_closed_ge' (a : Œ±) : IsClosed { b | a ‚â§ b } :=
  is_closed_le continuous_const continuous_id

theorem is_closed_Ici {a : Œ±} : IsClosed (Ici a) :=
  is_closed_ge' a

instance  : OrderClosedTopology (OrderDual Œ±) :=
  ‚ü®(@OrderClosedTopology.is_closed_le' Œ± _ _ _).Preimage continuous_swap‚ü©

theorem is_closed_Icc {a b : Œ±} : IsClosed (Icc a b) :=
  IsClosed.inter is_closed_Ici is_closed_Iic

@[simp]
theorem closure_Icc (a b : Œ±) : Closure (Icc a b) = Icc a b :=
  is_closed_Icc.closure_eq

@[simp]
theorem closure_Iic (a : Œ±) : Closure (Iic a) = Iic a :=
  is_closed_Iic.closure_eq

@[simp]
theorem closure_Ici (a : Œ±) : Closure (Ici a) = Ici a :=
  is_closed_Ici.closure_eq

theorem le_of_tendsto_of_tendsto {f g : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [ne_bot b] (hf : tendsto f b (ùìù a‚ÇÅ))
  (hg : tendsto g b (ùìù a‚ÇÇ)) (h : f ‚â§·∂†[b] g) : a‚ÇÅ ‚â§ a‚ÇÇ :=
  have  : tendsto (fun b => (f b, g b)) b (ùìù (a‚ÇÅ, a‚ÇÇ)) :=
    by 
      rw [nhds_prod_eq] <;> exact hf.prod_mk hg 
  show (a‚ÇÅ, a‚ÇÇ) ‚àà { p:Œ± √ó Œ± | p.1 ‚â§ p.2 } from t.is_closed_le'.mem_of_tendsto this h

theorem le_of_tendsto_of_tendsto' {f g : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [ne_bot b] (hf : tendsto f b (ùìù a‚ÇÅ))
  (hg : tendsto g b (ùìù a‚ÇÇ)) (h : ‚àÄ x, f x ‚â§ g x) : a‚ÇÅ ‚â§ a‚ÇÇ :=
  le_of_tendsto_of_tendsto hf hg (eventually_of_forall h)

theorem le_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : Filter Œ≤} [ne_bot x] (lim : tendsto f x (ùìù a))
  (h : ‚àÄ·∂†c in x, f c ‚â§ b) : a ‚â§ b :=
  le_of_tendsto_of_tendsto lim‚Çì tendsto_const_nhds h

theorem le_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : Filter Œ≤} [ne_bot x] (lim : tendsto f x (ùìù a)) (h : ‚àÄ c, f c ‚â§ b) :
  a ‚â§ b :=
  le_of_tendsto lim‚Çì (eventually_of_forall h)

theorem ge_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : Filter Œ≤} [ne_bot x] (lim : tendsto f x (ùìù a))
  (h : ‚àÄ·∂†c in x, b ‚â§ f c) : b ‚â§ a :=
  le_of_tendsto_of_tendsto tendsto_const_nhds lim‚Çì h

theorem ge_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : Filter Œ≤} [ne_bot x] (lim : tendsto f x (ùìù a)) (h : ‚àÄ c, b ‚â§ f c) :
  b ‚â§ a :=
  ge_of_tendsto lim‚Çì (eventually_of_forall h)

@[simp]
theorem closure_le_eq [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) :
  Closure { b | f b ‚â§ g b } = { b | f b ‚â§ g b } :=
  (is_closed_le hf hg).closure_eq

theorem closure_lt_subset_le [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) :
  Closure { b | f b < g b } ‚äÜ { b | f b ‚â§ g b } :=
  by 
    rw [‚Üêclosure_le_eq hf hg]
    exact closure_mono fun b => le_of_lt‚Çì

theorem ContinuousWithinAt.closure_le [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : Set Œ≤} {x : Œ≤} (hx : x ‚àà Closure s)
  (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) (h : ‚àÄ y (_ : y ‚àà s), f y ‚â§ g y) : f x ‚â§ g x :=
  show (f x, g x) ‚àà { p:Œ± √ó Œ± | p.1 ‚â§ p.2 } from
    OrderClosedTopology.is_closed_le'.closure_subset ((hf.prod hg).mem_closure hx h)

/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,
then the set `{x ‚àà s | f x ‚â§ g x}` is a closed set. -/
theorem IsClosed.is_closed_le [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : Set Œ≤} (hs : IsClosed s) (hf : ContinuousOn f s)
  (hg : ContinuousOn g s) : IsClosed { x‚ààs | f x ‚â§ g x } :=
  (hf.prod hg).preimage_closed_of_closed hs OrderClosedTopology.is_closed_le'

omit t

theorem nhds_within_Ici_ne_bot {a b : Œ±} (H‚ÇÇ : a ‚â§ b) : ne_bot (ùìù[Ici a] b) :=
  nhds_within_ne_bot_of_mem H‚ÇÇ

@[instance]
theorem nhds_within_Ici_self_ne_bot (a : Œ±) : ne_bot (ùìù[Ici a] a) :=
  nhds_within_Ici_ne_bot (le_refl‚Çì a)

theorem nhds_within_Iic_ne_bot {a b : Œ±} (H : a ‚â§ b) : ne_bot (ùìù[Iic b] a) :=
  nhds_within_ne_bot_of_mem H

@[instance]
theorem nhds_within_Iic_self_ne_bot (a : Œ±) : ne_bot (ùìù[Iic a] a) :=
  nhds_within_Iic_ne_bot (le_refl‚Çì a)

end Preorder‚Çì

section PartialOrder‚Çì

variable[TopologicalSpace Œ±][PartialOrder‚Çì Œ±][t : OrderClosedTopology Œ±]

include t

private theorem is_closed_eq_aux : IsClosed { p:Œ± √ó Œ± | p.1 = p.2 } :=
  by 
    simp only [le_antisymm_iff‚Çì] <;> exact IsClosed.inter t.is_closed_le' (is_closed_le continuous_snd continuous_fst)

instance (priority := 90)OrderClosedTopology.to_t2_space : T2Space Œ± :=
  { t2 :=
      have  : IsOpen { p:Œ± √ó Œ± | p.1 ‚â† p.2 } := is_closed_eq_aux.is_open_compl 
      fun a b h =>
        let ‚ü®u, v, hu, hv, ha, hb, h‚ü© := is_open_prod_iff.mp this a b h
        ‚ü®u, v, hu, hv, ha, hb,
          Set.eq_empty_iff_forall_not_mem.2$
            fun a ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© =>
              have  : a ‚â† a := @h (a, a) ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
              this rfl‚ü© }

end PartialOrder‚Çì

section LinearOrder‚Çì

variable[TopologicalSpace Œ±][LinearOrder‚Çì Œ±][OrderClosedTopology Œ±]

theorem is_open_lt_prod : IsOpen { p:Œ± √ó Œ± | p.1 < p.2 } :=
  by 
    simpRw [‚Üêis_closed_compl_iff, compl_set_of, not_lt‚Çì]
    exact is_closed_le continuous_snd continuous_fst

theorem is_open_lt [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) :
  IsOpen { b | f b < g b } :=
  by 
    simp [lt_iff_not_ge‚Çì, -not_le‚Çì] <;> exact (is_closed_le hg hf).is_open_compl

variable{a b : Œ±}

theorem is_open_Iio : IsOpen (Iio a) :=
  is_open_lt continuous_id continuous_const

theorem is_open_Ioi : IsOpen (Ioi a) :=
  is_open_lt continuous_const continuous_id

theorem is_open_Ioo : IsOpen (Ioo a b) :=
  IsOpen.inter is_open_Ioi is_open_Iio

@[simp]
theorem interior_Ioi : Interior (Ioi a) = Ioi a :=
  is_open_Ioi.interior_eq

@[simp]
theorem interior_Iio : Interior (Iio a) = Iio a :=
  is_open_Iio.interior_eq

@[simp]
theorem interior_Ioo : Interior (Ioo a b) = Ioo a b :=
  is_open_Ioo.interior_eq

theorem Iio_mem_nhds {a b : Œ±} (h : a < b) : Iio b ‚àà ùìù a :=
  IsOpen.mem_nhds is_open_Iio h

theorem Ioi_mem_nhds {a b : Œ±} (h : a < b) : Ioi a ‚àà ùìù b :=
  IsOpen.mem_nhds is_open_Ioi h

theorem Iic_mem_nhds {a b : Œ±} (h : a < b) : Iic b ‚àà ùìù a :=
  mem_of_superset (Iio_mem_nhds h) Iio_subset_Iic_self

theorem Ici_mem_nhds {a b : Œ±} (h : a < b) : Ici a ‚àà ùìù b :=
  mem_of_superset (Ioi_mem_nhds h) Ioi_subset_Ici_self

theorem Ioo_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ioo a b ‚àà ùìù x :=
  IsOpen.mem_nhds is_open_Ioo ‚ü®ha, hb‚ü©

theorem Ioc_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ioc a b ‚àà ùìù x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ioc_self

theorem Ico_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ico a b ‚àà ùìù x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ico_self

theorem Icc_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Icc a b ‚àà ùìù x :=
  mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Icc_self

theorem eventually_le_of_tendsto_lt {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} {u v : Œ±} (hv : v < u) (h : tendsto f l (ùìù v)) :
  ‚àÄ·∂†a in l, f a ‚â§ u :=
  eventually.mono (tendsto_nhds.1 h (¬∑ < u) is_open_Iio hv) fun v => le_of_lt‚Çì

theorem eventually_ge_of_tendsto_gt {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} {u v : Œ±} (hv : u < v) (h : tendsto f l (ùìù v)) :
  ‚àÄ·∂†a in l, u ‚â§ f a :=
  eventually.mono (tendsto_nhds.1 h (¬∑ > u) is_open_Ioi hv) fun v => le_of_lt‚Çì

variable[TopologicalSpace Œ≥]

/-!
### Neighborhoods to the left and to the right on an `order_closed_topology`

Limits to the left and to the right of real functions are defined in terms of neighborhoods to
the left and to the right, either open or closed, i.e., members of `ùìù[Ioi a] a` and
`ùìù[Ici a] a` on the right, and similarly on the left. Here we simply prove that all
right-neighborhoods of a point are equal, and we'll prove later other useful characterizations which
require the stronger hypothesis `order_topology Œ±` -/


/-!
#### Right neighborhoods, point excluded
-/


theorem Ioo_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) : Ioo a c ‚àà ùìù[Ioi b] b :=
  mem_nhds_within.2
    ‚ü®Iio c, is_open_Iio, H.2,
      by 
        rw [inter_comm, Ioi_inter_Iio] <;> exact Ioo_subset_Ioo_left H.1‚ü©

theorem Ioc_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) : Ioc a c ‚àà ùìù[Ioi b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ioc_self

theorem Ico_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) : Ico a c ‚àà ùìù[Ioi b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ico_self

theorem Icc_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) : Icc a c ‚àà ùìù[Ioi b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Icc_self

@[simp]
theorem nhds_within_Ioc_eq_nhds_within_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioc a b] a = ùìù[Ioi a] a :=
  le_antisymm‚Çì (nhds_within_mono _ Ioc_subset_Ioi_self)$
    nhds_within_le_of_mem$ Ioc_mem_nhds_within_Ioi$ left_mem_Ico.2 h

@[simp]
theorem nhds_within_Ioo_eq_nhds_within_Ioi {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[Ioi a] a :=
  le_antisymm‚Çì (nhds_within_mono _ Ioo_subset_Ioi_self)$
    nhds_within_le_of_mem$ Ioo_mem_nhds_within_Ioi$ left_mem_Ico.2 h

@[simp]
theorem continuous_within_at_Ioc_iff_Ioi [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  ContinuousWithinAt f (Ioc a b) a ‚Üî ContinuousWithinAt f (Ioi a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioc_eq_nhds_within_Ioi h]

@[simp]
theorem continuous_within_at_Ioo_iff_Ioi [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  ContinuousWithinAt f (Ioo a b) a ‚Üî ContinuousWithinAt f (Ioi a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioo_eq_nhds_within_Ioi h]

/-!
#### Left neighborhoods, point excluded
-/


theorem Ioo_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) : Ioo a c ‚àà ùìù[Iio b] b :=
  by 
    simpa only [dual_Ioo] using Ioo_mem_nhds_within_Ioi (show to_dual b ‚àà Ico (to_dual c) (to_dual a) from H.symm)

theorem Ico_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) : Ico a c ‚àà ùìù[Iio b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ico_self

theorem Ioc_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) : Ioc a c ‚àà ùìù[Iio b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ioc_self

theorem Icc_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) : Icc a c ‚àà ùìù[Iio b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Icc_self

@[simp]
theorem nhds_within_Ico_eq_nhds_within_Iio {a b : Œ±} (h : a < b) : ùìù[Ico a b] b = ùìù[Iio b] b :=
  by 
    simpa only [dual_Ioc] using nhds_within_Ioc_eq_nhds_within_Ioi h.dual

@[simp]
theorem nhds_within_Ioo_eq_nhds_within_Iio {a b : Œ±} (h : a < b) : ùìù[Ioo a b] b = ùìù[Iio b] b :=
  by 
    simpa only [dual_Ioo] using nhds_within_Ioo_eq_nhds_within_Ioi h.dual

@[simp]
theorem continuous_within_at_Ico_iff_Iio {a b : Œ±} {f : Œ± ‚Üí Œ≥} (h : a < b) :
  ContinuousWithinAt f (Ico a b) b ‚Üî ContinuousWithinAt f (Iio b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ico_eq_nhds_within_Iio h]

@[simp]
theorem continuous_within_at_Ioo_iff_Iio {a b : Œ±} {f : Œ± ‚Üí Œ≥} (h : a < b) :
  ContinuousWithinAt f (Ioo a b) b ‚Üî ContinuousWithinAt f (Iio b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioo_eq_nhds_within_Iio h]

/-!
#### Right neighborhoods, point included
-/


theorem Ioo_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ioo a c) : Ioo a c ‚àà ùìù[Ici b] b :=
  mem_nhds_within_of_mem_nhds$ IsOpen.mem_nhds is_open_Ioo H

theorem Ioc_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ioo a c) : Ioc a c ‚àà ùìù[Ici b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Ici H) Ioo_subset_Ioc_self

theorem Ico_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ico a c) : Ico a c ‚àà ùìù[Ici b] b :=
  mem_nhds_within.2
    ‚ü®Iio c, is_open_Iio, H.2,
      by 
        simp only [inter_comm, Ici_inter_Iio, Ico_subset_Ico_left H.1]‚ü©

theorem Icc_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ico a c) : Icc a c ‚àà ùìù[Ici b] b :=
  mem_of_superset (Ico_mem_nhds_within_Ici H) Ico_subset_Icc_self

@[simp]
theorem nhds_within_Icc_eq_nhds_within_Ici {a b : Œ±} (h : a < b) : ùìù[Icc a b] a = ùìù[Ici a] a :=
  le_antisymm‚Çì (nhds_within_mono _ Icc_subset_Ici_self)$
    nhds_within_le_of_mem$ Icc_mem_nhds_within_Ici$ left_mem_Ico.2 h

@[simp]
theorem nhds_within_Ico_eq_nhds_within_Ici {a b : Œ±} (h : a < b) : ùìù[Ico a b] a = ùìù[Ici a] a :=
  le_antisymm‚Çì (nhds_within_mono _ fun x => And.left)$ nhds_within_le_of_mem$ Ico_mem_nhds_within_Ici$ left_mem_Ico.2 h

@[simp]
theorem continuous_within_at_Icc_iff_Ici [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  ContinuousWithinAt f (Icc a b) a ‚Üî ContinuousWithinAt f (Ici a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Icc_eq_nhds_within_Ici h]

@[simp]
theorem continuous_within_at_Ico_iff_Ici [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  ContinuousWithinAt f (Ico a b) a ‚Üî ContinuousWithinAt f (Ici a) a :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ico_eq_nhds_within_Ici h]

/-!
#### Left neighborhoods, point included
-/


theorem Ioo_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioo a c) : Ioo a c ‚àà ùìù[Iic b] b :=
  mem_nhds_within_of_mem_nhds$ IsOpen.mem_nhds is_open_Ioo H

theorem Ico_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioo a c) : Ico a c ‚àà ùìù[Iic b] b :=
  mem_of_superset (Ioo_mem_nhds_within_Iic H) Ioo_subset_Ico_self

theorem Ioc_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioc a c) : Ioc a c ‚àà ùìù[Iic b] b :=
  by 
    simpa only [dual_Ico] using Ico_mem_nhds_within_Ici (show to_dual b ‚àà Ico (to_dual c) (to_dual a) from H.symm)

theorem Icc_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioc a c) : Icc a c ‚àà ùìù[Iic b] b :=
  mem_of_superset (Ioc_mem_nhds_within_Iic H) Ioc_subset_Icc_self

@[simp]
theorem nhds_within_Icc_eq_nhds_within_Iic {a b : Œ±} (h : a < b) : ùìù[Icc a b] b = ùìù[Iic b] b :=
  by 
    simpa only [dual_Icc] using nhds_within_Icc_eq_nhds_within_Ici h.dual

@[simp]
theorem nhds_within_Ioc_eq_nhds_within_Iic {a b : Œ±} (h : a < b) : ùìù[Ioc a b] b = ùìù[Iic b] b :=
  by 
    simpa only [dual_Ico] using nhds_within_Ico_eq_nhds_within_Ici h.dual

@[simp]
theorem continuous_within_at_Icc_iff_Iic [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  ContinuousWithinAt f (Icc a b) b ‚Üî ContinuousWithinAt f (Iic b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Icc_eq_nhds_within_Iic h]

@[simp]
theorem continuous_within_at_Ioc_iff_Iic [TopologicalSpace Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  ContinuousWithinAt f (Ioc a b) b ‚Üî ContinuousWithinAt f (Iic b) b :=
  by 
    simp only [ContinuousWithinAt, nhds_within_Ioc_eq_nhds_within_Iic h]

end LinearOrder‚Çì

section LinearOrder‚Çì

variable[TopologicalSpace Œ±][LinearOrder‚Çì Œ±][OrderClosedTopology Œ±]{f g : Œ≤ ‚Üí Œ±}

section 

variable[TopologicalSpace Œ≤]

theorem frontier_le_subset_eq (hf : Continuous f) (hg : Continuous g) :
  Frontier { b | f b ‚â§ g b } ‚äÜ { b | f b = g b } :=
  by 
    rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg]
    rintro b ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©
    refine' le_antisymm‚Çì hb‚ÇÅ (closure_lt_subset_le hg hf _)
    convert hb‚ÇÇ using 2
    simp only [not_le.symm]
    rfl

theorem frontier_Iic_subset (a : Œ±) : Frontier (Iic a) ‚äÜ {a} :=
  frontier_le_subset_eq (@continuous_id Œ± _) continuous_const

theorem frontier_Ici_subset (a : Œ±) : Frontier (Ici a) ‚äÜ {a} :=
  @frontier_Iic_subset (OrderDual Œ±) _ _ _ _

theorem frontier_lt_subset_eq (hf : Continuous f) (hg : Continuous g) :
  Frontier { b | f b < g b } ‚äÜ { b | f b = g b } :=
  by 
    rw [‚Üêfrontier_compl] <;> convert frontier_le_subset_eq hg hf <;> simp [ext_iff, eq_comm]

theorem continuous_if_le [TopologicalSpace Œ≥] [‚àÄ x, Decidable (f x ‚â§ g x)] {f' g' : Œ≤ ‚Üí Œ≥} (hf : Continuous f)
  (hg : Continuous g) (hf' : ContinuousOn f' { x | f x ‚â§ g x }) (hg' : ContinuousOn g' { x | g x ‚â§ f x })
  (hfg : ‚àÄ x, f x = g x ‚Üí f' x = g' x) : Continuous fun x => if f x ‚â§ g x then f' x else g' x :=
  by 
    refine' continuous_if (fun a ha => hfg _ (frontier_le_subset_eq hf hg ha)) _ (hg'.mono _)
    ¬∑
      rwa [(is_closed_le hf hg).closure_eq]
    ¬∑
      simp only [not_le‚Çì]
      exact closure_lt_subset_le hg hf

theorem Continuous.if_le [TopologicalSpace Œ≥] [‚àÄ x, Decidable (f x ‚â§ g x)] {f' g' : Œ≤ ‚Üí Œ≥} (hf' : Continuous f')
  (hg' : Continuous g') (hf : Continuous f) (hg : Continuous g) (hfg : ‚àÄ x, f x = g x ‚Üí f' x = g' x) :
  Continuous fun x => if f x ‚â§ g x then f' x else g' x :=
  continuous_if_le hf hg hf'.continuous_on hg'.continuous_on hfg

@[continuity]
theorem Continuous.min (hf : Continuous f) (hg : Continuous g) : Continuous fun b => min (f b) (g b) :=
  by 
    simp only [min_def]
    exact hf.if_le hg hf hg fun x => id

@[continuity]
theorem Continuous.max (hf : Continuous f) (hg : Continuous g) : Continuous fun b => max (f b) (g b) :=
  @Continuous.min (OrderDual Œ±) _ _ _ _ _ _ _ hf hg

end 

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_min : continuous (Œª p : ¬´expr √ó ¬ª(Œ±, Œ±), min p.1 p.2) := continuous_fst.min continuous_snd

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_max : continuous (Œª p : ¬´expr √ó ¬ª(Œ±, Œ±), max p.1 p.2) := continuous_fst.max continuous_snd

theorem Filter.Tendsto.max {b : Filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (fun b => max (f b) (g b)) b (ùìù (max a‚ÇÅ a‚ÇÇ)) :=
  (continuous_max.Tendsto (a‚ÇÅ, a‚ÇÇ)).comp (hf.prod_mk_nhds hg)

theorem Filter.Tendsto.min {b : Filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (fun b => min (f b) (g b)) b (ùìù (min a‚ÇÅ a‚ÇÇ)) :=
  (continuous_min.Tendsto (a‚ÇÅ, a‚ÇÇ)).comp (hf.prod_mk_nhds hg)

theorem Dense.exists_lt [NoBotOrder Œ±] {s : Set Œ±} (hs : Dense s) (x : Œ±) : ‚àÉ (y : _)(_ : y ‚àà s), y < x :=
  hs.exists_mem_open is_open_Iio (no_bot x)

theorem Dense.exists_gt [NoTopOrder Œ±] {s : Set Œ±} (hs : Dense s) (x : Œ±) : ‚àÉ (y : _)(_ : y ‚àà s), x < y :=
  hs.order_dual.exists_lt x

theorem Dense.exists_le [NoBotOrder Œ±] {s : Set Œ±} (hs : Dense s) (x : Œ±) : ‚àÉ (y : _)(_ : y ‚àà s), y ‚â§ x :=
  (hs.exists_lt x).imp$ fun y hy => ‚ü®hy.fst, hy.snd.le‚ü©

theorem Dense.exists_ge [NoTopOrder Œ±] {s : Set Œ±} (hs : Dense s) (x : Œ±) : ‚àÉ (y : _)(_ : y ‚àà s), x ‚â§ y :=
  hs.order_dual.exists_le x

theorem Dense.exists_le' {s : Set Œ±} (hs : Dense s) (hbot : ‚àÄ x, IsBot x ‚Üí x ‚àà s) (x : Œ±) :
  ‚àÉ (y : _)(_ : y ‚àà s), y ‚â§ x :=
  by 
    byCases' hx : IsBot x
    ¬∑
      exact ‚ü®x, hbot x hx, le_rfl‚ü©
    ¬∑
      simp only [IsBot, not_forall, not_le‚Çì] at hx 
      rcases hs.exists_mem_open is_open_Iio hx with ‚ü®y, hys, hy : y < x‚ü©
      exact ‚ü®y, hys, hy.le‚ü©

theorem Dense.exists_ge' {s : Set Œ±} (hs : Dense s) (htop : ‚àÄ x, IsTop x ‚Üí x ‚àà s) (x : Œ±) :
  ‚àÉ (y : _)(_ : y ‚àà s), x ‚â§ y :=
  hs.order_dual.exists_le' htop x

theorem Dense.exists_between [DenselyOrdered Œ±] {s : Set Œ±} (hs : Dense s) {x y : Œ±} (h : x < y) :
  ‚àÉ (z : _)(_ : z ‚àà s), z ‚àà Ioo x y :=
  hs.exists_mem_open is_open_Ioo (nonempty_Ioo.2 h)

end LinearOrder‚Çì

end OrderClosedTopology

instance  [Preorder‚Çì Œ±] [TopologicalSpace Œ±] [OrderClosedTopology Œ±] [Preorder‚Çì Œ≤] [TopologicalSpace Œ≤]
  [OrderClosedTopology Œ≤] : OrderClosedTopology (Œ± √ó Œ≤) :=
  ‚ü®(is_closed_le (continuous_fst.comp continuous_fst) (continuous_fst.comp continuous_snd)).inter
      (is_closed_le (continuous_snd.comp continuous_fst) (continuous_snd.comp continuous_snd))‚ü©

instance  {Œπ : Type _} {Œ± : Œπ ‚Üí Type _} [‚àÄ i, Preorder‚Çì (Œ± i)] [‚àÄ i, TopologicalSpace (Œ± i)]
  [‚àÄ i, OrderClosedTopology (Œ± i)] : OrderClosedTopology (‚àÄ i, Œ± i) :=
  by 
    constructor 
    simp only [Pi.le_def, set_of_forall]
    exact
      is_closed_Inter
        fun i => is_closed_le ((continuous_apply i).comp continuous_fst) ((continuous_apply i).comp continuous_snd)

instance Pi.order_closed_topology' [Preorder‚Çì Œ≤] [TopologicalSpace Œ≤] [OrderClosedTopology Œ≤] :
  OrderClosedTopology (Œ± ‚Üí Œ≤) :=
  Pi.order_closed_topology

/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`preorder.topology`. -/
class OrderTopology(Œ± : Type _)[t : TopologicalSpace Œ±][Preorder‚Çì Œ±] : Prop where 
  topology_eq_generate_intervals : t = generate_from { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a }

/-- (Order) topology on a partial order `Œ±` generated by the subbase of open intervals
`(a, ‚àû) = { x ‚à£ a < x }, (-‚àû , b) = {x ‚à£ x < b}` for all `a, b` in `Œ±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def Preorder‚Çì.topology (Œ± : Type _) [Preorder‚Çì Œ±] : TopologicalSpace Œ± :=
  generate_from { s:Set Œ± | ‚àÉ a : Œ±, s = { b:Œ± | a < b } ‚à® s = { b:Œ± | b < a } }

section OrderTopology

instance  {Œ± : Type _} [TopologicalSpace Œ±] [PartialOrder‚Çì Œ±] [OrderTopology Œ±] : OrderTopology (OrderDual Œ±) :=
  ‚ü®by 
      convert @OrderTopology.topology_eq_generate_intervals Œ± _ _ _ <;> conv  in _ ‚à® _ => rw [Or.comm] <;> rfl‚ü©

section PartialOrder‚Çì

variable[TopologicalSpace Œ±][PartialOrder‚Çì Œ±][t : OrderTopology Œ±]

include t

theorem is_open_iff_generate_intervals {s : Set Œ±} : IsOpen s ‚Üî generate_open { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a } s :=
  by 
    rw [t.topology_eq_generate_intervals] <;> rfl

theorem is_open_lt' (a : Œ±) : IsOpen { b:Œ± | a < b } :=
  by 
    rw [@is_open_iff_generate_intervals Œ± _ _ t] <;> exact generate_open.basic _ ‚ü®a, Or.inl rfl‚ü©

theorem is_open_gt' (a : Œ±) : IsOpen { b:Œ± | b < a } :=
  by 
    rw [@is_open_iff_generate_intervals Œ± _ _ t] <;> exact generate_open.basic _ ‚ü®a, Or.inr rfl‚ü©

theorem lt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂†x in ùìù b, a < x :=
  IsOpen.mem_nhds (is_open_lt' _) h

theorem le_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂†x in ùìù b, a ‚â§ x :=
  (ùìù b).sets_of_superset (lt_mem_nhds h)$ fun b hb => le_of_lt‚Çì hb

theorem gt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂†x in ùìù a, x < b :=
  IsOpen.mem_nhds (is_open_gt' _) h

theorem ge_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂†x in ùìù a, x ‚â§ b :=
  (ùìù a).sets_of_superset (gt_mem_nhds h)$ fun b hb => le_of_lt‚Çì hb

theorem nhds_eq_order (a : Œ±) : ùìù a = (‚®Ö(b : _)(_ : b ‚àà Iio a), ùìü (Ioi b))‚äì‚®Ö(b : _)(_ : b ‚àà Ioi a), ùìü (Iio b) :=
  by 
    rw [t.topology_eq_generate_intervals, nhds_generate_from] <;>
      exact
        le_antisymm‚Çì
          (le_inf (le_binfi$ fun b hb => infi_le_of_le { c:Œ± | b < c }$ infi_le _ ‚ü®hb, b, Or.inl rfl‚ü©)
            (le_binfi$ fun b hb => infi_le_of_le { c:Œ± | c < b }$ infi_le _ ‚ü®hb, b, Or.inr rfl‚ü©))
          (le_infi$
            fun s =>
              le_infi$
                fun ‚ü®ha, b, hs‚ü© =>
                  match s, ha, hs with 
                  | _, h, Or.inl rfl => inf_le_of_left_le$ infi_le_of_le b$ infi_le _ h
                  | _, h, Or.inr rfl => inf_le_of_right_le$ infi_le_of_le b$ infi_le _ h)

theorem tendsto_order {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤} :
  tendsto f x (ùìù a) ‚Üî (‚àÄ a' (_ : a' < a), ‚àÄ·∂†b in x, a' < f b) ‚àß ‚àÄ a' (_ : a' > a), ‚àÄ·∂†b in x, f b < a' :=
  by 
    simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]

instance tendsto_Icc_class_nhds (a : Œ±) : tendsto_Ixx_class Icc (ùìù a) (ùìù a) :=
  by 
    simp only [nhds_eq_order, infi_subtype']
    refine' ((has_basis_infi_principal_finite _).inf (has_basis_infi_principal_finite _)).TendstoIxxClass fun s hs => _ 
    refine' ((ord_connected_bInter _).inter (ord_connected_bInter _)).out <;> intro _ _ 
    exacts[ord_connected_Ioi, ord_connected_Iio]

instance tendsto_Ico_class_nhds (a : Œ±) : tendsto_Ixx_class Ico (ùìù a) (ùìù a) :=
  tendsto_Ixx_class_of_subset fun _ _ => Ico_subset_Icc_self

instance tendsto_Ioc_class_nhds (a : Œ±) : tendsto_Ixx_class Ioc (ùìù a) (ùìù a) :=
  tendsto_Ixx_class_of_subset fun _ _ => Ioc_subset_Icc_self

instance tendsto_Ioo_class_nhds (a : Œ±) : tendsto_Ixx_class Ioo (ùìù a) (ùìù a) :=
  tendsto_Ixx_class_of_subset fun _ _ => Ioo_subset_Icc_self

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
eventually for the filter. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a : Œ±} (hg : tendsto g b (ùìù a))
  (hh : tendsto h b (ùìù a)) (hgf : ‚àÄ·∂†b in b, g b ‚â§ f b) (hfh : ‚àÄ·∂†b in b, f b ‚â§ h b) : tendsto f b (ùìù a) :=
  tendsto_order.2
    ‚ü®fun a' h' =>
        have  : ‚àÄ·∂†b in b, a' < g b := (tendsto_order.1 hg).left a' h' 
        by 
          filterUpwards [this, hgf] fun a => lt_of_lt_of_le‚Çì,
      fun a' h' =>
        have  : ‚àÄ·∂†b in b, h b < a' := (tendsto_order.1 hh).right a' h' 
        by 
          filterUpwards [this, hfh] fun a h‚ÇÅ h‚ÇÇ => lt_of_le_of_lt‚Çì h‚ÇÇ h‚ÇÅ‚ü©

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
everywhere. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤} {a : Œ±} (hg : tendsto g b (ùìù a))
  (hh : tendsto h b (ùìù a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) : tendsto f b (ùìù a) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (eventually_of_forall hgf) (eventually_of_forall hfh)

theorem nhds_order_unbounded {a : Œ±} (hu : ‚àÉ u, a < u) (hl : ‚àÉ l, l < a) :
  ùìù a = ‚®Ö(l : _)(h‚ÇÇ : l < a)(u : _)(h‚ÇÇ : a < u), ùìü (Ioo l u) :=
  have  : ‚àÉ u, u ‚àà Ioi a := hu 
  have  : ‚àÉ l, l ‚àà Iio a := hl 
  by 
    simp only [nhds_eq_order, inf_binfi, binfi_inf, inf_principal, Ioi_inter_Iio]
    rfl

theorem tendsto_order_unbounded {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤} (hu : ‚àÉ u, a < u) (hl : ‚àÉ l, l < a)
  (h : ‚àÄ l u, l < a ‚Üí a < u ‚Üí ‚àÄ·∂†b in x, l < f b ‚àß f b < u) : tendsto f x (ùìù a) :=
  by 
    rw [nhds_order_unbounded hu hl] <;>
      exact
        tendsto_infi.2$
          fun l =>
            tendsto_infi.2$
              fun hl => tendsto_infi.2$ fun u => tendsto_infi.2$ fun hu => tendsto_principal.2$ h l u hl hu

end PartialOrder‚Çì

instance tendsto_Ixx_nhds_within {Œ± : Type _} [Preorder‚Çì Œ±] [TopologicalSpace Œ±] (a : Œ±) {s t : Set Œ±} {Ixx}
  [tendsto_Ixx_class Ixx (ùìù a) (ùìù a)] [tendsto_Ixx_class Ixx (ùìü s) (ùìü t)] : tendsto_Ixx_class Ixx (ùìù[s] a) (ùìù[t] a) :=
  Filter.tendsto_Ixx_class_inf

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
instance tendsto_Icc_class_nhds_pi
{Œπ : Type*}
{Œ± : Œπ ‚Üí Type*}
[‚àÄ i, partial_order (Œ± i)]
[‚àÄ i, topological_space (Œ± i)]
[‚àÄ i, order_topology (Œ± i)]
(f : ‚àÄ i, Œ± i) : tendsto_Ixx_class Icc (exprùìù() f) (exprùìù() f) :=
begin
  constructor,
  conv [] ["in", expr (exprùìù() f).lift' powerset] { rw ["[", expr nhds_pi, ",", expr filter.pi, "]"] },
  simp [] [] ["only"] ["[", expr lift'_infi_powerset, ",", expr comap_lift'_eq2 monotone_powerset, ",", expr tendsto_infi, ",", expr tendsto_lift', ",", expr mem_powerset_iff, ",", expr subset_def, ",", expr mem_preimage, "]"] [] [],
  intros [ident i, ident s, ident hs],
  have [] [":", expr tendsto (Œª
    g : ‚àÄ i, Œ± i, g i) (exprùìù() f) (exprùìù() (f i))] [":=", expr (continuous_apply i).tendsto f],
  refine [expr (tendsto_lift'.1 ((this.comp tendsto_fst).Icc (this.comp tendsto_snd)) s hs).mono _],
  exact [expr Œª p hp g hg, hp ‚ü®hg.1 _, hg.2 _‚ü©]
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem induced_order_topology'
{Œ± : Type u}
{Œ≤ : Type v}
[partial_order Œ±]
[ta : topological_space Œ≤]
[partial_order Œ≤]
[order_topology Œ≤]
(f : Œ± ‚Üí Œ≤)
(hf : ‚àÄ {x y}, ¬´expr ‚Üî ¬ª(¬´expr < ¬ª(f x, f y), ¬´expr < ¬ª(x, y)))
(H‚ÇÅ : ‚àÄ {a x}, ¬´expr < ¬ª(x, f a) ‚Üí ¬´expr‚àÉ , ¬ª((b ¬´expr < ¬ª a), ¬´expr ‚â§ ¬ª(x, f b)))
(H‚ÇÇ : ‚àÄ
 {a x}, ¬´expr < ¬ª(f a, x) ‚Üí ¬´expr‚àÉ , ¬ª((b ¬´expr > ¬ª a), ¬´expr ‚â§ ¬ª(f b, x))) : @order_topology _ (induced f ta) _ :=
begin
  letI [] [] [":=", expr induced f ta],
  refine [expr ‚ü®eq_of_nhds_eq_nhds (Œª a, _)‚ü©],
  rw ["[", expr nhds_induced, ",", expr nhds_generate_from, ",", expr nhds_eq_order (f a), "]"] [],
  apply [expr le_antisymm],
  { refine [expr le_infi (Œª s, ¬´expr $ ¬ª(le_infi, Œª hs, le_principal_iff.2 _))],
    rcases [expr hs, "with", "‚ü®", ident ab, ",", ident b, ",", ident rfl, "|", ident rfl, "‚ü©"],
    { exact [expr mem_comap.2 ‚ü®{x | ¬´expr < ¬ª(f b, x)}, ¬´expr $ ¬ª(mem_inf_of_left, ¬´expr $ ¬ª(mem_infi_of_mem _, ¬´expr $ ¬ª(mem_infi_of_mem (hf.2 ab), mem_principal_self _))), Œª
        x, hf.1‚ü©] },
    { exact [expr mem_comap.2 ‚ü®{x | ¬´expr < ¬ª(x, f b)}, ¬´expr $ ¬ª(mem_inf_of_right, ¬´expr $ ¬ª(mem_infi_of_mem _, ¬´expr $ ¬ª(mem_infi_of_mem (hf.2 ab), mem_principal_self _))), Œª
        x, hf.1‚ü©] } },
  { rw ["[", "<-", expr map_le_iff_le_comap, "]"] [],
    refine [expr le_inf _ _]; refine [expr le_infi (Œª
      x, ¬´expr $ ¬ª(le_infi, Œª h, le_principal_iff.2 _))]; simp [] [] [] [] [] [],
    { rcases [expr H‚ÇÅ h, "with", "‚ü®", ident b, ",", ident ab, ",", ident xb, "‚ü©"],
      refine [expr mem_infi_of_mem _ (mem_infi_of_mem ‚ü®ab, b, or.inl rfl‚ü© (mem_principal.2 _))],
      exact [expr Œª c hc, lt_of_le_of_lt xb (hf.2 hc)] },
    { rcases [expr H‚ÇÇ h, "with", "‚ü®", ident b, ",", ident ab, ",", ident xb, "‚ü©"],
      refine [expr mem_infi_of_mem _ (mem_infi_of_mem ‚ü®ab, b, or.inr rfl‚ü© (mem_principal.2 _))],
      exact [expr Œª c hc, lt_of_lt_of_le (hf.2 hc) xb] } }
end

theorem induced_order_topology {Œ± : Type u} {Œ≤ : Type v} [PartialOrder‚Çì Œ±] [ta : TopologicalSpace Œ≤] [PartialOrder‚Çì Œ≤]
  [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y) (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) :
  @OrderTopology _ (induced f ta) _ :=
  induced_order_topology' f (@hf)
    (fun a x xa =>
      let ‚ü®b, xb, ba‚ü© := H xa
      ‚ü®b, hf.1 ba, le_of_lt‚Çì xb‚ü©)
    fun a x ax =>
      let ‚ü®b, ab, bx‚ü© := H ax
      ‚ü®b, hf.1 ab, le_of_lt‚Çì bx‚ü©

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- On an `ord_connected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance order_topology_of_ord_connected
{Œ± : Type u}
[ta : topological_space Œ±]
[linear_order Œ±]
[order_topology Œ±]
{t : set Œ±}
[ht : ord_connected t] : order_topology t :=
begin
  letI [] [] [":=", expr induced (coe : t ‚Üí Œ±) ta],
  refine [expr ‚ü®eq_of_nhds_eq_nhds (Œª a, _)‚ü©],
  rw ["[", expr nhds_induced, ",", expr nhds_generate_from, ",", expr nhds_eq_order (a : Œ±), "]"] [],
  apply [expr le_antisymm],
  { refine [expr le_infi (Œª s, ¬´expr $ ¬ª(le_infi, Œª hs, le_principal_iff.2 _))],
    rcases [expr hs, "with", "‚ü®", ident ab, ",", ident b, ",", ident rfl, "|", ident rfl, "‚ü©"],
    { refine [expr ‚ü®Ioi b, _, Œª _, id‚ü©],
      refine [expr mem_inf_of_left (mem_infi_of_mem b _)],
      exact [expr mem_infi_of_mem ab (mem_principal_self (Ioi ¬´expr‚Üë ¬ª(b)))] },
    { refine [expr ‚ü®Iio b, _, Œª _, id‚ü©],
      refine [expr mem_inf_of_right (mem_infi_of_mem b _)],
      exact [expr mem_infi_of_mem ab (mem_principal_self (Iio b))] } },
  { rw ["[", "<-", expr map_le_iff_le_comap, "]"] [],
    refine [expr le_inf _ _],
    { refine [expr le_infi (Œª x, ¬´expr $ ¬ª(le_infi, Œª h, le_principal_iff.2 _))],
      by_cases [expr hx, ":", expr ¬´expr ‚àà ¬ª(x, t)],
      { refine [expr mem_infi_of_mem (Ioi ‚ü®x, hx‚ü©) (mem_infi_of_mem ‚ü®h, ‚ü®‚ü®x, hx‚ü©, or.inl rfl‚ü©‚ü© _)],
        exact [expr Œª _, id] },
      simp [] [] ["only"] ["[", expr set_coe.exists, ",", expr mem_set_of_eq, ",", expr mem_map', "]"] [] [],
      convert [] [expr univ_sets _] [],
      suffices [ident hx'] [":", expr ‚àÄ y : t, ¬´expr ‚àà ¬ª(¬´expr‚Üë ¬ª(y), Ioi x)],
      { simp [] [] [] ["[", expr hx', "]"] [] [] },
      intros [ident y],
      revert [ident hx],
      contrapose ["!"] [],
      exact [expr Œª hx, ht.out y.2 a.2 ‚ü®le_of_not_gt hx, le_of_lt h‚ü©] },
    { refine [expr le_infi (Œª x, ¬´expr $ ¬ª(le_infi, Œª h, le_principal_iff.2 _))],
      by_cases [expr hx, ":", expr ¬´expr ‚àà ¬ª(x, t)],
      { refine [expr mem_infi_of_mem (Iio ‚ü®x, hx‚ü©) (mem_infi_of_mem ‚ü®h, ‚ü®‚ü®x, hx‚ü©, or.inr rfl‚ü©‚ü© _)],
        exact [expr Œª _, id] },
      simp [] [] ["only"] ["[", expr set_coe.exists, ",", expr mem_set_of_eq, ",", expr mem_map', "]"] [] [],
      convert [] [expr univ_sets _] [],
      suffices [ident hx'] [":", expr ‚àÄ y : t, ¬´expr ‚àà ¬ª(¬´expr‚Üë ¬ª(y), Iio x)],
      { simp [] [] [] ["[", expr hx', "]"] [] [] },
      intros [ident y],
      revert [ident hx],
      contrapose ["!"] [],
      exact [expr Œª hx, ht.out a.2 y.2 ‚ü®le_of_lt h, le_of_not_gt hx‚ü©] } }
end

theorem nhds_top_order [TopologicalSpace Œ±] [PartialOrder‚Çì Œ±] [OrderTop Œ±] [OrderTopology Œ±] :
  ùìù (‚ä§ : Œ±) = ‚®Ö(l : _)(h‚ÇÇ : l < ‚ä§), ùìü (Ioi l) :=
  by 
    simp [nhds_eq_order (‚ä§ : Œ±)]

theorem nhds_bot_order [TopologicalSpace Œ±] [PartialOrder‚Çì Œ±] [OrderBot Œ±] [OrderTopology Œ±] :
  ùìù (‚ä• : Œ±) = ‚®Ö(l : _)(h‚ÇÇ : ‚ä• < l), ùìü (Iio l) :=
  by 
    simp [nhds_eq_order (‚ä• : Œ±)]

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem nhds_top_basis
[topological_space Œ±]
[semilattice_sup Œ±]
[order_top Œ±]
[is_total Œ± has_le.le]
[order_topology Œ±]
[nontrivial Œ±] : (exprùìù() ¬´expr‚ä§¬ª()).has_basis (Œª a : Œ±, ¬´expr < ¬ª(a, ¬´expr‚ä§¬ª())) (Œª a : Œ±, Ioi a) :=
‚ü®begin
   simp [] [] ["only"] ["[", expr nhds_top_order, "]"] [] [],
   refine [expr @filter.mem_binfi_of_directed Œ± Œ± (Œª a, exprùìü() (Ioi a)) (Œª a, ¬´expr < ¬ª(a, ¬´expr‚ä§¬ª())) _ _],
   { rintros [ident a, "(", ident ha, ":", expr ¬´expr < ¬ª(a, ¬´expr‚ä§¬ª()), ")", ident b, "(", ident hb, ":", expr ¬´expr < ¬ª(b, ¬´expr‚ä§¬ª()), ")"],
     use [expr ¬´expr ‚äî ¬ª(a, b)],
     simp [] [] ["only"] ["[", expr filter.le_principal_iff, ",", expr ge_iff_le, ",", expr order.preimage, "]"] [] [],
     exact [expr ‚ü®sup_lt_iff.mpr ‚ü®ha, hb‚ü©, Ioi_subset_Ioi le_sup_left, Ioi_subset_Ioi le_sup_right‚ü©] },
   { obtain ["‚ü®", ident a, ",", ident ha, "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((a : Œ±), ¬´expr ‚â† ¬ª(a, ¬´expr‚ä§¬ª())), ":=", expr exists_ne ¬´expr‚ä§¬ª()],
     exact [expr ‚ü®a, lt_top_iff_ne_top.mpr ha‚ü©] }
 end‚ü©

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem nhds_bot_basis
[topological_space Œ±]
[semilattice_inf Œ±]
[order_bot Œ±]
[is_total Œ± has_le.le]
[order_topology Œ±]
[nontrivial Œ±] : (exprùìù() ¬´expr‚ä•¬ª()).has_basis (Œª a : Œ±, ¬´expr < ¬ª(¬´expr‚ä•¬ª(), a)) (Œª a : Œ±, Iio a) :=
@nhds_top_basis (order_dual Œ±) _ _ _ _ _ _

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem nhds_top_basis_Ici
[topological_space Œ±]
[semilattice_sup Œ±]
[order_top Œ±]
[is_total Œ± has_le.le]
[order_topology Œ±]
[nontrivial Œ±]
[densely_ordered Œ±] : (exprùìù() ¬´expr‚ä§¬ª()).has_basis (Œª a : Œ±, ¬´expr < ¬ª(a, ¬´expr‚ä§¬ª())) Ici :=
nhds_top_basis.to_has_basis (Œª a ha, let ‚ü®b, hab, hb‚ü© := exists_between ha in
 ‚ü®b, hb, Ici_subset_Ioi.mpr hab‚ü©) (Œª a ha, ‚ü®a, ha, Ioi_subset_Ici_self‚ü©)

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem nhds_bot_basis_Iic
[topological_space Œ±]
[semilattice_inf Œ±]
[order_bot Œ±]
[is_total Œ± has_le.le]
[order_topology Œ±]
[nontrivial Œ±]
[densely_ordered Œ±] : (exprùìù() ¬´expr‚ä•¬ª()).has_basis (Œª a : Œ±, ¬´expr < ¬ª(¬´expr‚ä•¬ª(), a)) Iic :=
@nhds_top_basis_Ici (order_dual Œ±) _ _ _ _ _ _ _

theorem tendsto_nhds_top_mono [TopologicalSpace Œ≤] [PartialOrder‚Çì Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤] {l : Filter Œ±}
  {f g : Œ± ‚Üí Œ≤} (hf : tendsto f l (ùìù ‚ä§)) (hg : f ‚â§·∂†[l] g) : tendsto g l (ùìù ‚ä§) :=
  by 
    simp only [nhds_top_order, tendsto_infi, tendsto_principal] at hf‚ä¢
    intro x hx 
    filterUpwards [hf x hx, hg]
    exact fun x => lt_of_lt_of_le‚Çì

theorem tendsto_nhds_bot_mono [TopologicalSpace Œ≤] [PartialOrder‚Çì Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤] {l : Filter Œ±}
  {f g : Œ± ‚Üí Œ≤} (hf : tendsto f l (ùìù ‚ä•)) (hg : g ‚â§·∂†[l] f) : tendsto g l (ùìù ‚ä•) :=
  @tendsto_nhds_top_mono Œ± (OrderDual Œ≤) _ _ _ _ _ _ _ hf hg

theorem tendsto_nhds_top_mono' [TopologicalSpace Œ≤] [PartialOrder‚Çì Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤] {l : Filter Œ±}
  {f g : Œ± ‚Üí Œ≤} (hf : tendsto f l (ùìù ‚ä§)) (hg : f ‚â§ g) : tendsto g l (ùìù ‚ä§) :=
  tendsto_nhds_top_mono hf (eventually_of_forall hg)

theorem tendsto_nhds_bot_mono' [TopologicalSpace Œ≤] [PartialOrder‚Çì Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤] {l : Filter Œ±}
  {f g : Œ± ‚Üí Œ≤} (hf : tendsto f l (ùìù ‚ä•)) (hg : g ‚â§ f) : tendsto g l (ùìù ‚ä•) :=
  tendsto_nhds_bot_mono hf (eventually_of_forall hg)

section LinearOrder‚Çì

variable[TopologicalSpace Œ±][LinearOrder‚Çì Œ±][OrderTopology Œ±]

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem exists_Ioc_subset_of_mem_nhds'
{a : Œ±}
{s : set Œ±}
(hs : ¬´expr ‚àà ¬ª(s, exprùìù() a))
{l : Œ±}
(hl : ¬´expr < ¬ª(l, a)) : ¬´expr‚àÉ , ¬ª((l' ¬´expr ‚àà ¬ª Ico l a), ¬´expr ‚äÜ ¬ª(Ioc l' a, s)) :=
begin
  rw ["[", expr nhds_eq_order a, "]"] ["at", ident hs],
  rcases [expr hs, "with", "‚ü®", ident t‚ÇÅ, ",", ident ht‚ÇÅ, ",", ident t‚ÇÇ, ",", ident ht‚ÇÇ, ",", ident rfl, "‚ü©"],
  suffices [] [":", expr ¬´expr‚àÉ , ¬ª((l' ¬´expr ‚àà ¬ª Ico l a), ¬´expr ‚äÜ ¬ª(Ioi l', t‚ÇÅ))],
  { have [ident A] [":", expr ¬´expr ‚â§ ¬ª(exprùìü() (Iic a), ¬´expr‚®Ö , ¬ª((b ¬´expr ‚àà ¬ª Ioi a), exprùìü() (Iio b)))] [],
    from [expr ¬´expr $ ¬ª(le_infi, Œª b, ¬´expr $ ¬ª(le_infi, Œª hb, ¬´expr $ ¬ª(principal_mono.2, Iic_subset_Iio.2 hb)))],
    have [ident B] [":", expr ¬´expr ‚äÜ ¬ª(¬´expr ‚à© ¬ª(t‚ÇÅ, Iic a), ¬´expr ‚à© ¬ª(t‚ÇÅ, t‚ÇÇ))] [],
    from [expr inter_subset_inter_right _ (A ht‚ÇÇ)],
    from [expr this.imp (Œª l', ¬´expr $ ¬ª(Exists.imp, Œª hl' hl x hx, B ‚ü®hl hx.1, hx.2‚ü©))] },
  clear [ident ht‚ÇÇ, ident t‚ÇÇ],
  rw ["[", expr mem_binfi_of_directed, "]"] ["at", ident ht‚ÇÅ],
  { rcases [expr ht‚ÇÅ, "with", "‚ü®", ident b, ",", ident hb, ",", ident hb', "‚ü©"],
    exact [expr ‚ü®max b l, ‚ü®le_max_right _ _, max_lt hb hl‚ü©, Œª
      x hx, ¬´expr $ ¬ª(hb', Ioi_subset_Ioi (le_max_left _ _) hx)‚ü©] },
  { intros [ident b, ident hb, ident b', ident hb'],
    simp [] [] ["only"] ["[", expr mem_Iio, "]"] [] ["at", ident hb, ident hb'],
    use ["[", expr max b b', ",", expr max_lt hb hb', "]"],
    simp [] [] [] ["[", expr le_refl, "]"] [] [] },
  exact [expr ‚ü®l, hl‚ü©]
end

theorem exists_Ico_subset_of_mem_nhds' {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {u : Œ±} (hu : a < u) :
  ‚àÉ (u' : _)(_ : u' ‚àà Ioc a u), Ico a u' ‚äÜ s :=
  by 
    simpa only [OrderDual.exists, exists_prop, dual_Ico, dual_Ioc] using
      exists_Ioc_subset_of_mem_nhds' (show of_dual ‚Åª¬π' s ‚àà ùìù (to_dual a) from hs) hu.dual

theorem exists_Ioc_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ l, l < a) :
  ‚àÉ (l : _)(_ : l < a), Ioc l a ‚äÜ s :=
  let ‚ü®l', hl'‚ü© := h 
  let ‚ü®l, hl‚ü© := exists_Ioc_subset_of_mem_nhds' hs hl'
  ‚ü®l, hl.fst.2, hl.snd‚ü©

theorem exists_Ico_subset_of_mem_nhds {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ u, a < u) :
  ‚àÉ (u : _)(_ : a < u), Ico a u ‚äÜ s :=
  let ‚ü®l', hl'‚ü© := h 
  let ‚ü®l, hl‚ü© := exists_Ico_subset_of_mem_nhds' hs hl'
  ‚ü®l, hl.fst.1, hl.snd‚ü©

theorem IsOpen.exists_Ioo_subset [Nontrivial Œ±] {s : Set Œ±} (hs : IsOpen s) (h : s.nonempty) :
  ‚àÉ a b, a < b ‚àß Ioo a b ‚äÜ s :=
  by 
    obtain ‚ü®x, hx‚ü© : ‚àÉ x, x ‚àà s := h 
    obtain ‚ü®y, hy‚ü© : ‚àÉ y, y ‚â† x := exists_ne x 
    rcases lt_trichotomy‚Çì x y with (H | rfl | H)
    ¬∑
      obtain ‚ü®u, xu, hu‚ü© : ‚àÉ (u : Œ±)(hu : x < u), Ico x u ‚äÜ s := exists_Ico_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©
      exact ‚ü®x, u, xu, Ioo_subset_Ico_self.trans hu‚ü©
    ¬∑
      exact (hy rfl).elim
    ¬∑
      obtain ‚ü®l, lx, hl‚ü© : ‚àÉ (l : Œ±)(hl : l < x), Ioc l x ‚äÜ s := exists_Ioc_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©
      exact ‚ü®l, x, lx, Ioo_subset_Ioc_self.trans hl‚ü©

theorem order_separated {a‚ÇÅ a‚ÇÇ : Œ±} (h : a‚ÇÅ < a‚ÇÇ) :
  ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß a‚ÇÅ ‚àà u ‚àß a‚ÇÇ ‚àà v ‚àß ‚àÄ b‚ÇÅ (_ : b‚ÇÅ ‚àà u), ‚àÄ b‚ÇÇ (_ : b‚ÇÇ ‚àà v), b‚ÇÅ < b‚ÇÇ :=
  match dense_or_discrete a‚ÇÅ a‚ÇÇ with 
  | Or.inl ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© =>
    ‚ü®{ a' | a' < a }, { a' | a < a' }, is_open_gt' a, is_open_lt' a, ha‚ÇÅ, ha‚ÇÇ, fun b‚ÇÅ h‚ÇÅ b‚ÇÇ h‚ÇÇ => lt_trans‚Çì h‚ÇÅ h‚ÇÇ‚ü©
  | Or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© =>
    ‚ü®{ a | a < a‚ÇÇ }, { a | a‚ÇÅ < a }, is_open_gt' a‚ÇÇ, is_open_lt' a‚ÇÅ, h, h,
      fun b‚ÇÅ hb‚ÇÅ b‚ÇÇ hb‚ÇÇ =>
        calc b‚ÇÅ ‚â§ a‚ÇÅ := h‚ÇÇ _ hb‚ÇÅ 
          _ < a‚ÇÇ := h 
          _ ‚â§ b‚ÇÇ := h‚ÇÅ _ hb‚ÇÇ
          ‚ü©

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[priority 100] instance order_topology.to_order_closed_topology : order_closed_topology Œ± :=
{ is_closed_le' := ¬´expr $ ¬ª(is_open_compl_iff.1, ¬´expr $ ¬ª(is_open_prod_iff.mpr, assume
    (a‚ÇÅ a‚ÇÇ)
    (h : ¬´expr¬¨ ¬ª(¬´expr ‚â§ ¬ª(a‚ÇÅ, a‚ÇÇ))), have h : ¬´expr < ¬ª(a‚ÇÇ, a‚ÇÅ), from lt_of_not_ge h,
    let ‚ü®u, v, hu, hv, ha‚ÇÅ, ha‚ÇÇ, h‚ü© := order_separated h in
    ‚ü®v, u, hv, hu, ha‚ÇÇ, ha‚ÇÅ, assume ‚ü®b‚ÇÅ, b‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, ¬´expr $ ¬ª(not_le_of_gt, h b‚ÇÇ h‚ÇÇ b‚ÇÅ h‚ÇÅ)‚ü©)) }

theorem OrderTopology.t2_space : T2Space Œ± :=
  by 
    infer_instance

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[priority 100] instance order_topology.regular_space : regular_space Œ± :=
{ regular := assume s a hs ha, have hs' : ¬´expr ‚àà ¬ª(¬´expr ·∂ú¬ª(s), exprùìù() a), from is_open.mem_nhds hs.is_open_compl ha,
  have ¬´expr‚àÉ , ¬ª((t : set Œ±), ¬´expr ‚àß ¬ª(is_open t, ¬´expr ‚àß ¬ª(‚àÄ
     l ¬´expr ‚àà ¬ª s, ¬´expr < ¬ª(l, a) ‚Üí ¬´expr ‚àà ¬ª(l, t), ¬´expr = ¬ª(¬´exprùìù[ ] ¬ª(t, a), ¬´expr‚ä•¬ª())))), from by_cases (assume
   h : ¬´expr‚àÉ , ¬ª((l), ¬´expr < ¬ª(l, a)), let ‚ü®l, hl, h‚ü© := exists_Ioc_subset_of_mem_nhds hs' h in
   match dense_or_discrete l a with
   | or.inl ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := ‚ü®{a | ¬´expr < ¬ª(a, b)}, is_open_gt' _, assume
    c
    hcs
    hca, show ¬´expr < ¬ª(c, b), from ¬´expr $ ¬ª(lt_of_not_ge, assume
     hbc, h ‚ü®lt_of_lt_of_le hb‚ÇÅ hbc, le_of_lt hca‚ü© hcs), ¬´expr $ ¬ª(inf_principal_eq_bot.2, ¬´expr $ ¬ª((exprùìù() a).sets_of_superset ((is_open_lt' _).mem_nhds hb‚ÇÇ), assume
      (x)
      (hx : ¬´expr < ¬ª(b, x)), show ¬´expr¬¨ ¬ª(¬´expr < ¬ª(x, b)), from ¬´expr $ ¬ª(not_lt.2, le_of_lt hx)))‚ü©
   | or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a' | ¬´expr < ¬ª(a', a)}, is_open_gt' _, assume
    b
    hbs
    hba, hba, ¬´expr $ ¬ª(inf_principal_eq_bot.2, ¬´expr $ ¬ª((exprùìù() a).sets_of_superset ((is_open_lt' _).mem_nhds hl), assume
      (x)
      (hx : ¬´expr < ¬ª(l, x)), show ¬´expr¬¨ ¬ª(¬´expr < ¬ª(x, a)), from ¬´expr $ ¬ª(not_lt.2, h‚ÇÅ _ hx)))‚ü©
   end) (assume: ¬´expr¬¨ ¬ª(¬´expr‚àÉ , ¬ª((l), ¬´expr < ¬ª(l, a))), ‚ü®¬´expr‚àÖ¬ª(), is_open_empty, assume
    l _ hl, (this ‚ü®l, hl‚ü©).elim, nhds_within_empty _‚ü©),
  let ‚ü®t‚ÇÅ, ht‚ÇÅo, ht‚ÇÅs, ht‚ÇÅa‚ü© := this in
  have ¬´expr‚àÉ , ¬ª((t : set Œ±), ¬´expr ‚àß ¬ª(is_open t, ¬´expr ‚àß ¬ª(‚àÄ
     u ¬´expr ‚àà ¬ª s, ¬´expr > ¬ª(u, a) ‚Üí ¬´expr ‚àà ¬ª(u, t), ¬´expr = ¬ª(¬´exprùìù[ ] ¬ª(t, a), ¬´expr‚ä•¬ª())))), from by_cases (assume
   h : ¬´expr‚àÉ , ¬ª((u), ¬´expr > ¬ª(u, a)), let ‚ü®u, hu, h‚ü© := exists_Ico_subset_of_mem_nhds hs' h in
   match dense_or_discrete a u with
   | or.inl ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := ‚ü®{a | ¬´expr < ¬ª(b, a)}, is_open_lt' _, assume
    c
    hcs
    hca, show ¬´expr > ¬ª(c, b), from ¬´expr $ ¬ª(lt_of_not_ge, assume
     hbc, h ‚ü®le_of_lt hca, lt_of_le_of_lt hbc hb‚ÇÇ‚ü© hcs), ¬´expr $ ¬ª(inf_principal_eq_bot.2, ¬´expr $ ¬ª((exprùìù() a).sets_of_superset ((is_open_gt' _).mem_nhds hb‚ÇÅ), assume
      (x)
      (hx : ¬´expr > ¬ª(b, x)), show ¬´expr¬¨ ¬ª(¬´expr > ¬ª(x, b)), from ¬´expr $ ¬ª(not_lt.2, le_of_lt hx)))‚ü©
   | or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a' | ¬´expr > ¬ª(a', a)}, is_open_lt' _, assume
    b
    hbs
    hba, hba, ¬´expr $ ¬ª(inf_principal_eq_bot.2, ¬´expr $ ¬ª((exprùìù() a).sets_of_superset ((is_open_gt' _).mem_nhds hu), assume
      (x)
      (hx : ¬´expr > ¬ª(u, x)), show ¬´expr¬¨ ¬ª(¬´expr > ¬ª(x, a)), from ¬´expr $ ¬ª(not_lt.2, h‚ÇÇ _ hx)))‚ü©
   end) (assume: ¬´expr¬¨ ¬ª(¬´expr‚àÉ , ¬ª((u), ¬´expr > ¬ª(u, a))), ‚ü®¬´expr‚àÖ¬ª(), is_open_empty, assume
    l _ hl, (this ‚ü®l, hl‚ü©).elim, nhds_within_empty _‚ü©),
  let ‚ü®t‚ÇÇ, ht‚ÇÇo, ht‚ÇÇs, ht‚ÇÇa‚ü© := this in
  ‚ü®¬´expr ‚à™ ¬ª(t‚ÇÅ, t‚ÇÇ), is_open.union ht‚ÇÅo ht‚ÇÇo, assume
   x hx, have ¬´expr ‚â† ¬ª(x, a), from assume eq, ¬´expr $ ¬ª(ha, ¬´expr ‚ñ∏ ¬ª(eq, hx)),
   (ne_iff_lt_or_gt.mp this).imp (ht‚ÇÅs _ hx) (ht‚ÇÇs _ hx), by rw ["[", expr nhds_within_union, ",", expr ht‚ÇÅa, ",", expr ht‚ÇÇa, ",", expr bot_sup_eq, "]"] []‚ü©,
  ..order_topology.t2_space }

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
theorem mem_nhds_iff_exists_Ioo_subset' {a : Œ±} {s : Set Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
  s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
  by 
    split 
    ¬∑
      intro h 
      rcases exists_Ico_subset_of_mem_nhds h hu with ‚ü®u, au, hu‚ü©
      rcases exists_Ioc_subset_of_mem_nhds h hl with ‚ü®l, la, hl‚ü©
      refine' ‚ü®l, u, ‚ü®la, au‚ü©, fun x hx => _‚ü©
      cases' le_total‚Çì a x with hax hax
      ¬∑
        exact hu ‚ü®hax, hx.2‚ü©
      ¬∑
        exact hl ‚ü®hx.1, hax‚ü©
    ¬∑
      rintro ‚ü®l, u, ha, h‚ü©
      apply mem_of_superset (IsOpen.mem_nhds is_open_Ioo ha) h

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
theorem mem_nhds_iff_exists_Ioo_subset [NoTopOrder Œ±] [NoBotOrder Œ±] {a : Œ±} {s : Set Œ±} :
  s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
  mem_nhds_iff_exists_Ioo_subset' (no_bot a) (no_top a)

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem nhds_basis_Ioo'
{a : Œ±}
(hl : ¬´expr‚àÉ , ¬ª((l), ¬´expr < ¬ª(l, a)))
(hu : ¬´expr‚àÉ , ¬ª((u), ¬´expr < ¬ª(a, u))) : (exprùìù() a).has_basis (Œª
 b : ¬´expr √ó ¬ª(Œ±, Œ±), ¬´expr ‚àß ¬ª(¬´expr < ¬ª(b.1, a), ¬´expr < ¬ª(a, b.2))) (Œª b, Ioo b.1 b.2) :=
‚ü®Œª s, ¬´expr $ ¬ª((mem_nhds_iff_exists_Ioo_subset' hl hu).trans, by simp [] [] [] [] [] [])‚ü©

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem nhds_basis_Ioo
[no_top_order Œ±]
[no_bot_order Œ±]
(a : Œ±) : (exprùìù() a).has_basis (Œª
 b : ¬´expr √ó ¬ª(Œ±, Œ±), ¬´expr ‚àß ¬ª(¬´expr < ¬ª(b.1, a), ¬´expr < ¬ª(a, b.2))) (Œª b, Ioo b.1 b.2) :=
nhds_basis_Ioo' (no_bot a) (no_top a)

theorem Filter.Eventually.exists_Ioo_subset [NoTopOrder Œ±] [NoBotOrder Œ±] {a : Œ±} {p : Œ± ‚Üí Prop}
  (hp : ‚àÄ·∂†x in ùìù a, p x) : ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ { x | p x } :=
  mem_nhds_iff_exists_Ioo_subset.1 hp

section Pi

/-!
### Intervals in `Œ† i, œÄ i` belong to `ùìù x`

For each lemma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `Œπ ‚Üí ‚Ñù`.
-/


variable{Œπ :
    Type
      _}{œÄ :
    Œπ ‚Üí
      Type
        _}[Fintype
      Œπ][‚àÄ i,
      LinearOrder‚Çì (œÄ i)][‚àÄ i, TopologicalSpace (œÄ i)][‚àÄ i, OrderTopology (œÄ i)]{a b x : ‚àÄ i, œÄ i}{a' b' x' : Œπ ‚Üí Œ±}

theorem pi_Iic_mem_nhds (ha : ‚àÄ i, x i < a i) : Iic a ‚àà ùìù x :=
  pi_univ_Iic a ‚ñ∏ set_pi_mem_nhds (finite.of_fintype _) fun i _ => Iic_mem_nhds (ha _)

theorem pi_Iic_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iic a' ‚àà ùìù x' :=
  pi_Iic_mem_nhds ha

theorem pi_Ici_mem_nhds (ha : ‚àÄ i, a i < x i) : Ici a ‚àà ùìù x :=
  pi_univ_Ici a ‚ñ∏ set_pi_mem_nhds (finite.of_fintype _) fun i _ => Ici_mem_nhds (ha _)

theorem pi_Ici_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ici a' ‚àà ùìù x' :=
  pi_Ici_mem_nhds ha

theorem pi_Icc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Icc a b ‚àà ùìù x :=
  pi_univ_Icc a b ‚ñ∏ set_pi_mem_nhds (finite.of_fintype _) fun i _ => Icc_mem_nhds (ha _) (hb _)

theorem pi_Icc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Icc a' b' ‚àà ùìù x' :=
  pi_Icc_mem_nhds ha hb

variable[Nonempty Œπ]

theorem pi_Iio_mem_nhds (ha : ‚àÄ i, x i < a i) : Iio a ‚àà ùìù x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Iio_subset a)
    exact Iio_mem_nhds (ha i)

theorem pi_Iio_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iio a' ‚àà ùìù x' :=
  pi_Iio_mem_nhds ha

theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=
  @pi_Iio_mem_nhds Œπ (fun i => OrderDual (œÄ i)) _ _ _ _ _ _ _ ha

theorem pi_Ioi_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ioi a' ‚àà ùìù x' :=
  pi_Ioi_mem_nhds ha

theorem pi_Ioc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioc a b ‚àà ùìù x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Ioc_subset a b)
    exact Ioc_mem_nhds (ha i) (hb i)

theorem pi_Ioc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioc a' b' ‚àà ùìù x' :=
  pi_Ioc_mem_nhds ha hb

theorem pi_Ico_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ico a b ‚àà ùìù x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Ico_subset a b)
    exact Ico_mem_nhds (ha i) (hb i)

theorem pi_Ico_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ico a' b' ‚àà ùìù x' :=
  pi_Ico_mem_nhds ha hb

theorem pi_Ioo_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioo a b ‚àà ùìù x :=
  by 
    refine' mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) fun i _ => _) (pi_univ_Ioo_subset a b)
    exact Ioo_mem_nhds (ha i) (hb i)

theorem pi_Ioo_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioo a' b' ‚àà ùìù x' :=
  pi_Ioo_mem_nhds ha hb

end Pi

theorem disjoint_nhds_at_top [NoTopOrder Œ±] (x : Œ±) : Disjoint (ùìù x) at_top :=
  by 
    rw [Filter.disjoint_iff]
    cases' no_top x with a ha 
    use Iio a, Iio_mem_nhds ha, Ici a, mem_at_top a 
    rw [inter_comm, Ici_inter_Iio, Ico_self]

@[simp]
theorem inf_nhds_at_top [NoTopOrder Œ±] (x : Œ±) : ùìù x‚äìat_top = ‚ä• :=
  disjoint_iff.1 (disjoint_nhds_at_top x)

theorem disjoint_nhds_at_bot [NoBotOrder Œ±] (x : Œ±) : Disjoint (ùìù x) at_bot :=
  @disjoint_nhds_at_top (OrderDual Œ±) _ _ _ _ x

@[simp]
theorem inf_nhds_at_bot [NoBotOrder Œ±] (x : Œ±) : ùìù x‚äìat_bot = ‚ä• :=
  @inf_nhds_at_top (OrderDual Œ±) _ _ _ _ x

theorem not_tendsto_nhds_of_tendsto_at_top [NoTopOrder Œ±] {F : Filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±}
  (hf : tendsto f F at_top) (x : Œ±) : ¬¨tendsto f F (ùìù x) :=
  hf.not_tendsto (disjoint_nhds_at_top x).symm

theorem not_tendsto_at_top_of_tendsto_nhds [NoTopOrder Œ±] {F : Filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} {x : Œ±}
  (hf : tendsto f F (ùìù x)) : ¬¨tendsto f F at_top :=
  hf.not_tendsto (disjoint_nhds_at_top x)

theorem not_tendsto_nhds_of_tendsto_at_bot [NoBotOrder Œ±] {F : Filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±}
  (hf : tendsto f F at_bot) (x : Œ±) : ¬¨tendsto f F (ùìù x) :=
  hf.not_tendsto (disjoint_nhds_at_bot x).symm

theorem not_tendsto_at_bot_of_tendsto_nhds [NoBotOrder Œ±] {F : Filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} {x : Œ±}
  (hf : tendsto f F (ùìù x)) : ¬¨tendsto f F at_bot :=
  hf.not_tendsto (disjoint_nhds_at_bot x)

/-!
### Neighborhoods to the left and to the right on an `order_topology`

We've seen some properties of left and right neighborhood of a point in an `order_closed_topology`.
In an `order_topology`, such neighborhoods can be characterized as the sets containing suitable
intervals to the right or to the left of `a`. We give now these characterizations. -/


/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `(a, +‚àû)`
1. `s` is a neighborhood of `a` within `(a, b]`
2. `s` is a neighborhood of `a` within `(a, b)`
3. `s` includes `(a, u)` for some `u ‚àà (a, b]`
4. `s` includes `(a, u)` for some `u > a` -/
theorem tfae_mem_nhds_within_Ioi {a b : Œ±} (hab : a < b) (s : Set Œ±) :
  tfae
    [s ‚àà ùìù[Ioi a] a, s ‚àà ùìù[Ioc a b] a, s ‚àà ùìù[Ioo a b] a, ‚àÉ (u : _)(_ : u ‚àà Ioc a b), Ioo a u ‚äÜ s,
      ‚àÉ (u : _)(_ : u ‚àà Ioi a), Ioo a u ‚äÜ s] :=
  by 
    tfaeHave 1 ‚Üî 2
    ¬∑
      rw [nhds_within_Ioc_eq_nhds_within_Ioi hab]
    tfaeHave 1 ‚Üî 3
    ¬∑
      rw [nhds_within_Ioo_eq_nhds_within_Ioi hab]
    tfaeHave 4 ‚Üí 5 
    exact fun ‚ü®u, umem, hu‚ü© => ‚ü®u, umem.1, hu‚ü©
    tfaeHave 5 ‚Üí 1
    ¬∑
      rintro ‚ü®u, hau, hu‚ü©
      exact mem_of_superset (Ioo_mem_nhds_within_Ioi ‚ü®le_refl‚Çì a, hau‚ü©) hu 
    tfaeHave 1 ‚Üí 4
    ¬∑
      intro h 
      rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©
      rcases exists_Ico_subset_of_mem_nhds' va hab with ‚ü®u, au, hu‚ü©
      refine' ‚ü®u, au, fun x hx => _‚ü©
      refine' hv ‚ü®hu ‚ü®le_of_lt‚Çì hx.1, hx.2‚ü©, _‚ü©
      exact hx.1
    tfaeFinish

theorem mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
  s ‚àà ùìù[Ioi a] a ‚Üî ‚àÉ (u : _)(_ : u ‚àà Ioc a u'), Ioo a u ‚äÜ s :=
  (tfae_mem_nhds_within_Ioi hu' s).out 0 3

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset' {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
  s ‚àà ùìù[Ioi a] a ‚Üî ‚àÉ (u : _)(_ : u ‚àà Ioi a), Ioo a u ‚äÜ s :=
  (tfae_mem_nhds_within_Ioi hu' s).out 0 4

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset [NoTopOrder Œ±] {a : Œ±} {s : Set Œ±} :
  s ‚àà ùìù[Ioi a] a ‚Üî ‚àÉ (u : _)(_ : u ‚àà Ioi a), Ioo a u ‚äÜ s :=
  let ‚ü®u', hu'‚ü© := no_top a 
  mem_nhds_within_Ioi_iff_exists_Ioo_subset' hu'

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioc_subset [NoTopOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±} :
  s ‚àà ùìù[Ioi a] a ‚Üî ‚àÉ (u : _)(_ : u ‚àà Ioi a), Ioc a u ‚äÜ s :=
  by 
    rw [mem_nhds_within_Ioi_iff_exists_Ioo_subset]
    split 
    ¬∑
      rintro ‚ü®u, au, as‚ü©
      rcases exists_between au with ‚ü®v, hv‚ü©
      exact ‚ü®v, hv.1, fun x hx => as ‚ü®hx.1, lt_of_le_of_lt‚Çì hx.2 hv.2‚ü©‚ü©
    ¬∑
      rintro ‚ü®u, au, as‚ü©
      exact ‚ü®u, au, subset.trans Ioo_subset_Ioc_self as‚ü©

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b)`
1. `s` is a neighborhood of `b` within `[a, b)`
2. `s` is a neighborhood of `b` within `(a, b)`
3. `s` includes `(l, b)` for some `l ‚àà [a, b)`
4. `s` includes `(l, b)` for some `l < b` -/
theorem tfae_mem_nhds_within_Iio {a b : Œ±} (h : a < b) (s : Set Œ±) :
  tfae
    [s ‚àà ùìù[Iio b] b, s ‚àà ùìù[Ico a b] b, s ‚àà ùìù[Ioo a b] b, ‚àÉ (l : _)(_ : l ‚àà Ico a b), Ioo l b ‚äÜ s,
      ‚àÉ (l : _)(_ : l ‚àà Iio b), Ioo l b ‚äÜ s] :=
  by 
    simpa only [exists_prop, OrderDual.exists, dual_Ioi, dual_Ioc, dual_Ioo] using
      tfae_mem_nhds_within_Ioi h.dual (of_dual ‚Åª¬π' s)

theorem mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[Iio a] a ‚Üî ‚àÉ (l : _)(_ : l ‚àà Ico l' a), Ioo l a ‚äÜ s :=
  (tfae_mem_nhds_within_Iio hl' s).out 0 3

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset' {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[Iio a] a ‚Üî ‚àÉ (l : _)(_ : l ‚àà Iio a), Ioo l a ‚äÜ s :=
  (tfae_mem_nhds_within_Iio hl' s).out 0 4

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset [NoBotOrder Œ±] {a : Œ±} {s : Set Œ±} :
  s ‚àà ùìù[Iio a] a ‚Üî ‚àÉ (l : _)(_ : l ‚àà Iio a), Ioo l a ‚äÜ s :=
  let ‚ü®l', hl'‚ü© := no_bot a 
  mem_nhds_within_Iio_iff_exists_Ioo_subset' hl'

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
theorem mem_nhds_within_Iio_iff_exists_Ico_subset
[no_bot_order Œ±]
[densely_ordered Œ±]
{a : Œ±}
{s : set Œ±} : ¬´expr ‚Üî ¬ª(¬´expr ‚àà ¬ª(s, ¬´exprùìù[ ] ¬ª(Iio a, a)), ¬´expr‚àÉ , ¬ª((l ¬´expr ‚àà ¬ª Iio a), ¬´expr ‚äÜ ¬ª(Ico l a, s))) :=
begin
  have [] [":", expr ¬´expr ‚Üî ¬ª(¬´expr ‚àà ¬ª(¬´expr ‚Åª¬π' ¬ª(of_dual, s), ¬´exprùìù[ ] ¬ª(Ioi (to_dual a), to_dual a)), _)] [":=", expr mem_nhds_within_Ioi_iff_exists_Ioc_subset],
  simpa [] [] ["only"] ["[", expr order_dual.exists, ",", expr exists_prop, ",", expr dual_Ioc, "]"] [] ["using", expr this]
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `[a, +‚àû)`
1. `s` is a neighborhood of `a` within `[a, b]`
2. `s` is a neighborhood of `a` within `[a, b)`
3. `s` includes `[a, u)` for some `u ‚àà (a, b]`
4. `s` includes `[a, u)` for some `u > a` -/
theorem tfae_mem_nhds_within_Ici {a b : Œ±} (hab : a < b) (s : Set Œ±) :
  tfae
    [s ‚àà ùìù[Ici a] a, s ‚àà ùìù[Icc a b] a, s ‚àà ùìù[Ico a b] a, ‚àÉ (u : _)(_ : u ‚àà Ioc a b), Ico a u ‚äÜ s,
      ‚àÉ (u : _)(_ : u ‚àà Ioi a), Ico a u ‚äÜ s] :=
  by 
    tfaeHave 1 ‚Üî 2
    ¬∑
      rw [nhds_within_Icc_eq_nhds_within_Ici hab]
    tfaeHave 1 ‚Üî 3
    ¬∑
      rw [nhds_within_Ico_eq_nhds_within_Ici hab]
    tfaeHave 4 ‚Üí 5 
    exact fun ‚ü®u, umem, hu‚ü© => ‚ü®u, umem.1, hu‚ü©
    tfaeHave 5 ‚Üí 1
    ¬∑
      rintro ‚ü®u, hau, hu‚ü©
      exact mem_of_superset (Ico_mem_nhds_within_Ici ‚ü®le_refl‚Çì a, hau‚ü©) hu 
    tfaeHave 1 ‚Üí 4
    ¬∑
      intro h 
      rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©
      rcases exists_Ico_subset_of_mem_nhds' va hab with ‚ü®u, au, hu‚ü©
      refine' ‚ü®u, au, fun x hx => _‚ü©
      refine' hv ‚ü®hu ‚ü®hx.1, hx.2‚ü©, _‚ü©
      exact hx.1
    tfaeFinish

theorem mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
  s ‚àà ùìù[Ici a] a ‚Üî ‚àÉ (u : _)(_ : u ‚àà Ioc a u'), Ico a u ‚äÜ s :=
  (tfae_mem_nhds_within_Ici hu' s).out 0 3
    (by 
      normNum)
    (by 
      normNum)

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhds_within_Ici_iff_exists_Ico_subset' {a u' : Œ±} {s : Set Œ±} (hu' : a < u') :
  s ‚àà ùìù[Ici a] a ‚Üî ‚àÉ (u : _)(_ : u ‚àà Ioi a), Ico a u ‚äÜ s :=
  (tfae_mem_nhds_within_Ici hu' s).out 0 4
    (by 
      normNum)
    (by 
      normNum)

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Ico_subset [NoTopOrder Œ±] {a : Œ±} {s : Set Œ±} :
  s ‚àà ùìù[Ici a] a ‚Üî ‚àÉ (u : _)(_ : u ‚àà Ioi a), Ico a u ‚äÜ s :=
  let ‚ü®u', hu'‚ü© := no_top a 
  mem_nhds_within_Ici_iff_exists_Ico_subset' hu'

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Icc_subset' [NoTopOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±} :
  s ‚àà ùìù[Ici a] a ‚Üî ‚àÉ (u : _)(_ : u ‚àà Ioi a), Icc a u ‚äÜ s :=
  by 
    rw [mem_nhds_within_Ici_iff_exists_Ico_subset]
    split 
    ¬∑
      rintro ‚ü®u, au, as‚ü©
      rcases exists_between au with ‚ü®v, hv‚ü©
      exact ‚ü®v, hv.1, fun x hx => as ‚ü®hx.1, lt_of_le_of_lt‚Çì hx.2 hv.2‚ü©‚ü©
    ¬∑
      rintro ‚ü®u, au, as‚ü©
      exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü©

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b]`
1. `s` is a neighborhood of `b` within `[a, b]`
2. `s` is a neighborhood of `b` within `(a, b]`
3. `s` includes `(l, b]` for some `l ‚àà [a, b)`
4. `s` includes `(l, b]` for some `l < b` -/
theorem tfae_mem_nhds_within_Iic {a b : Œ±} (h : a < b) (s : Set Œ±) :
  tfae
    [s ‚àà ùìù[Iic b] b, s ‚àà ùìù[Icc a b] b, s ‚àà ùìù[Ioc a b] b, ‚àÉ (l : _)(_ : l ‚àà Ico a b), Ioc l b ‚äÜ s,
      ‚àÉ (l : _)(_ : l ‚àà Iio b), Ioc l b ‚äÜ s] :=
  by 
    simpa only [exists_prop, OrderDual.exists, dual_Ici, dual_Ioc, dual_Icc, dual_Ico] using
      tfae_mem_nhds_within_Ici h.dual (of_dual ‚Åª¬π' s)

theorem mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[Iic a] a ‚Üî ‚àÉ (l : _)(_ : l ‚àà Ico l' a), Ioc l a ‚äÜ s :=
  (tfae_mem_nhds_within_Iic hl' s).out 0 3
    (by 
      normNum)
    (by 
      normNum)

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset' {a l' : Œ±} {s : Set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[Iic a] a ‚Üî ‚àÉ (l : _)(_ : l ‚àà Iio a), Ioc l a ‚äÜ s :=
  (tfae_mem_nhds_within_Iic hl' s).out 0 4
    (by 
      normNum)
    (by 
      normNum)

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset [NoBotOrder Œ±] {a : Œ±} {s : Set Œ±} :
  s ‚àà ùìù[Iic a] a ‚Üî ‚àÉ (l : _)(_ : l ‚àà Iio a), Ioc l a ‚äÜ s :=
  let ‚ü®l', hl'‚ü© := no_bot a 
  mem_nhds_within_Iic_iff_exists_Ioc_subset' hl'

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Icc_subset' [NoBotOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±} :
  s ‚àà ùìù[Iic a] a ‚Üî ‚àÉ (l : _)(_ : l ‚àà Iio a), Icc l a ‚äÜ s :=
  by 
    convert @mem_nhds_within_Ici_iff_exists_Icc_subset' (OrderDual Œ±) _ _ _ _ _ _ _ 
    simpRw [show ‚àÄ (u : OrderDual Œ±), @Icc (OrderDual Œ±) _ a u = @Icc Œ± _ u a from fun u => dual_Icc]
    rfl

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Icc_subset [NoTopOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±} :
  s ‚àà ùìù[Ici a] a ‚Üî ‚àÉ u, a < u ‚àß Icc a u ‚äÜ s :=
  by 
    rw [mem_nhds_within_Ici_iff_exists_Ico_subset]
    split 
    ¬∑
      rintro ‚ü®u, au, as‚ü©
      rcases exists_between au with ‚ü®v, hv‚ü©
      exact ‚ü®v, hv.1, fun x hx => as ‚ü®hx.1, lt_of_le_of_lt‚Çì hx.2 hv.2‚ü©‚ü©
    ¬∑
      rintro ‚ü®u, au, as‚ü©
      exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü©

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Icc_subset [NoBotOrder Œ±] [DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±} :
  s ‚àà ùìù[Iic a] a ‚Üî ‚àÉ l, l < a ‚àß Icc l a ‚äÜ s :=
  by 
    rw [mem_nhds_within_Iic_iff_exists_Ioc_subset]
    split 
    ¬∑
      rintro ‚ü®l, la, as‚ü©
      rcases exists_between la with ‚ü®v, hv‚ü©
      refine' ‚ü®v, hv.2, fun x hx => as ‚ü®lt_of_lt_of_le‚Çì hv.1 hx.1, hx.2‚ü©‚ü©
    ¬∑
      rintro ‚ü®l, la, as‚ü©
      exact ‚ü®l, la, subset.trans Ioc_subset_Icc_self as‚ü©

end LinearOrder‚Çì

section LinearOrderedAddCommGroup

variable[TopologicalSpace Œ±][LinearOrderedAddCommGroup Œ±][OrderTopology Œ±]

variable{l : Filter Œ≤}{f g : Œ≤ ‚Üí Œ±}

theorem nhds_eq_infi_abs_sub (a : Œ±) : ùìù a = ‚®Ö(r : _)(_ : r > 0), ùìü { b | |a - b| < r } :=
  by 
    simp only [le_antisymm_iff‚Çì, nhds_eq_order, le_inf_iff, le_infi_iff, le_principal_iff, mem_Ioi, mem_Iio,
      abs_sub_lt_iff, @sub_lt_iff_lt_add _ _ _ _ _ _ a, @sub_lt _ _ _ _ a, set_of_and]
    refine' ‚ü®_, _, _‚ü©
    ¬∑
      intro Œµ Œµ0 
      exact
        inter_mem_inf (mem_infi_of_mem (a - Œµ)$ mem_infi_of_mem (sub_lt_self a Œµ0) (mem_principal_self _))
          (mem_infi_of_mem (Œµ+a)$
            mem_infi_of_mem
              (by 
                simpa)
              (mem_principal_self _))
    ¬∑
      intro b hb 
      exact
        mem_infi_of_mem (a - b)
          (mem_infi_of_mem (sub_pos.2 hb)
            (by 
              simp [Ioi]))
    ¬∑
      intro b hb 
      exact
        mem_infi_of_mem (b - a)
          (mem_infi_of_mem (sub_pos.2 hb)
            (by 
              simp [Iio]))

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem order_topology_of_nhds_abs
{Œ± : Type*}
[topological_space Œ±]
[linear_ordered_add_comm_group Œ±]
(h_nhds : ‚àÄ
 a : Œ±, ¬´expr = ¬ª(exprùìù() a, ¬´expr‚®Ö , ¬ª((r ¬´expr > ¬ª 0), exprùìü() {b | ¬´expr < ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(a, b)), r)}))) : order_topology Œ± :=
begin
  refine [expr ‚ü®¬´expr $ ¬ª(eq_of_nhds_eq_nhds, Œª a, _)‚ü©],
  rw ["[", expr h_nhds, "]"] [],
  letI [] [] [":=", expr preorder.topology Œ±],
  letI [] [":", expr order_topology Œ±] [":=", expr ‚ü®rfl‚ü©],
  exact [expr (nhds_eq_infi_abs_sub a).symm]
end

theorem LinearOrderedAddCommGroup.tendsto_nhds {x : Filter Œ≤} {a : Œ±} :
  tendsto f x (ùìù a) ‚Üî ‚àÄ Œµ (_ : Œµ > (0 : Œ±)), ‚àÄ·∂†b in x, |f b - a| < Œµ :=
  by 
    simp [nhds_eq_infi_abs_sub, abs_sub_comm a]

theorem eventually_abs_sub_lt (a : Œ±) {Œµ : Œ±} (hŒµ : 0 < Œµ) : ‚àÄ·∂†x in ùìù a, |x - a| < Œµ :=
  (nhds_eq_infi_abs_sub a).symm ‚ñ∏
    mem_infi_of_mem Œµ
      (mem_infi_of_mem hŒµ$
        by 
          simp only [abs_sub_comm, mem_principal_self])

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[priority 100] instance linear_ordered_add_comm_group.topological_add_group : topological_add_group Œ± :=
{ continuous_add := begin
    refine [expr continuous_iff_continuous_at.2 _],
    rintro ["‚ü®", ident a, ",", ident b, "‚ü©"],
    refine [expr linear_ordered_add_comm_group.tendsto_nhds.2 (Œª Œµ Œµ0, _)],
    rcases [expr dense_or_discrete 0 Œµ, "with", "(", "‚ü®", ident Œ¥, ",", ident Œ¥0, ",", ident Œ¥Œµ, "‚ü©", "|", "‚ü®", ident h‚ÇÅ, ",", ident h‚ÇÇ, "‚ü©", ")"],
    { filter_upwards ["[", expr prod_is_open.mem_nhds (eventually_abs_sub_lt a Œ¥0) (eventually_abs_sub_lt b (sub_pos.2 Œ¥Œµ)), "]"] [],
      rintros ["‚ü®", ident x, ",", ident y, "‚ü©", "‚ü®", ident hx, ":", expr ¬´expr < ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(x, a)), Œ¥), ",", ident hy, ":", expr ¬´expr < ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(y, b)), ¬´expr - ¬ª(Œµ, Œ¥)), "‚ü©"],
      rw ["[", expr add_sub_comm, "]"] [],
      calc
        ¬´expr ‚â§ ¬ª(¬´expr| |¬ª(¬´expr + ¬ª(¬´expr - ¬ª(x, a), ¬´expr - ¬ª(y, b))), ¬´expr + ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(x, a)), ¬´expr| |¬ª(¬´expr - ¬ª(y, b)))) : abs_add _ _
        ¬´expr < ¬ª(..., ¬´expr + ¬ª(Œ¥, ¬´expr - ¬ª(Œµ, Œ¥))) : add_lt_add hx hy
        ¬´expr = ¬ª(..., Œµ) : add_sub_cancel'_right _ _ },
    { have [ident hŒµ] [":", expr ‚àÄ {x y}, ¬´expr < ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(x, y)), Œµ) ‚Üí ¬´expr = ¬ª(x, y)] [],
      { intros [ident x, ident y, ident h],
        simpa [] [] [] ["[", expr sub_eq_zero, "]"] [] ["using", expr h‚ÇÇ _ h] },
      filter_upwards ["[", expr prod_is_open.mem_nhds (eventually_abs_sub_lt a Œµ0) (eventually_abs_sub_lt b Œµ0), "]"] [],
      rintros ["‚ü®", ident x, ",", ident y, "‚ü©", "‚ü®", ident hx, ":", expr ¬´expr < ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(x, a)), Œµ), ",", ident hy, ":", expr ¬´expr < ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(y, b)), Œµ), "‚ü©"],
      simpa [] [] [] ["[", expr hŒµ hx, ",", expr hŒµ hy, "]"] [] [] }
  end,
  continuous_neg := ¬´expr $ ¬ª(continuous_iff_continuous_at.2, Œª
   a, ¬´expr $ ¬ª(linear_ordered_add_comm_group.tendsto_nhds.2, Œª
    Œµ
    Œµ0, ¬´expr $ ¬ª((eventually_abs_sub_lt a Œµ0).mono, Œª
     x hx, by rwa ["[", expr neg_sub_neg, ",", expr abs_sub_comm, "]"] []))) }

@[continuity]
theorem continuous_abs : Continuous (abs : Œ± ‚Üí Œ±) :=
  continuous_id.max continuous_neg

theorem Filter.Tendsto.abs {f : Œ≤ ‚Üí Œ±} {a : Œ±} {l : Filter Œ≤} (h : tendsto f l (ùìù a)) :
  tendsto (fun x => |f x|) l (ùìù |a|) :=
  (continuous_abs.Tendsto _).comp h

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem tendsto_zero_iff_abs_tendsto_zero
(f : Œ≤ ‚Üí Œ±)
{l : filter Œ≤} : ¬´expr ‚Üî ¬ª(tendsto f l (exprùìù() 0), tendsto ¬´expr ‚àò ¬ª(abs, f) l (exprùìù() 0)) :=
begin
  refine [expr ‚ü®Œª h, ¬´expr ‚ñ∏ ¬ª((abs_zero : ¬´expr = ¬ª(¬´expr| |¬ª((0 : Œ±)), 0)), h.abs), Œª h, _‚ü©],
  have [] [":", expr tendsto (Œª
    a, ¬´expr- ¬ª(¬´expr| |¬ª(f a))) l (exprùìù() 0)] [":=", expr ¬´expr ‚ñ∏ ¬ª((neg_zero : ¬´expr = ¬ª(¬´expr- ¬ª((0 : Œ±)), 0)), h.neg)],
  exact [expr tendsto_of_tendsto_of_tendsto_of_le_of_le this h (Œª
    x, ¬´expr $ ¬ª(neg_abs_le_self, f x)) (Œª x, ¬´expr $ ¬ª(le_abs_self, f x))]
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem nhds_basis_Ioo_pos
[no_bot_order Œ±]
[no_top_order Œ±]
(a : Œ±) : (exprùìù() a).has_basis (Œª Œµ : Œ±, ¬´expr < ¬ª((0 : Œ±), Œµ)) (Œª Œµ, Ioo ¬´expr - ¬ª(a, Œµ) ¬´expr + ¬ª(a, Œµ)) :=
‚ü®begin
   refine [expr Œª t, (nhds_basis_Ioo a).mem_iff.trans ‚ü®_, _‚ü©],
   { rintros ["‚ü®", "‚ü®", ident l, ",", ident u, "‚ü©", ",", "‚ü®", ident hl, ":", expr ¬´expr < ¬ª(l, a), ",", ident hu, ":", expr ¬´expr < ¬ª(a, u), "‚ü©", ",", ident h', ":", expr ¬´expr ‚äÜ ¬ª(Ioo l u, t), "‚ü©"],
     refine [expr ‚ü®min ¬´expr - ¬ª(a, l) ¬´expr - ¬ª(u, a), by apply [expr lt_min]; rwa [expr sub_pos] [], _‚ü©],
     rintros [ident x, "‚ü®", ident hx, ",", ident hx', "‚ü©"],
     apply [expr h'],
     rw ["[", expr sub_lt, ",", expr lt_min_iff, ",", expr sub_lt_sub_iff_left, "]"] ["at", ident hx],
     rw ["[", "<-", expr sub_lt_iff_lt_add', ",", expr lt_min_iff, ",", expr sub_lt_sub_iff_right, "]"] ["at", ident hx'],
     exact [expr ‚ü®hx.1, hx'.2‚ü©] },
   { rintros ["‚ü®", ident Œµ, ",", ident Œµ_pos, ",", ident h, "‚ü©"],
     exact [expr ‚ü®(¬´expr - ¬ª(a, Œµ), ¬´expr + ¬ª(a, Œµ)), by simp [] [] [] ["[", expr Œµ_pos, "]"] [] [], h‚ü©] }
 end‚ü©

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem nhds_basis_abs_sub_lt
[no_bot_order Œ±]
[no_top_order Œ±]
(a : Œ±) : (exprùìù() a).has_basis (Œª
 Œµ : Œ±, ¬´expr < ¬ª((0 : Œ±), Œµ)) (Œª Œµ, {b | ¬´expr < ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(b, a)), Œµ)}) :=
begin
  convert [] [expr nhds_basis_Ioo_pos a] [],
  { ext [] [ident Œµ] [],
    change [expr ¬´expr ‚Üî ¬ª(¬´expr < ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(x, a)), Œµ), ¬´expr ‚àß ¬ª(¬´expr < ¬ª(¬´expr - ¬ª(a, Œµ), x), ¬´expr < ¬ª(x, ¬´expr + ¬ª(a, Œµ))))] [] [],
    simp [] [] [] ["[", expr abs_lt, ",", expr sub_lt_iff_lt_add, ",", expr add_comm Œµ a, ",", expr add_comm x Œµ, "]"] [] [] }
end

variable(Œ±)

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem nhds_basis_zero_abs_sub_lt
[no_bot_order Œ±]
[no_top_order Œ±] : (exprùìù() (0 : Œ±)).has_basis (Œª
 Œµ : Œ±, ¬´expr < ¬ª((0 : Œ±), Œµ)) (Œª Œµ, {b | ¬´expr < ¬ª(¬´expr| |¬ª(b), Œµ)}) :=
by simpa [] [] [] [] [] ["using", expr nhds_basis_abs_sub_lt (0 : Œ±)]

variable{Œ±}

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- If `a` is positive we can form a basis from only nonnegative `Ioo` intervals -/
theorem nhds_basis_Ioo_pos_of_pos
[no_bot_order Œ±]
[no_top_order Œ±]
{a : Œ±}
(ha : ¬´expr < ¬ª(0, a)) : (exprùìù() a).has_basis (Œª
 Œµ : Œ±, ¬´expr ‚àß ¬ª(¬´expr < ¬ª((0 : Œ±), Œµ), ¬´expr ‚â§ ¬ª(Œµ, a))) (Œª Œµ, Ioo ¬´expr - ¬ª(a, Œµ) ¬´expr + ¬ª(a, Œµ)) :=
‚ü®Œª
 t, (nhds_basis_Ioo_pos a).mem_iff.trans ‚ü®Œª h, let ‚ü®i, hi, hit‚ü© := h in
  ‚ü®min i a, ‚ü®lt_min hi ha, min_le_right i a‚ü©, trans (Ioo_subset_Ioo (sub_le_sub_left (min_le_left i a) a) (add_le_add_left (min_le_left i a) a)) hit‚ü©, Œª
  h, let ‚ü®i, hi, hit‚ü© := h in
  ‚ü®i, hi.1, hit‚ü©‚ü©‚ü©

section 

variable[TopologicalSpace Œ≤]{b : Œ≤}{a : Œ±}{s : Set Œ≤}

theorem Continuous.abs (h : Continuous f) : Continuous fun x => |f x| :=
  continuous_abs.comp h

theorem ContinuousAt.abs (h : ContinuousAt f b) : ContinuousAt (fun x => |f x|) b :=
  h.abs

theorem ContinuousWithinAt.abs (h : ContinuousWithinAt f s b) : ContinuousWithinAt (fun x => |f x|) s b :=
  h.abs

theorem ContinuousOn.abs (h : ContinuousOn f s) : ContinuousOn (fun x => |f x|) s :=
  fun x hx => (h x hx).abs

theorem tendsto_abs_nhds_within_zero : tendsto (abs : Œ± ‚Üí Œ±) (ùìù[¬´expr ·∂ú¬ª {0}] 0) (ùìù[Ioi 0] 0) :=
  (continuous_abs.tendsto' (0 : Œ±) 0 abs_zero).inf$ tendsto_principal_principal.2$ fun x => abs_pos.2

end 

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_top` then `f + g` tends to `at_top`. -/
theorem Filter.Tendsto.add_at_top {C : Œ±} (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  by 
    nontriviality Œ± 
    obtain ‚ü®C', hC'‚ü© : ‚àÉ C', C' < C := no_bot C 
    refine' tendsto_at_top_add_left_of_le' _ C' _ hg 
    exact (hf.eventually (lt_mem_nhds hC')).mono fun x => le_of_lt‚Çì

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_bot` then `f + g` tends to `at_bot`. -/
theorem Filter.Tendsto.add_at_bot {C : Œ±} (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @Filter.Tendsto.add_at_top (OrderDual Œ±) _ _ _ _ _ _ _ _ hf hg

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_top` and `g` tends to `C` then `f + g` tends to `at_top`. -/
theorem Filter.Tendsto.at_top_add {C : Œ±} (hf : tendsto f l at_top) (hg : tendsto g l (ùìù C)) :
  tendsto (fun x => f x+g x) l at_top :=
  by 
    conv  in _+_ => rw [add_comm‚Çì]
    exact hg.add_at_top hf

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_bot` and `g` tends to `C` then `f + g` tends to `at_bot`. -/
theorem Filter.Tendsto.at_bot_add {C : Œ±} (hf : tendsto f l at_bot) (hg : tendsto g l (ùìù C)) :
  tendsto (fun x => f x+g x) l at_bot :=
  by 
    conv  in _+_ => rw [add_comm‚Çì]
    exact hg.add_at_bot hf

end LinearOrderedAddCommGroup

section LinearOrderedField

variable[LinearOrderedField Œ±][TopologicalSpace Œ±][OrderTopology Œ±]

variable{l : Filter Œ≤}{f g : Œ≤ ‚Üí Œ±}

section continuous_mul

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem mul_tendsto_nhds_zero_right
(x : Œ±) : ¬´expr $ ¬ª(tendsto (uncurry ((¬´expr * ¬ª) : Œ± ‚Üí Œ± ‚Üí Œ±)) ¬´expr √ó·∂† ¬ª(exprùìù() 0, exprùìù() x), exprùìù() 0) :=
begin
  have [ident hx] [":", expr ¬´expr < ¬ª(0, ¬´expr * ¬ª(2, ¬´expr + ¬ª(1, ¬´expr| |¬ª(x))))] [":=", expr ¬´expr $ ¬ª(mul_pos zero_lt_two, ¬´expr $ ¬ª(lt_of_lt_of_le zero_lt_one, le_add_of_le_of_nonneg le_rfl (abs_nonneg x)))],
  rw [expr ¬´expr $ ¬ª((nhds_basis_zero_abs_sub_lt Œ±).prod, nhds_basis_abs_sub_lt x).tendsto_iff (nhds_basis_zero_abs_sub_lt Œ±)] [],
  refine [expr Œª
   Œµ Œµ_pos, ‚ü®(¬´expr / ¬ª(Œµ, ¬´expr * ¬ª(2, ¬´expr + ¬ª(1, ¬´expr| |¬ª(x)))), 1), ‚ü®div_pos Œµ_pos hx, zero_lt_one‚ü©, _‚ü©],
  suffices [] [":", expr ‚àÄ
   a
   b : Œ±, ¬´expr < ¬ª(¬´expr| |¬ª(a), ¬´expr / ¬ª(Œµ, ¬´expr * ¬ª(2, ¬´expr + ¬ª(1, ¬´expr| |¬ª(x))))) ‚Üí ¬´expr < ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(b, x)), 1) ‚Üí ¬´expr < ¬ª(¬´expr * ¬ª(¬´expr| |¬ª(a), ¬´expr| |¬ª(b)), Œµ)],
  by simpa [] [] ["only"] ["[", expr and_imp, ",", expr prod.forall, ",", expr mem_prod, ",", "<-", expr abs_mul, "]"] [] [],
  intros [ident a, ident b, ident h, ident h'],
  refine [expr lt_of_le_of_lt (mul_le_mul_of_nonneg_left _ (abs_nonneg a)) ((lt_div_iff hx).1 h)],
  calc
    ¬´expr = ¬ª(¬´expr| |¬ª(b), ¬´expr| |¬ª(¬´expr + ¬ª(¬´expr - ¬ª(b, x), x))) : by rw [expr sub_add_cancel b x] []
    ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(b, x)), ¬´expr| |¬ª(x))) : abs_add ¬´expr - ¬ª(b, x) x
    ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(1, ¬´expr| |¬ª(x))) : add_le_add_right (le_of_lt h') ¬´expr| |¬ª(x)
    ¬´expr ‚â§ ¬ª(..., ¬´expr * ¬ª(2, ¬´expr + ¬ª(1, ¬´expr| |¬ª(x)))) : by linarith [] [] []
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem mul_tendsto_nhds_zero_left
(x : Œ±) : ¬´expr $ ¬ª(tendsto (uncurry ((¬´expr * ¬ª) : Œ± ‚Üí Œ± ‚Üí Œ±)) ¬´expr √ó·∂† ¬ª(exprùìù() x, exprùìù() 0), exprùìù() 0) :=
begin
  intros [ident s, ident hs],
  have [] [] [":=", expr mul_tendsto_nhds_zero_right x hs],
  rw ["[", expr filter.mem_map, ",", expr mem_prod_iff, "]"] ["at", ident this, "‚ä¢"],
  obtain ["‚ü®", ident U, ",", ident hU, ",", ident V, ",", ident hV, ",", ident h, "‚ü©", ":=", expr this],
  exact [expr ‚ü®V, hV, U, hU, Œª
    y
    hy, (¬´expr ‚ñ∏ ¬ª(mul_comm y.2 y.1, h (‚ü®hy.2, hy.1‚ü© : ¬´expr ‚àà ¬ª(prod.mk y.2 y.1, U.prod V))) : ¬´expr ‚àà ¬ª(¬´expr * ¬ª(y.1, y.2), s))‚ü©]
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem nhds_eq_map_mul_left_nhds_one
{x‚ÇÄ : Œ±}
(hx‚ÇÄ : ¬´expr ‚â† ¬ª(x‚ÇÄ, 0)) : ¬´expr = ¬ª(exprùìù() x‚ÇÄ, map (Œª x, ¬´expr * ¬ª(x‚ÇÄ, x)) (exprùìù() 1)) :=
begin
  have [ident hx‚ÇÄ'] [":", expr ¬´expr < ¬ª(0, ¬´expr| |¬ª(x‚ÇÄ))] [":=", expr abs_pos.2 hx‚ÇÄ],
  refine [expr filter.ext (Œª t, _)],
  simp [] [] ["only"] ["[", expr exists_prop, ",", expr set_of_subset_set_of, ",", expr (nhds_basis_abs_sub_lt x‚ÇÄ).mem_iff, ",", expr (nhds_basis_abs_sub_lt (1 : Œ±)).mem_iff, ",", expr filter.mem_map', "]"] [] [],
  refine [expr ‚ü®Œª h, _, Œª h, _‚ü©],
  { obtain ["‚ü®", ident i, ",", ident hi, ",", ident hit, "‚ü©", ":=", expr h],
    refine [expr ‚ü®¬´expr / ¬ª(i, ¬´expr| |¬ª(x‚ÇÄ)), div_pos hi (abs_pos.2 hx‚ÇÄ), Œª x hx, hit _‚ü©],
    calc
      ¬´expr = ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(¬´expr * ¬ª(x‚ÇÄ, x), x‚ÇÄ)), ¬´expr| |¬ª(¬´expr * ¬ª(x‚ÇÄ, ¬´expr - ¬ª(x, 1)))) : congr_arg abs (by ring_nf [] [] [])
      ¬´expr = ¬ª(..., ¬´expr * ¬ª(¬´expr| |¬ª(x‚ÇÄ), ¬´expr| |¬ª(¬´expr - ¬ª(x, 1)))) : abs_mul x‚ÇÄ ¬´expr - ¬ª(x, 1)
      ¬´expr < ¬ª(..., ¬´expr * ¬ª(¬´expr| |¬ª(x‚ÇÄ), ¬´expr / ¬ª(i, ¬´expr| |¬ª(x‚ÇÄ)))) : mul_lt_mul' le_rfl hx (abs_nonneg ¬´expr - ¬ª(x, 1)) (abs_pos.2 hx‚ÇÄ)
      ¬´expr = ¬ª(..., ¬´expr / ¬ª(¬´expr * ¬ª(¬´expr| |¬ª(x‚ÇÄ), i), ¬´expr| |¬ª(x‚ÇÄ))) : by ring []
      ¬´expr = ¬ª(..., i) : mul_div_cancel_left i (Œª h, hx‚ÇÄ (abs_eq_zero.1 h)) },
  { obtain ["‚ü®", ident i, ",", ident hi, ",", ident hit, "‚ü©", ":=", expr h],
    refine [expr ‚ü®¬´expr * ¬ª(i, ¬´expr| |¬ª(x‚ÇÄ)), mul_pos hi (abs_pos.2 hx‚ÇÄ), Œª x hx, _‚ü©],
    have [] [":", expr ¬´expr < ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(¬´expr / ¬ª(x, x‚ÇÄ), 1)), i)] [],
    calc
      ¬´expr = ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(¬´expr / ¬ª(x, x‚ÇÄ), 1)), ¬´expr| |¬ª(¬´expr - ¬ª(¬´expr / ¬ª(x, x‚ÇÄ), ¬´expr / ¬ª(x‚ÇÄ, x‚ÇÄ)))) : by rw [expr div_self hx‚ÇÄ] []
      ¬´expr = ¬ª(..., ¬´expr| |¬ª(¬´expr / ¬ª(¬´expr - ¬ª(x, x‚ÇÄ), x‚ÇÄ))) : congr_arg abs (sub_div x x‚ÇÄ x‚ÇÄ).symm
      ¬´expr = ¬ª(..., ¬´expr / ¬ª(¬´expr| |¬ª(¬´expr - ¬ª(x, x‚ÇÄ)), ¬´expr| |¬ª(x‚ÇÄ))) : abs_div ¬´expr - ¬ª(x, x‚ÇÄ) x‚ÇÄ
      ¬´expr < ¬ª(..., ¬´expr / ¬ª(¬´expr * ¬ª(i, ¬´expr| |¬ª(x‚ÇÄ)), ¬´expr| |¬ª(x‚ÇÄ))) : div_lt_div hx le_rfl (mul_nonneg (le_of_lt hi) (abs_nonneg x‚ÇÄ)) (abs_pos.2 hx‚ÇÄ)
      ¬´expr = ¬ª(..., i) : by rw ["[", "<-", expr mul_div_assoc', ",", expr div_self ¬´expr $ ¬ª(ne_of_lt, abs_pos.2 hx‚ÇÄ).symm, ",", expr mul_one, "]"] [],
    specialize [expr hit ¬´expr / ¬ª(x, x‚ÇÄ) this],
    rwa ["[", expr mul_div_assoc', ",", expr mul_div_cancel_left x hx‚ÇÄ, "]"] ["at", ident hit] }
end

theorem nhds_eq_map_mul_right_nhds_one {x‚ÇÄ : Œ±} (hx‚ÇÄ : x‚ÇÄ ‚â† 0) : ùìù x‚ÇÄ = map (fun x => x*x‚ÇÄ) (ùìù 1) :=
  by 
    simpRw [mul_comm‚Çì _ x‚ÇÄ, nhds_eq_map_mul_left_nhds_one hx‚ÇÄ]

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem mul_tendsto_nhds_one_nhds_one : ¬´expr $ ¬ª(tendsto (uncurry ((¬´expr * ¬ª) : Œ± ‚Üí Œ± ‚Üí Œ±)) ¬´expr √ó·∂† ¬ª(exprùìù() 1, exprùìù() 1), exprùìù() 1) :=
begin
  rw [expr ¬´expr $ ¬ª((nhds_basis_Ioo_pos (1 : Œ±)).prod, nhds_basis_Ioo_pos (1 : Œ±)).tendsto_iff (nhds_basis_Ioo_pos_of_pos (zero_lt_one : ¬´expr < ¬ª((0 : Œ±), 1)))] [],
  intros [ident Œµ, ident hŒµ],
  have [ident hŒµ'] [":", expr ¬´expr ‚â§ ¬ª(0, ¬´expr - ¬ª(1, ¬´expr / ¬ª(Œµ, 4)))] [":=", expr by linarith [] [] []],
  have [ident Œµ_pos] [":", expr ¬´expr < ¬ª(0, ¬´expr / ¬ª(Œµ, 4))] [":=", expr by linarith [] [] []],
  have [ident Œµ_pos'] [":", expr ¬´expr < ¬ª(0, ¬´expr / ¬ª(Œµ, 2))] [":=", expr by linarith [] [] []],
  simp [] [] ["only"] ["[", expr and_imp, ",", expr prod.forall, ",", expr mem_Ioo, ",", expr function.uncurry_apply_pair, ",", expr mem_prod, ",", expr prod.exists, "]"] [] [],
  refine [expr ‚ü®¬´expr / ¬ª(Œµ, 4), ¬´expr / ¬ª(Œµ, 4), ‚ü®Œµ_pos, Œµ_pos‚ü©, Œª a b ha ha' hb hb', _‚ü©],
  have [ident ha0] [":", expr ¬´expr ‚â§ ¬ª(0, a)] [":=", expr le_trans hŒµ' (le_of_lt ha)],
  have [ident hb0] [":", expr ¬´expr ‚â§ ¬ª(0, b)] [":=", expr le_trans hŒµ' (le_of_lt hb)],
  refine [expr ‚ü®lt_of_le_of_lt _ (mul_lt_mul'' ha hb hŒµ' hŒµ'), lt_of_lt_of_le (mul_lt_mul'' ha' hb' ha0 hb0) _‚ü©],
  { calc
      ¬´expr = ¬ª(¬´expr - ¬ª(1, Œµ), ¬´expr - ¬ª(¬´expr - ¬ª(1, ¬´expr / ¬ª(Œµ, 2)), ¬´expr / ¬ª(Œµ, 2))) : by ring_nf [] [] []
      ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(¬´expr - ¬ª(¬´expr - ¬ª(1, ¬´expr / ¬ª(Œµ, 2)), ¬´expr / ¬ª(Œµ, 2)), ¬´expr * ¬ª(¬´expr / ¬ª(Œµ, 2), ¬´expr / ¬ª(Œµ, 2)))) : le_add_of_nonneg_right (le_of_lt (mul_pos Œµ_pos' Œµ_pos'))
      ¬´expr = ¬ª(..., ¬´expr * ¬ª(¬´expr - ¬ª(1, ¬´expr / ¬ª(Œµ, 2)), ¬´expr - ¬ª(1, ¬´expr / ¬ª(Œµ, 2)))) : by ring_nf [] [] []
      ¬´expr ‚â§ ¬ª(..., ¬´expr * ¬ª(¬´expr - ¬ª(1, ¬´expr / ¬ª(Œµ, 4)), ¬´expr - ¬ª(1, ¬´expr / ¬ª(Œµ, 4)))) : mul_le_mul (by linarith [] [] []) (by linarith [] [] []) (by linarith [] [] []) hŒµ' },
  { calc
      ¬´expr = ¬ª(¬´expr * ¬ª(¬´expr + ¬ª(1, ¬´expr / ¬ª(Œµ, 4)), ¬´expr + ¬ª(1, ¬´expr / ¬ª(Œµ, 4))), ¬´expr + ¬ª(¬´expr + ¬ª(1, ¬´expr / ¬ª(Œµ, 2)), ¬´expr * ¬ª(¬´expr / ¬ª(Œµ, 4), ¬´expr / ¬ª(Œµ, 4)))) : by ring_nf [] [] []
      ¬´expr = ¬ª(..., ¬´expr + ¬ª(¬´expr + ¬ª(1, ¬´expr / ¬ª(Œµ, 2)), ¬´expr / ¬ª(¬´expr * ¬ª(Œµ, Œµ), 16))) : by ring_nf [] [] []
      ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(¬´expr + ¬ª(1, ¬´expr / ¬ª(Œµ, 2)), ¬´expr / ¬ª(Œµ, 2))) : add_le_add_left (div_le_div (le_of_lt hŒµ.1) (le_trans ((mul_le_mul_left hŒµ.1).2 hŒµ.2) ¬´expr $ ¬ª(le_of_eq, mul_one Œµ)) zero_lt_two (by linarith [] [] [])) ¬´expr + ¬ª(1, ¬´expr / ¬ª(Œµ, 2))
      ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(1, Œµ)) : by ring_nf [] [] [] }
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[priority 100] instance linear_ordered_field.has_continuous_mul : has_continuous_mul Œ± :=
‚ü®begin
   rw [expr continuous_iff_continuous_at] [],
   rintro ["‚ü®", ident x‚ÇÄ, ",", ident y‚ÇÄ, "‚ü©"],
   by_cases [expr hx‚ÇÄ, ":", expr ¬´expr = ¬ª(x‚ÇÄ, 0)],
   { rw ["[", expr hx‚ÇÄ, ",", expr continuous_at, ",", expr zero_mul, ",", expr nhds_prod_eq, "]"] [],
     exact [expr mul_tendsto_nhds_zero_right y‚ÇÄ] },
   by_cases [expr hy‚ÇÄ, ":", expr ¬´expr = ¬ª(y‚ÇÄ, 0)],
   { rw ["[", expr hy‚ÇÄ, ",", expr continuous_at, ",", expr mul_zero, ",", expr nhds_prod_eq, "]"] [],
     exact [expr mul_tendsto_nhds_zero_left x‚ÇÄ] },
   have [ident hxy] [":", expr ¬´expr ‚â† ¬ª(¬´expr * ¬ª(x‚ÇÄ, y‚ÇÄ), 0)] [":=", expr mul_ne_zero hx‚ÇÄ hy‚ÇÄ],
   have [ident key] [":", expr ¬´expr = ¬ª(Œª
     p : ¬´expr √ó ¬ª(Œ±, Œ±), ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, p.1), ¬´expr * ¬ª(p.2, y‚ÇÄ)), ¬´expr ‚àò ¬ª(¬´expr ‚àò ¬ª(Œª
       x, ¬´expr * ¬ª(x‚ÇÄ, x), Œª x, ¬´expr * ¬ª(x, y‚ÇÄ)), uncurry ((¬´expr * ¬ª))))] [],
   { ext [] [ident p] [],
     simp [] [] [] ["[", expr uncurry, ",", expr mul_assoc, "]"] [] [] },
   have [ident key‚ÇÇ] [":", expr ¬´expr = ¬ª(¬´expr ‚àò ¬ª(Œª
      x, ¬´expr * ¬ª(x‚ÇÄ, x), Œª x, ¬´expr * ¬ª(y‚ÇÄ, x)), Œª x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, y‚ÇÄ), x))] [],
   { ext [] [ident x] [],
     simp [] [] [] [] [] [] },
   calc
     ¬´expr = ¬ª(map (uncurry ((¬´expr * ¬ª))) (exprùìù() (x‚ÇÄ, y‚ÇÄ)), map (uncurry ((¬´expr * ¬ª))) ¬´expr √ó·∂† ¬ª(exprùìù() x‚ÇÄ, exprùìù() y‚ÇÄ)) : by rw [expr nhds_prod_eq] []
     ¬´expr = ¬ª(..., map (Œª
       p : ¬´expr √ó ¬ª(Œ±, Œ±), ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, p.1), ¬´expr * ¬ª(p.2, y‚ÇÄ))) ¬´expr √ó·∂† ¬ª(exprùìù() 1, exprùìù() 1)) : by rw ["[", expr uncurry, ",", expr nhds_eq_map_mul_left_nhds_one hx‚ÇÄ, ",", expr nhds_eq_map_mul_right_nhds_one hy‚ÇÄ, ",", expr prod_map_map_eq, ",", expr filter.map_map, "]"] []
     ¬´expr = ¬ª(..., map ¬´expr ‚àò ¬ª(Œª
       x, ¬´expr * ¬ª(x‚ÇÄ, x), Œª
       x, ¬´expr * ¬ª(x, y‚ÇÄ)) (map (uncurry ((¬´expr * ¬ª))) ¬´expr √ó·∂† ¬ª(exprùìù() 1, exprùìù() 1))) : by rw ["[", expr key, ",", "<-", expr filter.map_map, "]"] []
     ¬´expr ‚â§ ¬ª(..., map ¬´expr ‚àò ¬ª(Œª
       x : Œ±, ¬´expr * ¬ª(x‚ÇÄ, x), Œª x, ¬´expr * ¬ª(x, y‚ÇÄ)) (exprùìù() 1)) : map_mono mul_tendsto_nhds_one_nhds_one
     ¬´expr = ¬ª(..., exprùìù() ¬´expr * ¬ª(x‚ÇÄ, y‚ÇÄ)) : by rw ["[", "<-", expr filter.map_map, ",", "<-", expr nhds_eq_map_mul_right_nhds_one hy‚ÇÄ, ",", expr nhds_eq_map_mul_left_nhds_one hy‚ÇÄ, ",", expr filter.map_map, ",", expr key‚ÇÇ, ",", "<-", expr nhds_eq_map_mul_left_nhds_one hxy, "]"] []
 end‚ü©

end continuous_mul

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a positive constant `C` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.at_top_mul {C : Œ±} (hC : 0 < C) (hf : tendsto f l at_top) (hg : tendsto g l (ùìù C)) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    refine' tendsto_at_top_mono' _ _ (hf.at_top_mul_const (half_pos hC))
    filterUpwards [hg.eventually (lt_mem_nhds (half_lt_self hC)), hf.eventually (eventually_ge_at_top 0)]
    exact fun x hg hf => mul_le_mul_of_nonneg_left hg.le hf

/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and
`g` tends to `at_top` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.mul_at_top {C : Œ±} (hC : 0 < C) (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_top) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    simpa only [mul_comm‚Çì] using hg.at_top_mul hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a negative constant `C` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.at_top_mul_neg {C : Œ±} (hC : C < 0) (hf : tendsto f l at_top) (hg : tendsto g l (ùìù C)) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa only [¬∑ ‚àò ¬∑, neg_mul_eq_mul_neg, neg_neg‚Çì] using
      tendsto_neg_at_top_at_bot.comp (hf.at_top_mul (neg_pos.2 hC) hg.neg)

/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and
`g` tends to `at_top` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.neg_mul_at_top {C : Œ±} (hC : C < 0) (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_top) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa only [mul_comm‚Çì] using hg.at_top_mul_neg hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to
a positive constant `C` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.at_bot_mul {C : Œ±} (hC : 0 < C) (hf : tendsto f l at_bot) (hg : tendsto g l (ùìù C)) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa [¬∑ ‚àò ¬∑] using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul hC hg)

/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to
a negative constant `C` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.at_bot_mul_neg {C : Œ±} (hC : C < 0) (hf : tendsto f l at_bot) (hg : tendsto g l (ùìù C)) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    simpa [¬∑ ‚àò ¬∑] using tendsto_neg_at_bot_at_top.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul_neg hC hg)

/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and
`g` tends to `at_bot` then `f * g` tends to `at_bot`. -/
theorem Filter.Tendsto.mul_at_bot {C : Œ±} (hC : 0 < C) (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x*g x) l at_bot :=
  by 
    simpa only [mul_comm‚Çì] using hg.at_bot_mul hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and
`g` tends to `at_bot` then `f * g` tends to `at_top`. -/
theorem Filter.Tendsto.neg_mul_at_bot {C : Œ±} (hC : C < 0) (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    simpa only [mul_comm‚Çì] using hg.at_bot_mul_neg hC hf

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The function `x ‚Ü¶ x‚Åª¬π` tends to `+‚àû` on the right of `0`. -/
theorem tendsto_inv_zero_at_top : tendsto (Œª x : Œ±, ¬´expr ‚Åª¬π¬ª(x)) ¬´exprùìù[ ] ¬ª(set.Ioi (0 : Œ±), 0) at_top :=
begin
  refine [expr (at_top_basis' 1).tendsto_right_iff.2 (Œª b hb, _)],
  have [ident hb'] [":", expr ¬´expr < ¬ª(0, b)] [":=", expr zero_lt_one.trans_le hb],
  filter_upwards ["[", expr Ioc_mem_nhds_within_Ioi ‚ü®le_rfl, inv_pos.2 hb'‚ü©, "]"] [],
  exact [expr Œª x hx, (le_inv hx.1 hb').1 hx.2]
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The function `r ‚Ü¶ r‚Åª¬π` tends to `0` on the right as `r ‚Üí +‚àû`. -/
theorem tendsto_inv_at_top_zero' : tendsto (Œª r : Œ±, ¬´expr ‚Åª¬π¬ª(r)) at_top ¬´exprùìù[ ] ¬ª(set.Ioi (0 : Œ±), 0) :=
begin
  refine [expr (has_basis.tendsto_iff at_top_basis ‚ü®Œª s, mem_nhds_within_Ioi_iff_exists_Ioc_subset‚ü©).2 _],
  refine [expr Œª b hb, ‚ü®¬´expr ‚Åª¬π¬ª(b), trivial, Œª x hx, _‚ü©],
  have [] [":", expr ¬´expr < ¬ª(0, x)] [":=", expr lt_of_lt_of_le (inv_pos.2 hb) hx],
  exact [expr ‚ü®inv_pos.2 this, (inv_le this hb).2 hx‚ü©]
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem tendsto_inv_at_top_zero : tendsto (Œª r : Œ±, ¬´expr ‚Åª¬π¬ª(r)) at_top (exprùìù() 0) :=
tendsto_inv_at_top_zero'.mono_right inf_le_left

theorem Filter.Tendsto.div_at_top [HasContinuousMul Œ±] {f g : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {a : Œ±} (h : tendsto f l (ùìù a))
  (hg : tendsto g l at_top) : tendsto (fun x => f x / g x) l (ùìù 0) :=
  by 
    simp only [div_eq_mul_inv]
    exact mul_zero a ‚ñ∏ h.mul (tendsto_inv_at_top_zero.comp hg)

theorem Filter.Tendsto.inv_tendsto_at_top (h : tendsto f l at_top) : tendsto (f‚Åª¬π) l (ùìù 0) :=
  tendsto_inv_at_top_zero.comp h

theorem Filter.Tendsto.inv_tendsto_zero (h : tendsto f l (ùìù[Set.Ioi 0] 0)) : tendsto (f‚Åª¬π) l at_top :=
  tendsto_inv_zero_at_top.comp h

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- The function `x^(-n)` tends to `0` at `+‚àû` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_neg_at_top`. -/
theorem tendsto_pow_neg_at_top
{n : expr‚Ñï()}
(hn : ¬´expr ‚â§ ¬ª(1, n)) : tendsto (Œª x : Œ±, ¬´expr ^ ¬ª(x, ¬´expr- ¬ª((n : expr‚Ñ§())))) at_top (exprùìù() 0) :=
tendsto.congr (Œª
 x, (zpow_neg‚ÇÄ x n).symm) (filter.tendsto.inv_tendsto_at_top (by simpa [] [] [] ["[", expr zpow_coe_nat, "]"] [] ["using", expr tendsto_pow_at_top hn]))

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem tendsto_zpow_at_top_zero
{n : expr‚Ñ§()}
(hn : ¬´expr < ¬ª(n, 0)) : tendsto (Œª x : Œ±, ¬´expr ^ ¬ª(x, n)) at_top (exprùìù() 0) :=
begin
  have [] [":", expr ¬´expr ‚â§ ¬ª(1, ¬´expr- ¬ª(n))] [":=", expr le_neg.mp (int.le_of_lt_add_one (hn.trans_le (neg_add_self 1).symm.le))],
  apply [expr tendsto.congr (show ‚àÄ
    x : Œ±, ¬´expr = ¬ª(¬´expr ^ ¬ª(x, ¬´expr- ¬ª(¬´expr- ¬ª(n))), ¬´expr ^ ¬ª(x, n)), by simp [] [] [] [] [] [])],
  lift [expr ¬´expr- ¬ª(n)] ["to", expr expr‚Ñï()] ["using", expr le_of_lt (neg_pos.mpr hn)] ["with", ident N],
  exact [expr tendsto_pow_neg_at_top (by exact_mod_cast [expr this])]
end

theorem tendsto_const_mul_zpow_at_top_zero {n : ‚Ñ§} {c : Œ±} (hn : n < 0) : tendsto (fun x => c*x ^ n) at_top (ùìù 0) :=
  mul_zero c ‚ñ∏ Filter.Tendsto.const_mul c (tendsto_zpow_at_top_zero hn)

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem tendsto_const_mul_pow_nhds_iff
{n : expr‚Ñï()}
{c d : Œ±}
(hc : ¬´expr ‚â† ¬ª(c, 0)) : ¬´expr ‚Üî ¬ª(tendsto (Œª
  x : Œ±, ¬´expr * ¬ª(c, ¬´expr ^ ¬ª(x, n))) at_top (exprùìù() d), ¬´expr ‚àß ¬ª(¬´expr = ¬ª(n, 0), ¬´expr = ¬ª(c, d))) :=
begin
  refine [expr ‚ü®Œª h, _, Œª h, _‚ü©],
  { have [ident hn] [":", expr ¬´expr = ¬ª(n, 0)] [],
    { by_contradiction [ident hn],
      have [ident hn] [":", expr ¬´expr ‚â§ ¬ª(1, n)] [":=", expr nat.succ_le_iff.2 (lt_of_le_of_ne (zero_le _) (ne.symm hn))],
      by_cases [expr hc', ":", expr ¬´expr < ¬ª(0, c)],
      { have [] [] [":=", expr (tendsto_const_mul_pow_at_top_iff c n).2 ‚ü®hn, hc'‚ü©],
        exact [expr not_tendsto_nhds_of_tendsto_at_top this d h] },
      { have [] [] [":=", expr (tendsto_neg_const_mul_pow_at_top_iff c n).2 ‚ü®hn, lt_of_le_of_ne (not_lt.1 hc') hc‚ü©],
        exact [expr not_tendsto_nhds_of_tendsto_at_bot this d h] } },
    have [] [":", expr ¬´expr = ¬ª(Œª x : Œ±, ¬´expr * ¬ª(c, ¬´expr ^ ¬ª(x, n)), Œª x : Œ±, c)] [],
    by simp [] [] [] ["[", expr hn, "]"] [] [],
    rw ["[", expr this, ",", expr tendsto_const_nhds_iff, "]"] ["at", ident h],
    exact [expr ‚ü®hn, h‚ü©] },
  { obtain ["‚ü®", ident hn, ",", ident hcd, "‚ü©", ":=", expr h],
    simpa [] [] [] ["[", expr hn, ",", expr hcd, "]"] [] ["using", expr tendsto_const_nhds] }
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem tendsto_const_mul_zpow_at_top_zero_iff
{n : expr‚Ñ§()}
{c d : Œ±}
(hc : ¬´expr ‚â† ¬ª(c, 0)) : ¬´expr ‚Üî ¬ª(tendsto (Œª
  x : Œ±, ¬´expr * ¬ª(c, ¬´expr ^ ¬ª(x, n))) at_top (exprùìù() d), ¬´expr ‚à® ¬ª(¬´expr ‚àß ¬ª(¬´expr = ¬ª(n, 0), ¬´expr = ¬ª(c, d)), ¬´expr ‚àß ¬ª(¬´expr < ¬ª(n, 0), ¬´expr = ¬ª(d, 0)))) :=
begin
  refine [expr ‚ü®Œª h, _, Œª h, _‚ü©],
  { by_cases [expr hn, ":", expr ¬´expr ‚â§ ¬ª(0, n)],
    { lift [expr n] ["to", expr expr‚Ñï()] ["using", expr hn] [],
      simp [] [] ["only"] ["[", expr zpow_coe_nat, "]"] [] ["at", ident h],
      rw ["[", expr tendsto_const_mul_pow_nhds_iff hc, ",", "<-", expr int.coe_nat_eq_zero, "]"] ["at", ident h],
      exact [expr or.inl h] },
    { rw [expr not_le] ["at", ident hn],
      refine [expr or.inr ‚ü®hn, tendsto_nhds_unique h (tendsto_const_mul_zpow_at_top_zero hn)‚ü©] } },
  { cases [expr h] [],
    { simp [] [] ["only"] ["[", expr h.left, ",", expr h.right, ",", expr zpow_zero, ",", expr mul_one, "]"] [] [],
      exact [expr tendsto_const_nhds] },
    { exact [expr ¬´expr ‚ñ∏ ¬ª(h.2.symm, tendsto_const_mul_zpow_at_top_zero h.1)] } }
end

end LinearOrderedField

theorem preimage_neg [AddGroup‚Çì Œ±] : preimage (Neg.neg : Œ± ‚Üí Œ±) = image (Neg.neg : Œ± ‚Üí Œ±) :=
  (image_eq_preimage_of_inverse neg_neg‚Çì neg_neg‚Çì).symm

theorem Filter.map_neg [AddGroup‚Çì Œ±] : map (Neg.neg : Œ± ‚Üí Œ±) = comap (Neg.neg : Œ± ‚Üí Œ±) :=
  funext$ fun f => map_eq_comap_of_inverse (funext neg_neg‚Çì) (funext neg_neg‚Çì)

section OrderTopology

variable[TopologicalSpace Œ±][TopologicalSpace Œ≤][LinearOrder‚Çì Œ±][LinearOrder‚Çì Œ≤][OrderTopology Œ±][OrderTopology Œ≤]

theorem IsLub.frequently_mem {a : Œ±} {s : Set Œ±} (ha : IsLub s a) (hs : s.nonempty) : ‚àÉ·∂†x in ùìù[Iic a] a, x ‚àà s :=
  by 
    rcases hs with ‚ü®a', ha'‚ü©
    intro h 
    rcases(ha.1 ha').eq_or_lt with (rfl | ha'a)
    ¬∑
      exact h.self_of_nhds_within le_rfl ha'
    ¬∑
      rcases(mem_nhds_within_Iic_iff_exists_Ioc_subset' ha'a).1 h with ‚ü®b, hba, hb‚ü©
      rcases ha.exists_between hba with ‚ü®b', hb's, hb'‚ü©
      exact hb hb' hb's

theorem IsLub.frequently_nhds_mem {a : Œ±} {s : Set Œ±} (ha : IsLub s a) (hs : s.nonempty) : ‚àÉ·∂†x in ùìù a, x ‚àà s :=
  (ha.frequently_mem hs).filter_mono inf_le_left

theorem IsGlb.frequently_mem {a : Œ±} {s : Set Œ±} (ha : IsGlb s a) (hs : s.nonempty) : ‚àÉ·∂†x in ùìù[Ici a] a, x ‚àà s :=
  @IsLub.frequently_mem (OrderDual Œ±) _ _ _ _ _ ha hs

theorem IsGlb.frequently_nhds_mem {a : Œ±} {s : Set Œ±} (ha : IsGlb s a) (hs : s.nonempty) : ‚àÉ·∂†x in ùìù a, x ‚àà s :=
  (ha.frequently_mem hs).filter_mono inf_le_left

theorem IsLub.mem_closure {a : Œ±} {s : Set Œ±} (ha : IsLub s a) (hs : s.nonempty) : a ‚àà Closure s :=
  (ha.frequently_nhds_mem hs).mem_closure

theorem IsGlb.mem_closure {a : Œ±} {s : Set Œ±} (ha : IsGlb s a) (hs : s.nonempty) : a ‚àà Closure s :=
  (ha.frequently_nhds_mem hs).mem_closure

theorem IsLub.nhds_within_ne_bot {a : Œ±} {s : Set Œ±} (ha : IsLub s a) (hs : s.nonempty) : ne_bot (ùìù[s] a) :=
  mem_closure_iff_nhds_within_ne_bot.1 (ha.mem_closure hs)

theorem IsGlb.nhds_within_ne_bot : ‚àÄ {a : Œ±} {s : Set Œ±}, IsGlb s a ‚Üí s.nonempty ‚Üí ne_bot (ùìù[s] a) :=
  @IsLub.nhds_within_ne_bot (OrderDual Œ±) _ _ _

theorem is_lub_of_mem_nhds {s : Set Œ±} {a : Œ±} {f : Filter Œ±} (hsa : a ‚àà UpperBounds s) (hsf : s ‚àà f) [ne_bot (f‚äìùìù a)] :
  IsLub s a :=
  ‚ü®hsa,
    fun b hb =>
      not_lt‚Çì.1$
        fun hba =>
          have  : s ‚à© { a | b < a } ‚àà f‚äìùìù a := inter_mem_inf hsf (IsOpen.mem_nhds (is_open_lt' _) hba)
          let ‚ü®x, ‚ü®hxs, hxb‚ü©‚ü© := Filter.nonempty_of_mem this 
          have  : b < b := lt_of_lt_of_le‚Çì hxb$ hb hxs 
          lt_irrefl‚Çì b this‚ü©

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_lub_of_mem_closure
{s : set Œ±}
{a : Œ±}
(hsa : ¬´expr ‚àà ¬ª(a, upper_bounds s))
(hsf : ¬´expr ‚àà ¬ª(a, closure s)) : is_lub s a :=
begin
  rw ["[", expr mem_closure_iff_cluster_pt, ",", expr cluster_pt, ",", expr inf_comm, "]"] ["at", ident hsf],
  haveI [] [":", expr ¬´expr ‚äì ¬ª(exprùìü() s, exprùìù() a).ne_bot] [":=", expr hsf],
  exact [expr is_lub_of_mem_nhds hsa (mem_principal_self s)]
end

theorem is_glb_of_mem_nhds :
  ‚àÄ {s : Set Œ±} {a : Œ±} {f : Filter Œ±}, a ‚àà LowerBounds s ‚Üí s ‚àà f ‚Üí ne_bot (f‚äìùìù a) ‚Üí IsGlb s a :=
  @is_lub_of_mem_nhds (OrderDual Œ±) _ _ _

theorem is_glb_of_mem_closure {s : Set Œ±} {a : Œ±} (hsa : a ‚àà LowerBounds s) (hsf : a ‚àà Closure s) : IsGlb s a :=
  @is_lub_of_mem_closure (OrderDual Œ±) _ _ _ s a hsa hsf

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_lub.mem_upper_bounds_of_tendsto
[preorder Œ≥]
[topological_space Œ≥]
[order_closed_topology Œ≥]
{f : Œ± ‚Üí Œ≥}
{s : set Œ±}
{a : Œ±}
{b : Œ≥}
(hf : monotone_on f s)
(ha : is_lub s a)
(hb : tendsto f ¬´exprùìù[ ] ¬ª(s, a) (exprùìù() b)) : ¬´expr ‚àà ¬ª(b, upper_bounds ¬´expr '' ¬ª(f, s)) :=
begin
  rintro ["_", "‚ü®", ident x, ",", ident hx, ",", ident rfl, "‚ü©"],
  replace [ident ha] [] [":=", expr ha.inter_Ici_of_mem hx],
  haveI [] [] [":=", expr ha.nhds_within_ne_bot ‚ü®x, hx, le_rfl‚ü©],
  refine [expr ge_of_tendsto (hb.mono_left (nhds_within_mono _ (inter_subset_left s (Ici x)))) _],
  exact [expr mem_of_superset self_mem_nhds_within (Œª y hy, hf hx hy.1 hy.2)]
end

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_lub.is_lub_of_tendsto
[preorder Œ≥]
[topological_space Œ≥]
[order_closed_topology Œ≥]
{f : Œ± ‚Üí Œ≥}
{s : set Œ±}
{a : Œ±}
{b : Œ≥}
(hf : monotone_on f s)
(ha : is_lub s a)
(hs : s.nonempty)
(hb : tendsto f ¬´exprùìù[ ] ¬ª(s, a) (exprùìù() b)) : is_lub ¬´expr '' ¬ª(f, s) b :=
begin
  haveI [] [] [":=", expr ha.nhds_within_ne_bot hs],
  exact [expr ‚ü®ha.mem_upper_bounds_of_tendsto hf hb, Œª
    b'
    hb', le_of_tendsto hb ¬´expr $ ¬ª(mem_of_superset self_mem_nhds_within, Œª
     x hx, ¬´expr $ ¬ª(hb', mem_image_of_mem _ hx))‚ü©]
end

theorem IsGlb.mem_lower_bounds_of_tendsto [Preorder‚Çì Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] {f : Œ± ‚Üí Œ≥}
  {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : MonotoneOn f s) (ha : IsGlb s a) (hb : tendsto f (ùìù[s] a) (ùìù b)) :
  b ‚àà LowerBounds (f '' s) :=
  @IsLub.mem_upper_bounds_of_tendsto (OrderDual Œ±) (OrderDual Œ≥) _ _ _ _ _ _ _ _ _ _ hf.dual ha hb

theorem IsGlb.is_glb_of_tendsto [Preorder‚Çì Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] {f : Œ± ‚Üí Œ≥} {s : Set Œ±}
  {a : Œ±} {b : Œ≥} (hf : MonotoneOn f s) : IsGlb s a ‚Üí s.nonempty ‚Üí tendsto f (ùìù[s] a) (ùìù b) ‚Üí IsGlb (f '' s) b :=
  @IsLub.is_lub_of_tendsto (OrderDual Œ±) (OrderDual Œ≥) _ _ _ _ _ _ f s a b hf.dual

theorem IsLub.mem_lower_bounds_of_tendsto [Preorder‚Çì Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] {f : Œ± ‚Üí Œ≥}
  {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : AntitoneOn f s) (ha : IsLub s a) (hb : tendsto f (ùìù[s] a) (ùìù b)) :
  b ‚àà LowerBounds (f '' s) :=
  @IsLub.mem_upper_bounds_of_tendsto Œ± (OrderDual Œ≥) _ _ _ _ _ _ _ _ _ _ hf ha hb

theorem IsLub.is_glb_of_tendsto [Preorder‚Çì Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] :
  ‚àÄ {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥},
    AntitoneOn f s ‚Üí IsLub s a ‚Üí s.nonempty ‚Üí tendsto f (ùìù[s] a) (ùìù b) ‚Üí IsGlb (f '' s) b :=
  @IsLub.is_lub_of_tendsto Œ± (OrderDual Œ≥) _ _ _ _ _ _

theorem IsGlb.mem_upper_bounds_of_tendsto [Preorder‚Çì Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] {f : Œ± ‚Üí Œ≥}
  {s : Set Œ±} {a : Œ±} {b : Œ≥} (hf : AntitoneOn f s) (ha : IsGlb s a) (hb : tendsto f (ùìù[s] a) (ùìù b)) :
  b ‚àà UpperBounds (f '' s) :=
  @IsGlb.mem_lower_bounds_of_tendsto Œ± (OrderDual Œ≥) _ _ _ _ _ _ _ _ _ _ hf ha hb

theorem IsGlb.is_lub_of_tendsto [Preorder‚Çì Œ≥] [TopologicalSpace Œ≥] [OrderClosedTopology Œ≥] :
  ‚àÄ {f : Œ± ‚Üí Œ≥} {s : Set Œ±} {a : Œ±} {b : Œ≥},
    AntitoneOn f s ‚Üí IsGlb s a ‚Üí s.nonempty ‚Üí tendsto f (ùìù[s] a) (ùìù b) ‚Üí IsLub (f '' s) b :=
  @IsGlb.is_glb_of_tendsto Œ± (OrderDual Œ≥) _ _ _ _ _ _

theorem IsLub.mem_of_is_closed {a : Œ±} {s : Set Œ±} (ha : IsLub s a) (hs : s.nonempty) (sc : IsClosed s) : a ‚àà s :=
  sc.closure_subset$ ha.mem_closure hs

alias IsLub.mem_of_is_closed ‚Üê IsClosed.is_lub_mem

theorem IsGlb.mem_of_is_closed {a : Œ±} {s : Set Œ±} (ha : IsGlb s a) (hs : s.nonempty) (sc : IsClosed s) : a ‚àà s :=
  sc.closure_subset$ ha.mem_closure hs

alias IsGlb.mem_of_is_closed ‚Üê IsClosed.is_glb_mem

/-!
### Existence of sequences tending to Inf or Sup of a given set
-/


-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_lub.exists_seq_strict_mono_tendsto_of_not_mem
{t : set Œ±}
{x : Œ±}
[is_countably_generated (exprùìù() x)]
(htx : is_lub t x)
(not_mem : ¬´expr ‚àâ ¬ª(x, t))
(ht : t.nonempty) : ¬´expr‚àÉ , ¬ª((u : expr‚Ñï() ‚Üí Œ±), ¬´expr ‚àß ¬ª(strict_mono u, ¬´expr ‚àß ¬ª(‚àÄ
   n, ¬´expr < ¬ª(u n, x), ¬´expr ‚àß ¬ª(tendsto u at_top (exprùìù() x), ‚àÄ n, ¬´expr ‚àà ¬ª(u n, t))))) :=
begin
  rcases [expr ht, "with", "‚ü®", ident l, ",", ident hl, "‚ü©"],
  have [ident hl] [":", expr ¬´expr < ¬ª(l, x)] [],
  from [expr (htx.1 hl).eq_or_lt.resolve_left (Œª h, ¬´expr $ ¬ª(not_mem, ¬´expr ‚ñ∏ ¬ª(h, hl)).elim)],
  obtain ["‚ü®", ident s, ",", ident hs, "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((s : expr‚Ñï() ‚Üí set Œ±), (exprùìù() x).has_basis (Œª
     _x : expr‚Ñï(), true) s), ":=", expr let ‚ü®s, hs‚ü© := (exprùìù() x).exists_antitone_basis in
   ‚ü®s, hs.to_has_basis‚ü©],
  have [] [":", expr ‚àÄ
   n
   k, ¬´expr < ¬ª(k, x) ‚Üí ¬´expr‚àÉ , ¬ª((y), ¬´expr ‚àß ¬ª(¬´expr ‚äÜ ¬ª(Icc y x, s n), ¬´expr ‚àß ¬ª(¬´expr < ¬ª(k, y), ¬´expr ‚àß ¬ª(¬´expr < ¬ª(y, x), ¬´expr ‚àà ¬ª(y, t)))))] [],
  { assume [binders (n k hk)],
    obtain ["‚ü®", ident L, ",", ident hL, ",", ident h, "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((L : Œ±)
      (hL : ¬´expr ‚àà ¬ª(L, Ico k x)), ¬´expr ‚äÜ ¬ª(Ioc L x, s n)), ":=", expr exists_Ioc_subset_of_mem_nhds' (hs.mem_of_mem trivial) hk],
    obtain ["‚ü®", ident y, ",", ident hy, "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((y : Œ±), ¬´expr ‚àß ¬ª(¬´expr < ¬ª(L, y), ¬´expr ‚àß ¬ª(¬´expr < ¬ª(y, x), ¬´expr ‚àà ¬ª(y, t))))],
    { rcases [expr htx.exists_between' not_mem hL.2, "with", "‚ü®", ident y, ",", ident yt, ",", ident hy, "‚ü©"],
      refine [expr ‚ü®y, hy.1, hy.2, yt‚ü©] },
    exact [expr ‚ü®y, Œª z hz, h ‚ü®hy.1.trans_le hz.1, hz.2‚ü©, hL.1.trans_lt hy.1, hy.2‚ü©] },
  choose ["!"] [ident f] [ident hf] ["using", expr this],
  let [ident u] [":", expr expr‚Ñï() ‚Üí Œ±] [":=", expr Œª n, nat.rec_on n (f 0 l) (Œª n h, f n.succ h)],
  have [ident I] [":", expr ‚àÄ n, ¬´expr < ¬ª(u n, x)] [],
  { assume [binders (n)],
    induction [expr n] [] ["with", ident n, ident IH] [],
    { exact [expr (hf 0 l hl).2.2.1] },
    { exact [expr (hf n.succ _ IH).2.2.1] } },
  have [ident S] [":", expr strict_mono u] [":=", expr strict_mono_nat_of_lt_succ (Œª n, (hf n.succ _ (I n)).2.1)],
  refine [expr ‚ü®u, S, I, hs.tendsto_right_iff.2 (Œª n _, _), Œª n, _‚ü©],
  { simp [] [] ["only"] ["[", expr ge_iff_le, ",", expr eventually_at_top, "]"] [] [],
    refine [expr ‚ü®n, Œª p hp, _‚ü©],
    have [ident up] [":", expr ¬´expr ‚àà ¬ª(u p, Icc (u n) x)] [":=", expr ‚ü®S.monotone hp, (I p).le‚ü©],
    have [] [":", expr ¬´expr ‚äÜ ¬ª(Icc (u n) x, s n)] [],
    by { cases [expr n] [],
      { exact [expr (hf 0 l hl).1] },
      { exact [expr (hf n.succ (u n) (I n)).1] } },
    exact [expr this up] },
  { cases [expr n] [],
    { exact [expr (hf 0 l hl).2.2.2] },
    { exact [expr (hf n.succ _ (I n)).2.2.2] } }
end

theorem IsLub.exists_seq_monotone_tendsto {t : Set Œ±} {x : Œ±} [is_countably_generated (ùìù x)] (htx : IsLub t x)
  (ht : t.nonempty) : ‚àÉ u : ‚Ñï ‚Üí Œ±, Monotone u ‚àß (‚àÄ n, u n ‚â§ x) ‚àß tendsto u at_top (ùìù x) ‚àß ‚àÄ n, u n ‚àà t :=
  by 
    byCases' h : x ‚àà t
    ¬∑
      exact ‚ü®fun n => x, monotone_const, fun n => le_rfl, tendsto_const_nhds, fun n => h‚ü©
    ¬∑
      rcases htx.exists_seq_strict_mono_tendsto_of_not_mem h ht with ‚ü®u, hu‚ü©
      exact ‚ü®u, hu.1.Monotone, fun n => (hu.2.1 n).le, hu.2.2‚ü©

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem exists_seq_strict_mono_tendsto'
{Œ± : Type*}
[linear_order Œ±]
[topological_space Œ±]
[densely_ordered Œ±]
[order_topology Œ±]
[first_countable_topology Œ±]
{x y : Œ±}
(hy : ¬´expr < ¬ª(y, x)) : ¬´expr‚àÉ , ¬ª((u : expr‚Ñï() ‚Üí Œ±), ¬´expr ‚àß ¬ª(strict_mono u, ¬´expr ‚àß ¬ª(‚àÄ
   n, ¬´expr < ¬ª(u n, x), tendsto u at_top (exprùìù() x)))) :=
begin
  have [ident hx] [":", expr ¬´expr ‚àâ ¬ª(x, Iio x)] [":=", expr Œª h, (lt_irrefl x h).elim],
  have [ident ht] [":", expr set.nonempty (Iio x)] [":=", expr ‚ü®y, hy‚ü©],
  rcases [expr is_lub_Iio.exists_seq_strict_mono_tendsto_of_not_mem hx ht, "with", "‚ü®", ident u, ",", ident hu, "‚ü©"],
  exact [expr ‚ü®u, hu.1, hu.2.1, hu.2.2.1‚ü©]
end

theorem exists_seq_strict_mono_tendsto [DenselyOrdered Œ±] [NoBotOrder Œ±] [first_countable_topology Œ±] (x : Œ±) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictMono u ‚àß (‚àÄ n, u n < x) ‚àß tendsto u at_top (ùìù x) :=
  by 
    obtain ‚ü®y, hy‚ü© : ‚àÉ y, y < x := no_bot _ 
    exact exists_seq_strict_mono_tendsto' hy

theorem exists_seq_tendsto_Sup {Œ± : Type _} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±]
  [first_countable_topology Œ±] {S : Set Œ±} (hS : S.nonempty) (hS' : BddAbove S) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, Monotone u ‚àß tendsto u at_top (ùìù (Sup S)) ‚àß ‚àÄ n, u n ‚àà S :=
  by 
    rcases(is_lub_cSup hS hS').exists_seq_monotone_tendsto hS with ‚ü®u, hu‚ü©
    exact ‚ü®u, hu.1, hu.2.2‚ü©

theorem IsGlb.exists_seq_strict_anti_tendsto_of_not_mem {t : Set Œ±} {x : Œ±} [is_countably_generated (ùìù x)]
  (htx : IsGlb t x) (not_mem : x ‚àâ t) (ht : t.nonempty) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, x < u n) ‚àß tendsto u at_top (ùìù x) ‚àß ‚àÄ n, u n ‚àà t :=
  @IsLub.exists_seq_strict_mono_tendsto_of_not_mem (OrderDual Œ±) _ _ _ t x _ htx not_mem ht

theorem IsGlb.exists_seq_antitone_tendsto {t : Set Œ±} {x : Œ±} [is_countably_generated (ùìù x)] (htx : IsGlb t x)
  (ht : t.nonempty) : ‚àÉ u : ‚Ñï ‚Üí Œ±, Antitone u ‚àß (‚àÄ n, x ‚â§ u n) ‚àß tendsto u at_top (ùìù x) ‚àß ‚àÄ n, u n ‚àà t :=
  @IsLub.exists_seq_monotone_tendsto (OrderDual Œ±) _ _ _ t x _ htx ht

theorem exists_seq_strict_anti_tendsto' [DenselyOrdered Œ±] [first_countable_topology Œ±] {x y : Œ±} (hy : x < y) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, x < u n) ‚àß tendsto u at_top (ùìù x) :=
  @exists_seq_strict_mono_tendsto' (OrderDual Œ±) _ _ _ _ _ x y hy

theorem exists_seq_strict_anti_tendsto [DenselyOrdered Œ±] [NoTopOrder Œ±] [first_countable_topology Œ±] (x : Œ±) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, StrictAnti u ‚àß (‚àÄ n, x < u n) ‚àß tendsto u at_top (ùìù x) :=
  @exists_seq_strict_mono_tendsto (OrderDual Œ±) _ _ _ _ _ _ x

theorem exists_seq_tendsto_Inf {Œ± : Type _} [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±]
  [first_countable_topology Œ±] {S : Set Œ±} (hS : S.nonempty) (hS' : BddBelow S) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, Antitone u ‚àß tendsto u at_top (ùìù (Inf S)) ‚àß ‚àÄ n, u n ‚àà S :=
  @exists_seq_tendsto_Sup (OrderDual Œ±) _ _ _ _ S hS hS'

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- A compact set is bounded below -/
theorem is_compact.bdd_below
{Œ± : Type u}
[topological_space Œ±]
[linear_order Œ±]
[order_closed_topology Œ±]
[nonempty Œ±]
{s : set Œ±}
(hs : is_compact s) : bdd_below s :=
begin
  by_contra [ident H],
  rcases [expr hs.elim_finite_subcover_image (Œª
    (x)
    (_ : ¬´expr ‚àà ¬ª(x, s)), @is_open_Ioi _ _ _ _ x) _, "with", "‚ü®", ident t, ",", ident st, ",", ident ft, ",", ident ht, "‚ü©"],
  { refine [expr H ¬´expr $ ¬ª(ft.bdd_below.imp, Œª C hC y hy, _)],
    rcases [expr mem_bUnion_iff.1 (ht hy), "with", "‚ü®", ident x, ",", ident hx, ",", ident xy, "‚ü©"],
    exact [expr le_trans (hC hx) (le_of_lt xy)] },
  { refine [expr Œª x hx, mem_bUnion_iff.2 (not_imp_comm.1 _ H)],
    exact [expr Œª h, ‚ü®x, Œª y hy, le_of_not_lt ¬´expr $ ¬ª(h.imp, Œª ys, ‚ü®_, hy, ys‚ü©)‚ü©] }
end

/-- A compact set is bounded above -/
theorem IsCompact.bdd_above {Œ± : Type u} [TopologicalSpace Œ±] [LinearOrder‚Çì Œ±] [OrderClosedTopology Œ±] :
  ‚àÄ [Nonempty Œ±] {s : Set Œ±}, IsCompact s ‚Üí BddAbove s :=
  @IsCompact.bdd_below (OrderDual Œ±) _ _ _

end OrderTopology

section DenselyOrdered

variable[TopologicalSpace Œ±][LinearOrder‚Çì Œ±][OrderTopology Œ±][DenselyOrdered Œ±]{a b : Œ±}{s : Set Œ±}

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`, unless `a` is a top
element. -/
theorem closure_Ioi' {a b : Œ±} (hab : a < b) : Closure (Ioi a) = Ici a :=
  by 
    apply subset.antisymm
    ¬∑
      exact closure_minimal Ioi_subset_Ici_self is_closed_Ici
    ¬∑
      rw [‚Üêdiff_subset_closure_iff, Ici_diff_Ioi_same, singleton_subset_iff]
      exact is_glb_Ioi.mem_closure ‚ü®_, hab‚ü©

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`. -/
@[simp]
theorem closure_Ioi (a : Œ±) [NoTopOrder Œ±] : Closure (Ioi a) = Ici a :=
  let ‚ü®b, hb‚ü© := no_top a 
  closure_Ioi' hb

/-- The closure of the interval `(-‚àû, a)` is the closed interval `(-‚àû, a]`, unless `a` is a bottom
element. -/
theorem closure_Iio' {a b : Œ±} (hab : b < a) : Closure (Iio a) = Iic a :=
  @closure_Ioi' (OrderDual Œ±) _ _ _ _ _ _ hab

/-- The closure of the interval `(-‚àû, a)` is the interval `(-‚àû, a]`. -/
@[simp]
theorem closure_Iio (a : Œ±) [NoBotOrder Œ±] : Closure (Iio a) = Iic a :=
  let ‚ü®b, hb‚ü© := no_bot a 
  closure_Iio' hb

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ioo {a b : Œ±} (hab : ¬´expr < ¬ª(a, b)) : ¬´expr = ¬ª(closure (Ioo a b), Icc a b) :=
begin
  apply [expr subset.antisymm],
  { exact [expr closure_minimal Ioo_subset_Icc_self is_closed_Icc] },
  { rw ["[", "<-", expr diff_subset_closure_iff, ",", expr Icc_diff_Ioo_same hab.le, "]"] [],
    have [ident hab'] [":", expr (Ioo a b).nonempty] [],
    from [expr nonempty_Ioo.2 hab],
    simp [] [] ["only"] ["[", expr insert_subset, ",", expr singleton_subset_iff, "]"] [] [],
    exact [expr ‚ü®(is_glb_Ioo hab).mem_closure hab', (is_lub_Ioo hab).mem_closure hab'‚ü©] }
end

/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ioc {a b : Œ±} (hab : a < b) : Closure (Ioc a b) = Icc a b :=
  by 
    apply subset.antisymm
    ¬∑
      exact closure_minimal Ioc_subset_Icc_self is_closed_Icc
    ¬∑
      apply subset.trans _ (closure_mono Ioo_subset_Ioc_self)
      rw [closure_Ioo hab]

/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
@[simp]
theorem closure_Ico {a b : Œ±} (hab : a < b) : Closure (Ico a b) = Icc a b :=
  by 
    apply subset.antisymm
    ¬∑
      exact closure_minimal Ico_subset_Icc_self is_closed_Icc
    ¬∑
      apply subset.trans _ (closure_mono Ioo_subset_Ico_self)
      rw [closure_Ioo hab]

@[simp]
theorem interior_Ici [NoBotOrder Œ±] {a : Œ±} : Interior (Ici a) = Ioi a :=
  by 
    rw [‚Üêcompl_Iio, interior_compl, closure_Iio, compl_Iic]

@[simp]
theorem interior_Iic [NoTopOrder Œ±] {a : Œ±} : Interior (Iic a) = Iio a :=
  by 
    rw [‚Üêcompl_Ioi, interior_compl, closure_Ioi, compl_Ici]

@[simp]
theorem interior_Icc [NoBotOrder Œ±] [NoTopOrder Œ±] {a b : Œ±} : Interior (Icc a b) = Ioo a b :=
  by 
    rw [‚ÜêIci_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]

@[simp]
theorem interior_Ico [NoBotOrder Œ±] {a b : Œ±} : Interior (Ico a b) = Ioo a b :=
  by 
    rw [‚ÜêIci_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]

@[simp]
theorem interior_Ioc [NoTopOrder Œ±] {a b : Œ±} : Interior (Ioc a b) = Ioo a b :=
  by 
    rw [‚ÜêIoi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]

@[simp]
theorem frontier_Ici [NoBotOrder Œ±] {a : Œ±} : Frontier (Ici a) = {a} :=
  by 
    simp [Frontier]

@[simp]
theorem frontier_Iic [NoTopOrder Œ±] {a : Œ±} : Frontier (Iic a) = {a} :=
  by 
    simp [Frontier]

@[simp]
theorem frontier_Ioi [NoTopOrder Œ±] {a : Œ±} : Frontier (Ioi a) = {a} :=
  by 
    simp [Frontier]

@[simp]
theorem frontier_Iio [NoBotOrder Œ±] {a : Œ±} : Frontier (Iio a) = {a} :=
  by 
    simp [Frontier]

@[simp]
theorem frontier_Icc [NoBotOrder Œ±] [NoTopOrder Œ±] {a b : Œ±} (h : a < b) : Frontier (Icc a b) = {a, b} :=
  by 
    simp [Frontier, le_of_lt‚Çì h, Icc_diff_Ioo_same]

@[simp]
theorem frontier_Ioo {a b : Œ±} (h : a < b) : Frontier (Ioo a b) = {a, b} :=
  by 
    simp [Frontier, h, le_of_lt‚Çì h, Icc_diff_Ioo_same]

@[simp]
theorem frontier_Ico [NoBotOrder Œ±] {a b : Œ±} (h : a < b) : Frontier (Ico a b) = {a, b} :=
  by 
    simp [Frontier, h, le_of_lt‚Çì h, Icc_diff_Ioo_same]

@[simp]
theorem frontier_Ioc [NoTopOrder Œ±] {a b : Œ±} (h : a < b) : Frontier (Ioc a b) = {a, b} :=
  by 
    simp [Frontier, h, le_of_lt‚Çì h, Icc_diff_Ioo_same]

theorem nhds_within_Ioi_ne_bot' {a b c : Œ±} (H‚ÇÅ : a < c) (H‚ÇÇ : a ‚â§ b) : ne_bot (ùìù[Ioi a] b) :=
  mem_closure_iff_nhds_within_ne_bot.1$
    by 
      rw [closure_Ioi' H‚ÇÅ]
      exact H‚ÇÇ

theorem nhds_within_Ioi_ne_bot [NoTopOrder Œ±] {a b : Œ±} (H : a ‚â§ b) : ne_bot (ùìù[Ioi a] b) :=
  let ‚ü®c, hc‚ü© := no_top a 
  nhds_within_Ioi_ne_bot' hc H

theorem nhds_within_Ioi_self_ne_bot' {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ioi a] a) :=
  nhds_within_Ioi_ne_bot' H (le_refl‚Çì a)

@[instance]
theorem nhds_within_Ioi_self_ne_bot [NoTopOrder Œ±] (a : Œ±) : ne_bot (ùìù[Ioi a] a) :=
  nhds_within_Ioi_ne_bot (le_refl‚Çì a)

theorem Filter.Eventually.exists_gt [NoTopOrder Œ±] {a : Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂†x in ùìù a, p x) :
  ‚àÉ (b : _)(_ : b > a), p b :=
  by 
    simpa only [exists_prop, gt_iff_lt, and_comm] using
      ((h.filter_mono (@nhds_within_le_nhds _ _ a (Ioi a))).And self_mem_nhds_within).exists

theorem nhds_within_Iio_ne_bot' {a b c : Œ±} (H‚ÇÅ : a < c) (H‚ÇÇ : b ‚â§ c) : ne_bot (ùìù[Iio c] b) :=
  mem_closure_iff_nhds_within_ne_bot.1$
    by 
      rw [closure_Iio' H‚ÇÅ]
      exact H‚ÇÇ

theorem nhds_within_Iio_ne_bot [NoBotOrder Œ±] {a b : Œ±} (H : a ‚â§ b) : ne_bot (ùìù[Iio b] a) :=
  let ‚ü®c, hc‚ü© := no_bot b 
  nhds_within_Iio_ne_bot' hc H

theorem nhds_within_Iio_self_ne_bot' {a b : Œ±} (H : a < b) : ne_bot (ùìù[Iio b] b) :=
  nhds_within_Iio_ne_bot' H (le_refl‚Çì b)

@[instance]
theorem nhds_within_Iio_self_ne_bot [NoBotOrder Œ±] (a : Œ±) : ne_bot (ùìù[Iio a] a) :=
  nhds_within_Iio_ne_bot (le_refl‚Çì a)

theorem Filter.Eventually.exists_lt [NoBotOrder Œ±] {a : Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂†x in ùìù a, p x) :
  ‚àÉ (b : _)(_ : b < a), p b :=
  @Filter.Eventually.exists_gt (OrderDual Œ±) _ _ _ _ _ _ _ h

theorem right_nhds_within_Ico_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ico a b] b) :=
  (is_lub_Ico H).nhds_within_ne_bot (nonempty_Ico.2 H)

theorem left_nhds_within_Ioc_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ioc a b] a) :=
  (is_glb_Ioc H).nhds_within_ne_bot (nonempty_Ioc.2 H)

theorem left_nhds_within_Ioo_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ioo a b] a) :=
  (is_glb_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)

theorem right_nhds_within_Ioo_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ioo a b] b) :=
  (is_lub_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem comap_coe_nhds_within_Iio_of_Ioo_subset
(hb : ¬´expr ‚äÜ ¬ª(s, Iio b))
(hs : s.nonempty ‚Üí ¬´expr‚àÉ , ¬ª((a ¬´expr < ¬ª b), ¬´expr ‚äÜ ¬ª(Ioo a b, s))) : ¬´expr = ¬ª(comap (coe : s ‚Üí Œ±) ¬´exprùìù[ ] ¬ª(Iio b, b), at_top) :=
begin
  nontriviality [] [],
  haveI [] [":", expr nonempty s] [":=", expr nontrivial_iff_nonempty.1 ¬´expr‚Äπ ‚Ä∫¬ª(_)],
  rcases [expr hs (nonempty_subtype.1 ¬´expr‚Äπ ‚Ä∫¬ª(_)), "with", "‚ü®", ident a, ",", ident h, ",", ident hs, "‚ü©"],
  ext [] [ident u] [],
  split,
  { rintros ["‚ü®", ident t, ",", ident ht, ",", ident hts, "‚ü©"],
    obtain ["‚ü®", ident x, ",", "‚ü®", ident hxa, ":", expr ¬´expr ‚â§ ¬ª(a, x), ",", ident hxb, ":", expr ¬´expr < ¬ª(x, b), "‚ü©", ",", ident hxt, ":", expr ¬´expr ‚äÜ ¬ª(Ioo x b, t), "‚ü©", ":=", expr (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht],
    obtain ["‚ü®", ident y, ",", ident hxy, ",", ident hyb, "‚ü©", ":=", expr exists_between hxb],
    refine [expr mem_of_superset (mem_at_top ‚ü®y, hs ‚ü®hxa.trans_lt hxy, hyb‚ü©‚ü©) _],
    rintros ["‚ü®", ident z, ",", ident hzs, "‚ü©", "(", ident hyz, ":", expr ¬´expr ‚â§ ¬ª(y, z), ")"],
    refine [expr hts (hxt ‚ü®hxy.trans_le _, hb _‚ü©)]; assumption },
  { intros [ident hu],
    obtain ["‚ü®", ident x, ":", expr s, ",", ident hx, ":", expr ‚àÄ
     z, ¬´expr ‚â§ ¬ª(x, z) ‚Üí ¬´expr ‚àà ¬ª(z, u), "‚ü©", ":=", expr mem_at_top_sets.1 hu],
    exact [expr ‚ü®Ioo x b, Ioo_mem_nhds_within_Iio ¬´expr $ ¬ª(right_mem_Ioc.2, hb x.2), Œª z hz, hx _ hz.1.le‚ü©] }
end

theorem comap_coe_nhds_within_Ioi_of_Ioo_subset (ha : s ‚äÜ Ioi a) (hs : s.nonempty ‚Üí ‚àÉ (b : _)(_ : b > a), Ioo a b ‚äÜ s) :
  comap (coe‚Çì : s ‚Üí Œ±) (ùìù[Ioi a] a) = at_bot :=
  comap_coe_nhds_within_Iio_of_Ioo_subset (show of_dual ‚Åª¬π' s ‚äÜ Iio (to_dual a) from ha)
    fun h =>
      by 
        simpa only [OrderDual.exists, dual_Ioo] using hs h

theorem map_coe_at_top_of_Ioo_subset (hb : s ‚äÜ Iio b) (hs : ‚àÄ a' (_ : a' < b), ‚àÉ (a : _)(_ : a < b), Ioo a b ‚äÜ s) :
  map (coe‚Çì : s ‚Üí Œ±) at_top = ùìù[Iio b] b :=
  by 
    rcases eq_empty_or_nonempty (Iio b) with (hb' | ‚ü®a, ha‚ü©)
    ¬∑
      rw [filter_eq_bot_of_is_empty at_top, map_bot, hb', nhds_within_empty]
      exact ‚ü®fun x => hb'.subset (hb x.2)‚ü©
    ¬∑
      rw [‚Üêcomap_coe_nhds_within_Iio_of_Ioo_subset hb fun _ => hs a ha, map_comap_of_mem]
      rw [Subtype.range_coe]
      exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha)

theorem map_coe_at_bot_of_Ioo_subset (ha : s ‚äÜ Ioi a) (hs : ‚àÄ b' (_ : b' > a), ‚àÉ (b : _)(_ : b > a), Ioo a b ‚äÜ s) :
  map (coe‚Çì : s ‚Üí Œ±) at_bot = ùìù[Ioi a] a :=
  by 
    refine' (map_coe_at_top_of_Ioo_subset (show of_dual ‚Åª¬π' s ‚äÜ Iio (to_dual a) from ha) fun b' hb' => _ : _)
    simpa only [OrderDual.exists, dual_Ioo] using hs b' hb'

/-- The `at_top` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at
the right endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhds_within_Iio (a b : Œ±) : comap (coe‚Çì : Ioo a b ‚Üí Œ±) (ùìù[Iio b] b) = at_top :=
  comap_coe_nhds_within_Iio_of_Ioo_subset Ioo_subset_Iio_self$ fun h => ‚ü®a, nonempty_Ioo.1 h, subset.refl _‚ü©

/-- The `at_bot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at
the left endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhds_within_Ioi (a b : Œ±) : comap (coe‚Çì : Ioo a b ‚Üí Œ±) (ùìù[Ioi a] a) = at_bot :=
  comap_coe_nhds_within_Ioi_of_Ioo_subset Ioo_subset_Ioi_self$ fun h => ‚ü®b, nonempty_Ioo.1 h, subset.refl _‚ü©

theorem comap_coe_Ioi_nhds_within_Ioi (a : Œ±) : comap (coe‚Çì : Ioi a ‚Üí Œ±) (ùìù[Ioi a] a) = at_bot :=
  comap_coe_nhds_within_Ioi_of_Ioo_subset (subset.refl _)$ fun ‚ü®x, hx‚ü© => ‚ü®x, hx, Ioo_subset_Ioi_self‚ü©

theorem comap_coe_Iio_nhds_within_Iio (a : Œ±) : comap (coe‚Çì : Iio a ‚Üí Œ±) (ùìù[Iio a] a) = at_top :=
  @comap_coe_Ioi_nhds_within_Ioi (OrderDual Œ±) _ _ _ _ a

@[simp]
theorem map_coe_Ioo_at_top {a b : Œ±} (h : a < b) : map (coe‚Çì : Ioo a b ‚Üí Œ±) at_top = ùìù[Iio b] b :=
  map_coe_at_top_of_Ioo_subset Ioo_subset_Iio_self$ fun _ _ => ‚ü®_, h, subset.refl _‚ü©

@[simp]
theorem map_coe_Ioo_at_bot {a b : Œ±} (h : a < b) : map (coe‚Çì : Ioo a b ‚Üí Œ±) at_bot = ùìù[Ioi a] a :=
  map_coe_at_bot_of_Ioo_subset Ioo_subset_Ioi_self$ fun _ _ => ‚ü®_, h, subset.refl _‚ü©

@[simp]
theorem map_coe_Ioi_at_bot (a : Œ±) : map (coe‚Çì : Ioi a ‚Üí Œ±) at_bot = ùìù[Ioi a] a :=
  map_coe_at_bot_of_Ioo_subset (subset.refl _)$ fun b hb => ‚ü®b, hb, Ioo_subset_Ioi_self‚ü©

@[simp]
theorem map_coe_Iio_at_top (a : Œ±) : map (coe‚Çì : Iio a ‚Üí Œ±) at_top = ùìù[Iio a] a :=
  @map_coe_Ioi_at_bot (OrderDual Œ±) _ _ _ _ _

variable{l : Filter Œ≤}{f : Œ± ‚Üí Œ≤}

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp]
theorem tendsto_comp_coe_Ioo_at_top
(h : ¬´expr < ¬ª(a, b)) : ¬´expr ‚Üî ¬ª(tendsto (Œª x : Ioo a b, f x) at_top l, tendsto f ¬´exprùìù[ ] ¬ª(Iio b, b) l) :=
by rw ["[", "<-", expr map_coe_Ioo_at_top h, ",", expr tendsto_map'_iff, "]"] []

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp]
theorem tendsto_comp_coe_Ioo_at_bot
(h : ¬´expr < ¬ª(a, b)) : ¬´expr ‚Üî ¬ª(tendsto (Œª x : Ioo a b, f x) at_bot l, tendsto f ¬´exprùìù[ ] ¬ª(Ioi a, a) l) :=
by rw ["[", "<-", expr map_coe_Ioo_at_bot h, ",", expr tendsto_map'_iff, "]"] []

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp]
theorem tendsto_comp_coe_Ioi_at_bot : ¬´expr ‚Üî ¬ª(tendsto (Œª
  x : Ioi a, f x) at_bot l, tendsto f ¬´exprùìù[ ] ¬ª(Ioi a, a) l) :=
by rw ["[", "<-", expr map_coe_Ioi_at_bot, ",", expr tendsto_map'_iff, "]"] []

-- error in Topology.Algebra.Ordered.Basic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp]
theorem tendsto_comp_coe_Iio_at_top : ¬´expr ‚Üî ¬ª(tendsto (Œª
  x : Iio a, f x) at_top l, tendsto f ¬´exprùìù[ ] ¬ª(Iio a, a) l) :=
by rw ["[", "<-", expr map_coe_Iio_at_top, ",", expr tendsto_map'_iff, "]"] []

@[simp]
theorem tendsto_Ioo_at_top {f : Œ≤ ‚Üí Ioo a b} : tendsto f l at_top ‚Üî tendsto (fun x => (f x : Œ±)) l (ùìù[Iio b] b) :=
  by 
    rw [‚Üêcomap_coe_Ioo_nhds_within_Iio, tendsto_comap_iff]

@[simp]
theorem tendsto_Ioo_at_bot {f : Œ≤ ‚Üí Ioo a b} : tendsto f l at_bot ‚Üî tendsto (fun x => (f x : Œ±)) l (ùìù[Ioi a] a) :=
  by 
    rw [‚Üêcomap_coe_Ioo_nhds_within_Ioi, tendsto_comap_iff]

@[simp]
theorem tendsto_Ioi_at_bot {f : Œ≤ ‚Üí Ioi a} : tendsto f l at_bot ‚Üî tendsto (fun x => (f x : Œ±)) l (ùìù[Ioi a] a) :=
  by 
    rw [‚Üêcomap_coe_Ioi_nhds_within_Ioi, tendsto_comap_iff]

@[simp]
theorem tendsto_Iio_at_top {f : Œ≤ ‚Üí Iio a} : tendsto f l at_top ‚Üî tendsto (fun x => (f x : Œ±)) l (ùìù[Iio a] a) :=
  by 
    rw [‚Üêcomap_coe_Iio_nhds_within_Iio, tendsto_comap_iff]

theorem dense_iff_forall_lt_exists_mem [Nontrivial Œ±] {s : Set Œ±} :
  Dense s ‚Üî ‚àÄ a b, a < b ‚Üí ‚àÉ (c : _)(_ : c ‚àà s), a < c ‚àß c < b :=
  by 
    split 
    ¬∑
      intro h a b hab 
      obtain ‚ü®c, ‚ü®hc, cs‚ü©‚ü© : (Ioo a b ‚à© s).Nonempty :=
        dense_iff_inter_open.1 h (Ioo a b) is_open_Ioo (nonempty_Ioo.2 hab)
      exact ‚ü®c, cs, hc‚ü©
    ¬∑
      intro h 
      apply dense_iff_inter_open.2 fun U U_open U_nonempty => _ 
      obtain ‚ü®a, b, hab, H‚ü© : ‚àÉ a b : Œ±, a < b ‚àß Ioo a b ‚äÜ U := U_open.exists_Ioo_subset U_nonempty 
      obtain ‚ü®x, xs, hx‚ü© : ‚àÉ (x : Œ±)(H : x ‚àà s), a < x ‚àß x < b := h a b hab 
      exact ‚ü®x, ‚ü®H hx, xs‚ü©‚ü©

instance  (x : Œ±) [Nontrivial Œ±] : ne_bot (ùìù[¬´expr ·∂ú¬ª {x}] x) :=
  by 
    apply forall_mem_nonempty_iff_ne_bot.1 fun s hs => _ 
    obtain ‚ü®u, u_open, xu, us‚ü© : ‚àÉ u : Set Œ±, IsOpen u ‚àß x ‚àà u ‚àß u ‚à© ¬´expr ·∂ú¬ª {x} ‚äÜ s := mem_nhds_within.1 hs 
    obtain ‚ü®a, b, a_lt_b, hab‚ü© : ‚àÉ a b : Œ±, a < b ‚àß Ioo a b ‚äÜ u := u_open.exists_Ioo_subset ‚ü®x, xu‚ü©
    obtain ‚ü®y, hy‚ü© : ‚àÉ y, a < y ‚àß y < b := exists_between a_lt_b 
    rcases ne_or_eq x y with (xy | rfl)
    ¬∑
      exact ‚ü®y, us ‚ü®hab hy, xy.symm‚ü©‚ü©
    obtain ‚ü®z, hz‚ü© : ‚àÉ z, a < z ‚àß z < x := exists_between hy.1 
    exact ‚ü®z, us ‚ü®hab ‚ü®hz.1, hz.2.trans hy.2‚ü©, hz.2.Ne‚ü©‚ü©

/-- Let `s` be a dense set in a nontrivial dense linear order `Œ±`. If `s` is a
separable space (e.g., if `Œ±` has a second countable topology), then there exists a countable
dense subset `t ‚äÜ s` such that `t` does not contain bottom/top elements of `Œ±`. -/
theorem Dense.exists_countable_dense_subset_no_bot_top [Nontrivial Œ±] {s : Set Œ±} [separable_space s] (hs : Dense s) :
  ‚àÉ (t : _)(_ : t ‚äÜ s), countable t ‚àß Dense t ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àâ t) ‚àß ‚àÄ x, IsTop x ‚Üí x ‚àâ t :=
  by 
    rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
    refine' ‚ü®t \ ({ x | IsBot x } ‚à™ { x | IsTop x }), _, _, _, _, _‚ü©
    ¬∑
      exact (diff_subset _ _).trans hts
    ¬∑
      exact htc.mono (diff_subset _ _)
    ¬∑
      exact htd.diff_finite ((subsingleton_is_bot Œ±).Finite.union (subsingleton_is_top Œ±).Finite)
    ¬∑
      intro x hx 
      simp [hx]
    ¬∑
      intro x hx 
      simp [hx]

variable(Œ±)

/-- If `Œ±` is a nontrivial separable dense linear order, then there exists a
countable dense set `s : set Œ±` that contains neither top nor bottom elements of `Œ±`.
For a dense set containing both bot and top elements, see
`exists_countable_dense_bot_top`. -/
theorem exists_countable_dense_no_bot_top [separable_space Œ±] [Nontrivial Œ±] :
  ‚àÉ s : Set Œ±, countable s ‚àß Dense s ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àâ s) ‚àß ‚àÄ x, IsTop x ‚Üí x ‚àâ s :=
  by 
    simpa using dense_univ.exists_countable_dense_subset_no_bot_top

end DenselyOrdered

section CompleteLinearOrder

variable[CompleteLinearOrder
      Œ±][TopologicalSpace Œ±][OrderTopology Œ±][CompleteLinearOrder Œ≤][TopologicalSpace Œ≤][OrderTopology Œ≤][Nonempty Œ≥]

theorem Sup_mem_closure {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±] [OrderTopology Œ±] {s : Set Œ±}
  (hs : s.nonempty) : Sup s ‚àà Closure s :=
  (is_lub_Sup s).mem_closure hs

theorem Inf_mem_closure {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±] [OrderTopology Œ±] {s : Set Œ±}
  (hs : s.nonempty) : Inf s ‚àà Closure s :=
  (is_glb_Inf s).mem_closure hs

theorem IsClosed.Sup_mem {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±] [OrderTopology Œ±] {s : Set Œ±}
  (hs : s.nonempty) (hc : IsClosed s) : Sup s ‚àà s :=
  (is_lub_Sup s).mem_of_is_closed hs hc

theorem IsClosed.Inf_mem {Œ± : Type u} [TopologicalSpace Œ±] [CompleteLinearOrder Œ±] [OrderTopology Œ±] {s : Set Œ±}
  (hs : s.nonempty) (hc : IsClosed s) : Inf s ‚àà s :=
  (is_glb_Inf s).mem_of_is_closed hs hc

/-- A monotone function continuous at the supremum of a nonempty set sends this supremum to
the supremum of the image of this set. -/
theorem map_Sup_of_continuous_at_of_monotone' {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (Sup s)) (Mf : Monotone f)
  (hs : s.nonempty) : f (Sup s) = Sup (f '' s) :=
  ((is_lub_Sup _).is_lub_of_tendsto (fun x hx y hy xy => Mf xy) hs$ Cf.mono_left inf_le_left).Sup_eq.symm

/-- A monotone function `s` sending `bot` to `bot` and continuous at the supremum of a set sends
this supremum to the supremum of the image of this set. -/
theorem map_Sup_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (Sup s)) (Mf : Monotone f)
  (fbot : f ‚ä• = ‚ä•) : f (Sup s) = Sup (f '' s) :=
  by 
    cases' s.eq_empty_or_nonempty with h h
    ¬∑
      simp [h, fbot]
    ¬∑
      exact map_Sup_of_continuous_at_of_monotone' Cf Mf h

/-- A monotone function continuous at the indexed supremum over a nonempty `Sort` sends this indexed
supremum to the indexed supremum of the composition. -/
theorem map_supr_of_continuous_at_of_monotone' {Œπ : Sort _} [Nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : ContinuousAt f (supr g)) (Mf : Monotone f) : f (‚®Üi, g i) = ‚®Üi, f (g i) :=
  by 
    rw [supr, map_Sup_of_continuous_at_of_monotone' Cf Mf (range_nonempty g), ‚Üêrange_comp, supr]

/-- If a monotone function sending `bot` to `bot` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
theorem map_supr_of_continuous_at_of_monotone {Œπ : Sort _} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±} (Cf : ContinuousAt f (supr g))
  (Mf : Monotone f) (fbot : f ‚ä• = ‚ä•) : f (‚®Üi, g i) = ‚®Üi, f (g i) :=
  by 
    rw [supr, map_Sup_of_continuous_at_of_monotone Cf Mf fbot, ‚Üêrange_comp, supr]

/-- A monotone function continuous at the infimum of a nonempty set sends this infimum to
the infimum of the image of this set. -/
theorem map_Inf_of_continuous_at_of_monotone' {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (Inf s)) (Mf : Monotone f)
  (hs : s.nonempty) : f (Inf s) = Inf (f '' s) :=
  @map_Sup_of_continuous_at_of_monotone' (OrderDual Œ±) (OrderDual Œ≤) _ _ _ _ _ _ f s Cf Mf.dual hs

/-- A monotone function `s` sending `top` to `top` and continuous at the infimum of a set sends
this infimum to the infimum of the image of this set. -/
theorem map_Inf_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (Inf s)) (Mf : Monotone f)
  (ftop : f ‚ä§ = ‚ä§) : f (Inf s) = Inf (f '' s) :=
  @map_Sup_of_continuous_at_of_monotone (OrderDual Œ±) (OrderDual Œ≤) _ _ _ _ _ _ f s Cf Mf.dual ftop

/-- A monotone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed infimum of the composition. -/
theorem map_infi_of_continuous_at_of_monotone' {Œπ : Sort _} [Nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : ContinuousAt f (infi g)) (Mf : Monotone f) : f (‚®Öi, g i) = ‚®Öi, f (g i) :=
  @map_supr_of_continuous_at_of_monotone' (OrderDual Œ±) (OrderDual Œ≤) _ _ _ _ _ _ Œπ _ f g Cf Mf.dual

/-- If a monotone function sending `top` to `top` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed infimum of the composition. -/
theorem map_infi_of_continuous_at_of_monotone {Œπ : Sort _} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±} (Cf : ContinuousAt f (infi g))
  (Mf : Monotone f) (ftop : f ‚ä§ = ‚ä§) : f (infi g) = infi (f ‚àò g) :=
  @map_supr_of_continuous_at_of_monotone (OrderDual Œ±) (OrderDual Œ≤) _ _ _ _ _ _ Œπ f g Cf Mf.dual ftop

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable[ConditionallyCompleteLinearOrder
      Œ±][TopologicalSpace
      Œ±][OrderTopology Œ±][ConditionallyCompleteLinearOrder Œ≤][TopologicalSpace Œ≤][OrderTopology Œ≤][Nonempty Œ≥]

theorem cSup_mem_closure {s : Set Œ±} (hs : s.nonempty) (B : BddAbove s) : Sup s ‚àà Closure s :=
  (is_lub_cSup hs B).mem_closure hs

theorem cInf_mem_closure {s : Set Œ±} (hs : s.nonempty) (B : BddBelow s) : Inf s ‚àà Closure s :=
  (is_glb_cInf hs B).mem_closure hs

theorem IsClosed.cSup_mem {s : Set Œ±} (hc : IsClosed s) (hs : s.nonempty) (B : BddAbove s) : Sup s ‚àà s :=
  (is_lub_cSup hs B).mem_of_is_closed hs hc

theorem IsClosed.cInf_mem {s : Set Œ±} (hc : IsClosed s) (hs : s.nonempty) (B : BddBelow s) : Inf s ‚àà s :=
  (is_glb_cInf hs B).mem_of_is_closed hs hc

/-- If a monotone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the supremum of the image of `s`. -/
theorem map_cSup_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (Sup s)) (Mf : Monotone f)
  (ne : s.nonempty) (H : BddAbove s) : f (Sup s) = Sup (f '' s) :=
  by 
    refine' ((is_lub_cSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm 
    refine' (is_lub_cSup Ne H).is_lub_of_tendsto (fun x hx y hy xy => Mf xy) Ne _ 
    exact Cf.mono_left inf_le_left

/-- If a monotone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the supremum of the composition. -/
theorem map_csupr_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : ContinuousAt f (‚®Üi, g i)) (Mf : Monotone f)
  (H : BddAbove (range g)) : f (‚®Üi, g i) = ‚®Üi, f (g i) :=
  by 
    rw [supr, map_cSup_of_continuous_at_of_monotone Cf Mf (range_nonempty _) H, ‚Üêrange_comp, supr]

/-- If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the infimum of the image of `s`. -/
theorem map_cInf_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (Inf s)) (Mf : Monotone f)
  (ne : s.nonempty) (H : BddBelow s) : f (Inf s) = Inf (f '' s) :=
  @map_cSup_of_continuous_at_of_monotone (OrderDual Œ±) (OrderDual Œ≤) _ _ _ _ _ _ f s Cf Mf.dual Ne H

/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally
complete linear order, under a boundedness assumption. -/
theorem map_cinfi_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±} (Cf : ContinuousAt f (‚®Öi, g i)) (Mf : Monotone f)
  (H : BddBelow (range g)) : f (‚®Öi, g i) = ‚®Öi, f (g i) :=
  @map_csupr_of_continuous_at_of_monotone (OrderDual Œ±) (OrderDual Œ≤) _ _ _ _ _ _ _ _ _ _ Cf Mf.dual H

/-- A monotone map has a limit to the left of any point `x`, equal to `Sup (f '' (Iio x))`. -/
theorem Monotone.tendsto_nhds_within_Iio {Œ± : Type _} [LinearOrder‚Çì Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±]
  {f : Œ± ‚Üí Œ≤} (Mf : Monotone f) (x : Œ±) : tendsto f (ùìù[Iio x] x) (ùìù (Sup (f '' Iio x))) :=
  by 
    rcases eq_empty_or_nonempty (Iio x) with (h | h)
    ¬∑
      simp [h]
    refine' tendsto_order.2 ‚ü®fun l hl => _, fun m hm => _‚ü©
    ¬∑
      obtain ‚ü®z, zx, lz‚ü© : ‚àÉ a : Œ±, a < x ‚àß l < f a
      ¬∑
        simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using
          exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl 
      exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' zx).2 ‚ü®z, zx, fun y hy => lz.trans_le (Mf hy.1.le)‚ü©
    ¬∑
      filterUpwards [self_mem_nhds_within]
      intro y hy 
      apply lt_of_le_of_lt‚Çì _ hm 
      exact le_cSup (Mf.map_bdd_above bdd_above_Iio) (mem_image_of_mem _ hy)

/-- A monotone map has a limit to the right of any point `x`, equal to `Inf (f '' (Ioi x))`. -/
theorem Monotone.tendsto_nhds_within_Ioi {Œ± : Type _} [LinearOrder‚Çì Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±]
  {f : Œ± ‚Üí Œ≤} (Mf : Monotone f) (x : Œ±) : tendsto f (ùìù[Ioi x] x) (ùìù (Inf (f '' Ioi x))) :=
  @Monotone.tendsto_nhds_within_Iio (OrderDual Œ≤) _ _ _ (OrderDual Œ±) _ _ _ f Mf.dual x

end ConditionallyCompleteLinearOrder

end OrderTopology

