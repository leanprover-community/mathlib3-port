import Mathbin.Order.Filter.Pointwise 
import Mathbin.GroupTheory.QuotientGroup 
import Mathbin.Topology.Algebra.Monoid 
import Mathbin.Topology.Homeomorph 
import Mathbin.Topology.Compacts

/-!
# Theory of topological groups

This file defines the following typeclasses:

* `topological_group`, `topological_add_group`: multiplicative and additive topological groups,
  i.e., groups with continuous `(*)` and `(‚Åª¬π)` / `(+)` and `(-)`;

* `has_continuous_sub G` means that `G` has a continuous subtraction operation.

There is an instance deducing `has_continuous_sub` from `topological_group` but we use a separate
typeclass because, e.g., `‚Ñï` and `‚Ñù‚â•0` have continuous subtraction but are not additive groups.

We also define `homeomorph` versions of several `equiv`s: `homeomorph.mul_left`,
`homeomorph.mul_right`, `homeomorph.inv`, and prove a few facts about neighbourhood filters in
groups.

## Tags

topological space, group, topological group
-/


open Classical Set Filter TopologicalSpace Function

open_locale Classical TopologicalSpace Filter Pointwise

universe u v w x

variable{Œ± : Type u}{Œ≤ : Type v}{G : Type w}{H : Type x}

section ContinuousMulGroup

/-!
### Groups with continuous multiplication

In this section we prove a few statements about groups with continuous `(*)`.
-/


variable[TopologicalSpace G][Group‚Çì G][HasContinuousMul G]

/-- Multiplication from the left in a topological group as a homeomorphism. -/
@[toAdditive "Addition from the left in a topological additive group as a homeomorphism."]
protected def Homeomorph.mulLeft (a : G) : G ‚âÉ‚Çú G :=
  { Equiv.mulLeft a with continuous_to_fun := continuous_const.mul continuous_id,
    continuous_inv_fun := continuous_const.mul continuous_id }

@[simp, toAdditive]
theorem Homeomorph.coe_mul_left (a : G) : ¬´expr‚áë ¬ª (Homeomorph.mulLeft a) = (¬∑*¬∑) a :=
  rfl

@[toAdditive]
theorem Homeomorph.mul_left_symm (a : G) : (Homeomorph.mulLeft a).symm = Homeomorph.mulLeft (a‚Åª¬π) :=
  by 
    ext 
    rfl

@[toAdditive]
theorem is_open_map_mul_left (a : G) : IsOpenMap fun x => a*x :=
  (Homeomorph.mulLeft a).IsOpenMap

@[toAdditive]
theorem is_closed_map_mul_left (a : G) : IsClosedMap fun x => a*x :=
  (Homeomorph.mulLeft a).IsClosedMap

/-- Multiplication from the right in a topological group as a homeomorphism. -/
@[toAdditive "Addition from the right in a topological additive group as a homeomorphism."]
protected def Homeomorph.mulRight (a : G) : G ‚âÉ‚Çú G :=
  { Equiv.mulRight a with continuous_to_fun := continuous_id.mul continuous_const,
    continuous_inv_fun := continuous_id.mul continuous_const }

@[toAdditive]
theorem is_open_map_mul_right (a : G) : IsOpenMap fun x => x*a :=
  (Homeomorph.mulRight a).IsOpenMap

@[toAdditive]
theorem is_closed_map_mul_right (a : G) : IsClosedMap fun x => x*a :=
  (Homeomorph.mulRight a).IsClosedMap

@[toAdditive]
theorem is_open_map_div_right (a : G) : IsOpenMap fun x => x / a :=
  by 
    simpa only [div_eq_mul_inv] using is_open_map_mul_right (a‚Åª¬π)

@[toAdditive]
theorem is_closed_map_div_right (a : G) : IsClosedMap fun x => x / a :=
  by 
    simpa only [div_eq_mul_inv] using is_closed_map_mul_right (a‚Åª¬π)

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[]] theorem discrete_topology_of_open_singleton_one (h : is_open ({1} : set G)) : discrete_topology G :=
begin
  rw ["<-", expr singletons_open_iff_discrete] [],
  intro [ident g],
  suffices [] [":", expr ¬´expr = ¬ª({g}, ¬´expr ‚Åª¬π' ¬ª(Œª x : G, ¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(g), x), {1}))],
  { rw [expr this] [],
    exact [expr (continuous_mul_left ¬´expr ‚Åª¬π¬ª(g)).is_open_preimage _ h] },
  simp [] [] ["only"] ["[", expr mul_one, ",", expr set.preimage_mul_left_singleton, ",", expr eq_self_iff_true, ",", expr inv_inv, ",", expr set.singleton_eq_singleton_iff, "]"] [] []
end

@[toAdditive]
theorem discrete_topology_iff_open_singleton_one : DiscreteTopology G ‚Üî IsOpen ({1} : Set G) :=
  ‚ü®fun h => forall_open_iff_discrete.mpr h {1}, discrete_topology_of_open_singleton_one‚ü©

end ContinuousMulGroup

section TopologicalGroup

/-!
### Topological groups

A topological group is a group in which the multiplication and inversion operations are
continuous. Topological additive groups are defined in the same way. Equivalently, we can require
that the division operation `Œª x y, x * y‚Åª¬π` (resp., subtraction) is continuous.
-/


-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- A topological (additive) group is a group in which the addition and negation operations are
continuous. -/
class topological_add_group
(G : Type u)
[topological_space G]
[add_group G]extends has_continuous_add G : exprProp() := (continuous_neg : continuous (Œª a : G, ¬´expr- ¬ª(a)))

/-- A topological group is a group in which the multiplication and inversion operations are
continuous. -/
@[toAdditive]
class TopologicalGroup(G : Type _)[TopologicalSpace G][Group‚Çì G] extends HasContinuousMul G : Prop where 
  continuous_inv : Continuous (HasInv.inv : G ‚Üí G)

variable[TopologicalSpace G][Group‚Çì G][TopologicalGroup G]

export TopologicalGroup(continuous_inv)

export TopologicalAddGroup(continuous_neg)

@[toAdditive]
theorem continuous_on_inv {s : Set G} : ContinuousOn HasInv.inv s :=
  continuous_inv.ContinuousOn

@[toAdditive]
theorem continuous_within_at_inv {s : Set G} {x : G} : ContinuousWithinAt HasInv.inv s x :=
  continuous_inv.ContinuousWithinAt

@[toAdditive]
theorem continuous_at_inv {x : G} : ContinuousAt HasInv.inv x :=
  continuous_inv.ContinuousAt

@[toAdditive]
theorem tendsto_inv (a : G) : tendsto HasInv.inv (ùìù a) (ùìù (a‚Åª¬π)) :=
  continuous_at_inv

/-- If a function converges to a value in a multiplicative topological group, then its inverse
converges to the inverse of this value. For the version in normed fields assuming additionally
that the limit is nonzero, use `tendsto.inv'`. -/
@[toAdditive]
theorem Filter.Tendsto.inv {f : Œ± ‚Üí G} {l : Filter Œ±} {y : G} (h : tendsto f l (ùìù y)) :
  tendsto (fun x => f x‚Åª¬π) l (ùìù (y‚Åª¬π)) :=
  (continuous_inv.Tendsto y).comp h

variable[TopologicalSpace Œ±]{f : Œ± ‚Üí G}{s : Set Œ±}{x : Œ±}

@[continuity, toAdditive]
theorem Continuous.inv (hf : Continuous f) : Continuous fun x => f x‚Åª¬π :=
  continuous_inv.comp hf

@[toAdditive]
theorem ContinuousAt.inv (hf : ContinuousAt f x) : ContinuousAt (fun x => f x‚Åª¬π) x :=
  continuous_at_inv.comp hf

@[toAdditive]
theorem ContinuousOn.inv (hf : ContinuousOn f s) : ContinuousOn (fun x => f x‚Åª¬π) s :=
  continuous_inv.comp_continuous_on hf

@[toAdditive]
theorem ContinuousWithinAt.inv (hf : ContinuousWithinAt f s x) : ContinuousWithinAt (fun x => f x‚Åª¬π) s x :=
  hf.inv

section OrderedCommGroup

variable[TopologicalSpace H][OrderedCommGroup H][TopologicalGroup H]

@[toAdditive]
theorem tendsto_inv_nhds_within_Ioi {a : H} : tendsto HasInv.inv (ùìù[Ioi a] a) (ùìù[Iio (a‚Åª¬π)] a‚Åª¬π) :=
  (continuous_inv.Tendsto a).inf$
    by 
      simp [tendsto_principal_principal]

@[toAdditive]
theorem tendsto_inv_nhds_within_Iio {a : H} : tendsto HasInv.inv (ùìù[Iio a] a) (ùìù[Ioi (a‚Åª¬π)] a‚Åª¬π) :=
  (continuous_inv.Tendsto a).inf$
    by 
      simp [tendsto_principal_principal]

@[toAdditive]
theorem tendsto_inv_nhds_within_Ioi_inv {a : H} : tendsto HasInv.inv (ùìù[Ioi (a‚Åª¬π)] a‚Åª¬π) (ùìù[Iio a] a) :=
  by 
    simpa only [inv_inv‚Çì] using @tendsto_inv_nhds_within_Ioi _ _ _ _ (a‚Åª¬π)

@[toAdditive]
theorem tendsto_inv_nhds_within_Iio_inv {a : H} : tendsto HasInv.inv (ùìù[Iio (a‚Åª¬π)] a‚Åª¬π) (ùìù[Ioi a] a) :=
  by 
    simpa only [inv_inv‚Çì] using @tendsto_inv_nhds_within_Iio _ _ _ _ (a‚Åª¬π)

@[toAdditive]
theorem tendsto_inv_nhds_within_Ici {a : H} : tendsto HasInv.inv (ùìù[Ici a] a) (ùìù[Iic (a‚Åª¬π)] a‚Åª¬π) :=
  (continuous_inv.Tendsto a).inf$
    by 
      simp [tendsto_principal_principal]

@[toAdditive]
theorem tendsto_inv_nhds_within_Iic {a : H} : tendsto HasInv.inv (ùìù[Iic a] a) (ùìù[Ici (a‚Åª¬π)] a‚Åª¬π) :=
  (continuous_inv.Tendsto a).inf$
    by 
      simp [tendsto_principal_principal]

@[toAdditive]
theorem tendsto_inv_nhds_within_Ici_inv {a : H} : tendsto HasInv.inv (ùìù[Ici (a‚Åª¬π)] a‚Åª¬π) (ùìù[Iic a] a) :=
  by 
    simpa only [inv_inv‚Çì] using @tendsto_inv_nhds_within_Ici _ _ _ _ (a‚Åª¬π)

@[toAdditive]
theorem tendsto_inv_nhds_within_Iic_inv {a : H} : tendsto HasInv.inv (ùìù[Iic (a‚Åª¬π)] a‚Åª¬π) (ùìù[Ici a] a) :=
  by 
    simpa only [inv_inv‚Çì] using @tendsto_inv_nhds_within_Iic _ _ _ _ (a‚Åª¬π)

end OrderedCommGroup

@[instance, toAdditive]
instance  [TopologicalSpace H] [Group‚Çì H] [TopologicalGroup H] : TopologicalGroup (G √ó H) :=
  { continuous_inv := continuous_inv.prod_map continuous_inv }

@[toAdditive]
instance Pi.topological_group {C : Œ≤ ‚Üí Type _} [‚àÄ b, TopologicalSpace (C b)] [‚àÄ b, Group‚Çì (C b)]
  [‚àÄ b, TopologicalGroup (C b)] : TopologicalGroup (‚àÄ b, C b) :=
  { continuous_inv := continuous_pi fun i => (continuous_apply i).inv }

variable(G)

/-- Inversion in a topological group as a homeomorphism. -/
@[toAdditive "Negation in a topological group as a homeomorphism."]
protected def Homeomorph.inv : G ‚âÉ‚Çú G :=
  { Equiv.inv G with continuous_to_fun := continuous_inv, continuous_inv_fun := continuous_inv }

@[toAdditive]
theorem nhds_one_symm : comap HasInv.inv (ùìù (1 : G)) = ùìù (1 : G) :=
  ((Homeomorph.inv G).comap_nhds_eq _).trans (congr_arg‚Çì nhds one_inv)

/-- The map `(x, y) ‚Ü¶ (x, xy)` as a homeomorphism. This is a shear mapping. -/
@[toAdditive "The map `(x, y) ‚Ü¶ (x, x + y)` as a homeomorphism.\nThis is a shear mapping."]
protected def Homeomorph.shearMulRight : G √ó G ‚âÉ‚Çú G √ó G :=
  { Equiv.prodShear (Equiv.refl _) Equiv.mulLeft with continuous_to_fun := continuous_fst.prod_mk continuous_mul,
    continuous_inv_fun := continuous_fst.prod_mk$ continuous_fst.inv.mul continuous_snd }

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp, to_additive #[]]
theorem homeomorph.shear_mul_right_coe : ¬´expr = ¬ª(¬´expr‚áë ¬ª(homeomorph.shear_mul_right G), Œª
 z : ¬´expr √ó ¬ª(G, G), (z.1, ¬´expr * ¬ª(z.1, z.2))) :=
rfl

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp, to_additive #[]]
theorem homeomorph.shear_mul_right_symm_coe : ¬´expr = ¬ª(¬´expr‚áë ¬ª((homeomorph.shear_mul_right G).symm), Œª
 z : ¬´expr √ó ¬ª(G, G), (z.1, ¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(z.1), z.2))) :=
rfl

variable{G}

@[toAdditive]
theorem inv_closure (s : Set G) : Closure s‚Åª¬π = Closure (s‚Åª¬π) :=
  (Homeomorph.inv G).preimage_closure s

/-- The (topological-space) closure of a subgroup of a space `M` with `has_continuous_mul` is
itself a subgroup. -/
@[toAdditive
      "The (topological-space) closure of an additive subgroup of a space `M` with\n`has_continuous_add` is itself an additive subgroup."]
def Subgroup.topologicalClosure (s : Subgroup G) : Subgroup G :=
  { s.to_submonoid.topological_closure with Carrier := Closure (s : Set G),
    inv_mem' :=
      fun g m =>
        by 
          simpa [‚Üêmem_inv, inv_closure] using m }

@[simp, toAdditive]
theorem Subgroup.topological_closure_coe {s : Subgroup G} : (s.topological_closure : Set G) = Closure s :=
  rfl

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[]]
instance subgroup.topological_closure_topological_group (s : subgroup G) : topological_group s.topological_closure :=
{ continuous_inv := begin
    apply [expr continuous_induced_rng],
    change [expr continuous (Œª p : s.topological_closure, ¬´expr ‚Åª¬π¬ª((p : G)))] [] [],
    continuity [] []
  end,
  ..s.to_submonoid.topological_closure_has_continuous_mul }

@[toAdditive]
theorem Subgroup.subgroup_topological_closure (s : Subgroup G) : s ‚â§ s.topological_closure :=
  subset_closure

@[toAdditive]
theorem Subgroup.is_closed_topological_closure (s : Subgroup G) : IsClosed (s.topological_closure : Set G) :=
  by 
    convert is_closed_closure

@[toAdditive]
theorem Subgroup.topological_closure_minimal (s : Subgroup G) {t : Subgroup G} (h : s ‚â§ t) (ht : IsClosed (t : Set G)) :
  s.topological_closure ‚â§ t :=
  closure_minimal h ht

@[toAdditive]
theorem DenseRange.topological_closure_map_subgroup [Group‚Çì H] [TopologicalSpace H] [TopologicalGroup H] {f : G ‚Üí* H}
  (hf : Continuous f) (hf' : DenseRange f) {s : Subgroup G} (hs : s.topological_closure = ‚ä§) :
  (s.map f).topologicalClosure = ‚ä§ :=
  by 
    rw [SetLike.ext'_iff] at hs‚ä¢
    simp only [Subgroup.topological_closure_coe, Subgroup.coe_top, ‚Üêdense_iff_closure_eq] at hs‚ä¢
    exact hf'.dense_image hf hs

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[ident exists_nhds_half_neg]]
theorem exists_nhds_split_inv
{s : set G}
(hs : ¬´expr ‚àà ¬ª(s, exprùìù() (1 : G))) : ¬´expr‚àÉ , ¬ª((V ¬´expr ‚àà ¬ª exprùìù() (1 : G)), ‚àÄ
 (v ¬´expr ‚àà ¬ª V)
 (w ¬´expr ‚àà ¬ª V), ¬´expr ‚àà ¬ª(¬´expr / ¬ª(v, w), s)) :=
have ¬´expr ‚àà ¬ª(¬´expr ‚Åª¬π' ¬ª(Œª
  p : ¬´expr √ó ¬ª(G, G), ¬´expr * ¬ª(p.1, ¬´expr ‚Åª¬π¬ª(p.2)), s), exprùìù() ((1, 1) : ¬´expr √ó ¬ª(G, G))), from continuous_at_fst.mul continuous_at_snd.inv (by simpa [] [] [] [] [] []),
by simpa [] [] ["only"] ["[", expr div_eq_mul_inv, ",", expr nhds_prod_eq, ",", expr mem_prod_self_iff, ",", expr prod_subset_iff, ",", expr mem_preimage, "]"] [] ["using", expr this]

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[]]
theorem nhds_translation_mul_inv
(x : G) : ¬´expr = ¬ª(comap (Œª y : G, ¬´expr * ¬ª(y, ¬´expr ‚Åª¬π¬ª(x))) (exprùìù() 1), exprùìù() x) :=
¬´expr $ ¬ª(((homeomorph.mul_right ¬´expr ‚Åª¬π¬ª(x)).comap_nhds_eq 1).trans, show ¬´expr = ¬ª(exprùìù() ¬´expr * ¬ª(1, ¬´expr ‚Åª¬π¬ª(¬´expr ‚Åª¬π¬ª(x))), exprùìù() x), by simp [] [] [] [] [] [])

@[simp, toAdditive]
theorem map_mul_left_nhds (x y : G) : map ((¬∑*¬∑) x) (ùìù y) = ùìù (x*y) :=
  (Homeomorph.mulLeft x).map_nhds_eq y

@[toAdditive]
theorem map_mul_left_nhds_one (x : G) : map ((¬∑*¬∑) x) (ùìù 1) = ùìù x :=
  by 
    simp 

@[toAdditive]
theorem TopologicalGroup.ext {G : Type _} [Group‚Çì G] {t t' : TopologicalSpace G} (tg : @TopologicalGroup G t _)
  (tg' : @TopologicalGroup G t' _) (h : @nhds G t 1 = @nhds G t' 1) : t = t' :=
  eq_of_nhds_eq_nhds$
    fun x =>
      by 
        rw [‚Üê@nhds_translation_mul_inv G t _ _ x, ‚Üê@nhds_translation_mul_inv G t' _ _ x, ‚Üêh]

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[to_additive #[]]
theorem topological_group.of_nhds_aux
{G : Type*}
[group G]
[topological_space G]
(hinv : tendsto (Œª x : G, ¬´expr ‚Åª¬π¬ª(x)) (exprùìù() 1) (exprùìù() 1))
(hleft : ‚àÄ x‚ÇÄ : G, ¬´expr = ¬ª(exprùìù() x‚ÇÄ, map (Œª x : G, ¬´expr * ¬ª(x‚ÇÄ, x)) (exprùìù() 1)))
(hconj : ‚àÄ
 x‚ÇÄ : G, ¬´expr ‚â§ ¬ª(map (Œª
   x : G, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, x), ¬´expr ‚Åª¬π¬ª(x‚ÇÄ))) (exprùìù() 1), exprùìù() 1)) : continuous (Œª x : G, ¬´expr ‚Åª¬π¬ª(x)) :=
begin
  rw [expr continuous_iff_continuous_at] [],
  rintros [ident x‚ÇÄ],
  have [ident key] [":", expr ¬´expr = ¬ª(Œª
    x, ¬´expr ‚Åª¬π¬ª(¬´expr * ¬ª(x‚ÇÄ, x)), ¬´expr ‚àò ¬ª(Œª
     x, ¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(x‚ÇÄ), x), ¬´expr ‚àò ¬ª(Œª
      x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, x), ¬´expr ‚Åª¬π¬ª(x‚ÇÄ)), Œª x, ¬´expr ‚Åª¬π¬ª(x))))] [],
  by { ext [] [] []; simp [] [] [] ["[", expr mul_assoc, "]"] [] [] },
  calc
    ¬´expr = ¬ª(map (Œª
      x, ¬´expr ‚Åª¬π¬ª(x)) (exprùìù() x‚ÇÄ), map (Œª
      x, ¬´expr ‚Åª¬π¬ª(x)) ¬´expr $ ¬ª(map (Œª x, ¬´expr * ¬ª(x‚ÇÄ, x)), exprùìù() 1)) : by rw [expr hleft] []
    ¬´expr = ¬ª(..., map (Œª x, ¬´expr ‚Åª¬π¬ª(¬´expr * ¬ª(x‚ÇÄ, x))) (exprùìù() 1)) : by rw [expr filter.map_map] []
    ¬´expr = ¬ª(..., map ¬´expr ‚àò ¬ª(¬´expr ‚àò ¬ª(Œª
       x, ¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(x‚ÇÄ), x), Œª
       x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, x), ¬´expr ‚Åª¬π¬ª(x‚ÇÄ))), Œª x, ¬´expr ‚Åª¬π¬ª(x)) (exprùìù() 1)) : by rw [expr key] []
    ¬´expr = ¬ª(..., map ¬´expr ‚àò ¬ª(Œª
      x, ¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(x‚ÇÄ), x), Œª
      x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, x), ¬´expr ‚Åª¬π¬ª(x‚ÇÄ))) _) : by rw ["<-", expr filter.map_map] []
    ¬´expr ‚â§ ¬ª(..., map ¬´expr ‚àò ¬ª(Œª
      x, ¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(x‚ÇÄ), x), Œª x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, x), ¬´expr ‚Åª¬π¬ª(x‚ÇÄ))) (exprùìù() 1)) : map_mono hinv
    ¬´expr = ¬ª(..., map (Œª
      x, ¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(x‚ÇÄ), x)) (map (Œª
       x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, x), ¬´expr ‚Åª¬π¬ª(x‚ÇÄ))) (exprùìù() 1))) : filter.map_map
    ¬´expr ‚â§ ¬ª(..., map (Œª x, ¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(x‚ÇÄ), x)) (exprùìù() 1)) : map_mono (hconj x‚ÇÄ)
    ¬´expr = ¬ª(..., exprùìù() ¬´expr ‚Åª¬π¬ª(x‚ÇÄ)) : (hleft _).symm
end

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[]]
theorem topological_group.of_nhds_one'
{G : Type u}
[group G]
[topological_space G]
(hmul : tendsto (uncurry ((¬´expr * ¬ª) : G ‚Üí G ‚Üí G)) ¬´expr √ó·∂† ¬ª(exprùìù() 1, exprùìù() 1) (exprùìù() 1))
(hinv : tendsto (Œª x : G, ¬´expr ‚Åª¬π¬ª(x)) (exprùìù() 1) (exprùìù() 1))
(hleft : ‚àÄ x‚ÇÄ : G, ¬´expr = ¬ª(exprùìù() x‚ÇÄ, map (Œª x, ¬´expr * ¬ª(x‚ÇÄ, x)) (exprùìù() 1)))
(hright : ‚àÄ x‚ÇÄ : G, ¬´expr = ¬ª(exprùìù() x‚ÇÄ, map (Œª x, ¬´expr * ¬ª(x, x‚ÇÄ)) (exprùìù() 1))) : topological_group G :=
begin
  refine [expr { continuous_mul := (has_continuous_mul.of_nhds_one hmul hleft hright).continuous_mul,
     continuous_inv := topological_group.of_nhds_aux hinv hleft _ }],
  intros [ident x‚ÇÄ],
  suffices [] [":", expr ¬´expr = ¬ª(map (Œª x : G, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, x), ¬´expr ‚Åª¬π¬ª(x‚ÇÄ))) (exprùìù() 1), exprùìù() 1)],
  by simp [] [] [] ["[", expr this, ",", expr le_refl, "]"] [] [],
  rw ["[", expr show ¬´expr = ¬ª(Œª
    x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, x), ¬´expr ‚Åª¬π¬ª(x‚ÇÄ)), ¬´expr ‚àò ¬ª(Œª
     x, ¬´expr * ¬ª(x‚ÇÄ, x), Œª x, ¬´expr * ¬ª(x, ¬´expr ‚Åª¬π¬ª(x‚ÇÄ)))), by { ext [] [] [],
     simp [] [] [] ["[", expr mul_assoc, "]"] [] [] }, ",", "<-", expr filter.map_map, ",", "<-", expr hright, ",", expr hleft ¬´expr ‚Åª¬π¬ª(x‚ÇÄ), ",", expr filter.map_map, "]"] [],
  convert [] [expr map_id] [],
  ext [] [] [],
  simp [] [] [] [] [] []
end

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[]]
theorem topological_group.of_nhds_one
{G : Type u}
[group G]
[topological_space G]
(hmul : tendsto (uncurry ((¬´expr * ¬ª) : G ‚Üí G ‚Üí G)) ¬´expr √ó·∂† ¬ª(exprùìù() 1, exprùìù() 1) (exprùìù() 1))
(hinv : tendsto (Œª x : G, ¬´expr ‚Åª¬π¬ª(x)) (exprùìù() 1) (exprùìù() 1))
(hleft : ‚àÄ x‚ÇÄ : G, ¬´expr = ¬ª(exprùìù() x‚ÇÄ, map (Œª x, ¬´expr * ¬ª(x‚ÇÄ, x)) (exprùìù() 1)))
(hconj : ‚àÄ
 x‚ÇÄ : G, tendsto (Œª x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, x), ¬´expr ‚Åª¬π¬ª(x‚ÇÄ))) (exprùìù() 1) (exprùìù() 1)) : topological_group G :=
{ continuous_mul := begin
    rw [expr continuous_iff_continuous_at] [],
    rintros ["‚ü®", ident x‚ÇÄ, ",", ident y‚ÇÄ, "‚ü©"],
    have [ident key] [":", expr ¬´expr = ¬ª(Œª
      p : ¬´expr √ó ¬ª(G, G), ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, p.1), ¬´expr * ¬ª(y‚ÇÄ, p.2)), ¬´expr ‚àò ¬ª(Œª
       x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, y‚ÇÄ), x), ¬´expr ‚àò ¬ª(uncurry ((¬´expr * ¬ª)), prod.map (Œª
         x, ¬´expr * ¬ª(¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(y‚ÇÄ), x), y‚ÇÄ)) id)))] [],
    by { ext [] [] [],
      simp [] [] [] ["[", expr uncurry, ",", expr prod.map, ",", expr mul_assoc, "]"] [] [] },
    specialize [expr hconj ¬´expr ‚Åª¬π¬ª(y‚ÇÄ)],
    rw [expr inv_inv] ["at", ident hconj],
    calc
      ¬´expr = ¬ª(map (Œª
        p : ¬´expr √ó ¬ª(G, G), ¬´expr * ¬ª(p.1, p.2)) (exprùìù() (x‚ÇÄ, y‚ÇÄ)), map (Œª
        p : ¬´expr √ó ¬ª(G, G), ¬´expr * ¬ª(p.1, p.2)) ¬´expr √ó·∂† ¬ª(exprùìù() x‚ÇÄ, exprùìù() y‚ÇÄ)) : by rw [expr nhds_prod_eq] []
      ¬´expr = ¬ª(..., map (Œª
        p : ¬´expr √ó ¬ª(G, G), ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, p.1), ¬´expr * ¬ª(y‚ÇÄ, p.2))) ¬´expr √ó·∂† ¬ª(exprùìù() 1, exprùìù() 1)) : by rw ["[", expr hleft x‚ÇÄ, ",", expr hleft y‚ÇÄ, ",", expr prod_map_map_eq, ",", expr filter.map_map, "]"] []
      ¬´expr = ¬ª(..., map ¬´expr ‚àò ¬ª(¬´expr ‚àò ¬ª(Œª
         x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, y‚ÇÄ), x), uncurry ((¬´expr * ¬ª))), prod.map (Œª
         x, ¬´expr * ¬ª(¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(y‚ÇÄ), x), y‚ÇÄ)) id) ¬´expr √ó·∂† ¬ª(exprùìù() 1, exprùìù() 1)) : by rw [expr key] []
      ¬´expr = ¬ª(..., map ¬´expr ‚àò ¬ª(Œª
        x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, y‚ÇÄ), x), uncurry ((¬´expr * ¬ª))) ¬´expr √ó·∂† ¬ª(¬´expr $ ¬ª(map (Œª
          x, ¬´expr * ¬ª(¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª(y‚ÇÄ), x), y‚ÇÄ)), exprùìù() 1), exprùìù() 1)) : by rw ["[", "<-", expr filter.map_map, ",", "<-", expr prod_map_map_eq', ",", expr map_id, "]"] []
      ¬´expr ‚â§ ¬ª(..., map ¬´expr ‚àò ¬ª(Œª
        x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, y‚ÇÄ), x), uncurry ((¬´expr * ¬ª))) ¬´expr √ó·∂† ¬ª(exprùìù() 1, exprùìù() 1)) : map_mono ¬´expr $ ¬ª(filter.prod_mono hconj, le_refl _)
      ¬´expr = ¬ª(..., map (Œª
        x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, y‚ÇÄ), x)) (map (uncurry ((¬´expr * ¬ª))) ¬´expr √ó·∂† ¬ª(exprùìù() 1, exprùìù() 1))) : by rw [expr filter.map_map] []
      ¬´expr ‚â§ ¬ª(..., map (Œª x, ¬´expr * ¬ª(¬´expr * ¬ª(x‚ÇÄ, y‚ÇÄ), x)) (exprùìù() 1)) : map_mono hmul
      ¬´expr = ¬ª(..., exprùìù() ¬´expr * ¬ª(x‚ÇÄ, y‚ÇÄ)) : (hleft _).symm
  end,
  continuous_inv := topological_group.of_nhds_aux hinv hleft hconj }

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[]]
theorem topological_group.of_comm_of_nhds_one
{G : Type u}
[comm_group G]
[topological_space G]
(hmul : tendsto (uncurry ((¬´expr * ¬ª) : G ‚Üí G ‚Üí G)) ¬´expr √ó·∂† ¬ª(exprùìù() 1, exprùìù() 1) (exprùìù() 1))
(hinv : tendsto (Œª x : G, ¬´expr ‚Åª¬π¬ª(x)) (exprùìù() 1) (exprùìù() 1))
(hleft : ‚àÄ x‚ÇÄ : G, ¬´expr = ¬ª(exprùìù() x‚ÇÄ, map (Œª x, ¬´expr * ¬ª(x‚ÇÄ, x)) (exprùìù() 1))) : topological_group G :=
topological_group.of_nhds_one hmul hinv hleft (by simpa [] [] [] [] [] ["using", expr tendsto_id])

end TopologicalGroup

section QuotientTopologicalGroup

variable[TopologicalSpace G][Group‚Çì G][TopologicalGroup G](N : Subgroup G)(n : N.normal)

@[toAdditive]
instance  {G : Type _} [Group‚Çì G] [TopologicalSpace G] (N : Subgroup G) : TopologicalSpace (QuotientGroup.Quotient N) :=
  Quotient‚Çì.topologicalSpace

open QuotientGroup

@[toAdditive]
theorem QuotientGroup.is_open_map_coe : IsOpenMap (coe‚Çì : G ‚Üí Quotient‚Çì N) :=
  by 
    intro s s_op 
    change IsOpen ((coe‚Çì : G ‚Üí Quotient‚Çì N) ‚Åª¬π' (coe‚Çì '' s))
    rw [QuotientGroup.preimage_image_coe N s]
    exact is_open_Union fun n => (continuous_mul_right _).is_open_preimage s s_op

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[to_additive #[]] instance topological_group_quotient [N.normal] : topological_group (quotient N) :=
{ continuous_mul := begin
    have [ident cont] [":", expr continuous ¬´expr ‚àò ¬ª((coe : G ‚Üí quotient N), Œª
      p : ¬´expr √ó ¬ª(G, G), ¬´expr * ¬ª(p.fst, p.snd))] [":=", expr continuous_quot_mk.comp continuous_mul],
    have [ident quot] [":", expr quotient_map (Œª p : ¬´expr √ó ¬ª(G, G), ((p.1 : quotient N), (p.2 : quotient N)))] [],
    { apply [expr is_open_map.to_quotient_map],
      { exact [expr (quotient_group.is_open_map_coe N).prod (quotient_group.is_open_map_coe N)] },
      { exact [expr continuous_quot_mk.prod_map continuous_quot_mk] },
      { exact [expr (surjective_quot_mk _).prod_map (surjective_quot_mk _)] } },
    exact [expr (quotient_map.continuous_iff quot).2 cont]
  end,
  continuous_inv := begin
    have [] [":", expr continuous ¬´expr ‚àò ¬ª((coe : G ‚Üí quotient N), Œª
      a : G, ¬´expr ‚Åª¬π¬ª(a))] [":=", expr continuous_quot_mk.comp continuous_inv],
    convert [] [expr continuous_quotient_lift _ this] []
  end }

end QuotientTopologicalGroup

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- A typeclass saying that `Œª p : G √ó G, p.1 - p.2` is a continuous function. This property
automatically holds for topological additive groups but it also holds, e.g., for `‚Ñù‚â•0`. -/
class has_continuous_sub
(G : Type*)
[topological_space G]
[has_sub G] : exprProp() := (continuous_sub : continuous (Œª p : ¬´expr √ó ¬ª(G, G), ¬´expr - ¬ª(p.1, p.2)))

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- A typeclass saying that `Œª p : G √ó G, p.1 / p.2` is a continuous function. This property
automatically holds for topological groups. Lemmas using this class have primes.
The unprimed version is for `group_with_zero`. -/
@[to_additive #[]]
class has_continuous_div
(G : Type*)
[topological_space G]
[has_div G] : exprProp() := (continuous_div' : continuous (Œª p : ¬´expr √ó ¬ª(G, G), ¬´expr / ¬ª(p.1, p.2)))

@[toAdditive]
instance (priority := 100)TopologicalGroup.to_has_continuous_div [TopologicalSpace G] [Group‚Çì G] [TopologicalGroup G] :
  HasContinuousDiv G :=
  ‚ü®by 
      simp only [div_eq_mul_inv]
      exact continuous_fst.mul continuous_snd.inv‚ü©

export HasContinuousSub(continuous_sub)

export HasContinuousDiv(continuous_div')

section HasContinuousDiv

variable[TopologicalSpace G][Div G][HasContinuousDiv G]

@[toAdditive sub]
theorem Filter.Tendsto.div' {f g : Œ± ‚Üí G} {l : Filter Œ±} {a b : G} (hf : tendsto f l (ùìù a)) (hg : tendsto g l (ùìù b)) :
  tendsto (fun x => f x / g x) l (ùìù (a / b)) :=
  (continuous_div'.Tendsto (a, b)).comp (hf.prod_mk_nhds hg)

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[ident const_sub]]
theorem filter.tendsto.const_div'
(b : G)
{c : G}
{f : Œ± ‚Üí G}
{l : filter Œ±}
(h : tendsto f l (exprùìù() c)) : tendsto (Œª k : Œ±, ¬´expr / ¬ª(b, f k)) l (exprùìù() ¬´expr / ¬ª(b, c)) :=
tendsto_const_nhds.div' h

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[ident sub_const]]
theorem filter.tendsto.div_const'
(b : G)
{c : G}
{f : Œ± ‚Üí G}
{l : filter Œ±}
(h : tendsto f l (exprùìù() c)) : tendsto (Œª k : Œ±, ¬´expr / ¬ª(f k, b)) l (exprùìù() ¬´expr / ¬ª(c, b)) :=
h.div' tendsto_const_nhds

variable[TopologicalSpace Œ±]{f g : Œ± ‚Üí G}{s : Set Œ±}{x : Œ±}

@[continuity, toAdditive sub]
theorem Continuous.div' (hf : Continuous f) (hg : Continuous g) : Continuous fun x => f x / g x :=
  continuous_div'.comp (hf.prod_mk hg : _)

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[ident continuous_sub_left]]
theorem continuous_div_left' (a : G) : continuous (Œª b : G, ¬´expr / ¬ª(a, b)) :=
continuous_const.div' continuous_id

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[ident continuous_sub_right]]
theorem continuous_div_right' (a : G) : continuous (Œª b : G, ¬´expr / ¬ª(b, a)) :=
continuous_id.div' continuous_const

@[toAdditive sub]
theorem ContinuousAt.div' {f g : Œ± ‚Üí G} {x : Œ±} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :
  ContinuousAt (fun x => f x / g x) x :=
  hf.div' hg

@[toAdditive sub]
theorem ContinuousWithinAt.div' (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) :
  ContinuousWithinAt (fun x => f x / g x) s x :=
  hf.div' hg

@[toAdditive sub]
theorem ContinuousOn.div' (hf : ContinuousOn f s) (hg : ContinuousOn g s) : ContinuousOn (fun x => f x / g x) s :=
  fun x hx => (hf x hx).div' (hg x hx)

end HasContinuousDiv

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[to_additive #[]]
theorem nhds_translation_div
[topological_space G]
[group G]
[topological_group G]
(x : G) : ¬´expr = ¬ª(comap (Œª y : G, ¬´expr / ¬ª(y, x)) (exprùìù() 1), exprùìù() x) :=
by simpa [] [] ["only"] ["[", expr div_eq_mul_inv, "]"] [] ["using", expr nhds_translation_mul_inv x]

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- additive group with a neighbourhood around 0.
Only used to construct a topology and uniform space.

This is currently only available for commutative groups, but it can be extended to
non-commutative groups too.
-/
class add_group_with_zero_nhd
(G : Type u)extends add_comm_group G :=
  (Z [] : filter G)
  (zero_Z : ¬´expr ‚â§ ¬ª(pure 0, Z))
  (sub_Z : tendsto (Œª p : ¬´expr √ó ¬ª(G, G), ¬´expr - ¬ª(p.1, p.2)) ¬´expr √ó·∂† ¬ª(Z, Z) Z)

section FilterMul

section 

variable[TopologicalSpace G][Group‚Çì G][TopologicalGroup G]

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[to_additive #[]] theorem is_open.mul_left {s t : set G} : is_open t ‚Üí is_open ¬´expr * ¬ª(s, t) :=
Œª ht, begin
  have [] [":", expr ‚àÄ
   a, is_open ¬´expr '' ¬ª(Œª x : G, ¬´expr * ¬ª(a, x), t)] [":=", expr assume a, is_open_map_mul_left a t ht],
  rw ["<-", expr Union_mul_left_image] [],
  exact [expr is_open_Union (Œª a, ¬´expr $ ¬ª(is_open_Union, Œª ha, this _))]
end

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[to_additive #[]] theorem is_open.mul_right {s t : set G} : is_open s ‚Üí is_open ¬´expr * ¬ª(s, t) :=
Œª hs, begin
  have [] [":", expr ‚àÄ a, is_open ¬´expr '' ¬ª(Œª x : G, ¬´expr * ¬ª(x, a), s)] [],
  assume [binders (a)],
  apply [expr is_open_map_mul_right],
  exact [expr hs],
  rw ["<-", expr Union_mul_right_image] [],
  exact [expr is_open_Union (Œª a, ¬´expr $ ¬ª(is_open_Union, Œª ha, this _))]
end

variable(G)

@[toAdditive]
theorem TopologicalGroup.t1_space (h : @IsClosed G _ {1}) : T1Space G :=
  ‚ü®fun x =>
      by 
        convert is_closed_map_mul_right x _ h 
        simp ‚ü©

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[to_additive #[]] theorem topological_group.regular_space [t1_space G] : regular_space G :=
‚ü®assume s a hs ha, let f := Œª p : ¬´expr √ó ¬ª(G, G), ¬´expr * ¬ª(p.1, ¬´expr ‚Åª¬π¬ª(p.2)) in
 have hf : continuous f := continuous_fst.mul continuous_snd.inv,
 let ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, a_mem_t‚ÇÅ, one_mem_t‚ÇÇ, t_subset‚ü© := is_open_prod_iff.1 ((is_open_compl_iff.2 hs).preimage hf) a (1 : G) (by simpa [] [] [] ["[", expr f, "]"] [] []) in
 begin
   use ["[", expr ¬´expr * ¬ª(s, t‚ÇÇ), ",", expr ht‚ÇÇ.mul_left, ",", expr Œª x hx, ‚ü®x, 1, hx, one_mem_t‚ÇÇ, mul_one _‚ü©, "]"],
   rw ["[", expr nhds_within, ",", expr inf_principal_eq_bot, ",", expr mem_nhds_iff, "]"] [],
   refine [expr ‚ü®t‚ÇÅ, _, ht‚ÇÅ, a_mem_t‚ÇÅ‚ü©],
   rintros [ident x, ident hx, "‚ü®", ident y, ",", ident z, ",", ident hy, ",", ident hz, ",", ident yz, "‚ü©"],
   have [] [":", expr ¬´expr ‚àà ¬ª(¬´expr * ¬ª(x, ¬´expr ‚Åª¬π¬ª(z)), ¬´expr ·∂ú¬ª(s))] [":=", expr prod_subset_iff.1 t_subset x hx z hz],
   have [] [":", expr ¬´expr ‚àà ¬ª(¬´expr * ¬ª(x, ¬´expr ‚Åª¬π¬ª(z)), s)] [],
   rw ["<-", expr yz] [],
   simpa [] [] [] [] [] [],
   contradiction
 end‚ü©

attribute [local instance] TopologicalGroup.regular_space

@[toAdditive]
theorem TopologicalGroup.t2_space [T1Space G] : T2Space G :=
  RegularSpace.t2_space G

end 

section 

/-! Some results about an open set containing the product of two sets in a topological group. -/


variable[TopologicalSpace G][Group‚Çì G][TopologicalGroup G]

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of `1`
  such that `KV ‚äÜ U`. -/
@[to_additive #[expr "Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of\n`0` such that `K + V ‚äÜ U`."]]
theorem compact_open_separated_mul
{K U : set G}
(hK : is_compact K)
(hU : is_open U)
(hKU : ¬´expr ‚äÜ ¬ª(K, U)) : ¬´expr‚àÉ , ¬ª((V : set G), ¬´expr ‚àß ¬ª(is_open V, ¬´expr ‚àß ¬ª(¬´expr ‚àà ¬ª((1 : G), V), ¬´expr ‚äÜ ¬ª(¬´expr * ¬ª(K, V), U)))) :=
begin
  let [ident W] [":", expr G ‚Üí set G] [":=", expr Œª x, ¬´expr ‚Åª¬π' ¬ª(Œª y, ¬´expr * ¬ª(x, y), U)],
  have [ident h1W] [":", expr ‚àÄ x, is_open (W x)] [":=", expr Œª x, hU.preimage (continuous_mul_left x)],
  have [ident h2W] [":", expr ‚àÄ
   x ¬´expr ‚àà ¬ª K, ¬´expr ‚àà ¬ª((1 : G), W x)] [":=", expr Œª
   x hx, by simp [] [] ["only"] ["[", expr mem_preimage, ",", expr mul_one, ",", expr hKU hx, "]"] [] []],
  choose [] [ident V] [ident hV] ["using", expr Œª
   x : K, exists_open_nhds_one_mul_subset ((h1W x).mem_nhds (h2W x.1 x.2))],
  let [ident X] [":", expr K ‚Üí set G] [":=", expr Œª x, ¬´expr ‚Åª¬π' ¬ª(Œª y, ¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª((x : G)), y), V x)],
  obtain ["‚ü®", ident t, ",", ident ht, "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((t : finset ¬´expr‚Ü• ¬ª(K)), ¬´expr ‚äÜ ¬ª(K, ¬´expr‚ãÉ , ¬ª((i ¬´expr ‚àà ¬ª t), X i)))],
  { refine [expr hK.elim_finite_subcover X (Œª x, (hV x).1.preimage (continuous_mul_left ¬´expr ‚Åª¬π¬ª(x))) _],
    intros [ident x, ident hx],
    rw ["[", expr mem_Union, "]"] [],
    use [expr ‚ü®x, hx‚ü©],
    rw ["[", expr mem_preimage, "]"] [],
    convert [] [expr (hV _).2.1] [],
    simp [] [] ["only"] ["[", expr mul_left_inv, ",", expr subtype.coe_mk, "]"] [] [] },
  refine [expr ‚ü®¬´expr‚ãÇ , ¬ª((x ¬´expr ‚àà ¬ª t), V x), is_open_bInter (finite_mem_finset _) (Œª x hx, (hV x).1), _, _‚ü©],
  { simp [] [] ["only"] ["[", expr mem_Inter, "]"] [] [],
    intros [ident x, ident hx],
    exact [expr (hV x).2.1] },
  rintro ["_", "‚ü®", ident x, ",", ident y, ",", ident hx, ",", ident hy, ",", ident rfl, "‚ü©"],
  simp [] [] ["only"] ["[", expr mem_Inter, "]"] [] ["at", ident hy],
  have [] [] [":=", expr ht hx],
  simp [] [] ["only"] ["[", expr mem_Union, ",", expr mem_preimage, "]"] [] ["at", ident this],
  rcases [expr this, "with", "‚ü®", ident z, ",", ident h1z, ",", ident h2z, "‚ü©"],
  have [] [":", expr ¬´expr ‚àà ¬ª(¬´expr * ¬ª(¬´expr * ¬ª(¬´expr ‚Åª¬π¬ª((z : G)), x), y), W z)] [":=", expr (hV z).2.2 (mul_mem_mul h2z (hy z h1z))],
  rw ["[", expr mem_preimage, "]"] ["at", ident this],
  convert [] [expr this] ["using", 1],
  simp [] [] ["only"] ["[", expr mul_assoc, ",", expr mul_inv_cancel_left, "]"] [] []
end

/-- A compact set is covered by finitely many left multiplicative translates of a set
  with non-empty interior. -/
@[toAdditive "A compact set is covered by finitely many left additive translates of a set\n  with non-empty interior."]
theorem compact_covered_by_mul_left_translates {K V : Set G} (hK : IsCompact K) (hV : (Interior V).Nonempty) :
  ‚àÉ t : Finset G, K ‚äÜ ‚ãÉ(g : _)(_ : g ‚àà t), (fun h => g*h) ‚Åª¬π' V :=
  by 
    obtain ‚ü®t, ht‚ü© : ‚àÉ t : Finset G, K ‚äÜ ‚ãÉ(x : _)(_ : x ‚àà t), Interior ((¬∑*¬∑) x ‚Åª¬π' V)
    ¬∑
      refine' hK.elim_finite_subcover (fun x => Interior$ (¬∑*¬∑) x ‚Åª¬π' V) (fun x => is_open_interior) _ 
      cases' hV with g‚ÇÄ hg‚ÇÄ 
      refine' fun g hg => mem_Union.2 ‚ü®g‚ÇÄ*g‚Åª¬π, _‚ü©
      refine' preimage_interior_subset_interior_preimage (continuous_const.mul continuous_id) _ 
      rwa [mem_preimage, inv_mul_cancel_right]
    exact ‚ü®t, subset.trans ht$ bUnion_mono$ fun g hg => interior_subset‚ü©

/-- Every locally compact separable topological group is œÉ-compact.
  Note: this is not true if we drop the topological group hypothesis. -/
@[toAdditive SeparableLocallyCompactAddGroup.sigma_compact_space]
instance (priority := 100)SeparableLocallyCompactGroup.sigma_compact_space [separable_space G] [LocallyCompactSpace G] :
  SigmaCompactSpace G :=
  by 
    obtain ‚ü®L, hLc, hL1‚ü© := exists_compact_mem_nhds (1 : G)
    refine' ‚ü®‚ü®fun n => (fun x => x*dense_seq G n) ‚Åª¬π' L, _, _‚ü©‚ü©
    ¬∑
      intro n 
      exact (Homeomorph.mulRight _).compact_preimage.mpr hLc
    ¬∑
      refine' Union_eq_univ_iff.2 fun x => _ 
      obtain ‚ü®_, ‚ü®n, rfl‚ü©, hn‚ü© : (range (dense_seq G) ‚à© (fun y => x*y) ‚Åª¬π' L).Nonempty
      ¬∑
        rw [‚Üê(Homeomorph.mulLeft x).apply_symm_apply 1] at hL1 
        exact (dense_range_dense_seq G).inter_nhds_nonempty ((Homeomorph.mulLeft x).Continuous.ContinuousAt$ hL1)
      exact ‚ü®n, hn‚ü©

-- error in Topology.Algebra.Group: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Every separated topological group in which there exists a compact set with nonempty interior
is locally compact. -/
@[to_additive #[]]
theorem topological_space.positive_compacts.locally_compact_space_of_group
[t2_space G]
(K : positive_compacts G) : locally_compact_space G :=
begin
  refine [expr locally_compact_of_compact_nhds (Œª x, _)],
  obtain ["‚ü®", ident y, ",", ident hy, "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((y), ¬´expr ‚àà ¬ª(y, interior K.1)), ":=", expr K.2.2],
  let [ident F] [] [":=", expr homeomorph.mul_left ¬´expr * ¬ª(x, ¬´expr ‚Åª¬π¬ª(y))],
  refine [expr ‚ü®¬´expr '' ¬ª(F, K.1), _, is_compact.image K.2.1 F.continuous‚ü©],
  suffices [] [":", expr ¬´expr ‚àà ¬ª(¬´expr ‚Åª¬π' ¬ª(F.symm, K.1), exprùìù() x)],
  by { convert [] [expr this] [],
    apply [expr equiv.image_eq_preimage] },
  apply [expr continuous_at.preimage_mem_nhds F.symm.continuous.continuous_at],
  have [] [":", expr ¬´expr = ¬ª(F.symm x, y)] [],
  by simp [] [] [] ["[", expr F, ",", expr homeomorph.mul_left_symm, "]"] [] [],
  rw [expr this] [],
  exact [expr mem_interior_iff_mem_nhds.1 hy]
end

end 

section 

variable[TopologicalSpace G][CommGroup‚Çì G][TopologicalGroup G]

@[toAdditive]
theorem nhds_mul (x y : G) : ùìù (x*y) = ùìù x*ùìù y :=
  filter_eq$
    Set.ext$
      fun s =>
        by 
          rw [‚Üênhds_translation_mul_inv x, ‚Üênhds_translation_mul_inv y, ‚Üênhds_translation_mul_inv (x*y)]
          split 
          ¬∑
            rintro ‚ü®t, ht, ts‚ü©
            rcases exists_nhds_one_split ht with ‚ü®V, V1, h‚ü©
            refine' ‚ü®(fun a => a*x‚Åª¬π) ‚Åª¬π' V, (fun a => a*y‚Åª¬π) ‚Åª¬π' V, ‚ü®V, V1, subset.refl _‚ü©, ‚ü®V, V1, subset.refl _‚ü©, _‚ü©
            rintro a ‚ü®v, w, v_mem, w_mem, rfl‚ü©
            apply ts 
            simpa [mul_comm‚Çì, mul_assoc‚Çì, mul_left_comm‚Çì] using h (v*x‚Åª¬π) v_mem (w*y‚Åª¬π) w_mem
          ¬∑
            rintro ‚ü®a, c, ‚ü®b, hb, ba‚ü©, ‚ü®d, hd, dc‚ü©, ac‚ü©
            refine' ‚ü®b ‚à© d, inter_mem hb hd, fun v => _‚ü©
            simp only [preimage_subset_iff, mul_inv_rev, mem_preimage] at *
            rintro ‚ü®vb, vd‚ü©
            refine' ac ‚ü®v*y‚Åª¬π, y, _, _, _‚ü©
            ¬∑
              rw [‚Üêmul_assoc‚Çì _ _ _] at vb 
              exact ba _ vb
            ¬∑
              apply dc y 
              rw [mul_right_inv‚Çì]
              exact mem_of_mem_nhds hd
            ¬∑
              simp only [inv_mul_cancel_right]

/-- On a topological group, `ùìù : G ‚Üí filter G` can be promoted to a `mul_hom`. -/
@[toAdditive "On an additive topological group, `ùìù : G ‚Üí filter G` can be promoted to an\n`add_hom`.", simps]
def nhdsMulHom : MulHom G (Filter G) :=
  { toFun := ùìù, map_mul' := fun _ _ => nhds_mul _ _ }

end 

end FilterMul

instance Additive.topological_add_group {G} [h : TopologicalSpace G] [Group‚Çì G] [TopologicalGroup G] :
  @TopologicalAddGroup (Additive G) h _ :=
  { continuous_neg := @continuous_inv G _ _ _ }

instance Multiplicative.topological_group {G} [h : TopologicalSpace G] [AddGroup‚Çì G] [TopologicalAddGroup G] :
  @TopologicalGroup (Multiplicative G) h _ :=
  { continuous_inv := @continuous_neg G _ _ _ }

namespace Units

variable[Monoid‚Çì Œ±][TopologicalSpace Œ±][HasContinuousMul Œ±]

instance  : TopologicalGroup (Units Œ±) :=
  { continuous_inv :=
      continuous_induced_rng
        ((continuous_unop.comp (continuous_snd.comp (@continuous_embed_product Œ± _ _))).prod_mk
          (continuous_op.comp continuous_coe)) }

end Units

