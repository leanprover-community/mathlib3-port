/-
Copyright (c) 2022 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel

! This file was ported from Lean 3 source module topology.algebra.order.left_right_lim
! leanprover-community/mathlib commit e97cf15cd1aec9bd5c193b2ffac5a6dc9118912b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Order.Basic
import Mathbin.Topology.Algebra.Order.LeftRight

/-!
# Left and right limits

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define the (strict) left and right limits of a function.

* `left_lim f x` is the strict left limit of `f` at `x` (using `f x` as a garbage value if `x`
  is isolated to its left).
* `right_lim f x` is the strict right limit of `f` at `x` (using `f x` as a garbage value if `x`
  is isolated to its right).

We develop a comprehensive API for monotone functions. Notably,

* `monotone.continuous_at_iff_left_lim_eq_right_lim` states that a monotone function is continuous
  at a point if and only if its left and right limits coincide.
* `monotone.countable_not_continuous_at` asserts that a monotone function taking values in a
  second-countable space has at most countably many discontinuity points.

We also port the API to antitone functions.

## TODO

Prove corresponding stronger results for strict_mono and strict_anti functions.
-/


open Set Filter

open Topology

section

variable {Œ± Œ≤ : Type _} [LinearOrder Œ±] [TopologicalSpace Œ≤]

#print Function.leftLim /-
/-- Let `f : Œ± ‚Üí Œ≤` be a function from a linear order `Œ±` to a topological_space `Œ≤`, and
let `a : Œ±`. The limit strictly to the left of `f` at `a`, denoted with `left_lim f a`, is defined
by using the order topology on `Œ±`. If `a` is isolated to its left or the function has no left
limit, we use `f a` instead to guarantee a good behavior in most cases. -/
noncomputable irreducible_def Function.leftLim (f : Œ± ‚Üí Œ≤) (a : Œ±) : Œ≤ := by
  classical
    haveI : Nonempty Œ≤ := ‚ü®f a‚ü©
    letI : TopologicalSpace Œ± := Preorder.topology Œ±
    exact if ùìù[<] a = ‚ä• ‚à® ¬¨‚àÉ y, tendsto f (ùìù[<] a) (ùìù y) then f a else limUnder (ùìù[<] a) f
#align function.left_lim Function.leftLim
-/

#print Function.rightLim /-
/-- Let `f : Œ± ‚Üí Œ≤` be a function from a linear order `Œ±` to a topological_space `Œ≤`, and
let `a : Œ±`. The limit strictly to the right of `f` at `a`, denoted with `right_lim f a`, is defined
by using the order topology on `Œ±`. If `a` is isolated to its right or the function has no right
limit, , we use `f a` instead to guarantee a good behavior in most cases. -/
noncomputable def Function.rightLim (f : Œ± ‚Üí Œ≤) (a : Œ±) : Œ≤ :=
  @Function.leftLim Œ±·µí·µà Œ≤ _ _ f a
#align function.right_lim Function.rightLim
-/

open Function

/- warning: left_lim_eq_of_tendsto -> leftLim_eq_of_tendsto is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [hŒ± : TopologicalSpace.{u1} Œ±] [h'Œ± : OrderTopology.{u1} Œ± hŒ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))] [_inst_3 : T2Space.{u2} Œ≤ _inst_2] {f : Œ± -> Œ≤} {a : Œ±} {y : Œ≤}, (Ne.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± hŒ± a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) a)) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) -> (Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± hŒ± a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) a)) (nhds.{u2} Œ≤ _inst_2 y)) -> (Eq.{succ u2} Œ≤ (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f a) y)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] [hŒ± : TopologicalSpace.{u2} Œ±] [h'Œ± : OrderTopology.{u2} Œ± hŒ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))] [_inst_3 : T2Space.{u1} Œ≤ _inst_2] {f : Œ± -> Œ≤} {a : Œ±} {y : Œ≤}, (Ne.{succ u2} (Filter.{u2} Œ±) (nhdsWithin.{u2} Œ± hŒ± a (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) a)) (Bot.bot.{u2} (Filter.{u2} Œ±) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ±) (Filter.instCompleteLatticeFilter.{u2} Œ±)))) -> (Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± hŒ± a (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) a)) (nhds.{u1} Œ≤ _inst_2 y)) -> (Eq.{succ u1} Œ≤ (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f a) y)
Case conversion may be inaccurate. Consider using '#align left_lim_eq_of_tendsto leftLim_eq_of_tendsto‚Çì'. -/
theorem leftLim_eq_of_tendsto [hŒ± : TopologicalSpace Œ±] [h'Œ± : OrderTopology Œ±] [T2Space Œ≤]
    {f : Œ± ‚Üí Œ≤} {a : Œ±} {y : Œ≤} (h : ùìù[<] a ‚â† ‚ä•) (h' : Tendsto f (ùìù[<] a) (ùìù y)) :
    leftLim f a = y := by
  have h'' : ‚àÉ y, tendsto f (ùìù[<] a) (ùìù y) := ‚ü®y, h'‚ü©
  rw [h'Œ±.topology_eq_generate_intervals] at h h' h''
  simp only [left_lim, h, h'', not_true, or_self_iff, if_false]
  haveI := ne_bot_iff.2 h
  exact h'.lim_eq
#align left_lim_eq_of_tendsto leftLim_eq_of_tendsto

/- warning: left_lim_eq_of_eq_bot -> leftLim_eq_of_eq_bot is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [hŒ± : TopologicalSpace.{u1} Œ±] [h'Œ± : OrderTopology.{u1} Œ± hŒ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))] (f : Œ± -> Œ≤) {a : Œ±}, (Eq.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± hŒ± a (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) a)) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) -> (Eq.{succ u2} Œ≤ (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f a) (f a))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] [hŒ± : TopologicalSpace.{u2} Œ±] [h'Œ± : OrderTopology.{u2} Œ± hŒ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))] (f : Œ± -> Œ≤) {a : Œ±}, (Eq.{succ u2} (Filter.{u2} Œ±) (nhdsWithin.{u2} Œ± hŒ± a (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) a)) (Bot.bot.{u2} (Filter.{u2} Œ±) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ±) (Filter.instCompleteLatticeFilter.{u2} Œ±)))) -> (Eq.{succ u1} Œ≤ (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f a) (f a))
Case conversion may be inaccurate. Consider using '#align left_lim_eq_of_eq_bot leftLim_eq_of_eq_bot‚Çì'. -/
theorem leftLim_eq_of_eq_bot [hŒ± : TopologicalSpace Œ±] [h'Œ± : OrderTopology Œ±] (f : Œ± ‚Üí Œ≤) {a : Œ±}
    (h : ùìù[<] a = ‚ä•) : leftLim f a = f a :=
  by
  rw [h'Œ±.topology_eq_generate_intervals] at h
  simp [left_lim, ite_eq_left_iff, h]
#align left_lim_eq_of_eq_bot leftLim_eq_of_eq_bot

end

open Function

namespace Monotone

variable {Œ± Œ≤ : Type _} [LinearOrder Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤]
  [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Monotone f) {x y : Œ±}

include hf

/- warning: monotone.left_lim_eq_Sup -> Monotone.leftLim_eq_sup‚Çõ is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))], (Ne.{succ u1} (Filter.{u1} Œ±) (nhdsWithin.{u1} Œ± _inst_5 x (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x)) (Bot.bot.{u1} (Filter.{u1} Œ±) (CompleteLattice.toHasBot.{u1} (Filter.{u1} Œ±) (Filter.completeLattice.{u1} Œ±)))) -> (Eq.{succ u2} Œ≤ (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (SupSet.sup‚Çõ.{u2} Œ≤ (ConditionallyCompleteLattice.toHasSup.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)) (Set.image.{u1, u2} Œ± Œ≤ f (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x)))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))], (Ne.{succ u2} (Filter.{u2} Œ±) (nhdsWithin.{u2} Œ± _inst_5 x (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x)) (Bot.bot.{u2} (Filter.{u2} Œ±) (CompleteLattice.toBot.{u2} (Filter.{u2} Œ±) (Filter.instCompleteLatticeFilter.{u2} Œ±)))) -> (Eq.{succ u1} Œ≤ (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (SupSet.sup‚Çõ.{u1} Œ≤ (ConditionallyCompleteLattice.toSupSet.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)) (Set.image.{u2, u1} Œ± Œ≤ f (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x)))))
Case conversion may be inaccurate. Consider using '#align monotone.left_lim_eq_Sup Monotone.leftLim_eq_sup‚Çõ‚Çì'. -/
theorem leftLim_eq_sup‚Çõ [TopologicalSpace Œ±] [OrderTopology Œ±] (h : ùìù[<] x ‚â† ‚ä•) :
    leftLim f x = sup‚Çõ (f '' Iio x) :=
  leftLim_eq_of_tendsto h (hf.tendsto_nhdsWithin_Iio x)
#align monotone.left_lim_eq_Sup Monotone.leftLim_eq_sup‚Çõ

/- warning: monotone.left_lim_le -> Monotone.leftLim_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (f y)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (f y)))
Case conversion may be inaccurate. Consider using '#align monotone.left_lim_le Monotone.leftLim_le‚Çì'. -/
theorem leftLim_le (h : x ‚â§ y) : leftLim f x ‚â§ f y :=
  by
  letI : TopologicalSpace Œ± := Preorder.topology Œ±
  haveI : OrderTopology Œ± := ‚ü®rfl‚ü©
  rcases eq_or_ne (ùìù[<] x) ‚ä• with (h' | h')
  ¬∑ simpa [left_lim, h'] using hf h
  haveI A : ne_bot (ùìù[<] x) := ne_bot_iff.2 h'
  rw [left_lim_eq_Sup hf h']
  refine' csup‚Çõ_le _ _
  ¬∑ simp only [nonempty_image_iff]
    exact (forall_mem_nonempty_iff_ne_bot.2 A) _ self_mem_nhdsWithin
  ¬∑ simp only [mem_image, mem_Iio, forall_exists_index, and_imp, forall_apply_eq_imp_iff‚ÇÇ]
    intro z hz
    exact hf (hz.le.trans h)
#align monotone.left_lim_le Monotone.leftLim_le

/- warning: monotone.le_left_lim -> Monotone.le_leftLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (f x) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f y)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (f x) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f y)))
Case conversion may be inaccurate. Consider using '#align monotone.le_left_lim Monotone.le_leftLim‚Çì'. -/
theorem le_leftLim (h : x < y) : f x ‚â§ leftLim f y :=
  by
  letI : TopologicalSpace Œ± := Preorder.topology Œ±
  haveI : OrderTopology Œ± := ‚ü®rfl‚ü©
  rcases eq_or_ne (ùìù[<] y) ‚ä• with (h' | h')
  ¬∑ rw [leftLim_eq_of_eq_bot _ h']
    exact hf h.le
  rw [left_lim_eq_Sup hf h']
  refine' le_csup‚Çõ ‚ü®f y, _‚ü© (mem_image_of_mem _ h)
  simp only [upperBounds, mem_image, mem_Iio, forall_exists_index, and_imp,
    forall_apply_eq_imp_iff‚ÇÇ, mem_set_of_eq]
  intro z hz
  exact hf hz.le
#align monotone.le_left_lim Monotone.le_leftLim

/- warning: monotone.left_lim -> Monotone.leftLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f))
Case conversion may be inaccurate. Consider using '#align monotone.left_lim Monotone.leftLim‚Çì'. -/
@[mono]
protected theorem leftLim : Monotone (leftLim f) :=
  by
  intro x y h
  rcases eq_or_lt_of_le h with (rfl | hxy)
  ¬∑ exact le_rfl
  ¬∑ exact (hf.left_lim_le le_rfl).trans (hf.le_left_lim hxy)
#align monotone.left_lim Monotone.leftLim

/- warning: monotone.le_right_lim -> Monotone.le_rightLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (f x) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f y)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (f x) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f y)))
Case conversion may be inaccurate. Consider using '#align monotone.le_right_lim Monotone.le_rightLim‚Çì'. -/
theorem le_rightLim (h : x ‚â§ y) : f x ‚â§ rightLim f y :=
  hf.dual.leftLim_le h
#align monotone.le_right_lim Monotone.le_rightLim

/- warning: monotone.right_lim_le -> Monotone.rightLim_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (f y)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (f y)))
Case conversion may be inaccurate. Consider using '#align monotone.right_lim_le Monotone.rightLim_le‚Çì'. -/
theorem rightLim_le (h : x < y) : rightLim f x ‚â§ f y :=
  hf.dual.le_leftLim h
#align monotone.right_lim_le Monotone.rightLim_le

/- warning: monotone.right_lim -> Monotone.rightLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f))
Case conversion may be inaccurate. Consider using '#align monotone.right_lim Monotone.rightLim‚Çì'. -/
@[mono]
protected theorem rightLim : Monotone (rightLim f) := fun x y h => hf.dual.leftLim h
#align monotone.right_lim Monotone.rightLim

/- warning: monotone.left_lim_le_right_lim -> Monotone.leftLim_le_rightLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f y)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f y)))
Case conversion may be inaccurate. Consider using '#align monotone.left_lim_le_right_lim Monotone.leftLim_le_rightLim‚Çì'. -/
theorem leftLim_le_rightLim (h : x ‚â§ y) : leftLim f x ‚â§ rightLim f y :=
  (hf.leftLim_le le_rfl).trans (hf.le_rightLim h)
#align monotone.left_lim_le_right_lim Monotone.leftLim_le_rightLim

/- warning: monotone.right_lim_le_left_lim -> Monotone.rightLim_le_leftLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f y)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f y)))
Case conversion may be inaccurate. Consider using '#align monotone.right_lim_le_left_lim Monotone.rightLim_le_leftLim‚Çì'. -/
theorem rightLim_le_leftLim (h : x < y) : rightLim f x ‚â§ leftLim f y :=
  by
  letI : TopologicalSpace Œ± := Preorder.topology Œ±
  haveI : OrderTopology Œ± := ‚ü®rfl‚ü©
  rcases eq_or_ne (ùìù[<] y) ‚ä• with (h' | h')
  ¬∑ simp [left_lim, h']
    exact right_lim_le hf h
  obtain ‚ü®a, ‚ü®xa, ay‚ü©‚ü© : (Ioo x y).Nonempty :=
    forall_mem_nonempty_iff_ne_bot.2 (ne_bot_iff.2 h') (Ioo x y)
      (Ioo_mem_nhdsWithin_Iio ‚ü®h, le_refl _‚ü©)
  calc
    right_lim f x ‚â§ f a := hf.right_lim_le xa
    _ ‚â§ left_lim f y := hf.le_left_lim ay
    
#align monotone.right_lim_le_left_lim Monotone.rightLim_le_leftLim

variable [TopologicalSpace Œ±] [OrderTopology Œ±]

/- warning: monotone.tendsto_left_lim -> Monotone.tendsto_leftLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))] (x : Œ±), Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± _inst_5 x (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x)) (nhds.{u2} Œ≤ _inst_3 (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))] (x : Œ±), Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± _inst_5 x (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x)) (nhds.{u1} Œ≤ _inst_3 (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x)))
Case conversion may be inaccurate. Consider using '#align monotone.tendsto_left_lim Monotone.tendsto_leftLim‚Çì'. -/
theorem tendsto_leftLim (x : Œ±) : Tendsto f (ùìù[<] x) (ùìù (leftLim f x)) :=
  by
  rcases eq_or_ne (ùìù[<] x) ‚ä• with (h' | h')
  ¬∑ simp [h']
  rw [left_lim_eq_Sup hf h']
  exact hf.tendsto_nhds_within_Iio x
#align monotone.tendsto_left_lim Monotone.tendsto_leftLim

/- warning: monotone.tendsto_left_lim_within -> Monotone.tendsto_leftLim_within is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))] (x : Œ±), Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± _inst_5 x (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x)) (nhdsWithin.{u2} Œ≤ _inst_3 (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (Set.Iic.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))] (x : Œ±), Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± _inst_5 x (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x)) (nhdsWithin.{u1} Œ≤ _inst_3 (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (Set.Iic.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x))))
Case conversion may be inaccurate. Consider using '#align monotone.tendsto_left_lim_within Monotone.tendsto_leftLim_within‚Çì'. -/
theorem tendsto_leftLim_within (x : Œ±) : Tendsto f (ùìù[<] x) (ùìù[‚â§] leftLim f x) :=
  by
  apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within f (hf.tendsto_left_lim x)
  filter_upwards [self_mem_nhdsWithin]with y hy using hf.le_left_lim hy
#align monotone.tendsto_left_lim_within Monotone.tendsto_leftLim_within

/- warning: monotone.tendsto_right_lim -> Monotone.tendsto_rightLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))] (x : Œ±), Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± _inst_5 x (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x)) (nhds.{u2} Œ≤ _inst_3 (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))] (x : Œ±), Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± _inst_5 x (Set.Ioi.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x)) (nhds.{u1} Œ≤ _inst_3 (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x)))
Case conversion may be inaccurate. Consider using '#align monotone.tendsto_right_lim Monotone.tendsto_rightLim‚Çì'. -/
theorem tendsto_rightLim (x : Œ±) : Tendsto f (ùìù[>] x) (ùìù (rightLim f x)) :=
  hf.dual.tendsto_leftLim x
#align monotone.tendsto_right_lim Monotone.tendsto_rightLim

/- warning: monotone.tendsto_right_lim_within -> Monotone.tendsto_rightLim_within is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))] (x : Œ±), Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± _inst_5 x (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x)) (nhdsWithin.{u2} Œ≤ _inst_3 (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (Set.Ici.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))] (x : Œ±), Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± _inst_5 x (Set.Ioi.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x)) (nhdsWithin.{u1} Œ≤ _inst_3 (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (Set.Ici.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x))))
Case conversion may be inaccurate. Consider using '#align monotone.tendsto_right_lim_within Monotone.tendsto_rightLim_within‚Çì'. -/
theorem tendsto_rightLim_within (x : Œ±) : Tendsto f (ùìù[>] x) (ùìù[‚â•] rightLim f x) :=
  hf.dual.tendsto_leftLim_within x
#align monotone.tendsto_right_lim_within Monotone.tendsto_rightLim_within

/- warning: monotone.continuous_within_at_Iio_iff_left_lim_eq -> Monotone.continuousWithinAt_Iio_iff_leftLim_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))], Iff (ContinuousWithinAt.{u1, u2} Œ± Œ≤ _inst_5 _inst_3 f (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x) x) (Eq.{succ u2} Œ≤ (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))], Iff (ContinuousWithinAt.{u2, u1} Œ± Œ≤ _inst_5 _inst_3 f (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x) x) (Eq.{succ u1} Œ≤ (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (f x)))
Case conversion may be inaccurate. Consider using '#align monotone.continuous_within_at_Iio_iff_left_lim_eq Monotone.continuousWithinAt_Iio_iff_leftLim_eq‚Çì'. -/
/-- A monotone function is continuous to the left at a point if and only if its left limit
coincides with the value of the function. -/
theorem continuousWithinAt_Iio_iff_leftLim_eq :
    ContinuousWithinAt f (Iio x) x ‚Üî leftLim f x = f x :=
  by
  rcases eq_or_ne (ùìù[<] x) ‚ä• with (h' | h')
  ¬∑ simp [leftLim_eq_of_eq_bot f h', ContinuousWithinAt, h']
  haveI : (ùìù[Iio x] x).ne_bot := ne_bot_iff.2 h'
  refine' ‚ü®fun h => tendsto_nhds_unique (hf.tendsto_left_lim x) h.Tendsto, fun h => _‚ü©
  have := hf.tendsto_left_lim x
  rwa [h] at this
#align monotone.continuous_within_at_Iio_iff_left_lim_eq Monotone.continuousWithinAt_Iio_iff_leftLim_eq

/- warning: monotone.continuous_within_at_Ioi_iff_right_lim_eq -> Monotone.continuousWithinAt_Ioi_iff_rightLim_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))], Iff (ContinuousWithinAt.{u1, u2} Œ± Œ≤ _inst_5 _inst_3 f (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x) x) (Eq.{succ u2} Œ≤ (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))], Iff (ContinuousWithinAt.{u2, u1} Œ± Œ≤ _inst_5 _inst_3 f (Set.Ioi.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x) x) (Eq.{succ u1} Œ≤ (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (f x)))
Case conversion may be inaccurate. Consider using '#align monotone.continuous_within_at_Ioi_iff_right_lim_eq Monotone.continuousWithinAt_Ioi_iff_rightLim_eq‚Çì'. -/
/-- A monotone function is continuous to the right at a point if and only if its right limit
coincides with the value of the function. -/
theorem continuousWithinAt_Ioi_iff_rightLim_eq :
    ContinuousWithinAt f (Ioi x) x ‚Üî rightLim f x = f x :=
  hf.dual.continuousWithinAt_Iio_iff_leftLim_eq
#align monotone.continuous_within_at_Ioi_iff_right_lim_eq Monotone.continuousWithinAt_Ioi_iff_rightLim_eq

/- warning: monotone.continuous_at_iff_left_lim_eq_right_lim -> Monotone.continuousAt_iff_leftLim_eq_rightLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))], Iff (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_5 _inst_3 f x) (Eq.{succ u2} Œ≤ (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Monotone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))], Iff (ContinuousAt.{u2, u1} Œ± Œ≤ _inst_5 _inst_3 f x) (Eq.{succ u1} Œ≤ (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x)))
Case conversion may be inaccurate. Consider using '#align monotone.continuous_at_iff_left_lim_eq_right_lim Monotone.continuousAt_iff_leftLim_eq_rightLim‚Çì'. -/
/-- A monotone function is continuous at a point if and only if its left and right limits
coincide. -/
theorem continuousAt_iff_leftLim_eq_rightLim : ContinuousAt f x ‚Üî leftLim f x = rightLim f x :=
  by
  refine' ‚ü®fun h => _, fun h => _‚ü©
  ¬∑ have A : left_lim f x = f x :=
      hf.continuous_within_at_Iio_iff_left_lim_eq.1 h.continuous_within_at
    have B : right_lim f x = f x :=
      hf.continuous_within_at_Ioi_iff_right_lim_eq.1 h.continuous_within_at
    exact A.trans B.symm
  ¬∑ have h' : left_lim f x = f x :=
      by
      apply le_antisymm (left_lim_le hf (le_refl _))
      rw [h]
      exact le_right_lim hf (le_refl _)
    refine' continuousAt_iff_continuous_left'_right'.2 ‚ü®_, _‚ü©
    ¬∑ exact hf.continuous_within_at_Iio_iff_left_lim_eq.2 h'
    ¬∑ rw [h] at h'
      exact hf.continuous_within_at_Ioi_iff_right_lim_eq.2 h'
#align monotone.continuous_at_iff_left_lim_eq_right_lim Monotone.continuousAt_iff_leftLim_eq_rightLim

#print Monotone.countable_not_continuousWithinAt_Ioi /-
/-- In a second countable space, the set of points where a monotone function is not right-continuous
is at most countable. Superseded by `countable_not_continuous_at` which gives the two-sided
version. -/
theorem countable_not_continuousWithinAt_Ioi [TopologicalSpace.SecondCountableTopology Œ≤] :
    Set.Countable { x | ¬¨ContinuousWithinAt f (Ioi x) x } :=
  by
  /- If `f` is not continuous on the right at `x`, there is an interval `(f x, z x)` which is not
    reached by `f`. This gives a family of disjoint open intervals in `Œ≤`. Such a family can only
    be countable as `Œ≤` is second-countable. -/
  nontriviality Œ±
  let s := { x | ¬¨ContinuousWithinAt f (Ioi x) x }
  have : ‚àÄ x, x ‚àà s ‚Üí ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y :=
    by
    rintro x (hx : ¬¨ContinuousWithinAt f (Ioi x) x)
    contrapose! hx
    refine' tendsto_order.2 ‚ü®fun m hm => _, fun u hu => _‚ü©
    ¬∑ filter_upwards [self_mem_nhdsWithin]with y hy using hm.trans_le (hf (le_of_lt hy))
    rcases hx u hu with ‚ü®v, xv, fvu‚ü©
    have : Ioo x v ‚àà ùìù[>] x := Ioo_mem_nhdsWithin_Ioi ‚ü®le_refl _, xv‚ü©
    filter_upwards [this]with y hy
    apply (hf hy.2.le).trans_lt fvu
  -- choose `z x` such that `f` does not take the values in `(f x, z x)`.
  choose! z hz using this
  have I : inj_on f s := by
    apply StrictMonoOn.injOn
    intro x hx y hy hxy
    calc
      f x < z x := (hz x hx).1
      _ ‚â§ f y := (hz x hx).2 y hxy
      
  -- show that `f s` is countable by arguing that a disjoint family of disjoint open intervals
  -- (the intervals `(f x, z x)`) is at most countable.
  have fs_count : (f '' s).Countable :=
    by
    have A : (f '' s).PairwiseDisjoint fun x => Ioo x (z (inv_fun_on f s x)) :=
      by
      rintro _ ‚ü®u, us, rfl‚ü© _ ‚ü®v, vs, rfl‚ü© huv
      wlog hle : u ‚â§ v generalizing u v
      ¬∑ exact (this v vs u us huv.symm (le_of_not_le hle)).symm
      have hlt : u < v := hle.lt_of_ne (ne_of_apply_ne _ huv)
      apply disjoint_iff_forall_ne.2
      rintro a ha b hb rfl
      simp only [I.left_inv_on_inv_fun_on us, I.left_inv_on_inv_fun_on vs] at ha hb
      exact lt_irrefl _ ((ha.2.trans_le ((hz u us).2 v hlt)).trans hb.1)
    apply Set.PairwiseDisjoint.countable_of_Ioo A
    rintro _ ‚ü®y, ys, rfl‚ü©
    simpa only [I.left_inv_on_inv_fun_on ys] using (hz y ys).1
  exact maps_to.countable_of_inj_on (maps_to_image f s) I fs_count
#align monotone.countable_not_continuous_within_at_Ioi Monotone.countable_not_continuousWithinAt_Ioi
-/

#print Monotone.countable_not_continuousWithinAt_Iio /-
/-- In a second countable space, the set of points where a monotone function is not left-continuous
is at most countable. Superseded by `countable_not_continuous_at` which gives the two-sided
version. -/
theorem countable_not_continuousWithinAt_Iio [TopologicalSpace.SecondCountableTopology Œ≤] :
    Set.Countable { x | ¬¨ContinuousWithinAt f (Iio x) x } :=
  hf.dual.countable_not_continuousWithinAt_Ioi
#align monotone.countable_not_continuous_within_at_Iio Monotone.countable_not_continuousWithinAt_Iio
-/

#print Monotone.countable_not_continuousAt /-
/-- In a second countable space, the set of points where a monotone function is not continuous
is at most countable. -/
theorem countable_not_continuousAt [TopologicalSpace.SecondCountableTopology Œ≤] :
    Set.Countable { x | ¬¨ContinuousAt f x } :=
  by
  apply
    (hf.countable_not_continuous_within_at_Ioi.union hf.countable_not_continuous_within_at_Iio).mono
      _
  refine' compl_subset_compl.1 _
  simp only [compl_union]
  rintro x ‚ü®hx, h'x‚ü©
  simp only [mem_set_of_eq, Classical.not_not, mem_compl_iff] at hx h'x‚ä¢
  exact continuousAt_iff_continuous_left'_right'.2 ‚ü®h'x, hx‚ü©
#align monotone.countable_not_continuous_at Monotone.countable_not_continuousAt
-/

end Monotone

namespace Antitone

variable {Œ± Œ≤ : Type _} [LinearOrder Œ±] [ConditionallyCompleteLinearOrder Œ≤] [TopologicalSpace Œ≤]
  [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Antitone f) {x y : Œ±}

include hf

/- warning: antitone.le_left_lim -> Antitone.le_leftLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (f y) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (f y) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x)))
Case conversion may be inaccurate. Consider using '#align antitone.le_left_lim Antitone.le_leftLim‚Çì'. -/
theorem le_leftLim (h : x ‚â§ y) : f y ‚â§ leftLim f x :=
  hf.dual_right.leftLim_le h
#align antitone.le_left_lim Antitone.le_leftLim

/- warning: antitone.left_lim_le -> Antitone.leftLim_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f y) (f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f y) (f x)))
Case conversion may be inaccurate. Consider using '#align antitone.left_lim_le Antitone.leftLim_le‚Çì'. -/
theorem leftLim_le (h : x < y) : leftLim f y ‚â§ f x :=
  hf.dual_right.le_leftLim h
#align antitone.left_lim_le Antitone.leftLim_le

/- warning: antitone.left_lim -> Antitone.leftLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f))
Case conversion may be inaccurate. Consider using '#align antitone.left_lim Antitone.leftLim‚Çì'. -/
@[mono]
protected theorem leftLim : Antitone (leftLim f) :=
  hf.dual_right.leftLim
#align antitone.left_lim Antitone.leftLim

/- warning: antitone.right_lim_le -> Antitone.rightLim_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f y) (f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f y) (f x)))
Case conversion may be inaccurate. Consider using '#align antitone.right_lim_le Antitone.rightLim_le‚Çì'. -/
theorem rightLim_le (h : x ‚â§ y) : rightLim f y ‚â§ f x :=
  hf.dual_right.le_rightLim h
#align antitone.right_lim_le Antitone.rightLim_le

/- warning: antitone.le_right_lim -> Antitone.le_rightLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (f y) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (f y) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x)))
Case conversion may be inaccurate. Consider using '#align antitone.le_right_lim Antitone.le_rightLim‚Çì'. -/
theorem le_rightLim (h : x < y) : f y ‚â§ rightLim f x :=
  hf.dual_right.rightLim_le h
#align antitone.le_right_lim Antitone.le_rightLim

/- warning: antitone.right_lim -> Antitone.rightLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f))
Case conversion may be inaccurate. Consider using '#align antitone.right_lim Antitone.rightLim‚Çì'. -/
@[mono]
protected theorem rightLim : Antitone (rightLim f) :=
  hf.dual_right.rightLim
#align antitone.right_lim Antitone.rightLim

/- warning: antitone.right_lim_le_left_lim -> Antitone.rightLim_le_leftLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u1} Œ± (Preorder.toLE.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f y) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LE.le.{u2} Œ± (Preorder.toLE.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f y) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x)))
Case conversion may be inaccurate. Consider using '#align antitone.right_lim_le_left_lim Antitone.rightLim_le_leftLim‚Çì'. -/
theorem rightLim_le_leftLim (h : x ‚â§ y) : rightLim f y ‚â§ leftLim f x :=
  hf.dual_right.leftLim_le_rightLim h
#align antitone.right_lim_le_left_lim Antitone.rightLim_le_leftLim

/- warning: antitone.left_lim_le_right_lim -> Antitone.leftLim_le_rightLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u1} Œ± (Preorder.toLT.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))) x y) -> (LE.le.{u2} Œ≤ (Preorder.toLE.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f y) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} {y : Œ±}, (LT.lt.{u2} Œ± (Preorder.toLT.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))) x y) -> (LE.le.{u1} Œ≤ (Preorder.toLE.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f y) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x)))
Case conversion may be inaccurate. Consider using '#align antitone.left_lim_le_right_lim Antitone.leftLim_le_rightLim‚Çì'. -/
theorem leftLim_le_rightLim (h : x < y) : leftLim f y ‚â§ rightLim f x :=
  hf.dual_right.rightLim_le_leftLim h
#align antitone.left_lim_le_right_lim Antitone.leftLim_le_rightLim

variable [TopologicalSpace Œ±] [OrderTopology Œ±]

/- warning: antitone.tendsto_left_lim -> Antitone.tendsto_leftLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))] (x : Œ±), Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± _inst_5 x (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x)) (nhds.{u2} Œ≤ _inst_3 (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))] (x : Œ±), Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± _inst_5 x (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x)) (nhds.{u1} Œ≤ _inst_3 (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x)))
Case conversion may be inaccurate. Consider using '#align antitone.tendsto_left_lim Antitone.tendsto_leftLim‚Çì'. -/
theorem tendsto_leftLim (x : Œ±) : Tendsto f (ùìù[<] x) (ùìù (leftLim f x)) :=
  hf.dual_right.tendsto_leftLim x
#align antitone.tendsto_left_lim Antitone.tendsto_leftLim

/- warning: antitone.tendsto_left_lim_within -> Antitone.tendsto_leftLim_within is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))] (x : Œ±), Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± _inst_5 x (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x)) (nhdsWithin.{u2} Œ≤ _inst_3 (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (Set.Ici.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))] (x : Œ±), Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± _inst_5 x (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x)) (nhdsWithin.{u1} Œ≤ _inst_3 (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (Set.Ici.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x))))
Case conversion may be inaccurate. Consider using '#align antitone.tendsto_left_lim_within Antitone.tendsto_leftLim_within‚Çì'. -/
theorem tendsto_leftLim_within (x : Œ±) : Tendsto f (ùìù[<] x) (ùìù[‚â•] leftLim f x) :=
  hf.dual_right.tendsto_leftLim_within x
#align antitone.tendsto_left_lim_within Antitone.tendsto_leftLim_within

/- warning: antitone.tendsto_right_lim -> Antitone.tendsto_rightLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))] (x : Œ±), Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± _inst_5 x (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x)) (nhds.{u2} Œ≤ _inst_3 (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))] (x : Œ±), Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± _inst_5 x (Set.Ioi.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x)) (nhds.{u1} Œ≤ _inst_3 (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x)))
Case conversion may be inaccurate. Consider using '#align antitone.tendsto_right_lim Antitone.tendsto_rightLim‚Çì'. -/
theorem tendsto_rightLim (x : Œ±) : Tendsto f (ùìù[>] x) (ùìù (rightLim f x)) :=
  hf.dual_right.tendsto_rightLim x
#align antitone.tendsto_right_lim Antitone.tendsto_rightLim

/- warning: antitone.tendsto_right_lim_within -> Antitone.tendsto_rightLim_within is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))] (x : Œ±), Filter.Tendsto.{u1, u2} Œ± Œ≤ f (nhdsWithin.{u1} Œ± _inst_5 x (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x)) (nhdsWithin.{u2} Œ≤ _inst_3 (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (Set.Iic.{u2} Œ≤ (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))] (x : Œ±), Filter.Tendsto.{u2, u1} Œ± Œ≤ f (nhdsWithin.{u2} Œ± _inst_5 x (Set.Ioi.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x)) (nhdsWithin.{u1} Œ≤ _inst_3 (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (Set.Iic.{u1} Œ≤ (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x))))
Case conversion may be inaccurate. Consider using '#align antitone.tendsto_right_lim_within Antitone.tendsto_rightLim_within‚Çì'. -/
theorem tendsto_rightLim_within (x : Œ±) : Tendsto f (ùìù[>] x) (ùìù[‚â§] rightLim f x) :=
  hf.dual_right.tendsto_rightLim_within x
#align antitone.tendsto_right_lim_within Antitone.tendsto_rightLim_within

/- warning: antitone.continuous_within_at_Iio_iff_left_lim_eq -> Antitone.continuousWithinAt_Iio_iff_leftLim_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))], Iff (ContinuousWithinAt.{u1, u2} Œ± Œ≤ _inst_5 _inst_3 f (Set.Iio.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x) x) (Eq.{succ u2} Œ≤ (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))], Iff (ContinuousWithinAt.{u2, u1} Œ± Œ≤ _inst_5 _inst_3 f (Set.Iio.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x) x) (Eq.{succ u1} Œ≤ (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (f x)))
Case conversion may be inaccurate. Consider using '#align antitone.continuous_within_at_Iio_iff_left_lim_eq Antitone.continuousWithinAt_Iio_iff_leftLim_eq‚Çì'. -/
/-- An antitone function is continuous to the left at a point if and only if its left limit
coincides with the value of the function. -/
theorem continuousWithinAt_Iio_iff_leftLim_eq :
    ContinuousWithinAt f (Iio x) x ‚Üî leftLim f x = f x :=
  hf.dual_right.continuousWithinAt_Iio_iff_leftLim_eq
#align antitone.continuous_within_at_Iio_iff_left_lim_eq Antitone.continuousWithinAt_Iio_iff_leftLim_eq

/- warning: antitone.continuous_within_at_Ioi_iff_right_lim_eq -> Antitone.continuousWithinAt_Ioi_iff_rightLim_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))], Iff (ContinuousWithinAt.{u1, u2} Œ± Œ≤ _inst_5 _inst_3 f (Set.Ioi.{u1} Œ± (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) x) x) (Eq.{succ u2} Œ≤ (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))], Iff (ContinuousWithinAt.{u2, u1} Œ± Œ≤ _inst_5 _inst_3 f (Set.Ioi.{u2} Œ± (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) x) x) (Eq.{succ u1} Œ≤ (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (f x)))
Case conversion may be inaccurate. Consider using '#align antitone.continuous_within_at_Ioi_iff_right_lim_eq Antitone.continuousWithinAt_Ioi_iff_rightLim_eq‚Çì'. -/
/-- An antitone function is continuous to the right at a point if and only if its right limit
coincides with the value of the function. -/
theorem continuousWithinAt_Ioi_iff_rightLim_eq :
    ContinuousWithinAt f (Ioi x) x ‚Üî rightLim f x = f x :=
  hf.dual_right.continuousWithinAt_Ioi_iff_rightLim_eq
#align antitone.continuous_within_at_Ioi_iff_right_lim_eq Antitone.continuousWithinAt_Ioi_iff_rightLim_eq

/- warning: antitone.continuous_at_iff_left_lim_eq_right_lim -> Antitone.continuousAt_iff_leftLim_eq_rightLim is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : LinearOrder.{u1} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≤] [_inst_4 : OrderTopology.{u2} Œ≤ _inst_3 (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u1, u2} Œ± Œ≤ (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1)))) (PartialOrder.toPreorder.{u2} Œ≤ (SemilatticeInf.toPartialOrder.{u2} Œ≤ (Lattice.toSemilatticeInf.{u2} Œ≤ (ConditionallyCompleteLattice.toLattice.{u2} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u2} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u1} Œ±] [_inst_6 : OrderTopology.{u1} Œ± _inst_5 (PartialOrder.toPreorder.{u1} Œ± (SemilatticeInf.toPartialOrder.{u1} Œ± (Lattice.toSemilatticeInf.{u1} Œ± (LinearOrder.toLattice.{u1} Œ± _inst_1))))], Iff (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_5 _inst_3 f x) (Eq.{succ u2} Œ≤ (Function.leftLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x) (Function.rightLim.{u1, u2} Œ± Œ≤ _inst_1 _inst_3 f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : LinearOrder.{u2} Œ±] [_inst_2 : ConditionallyCompleteLinearOrder.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≤] [_inst_4 : OrderTopology.{u1} Œ≤ _inst_3 (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2)))))] {f : Œ± -> Œ≤}, (Antitone.{u2, u1} Œ± Œ≤ (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1))))) (PartialOrder.toPreorder.{u1} Œ≤ (SemilatticeInf.toPartialOrder.{u1} Œ≤ (Lattice.toSemilatticeInf.{u1} Œ≤ (ConditionallyCompleteLattice.toLattice.{u1} Œ≤ (ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice.{u1} Œ≤ _inst_2))))) f) -> (forall {x : Œ±} [_inst_5 : TopologicalSpace.{u2} Œ±] [_inst_6 : OrderTopology.{u2} Œ± _inst_5 (PartialOrder.toPreorder.{u2} Œ± (SemilatticeInf.toPartialOrder.{u2} Œ± (Lattice.toSemilatticeInf.{u2} Œ± (DistribLattice.toLattice.{u2} Œ± (instDistribLattice.{u2} Œ± _inst_1)))))], Iff (ContinuousAt.{u2, u1} Œ± Œ≤ _inst_5 _inst_3 f x) (Eq.{succ u1} Œ≤ (Function.leftLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x) (Function.rightLim.{u2, u1} Œ± Œ≤ _inst_1 _inst_3 f x)))
Case conversion may be inaccurate. Consider using '#align antitone.continuous_at_iff_left_lim_eq_right_lim Antitone.continuousAt_iff_leftLim_eq_rightLim‚Çì'. -/
/-- An antitone function is continuous at a point if and only if its left and right limits
coincide. -/
theorem continuousAt_iff_leftLim_eq_rightLim : ContinuousAt f x ‚Üî leftLim f x = rightLim f x :=
  hf.dual_right.continuousAt_iff_leftLim_eq_rightLim
#align antitone.continuous_at_iff_left_lim_eq_right_lim Antitone.continuousAt_iff_leftLim_eq_rightLim

#print Antitone.countable_not_continuousAt /-
/-- In a second countable space, the set of points where an antitone function is not continuous
is at most countable. -/
theorem countable_not_continuousAt [TopologicalSpace.SecondCountableTopology Œ≤] :
    Set.Countable { x | ¬¨ContinuousAt f x } :=
  hf.dual_right.countable_not_continuousAt
#align antitone.countable_not_continuous_at Antitone.countable_not_continuousAt
-/

end Antitone

