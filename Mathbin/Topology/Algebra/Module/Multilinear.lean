/-
Copyright (c) 2020 Sébastien Gouëzel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sébastien Gouëzel

! This file was ported from Lean 3 source module topology.algebra.module.multilinear
! leanprover-community/mathlib commit f2b757fc5c341d88741b9c4630b1e8ba973c5726
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Algebra.Module.Basic
import Mathbin.LinearAlgebra.Multilinear.Basic

/-!
# Continuous multilinear maps

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define continuous multilinear maps as maps from `Π(i : ι), M₁ i` to `M₂` which are multilinear
and continuous, by extending the space of multilinear maps with a continuity assumption.
Here, `M₁ i` and `M₂` are modules over a ring `R`, and `ι` is an arbitrary type, and all these
spaces are also topological spaces.

## Main definitions

* `continuous_multilinear_map R M₁ M₂` is the space of continuous multilinear maps from
  `Π(i : ι), M₁ i` to `M₂`. We show that it is an `R`-module.

## Implementation notes

We mostly follow the API of multilinear maps.

## Notation

We introduce the notation `M [×n]→L[R] M'` for the space of continuous `n`-multilinear maps from
`M^n` to `M'`. This is a particular case of the general notion (where we allow varying dependent
types as the arguments of our continuous multilinear maps), but arguably the most important one,
especially when defining iterated derivatives.
-/


open Function Fin Set

open BigOperators

universe u v w w₁ w₁' w₂ w₃ w₄

variable {R : Type u} {ι : Type v} {n : ℕ} {M : Fin n.succ → Type w} {M₁ : ι → Type w₁}
  {M₁' : ι → Type w₁'} {M₂ : Type w₂} {M₃ : Type w₃} {M₄ : Type w₄}

#print ContinuousMultilinearMap /-
/-- Continuous multilinear maps over the ring `R`, from `Πi, M₁ i` to `M₂` where `M₁ i` and `M₂`
are modules over `R` with a topological structure. In applications, there will be compatibility
conditions between the algebraic and the topological structures, but this is not needed for the
definition. -/
structure ContinuousMultilinearMap (R : Type u) {ι : Type v} (M₁ : ι → Type w₁) (M₂ : Type w₂)
  [Semiring R] [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [∀ i, Module R (M₁ i)] [Module R M₂]
  [∀ i, TopologicalSpace (M₁ i)] [TopologicalSpace M₂] extends MultilinearMap R M₁ M₂ where
  cont : Continuous to_fun
#align continuous_multilinear_map ContinuousMultilinearMap
-/

-- mathport name: «expr [× ]→L[ ] »
notation:25 M "[×" n "]→L[" R "] " M' => ContinuousMultilinearMap R (fun i : Fin n => M) M'

namespace ContinuousMultilinearMap

section Semiring

variable [Semiring R] [∀ i, AddCommMonoid (M i)] [∀ i, AddCommMonoid (M₁ i)]
  [∀ i, AddCommMonoid (M₁' i)] [AddCommMonoid M₂] [AddCommMonoid M₃] [AddCommMonoid M₄]
  [∀ i, Module R (M i)] [∀ i, Module R (M₁ i)] [∀ i, Module R (M₁' i)] [Module R M₂] [Module R M₃]
  [Module R M₄] [∀ i, TopologicalSpace (M i)] [∀ i, TopologicalSpace (M₁ i)]
  [∀ i, TopologicalSpace (M₁' i)] [TopologicalSpace M₂] [TopologicalSpace M₃] [TopologicalSpace M₄]
  (f f' : ContinuousMultilinearMap R M₁ M₂)

#print ContinuousMultilinearMap.toMultilinearMap_injective /-
theorem toMultilinearMap_injective :
    Function.Injective
      (ContinuousMultilinearMap.toMultilinearMap :
        ContinuousMultilinearMap R M₁ M₂ → MultilinearMap R M₁ M₂)
  | ⟨f, hf⟩, ⟨g, hg⟩, rfl => rfl
#align continuous_multilinear_map.to_multilinear_map_injective ContinuousMultilinearMap.toMultilinearMap_injective
-/

#print ContinuousMultilinearMap.continuousMapClass /-
instance continuousMapClass : ContinuousMapClass (ContinuousMultilinearMap R M₁ M₂) (∀ i, M₁ i) M₂
    where
  coe f := f.toFun
  coe_injective' f g h := toMultilinearMap_injective <| MultilinearMap.coe_injective h
  map_continuous := ContinuousMultilinearMap.cont
#align continuous_multilinear_map.continuous_map_class ContinuousMultilinearMap.continuousMapClass
-/

instance : CoeFun (ContinuousMultilinearMap R M₁ M₂) fun _ => (∀ i, M₁ i) → M₂ :=
  ⟨fun f => f⟩

#print ContinuousMultilinearMap.Simps.apply /-
/-- See Note [custom simps projection]. We need to specify this projection explicitly in this case,
  because it is a composition of multiple projections. -/
def Simps.apply (L₁ : ContinuousMultilinearMap R M₁ M₂) (v : ∀ i, M₁ i) : M₂ :=
  L₁ v
#align continuous_multilinear_map.simps.apply ContinuousMultilinearMap.Simps.apply
-/

initialize_simps_projections ContinuousMultilinearMap (-toMultilinearMap,
  to_multilinear_map_to_fun → apply)

#print ContinuousMultilinearMap.coe_continuous /-
@[continuity]
theorem coe_continuous : Continuous (f : (∀ i, M₁ i) → M₂) :=
  f.cont
#align continuous_multilinear_map.coe_continuous ContinuousMultilinearMap.coe_continuous
-/

#print ContinuousMultilinearMap.coe_coe /-
@[simp]
theorem coe_coe : (f.toMultilinearMap : (∀ i, M₁ i) → M₂) = f :=
  rfl
#align continuous_multilinear_map.coe_coe ContinuousMultilinearMap.coe_coe
-/

#print ContinuousMultilinearMap.ext /-
@[ext]
theorem ext {f f' : ContinuousMultilinearMap R M₁ M₂} (H : ∀ x, f x = f' x) : f = f' :=
  FunLike.ext _ _ H
#align continuous_multilinear_map.ext ContinuousMultilinearMap.ext
-/

#print ContinuousMultilinearMap.ext_iff /-
theorem ext_iff {f f' : ContinuousMultilinearMap R M₁ M₂} : f = f' ↔ ∀ x, f x = f' x := by
  rw [← to_multilinear_map_injective.eq_iff, MultilinearMap.ext_iff] <;> rfl
#align continuous_multilinear_map.ext_iff ContinuousMultilinearMap.ext_iff
-/

/- warning: continuous_multilinear_map.map_add -> ContinuousMultilinearMap.map_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) [_inst_20 : DecidableEq.{succ u2} ι] (m : forall (i : ι), M₁ i) (i : ι) (x : M₁ i) (y : M₁ i), Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i (HAdd.hAdd.{u3, u3, u3} (M₁ i) (M₁ i) (M₁ i) (instHAdd.{u3} (M₁ i) (AddZeroClass.toHasAdd.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i))))) x y))) (HAdd.hAdd.{u4, u4, u4} M₂ M₂ M₂ (instHAdd.{u4} M₂ (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i x)) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i y)))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) [_inst_20 : DecidableEq.{succ u2} ι] (m : forall (i : ι), M₁ i) (i : ι) (x : M₁ i) (y : M₁ i), Eq.{succ u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i (HAdd.hAdd.{u3, u3, u3} (M₁ i) (M₁ i) (M₁ i) (instHAdd.{u3} (M₁ i) (AddZeroClass.toAdd.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i))))) x y))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i (HAdd.hAdd.{u3, u3, u3} (M₁ i) (M₁ i) (M₁ i) (instHAdd.{u3} (M₁ i) (AddZeroClass.toAdd.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i))))) x y))) (HAdd.hAdd.{u4, u4, u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i x)) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i y)) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i x)) (instHAdd.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i x)) (AddZeroClass.toAdd.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i x)) (AddMonoid.toAddZeroClass.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i x)) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i x)) _inst_5)))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i x)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_20 a b) m i y)))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.map_add ContinuousMultilinearMap.map_addₓ'. -/
@[simp]
theorem map_add [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i) :
    f (update m i (x + y)) = f (update m i x) + f (update m i y) :=
  f.map_add' m i x y
#align continuous_multilinear_map.map_add ContinuousMultilinearMap.map_add

#print ContinuousMultilinearMap.map_smul /-
@[simp]
theorem map_smul [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (c : R) (x : M₁ i) :
    f (update m i (c • x)) = c • f (update m i x) :=
  f.map_smul' m i c x
#align continuous_multilinear_map.map_smul ContinuousMultilinearMap.map_smul
-/

/- warning: continuous_multilinear_map.map_coord_zero -> ContinuousMultilinearMap.map_coord_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) {m : forall (i : ι), M₁ i} (i : ι), (Eq.{succ u3} (M₁ i) (m i) (OfNat.ofNat.{u3} (M₁ i) 0 (OfNat.mk.{u3} (M₁ i) 0 (Zero.zero.{u3} (M₁ i) (AddZeroClass.toHasZero.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))))))) -> (Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f m) (OfNat.ofNat.{u4} M₂ 0 (OfNat.mk.{u4} M₂ 0 (Zero.zero.{u4} M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))))))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) {m : forall (i : ι), M₁ i} (i : ι), (Eq.{succ u3} (M₁ i) (m i) (OfNat.ofNat.{u3} (M₁ i) 0 (Zero.toOfNat0.{u3} (M₁ i) (AddMonoid.toZero.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))))) -> (Eq.{succ u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f m) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) _inst_5)))))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.map_coord_zero ContinuousMultilinearMap.map_coord_zeroₓ'. -/
theorem map_coord_zero {m : ∀ i, M₁ i} (i : ι) (h : m i = 0) : f m = 0 :=
  f.toMultilinearMap.map_coord_zero i h
#align continuous_multilinear_map.map_coord_zero ContinuousMultilinearMap.map_coord_zero

/- warning: continuous_multilinear_map.map_zero -> ContinuousMultilinearMap.map_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) [_inst_20 : Nonempty.{succ u2} ι], Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (OfNat.ofNat.{max u2 u3} (forall (i : ι), M₁ i) 0 (OfNat.mk.{max u2 u3} (forall (i : ι), M₁ i) 0 (Zero.zero.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instZero.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i))))))))) (OfNat.ofNat.{u4} M₂ 0 (OfNat.mk.{u4} M₂ 0 (Zero.zero.{u4} M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))))))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) [_inst_20 : Nonempty.{succ u2} ι], Eq.{succ u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (OfNat.ofNat.{max u2 u3} (forall (i : ι), M₁ i) 0 (Zero.toOfNat0.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instZero.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddMonoid.toZero.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i))))))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (OfNat.ofNat.{max u2 u3} (forall (i : ι), M₁ i) 0 (Zero.toOfNat0.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instZero.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddMonoid.toZero.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i))))))) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (OfNat.ofNat.{max u2 u3} (forall (i : ι), M₁ i) 0 (Zero.toOfNat0.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instZero.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddMonoid.toZero.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i))))))) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (OfNat.ofNat.{max u2 u3} (forall (i : ι), M₁ i) 0 (Zero.toOfNat0.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instZero.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddMonoid.toZero.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i))))))) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (OfNat.ofNat.{max u2 u3} (forall (i : ι), M₁ i) 0 (Zero.toOfNat0.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instZero.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddMonoid.toZero.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i))))))) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (OfNat.ofNat.{max u2 u3} (forall (i : ι), M₁ i) 0 (Zero.toOfNat0.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instZero.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddMonoid.toZero.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i))))))) _inst_5))))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.map_zero ContinuousMultilinearMap.map_zeroₓ'. -/
@[simp]
theorem map_zero [Nonempty ι] : f 0 = 0 :=
  f.toMultilinearMap.map_zero
#align continuous_multilinear_map.map_zero ContinuousMultilinearMap.map_zero

instance : Zero (ContinuousMultilinearMap R M₁ M₂) :=
  ⟨{ (0 : MultilinearMap R M₁ M₂) with cont := continuous_const }⟩

instance : Inhabited (ContinuousMultilinearMap R M₁ M₂) :=
  ⟨0⟩

/- warning: continuous_multilinear_map.zero_apply -> ContinuousMultilinearMap.zero_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (m : forall (i : ι), M₁ i), Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (OfNat.ofNat.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) 0 (OfNat.mk.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) 0 (Zero.zero.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.hasZero.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17)))) m) (OfNat.ofNat.{u4} M₂ 0 (OfNat.mk.{u4} M₂ 0 (Zero.zero.{u4} M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))))))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (m : forall (i : ι), M₁ i), Eq.{succ u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) (OfNat.ofNat.{max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) 0 (Zero.toOfNat0.{max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.instZeroContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17))) m) (OfNat.ofNat.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) 0 (Zero.toOfNat0.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddMonoid.toZero.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) _inst_5))))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.zero_apply ContinuousMultilinearMap.zero_applyₓ'. -/
@[simp]
theorem zero_apply (m : ∀ i, M₁ i) : (0 : ContinuousMultilinearMap R M₁ M₂) m = 0 :=
  rfl
#align continuous_multilinear_map.zero_apply ContinuousMultilinearMap.zero_apply

/- warning: continuous_multilinear_map.to_multilinear_map_zero -> ContinuousMultilinearMap.toMultilinearMap_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂], Eq.{max (succ u2) (succ u3) (succ u4)} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (ContinuousMultilinearMap.toMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 (OfNat.ofNat.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) 0 (OfNat.mk.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) 0 (Zero.zero.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.hasZero.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17))))) (OfNat.ofNat.{max u2 u3 u4} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) 0 (OfNat.mk.{max u2 u3 u4} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) 0 (Zero.zero.{max u2 u3 u4} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (MultilinearMap.hasZero.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11))))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂], Eq.{max (max (succ u2) (succ u3)) (succ u4)} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (ContinuousMultilinearMap.toMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 (OfNat.ofNat.{max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) 0 (Zero.toOfNat0.{max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.instZeroContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17)))) (OfNat.ofNat.{max (max u2 u3) u4} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) 0 (Zero.toOfNat0.{max (max u2 u3) u4} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (MultilinearMap.instZeroMultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11)))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.to_multilinear_map_zero ContinuousMultilinearMap.toMultilinearMap_zeroₓ'. -/
@[simp]
theorem toMultilinearMap_zero : (0 : ContinuousMultilinearMap R M₁ M₂).toMultilinearMap = 0 :=
  rfl
#align continuous_multilinear_map.to_multilinear_map_zero ContinuousMultilinearMap.toMultilinearMap_zero

section SMul

variable {R' R'' A : Type _} [Monoid R'] [Monoid R''] [Semiring A] [∀ i, Module A (M₁ i)]
  [Module A M₂] [DistribMulAction R' M₂] [ContinuousConstSMul R' M₂] [SMulCommClass A R' M₂]
  [DistribMulAction R'' M₂] [ContinuousConstSMul R'' M₂] [SMulCommClass A R'' M₂]

instance : SMul R' (ContinuousMultilinearMap A M₁ M₂) :=
  ⟨fun c f => { c • f.toMultilinearMap with cont := f.cont.const_smul c }⟩

/- warning: continuous_multilinear_map.smul_apply -> ContinuousMultilinearMap.smul_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M₁ : ι -> Type.{u2}} {M₂ : Type.{u3}} [_inst_3 : forall (i : ι), AddCommMonoid.{u2} (M₁ i)] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_15 : forall (i : ι), TopologicalSpace.{u2} (M₁ i)] [_inst_17 : TopologicalSpace.{u3} M₂] {R' : Type.{u4}} {A : Type.{u5}} [_inst_20 : Monoid.{u4} R'] [_inst_22 : Semiring.{u5} A] [_inst_23 : forall (i : ι), Module.{u5, u2} A (M₁ i) _inst_22 (_inst_3 i)] [_inst_24 : Module.{u5, u3} A M₂ _inst_22 _inst_5] [_inst_25 : DistribMulAction.{u4, u3} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)] [_inst_26 : ContinuousConstSMul.{u4, u3} R' M₂ _inst_17 (SMulZeroClass.toHasSmul.{u4, u3} R' M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u4, u3} R' M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u4, u3} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) _inst_25)))] [_inst_27 : SMulCommClass.{u5, u4, u3} A R' M₂ (SMulZeroClass.toHasSmul.{u5, u3} A M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u5, u3} A M₂ (MulZeroClass.toHasZero.{u5} A (MulZeroOneClass.toMulZeroClass.{u5} A (MonoidWithZero.toMulZeroOneClass.{u5} A (Semiring.toMonoidWithZero.{u5} A _inst_22)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u5, u3} A M₂ (Semiring.toMonoidWithZero.{u5} A _inst_22) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (Module.toMulActionWithZero.{u5, u3} A M₂ _inst_22 _inst_5 _inst_24)))) (SMulZeroClass.toHasSmul.{u4, u3} R' M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u4, u3} R' M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u4, u3} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) _inst_25)))] (f : ContinuousMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (c : R') (m : forall (i : ι), M₁ i), Eq.{succ u3} M₂ (coeFn.{max (succ u1) (succ u2) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (ContinuousMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (SMul.smul.{u4, max u1 u2 u3} R' (ContinuousMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.hasSmul.{u1, u2, u3, u4, u5} ι M₁ M₂ (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_15 i) _inst_17 R' A _inst_20 _inst_22 (fun (i : ι) => _inst_23 i) _inst_24 _inst_25 _inst_26 _inst_27) c f) m) (SMul.smul.{u4, u3} R' M₂ (SMulZeroClass.toHasSmul.{u4, u3} R' M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u4, u3} R' M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u4, u3} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) _inst_25))) c (coeFn.{max (succ u1) (succ u2) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (ContinuousMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) f m))
but is expected to have type
  forall {ι : Type.{u3}} {M₁ : ι -> Type.{u4}} {M₂ : Type.{u5}} [_inst_3 : forall (i : ι), AddCommMonoid.{u4} (M₁ i)] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_15 : forall (i : ι), TopologicalSpace.{u4} (M₁ i)] [_inst_17 : TopologicalSpace.{u5} M₂] {R' : Type.{u1}} {A : Type.{u2}} [_inst_20 : Monoid.{u1} R'] [_inst_22 : Semiring.{u2} A] [_inst_23 : forall (i : ι), Module.{u2, u4} A (M₁ i) _inst_22 (_inst_3 i)] [_inst_24 : Module.{u2, u5} A M₂ _inst_22 _inst_5] [_inst_25 : DistribMulAction.{u1, u5} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)] [_inst_26 : ContinuousConstSMul.{u1, u5} R' M₂ _inst_17 (SMulZeroClass.toSMul.{u1, u5} R' M₂ (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u1, u5} R' M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u5} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5) _inst_25)))] [_inst_27 : SMulCommClass.{u2, u1, u5} A R' M₂ (SMulZeroClass.toSMul.{u2, u5} A M₂ (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u2, u5} A M₂ (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_22)) (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u2, u5} A M₂ (Semiring.toMonoidWithZero.{u2} A _inst_22) (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (Module.toMulActionWithZero.{u2, u5} A M₂ _inst_22 _inst_5 _inst_24)))) (SMulZeroClass.toSMul.{u1, u5} R' M₂ (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u1, u5} R' M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u5} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5) _inst_25)))] (f : ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (c : R') (m : forall (i : ι), M₁ i), Eq.{succ u5} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u5), max (succ u3) (succ u4), succ u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_23 i) i) _inst_24 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u3 u4) u5, max u3 u4, u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_23 i) i) _inst_24 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u3, u4} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_23 i) i) _inst_24 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) (HSMul.hSMul.{u1, max (max u3 u4) u5, max (max u3 u4) u5} R' (ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (instHSMul.{u1, max (max u3 u4) u5} R' (ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.instSMulContinuousMultilinearMap.{u3, u4, u5, u1, u2} ι M₁ M₂ (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_15 i) _inst_17 R' A _inst_20 _inst_22 (fun (i : ι) => _inst_23 i) _inst_24 _inst_25 _inst_26 _inst_27)) c f) m) (HSMul.hSMul.{u1, u5, u5} R' ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (instHSMul.{u1, u5} R' ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (SMulZeroClass.toSMul.{u1, u5} R' ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddMonoid.toZero.{u5} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddCommMonoid.toAddMonoid.{u5} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) _inst_5)) (DistribSMul.toSMulZeroClass.{u1, u5} R' ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddMonoid.toAddZeroClass.{u5} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddCommMonoid.toAddMonoid.{u5} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) _inst_5)) (DistribMulAction.toDistribSMul.{u1, u5} R' ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) _inst_20 (AddCommMonoid.toAddMonoid.{u5} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) _inst_5) _inst_25)))) c (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u5), max (succ u3) (succ u4), succ u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_23 i) i) _inst_24 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u3 u4) u5, max u3 u4, u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_23 i) i) _inst_24 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u3, u4} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_23 i) i) _inst_24 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f m))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.smul_apply ContinuousMultilinearMap.smul_applyₓ'. -/
@[simp]
theorem smul_apply (f : ContinuousMultilinearMap A M₁ M₂) (c : R') (m : ∀ i, M₁ i) :
    (c • f) m = c • f m :=
  rfl
#align continuous_multilinear_map.smul_apply ContinuousMultilinearMap.smul_apply

/- warning: continuous_multilinear_map.to_multilinear_map_smul -> ContinuousMultilinearMap.toMultilinearMap_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M₁ : ι -> Type.{u2}} {M₂ : Type.{u3}} [_inst_3 : forall (i : ι), AddCommMonoid.{u2} (M₁ i)] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_15 : forall (i : ι), TopologicalSpace.{u2} (M₁ i)] [_inst_17 : TopologicalSpace.{u3} M₂] {R' : Type.{u4}} {A : Type.{u5}} [_inst_20 : Monoid.{u4} R'] [_inst_22 : Semiring.{u5} A] [_inst_23 : forall (i : ι), Module.{u5, u2} A (M₁ i) _inst_22 (_inst_3 i)] [_inst_24 : Module.{u5, u3} A M₂ _inst_22 _inst_5] [_inst_25 : DistribMulAction.{u4, u3} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)] [_inst_26 : ContinuousConstSMul.{u4, u3} R' M₂ _inst_17 (SMulZeroClass.toHasSmul.{u4, u3} R' M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u4, u3} R' M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u4, u3} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) _inst_25)))] [_inst_27 : SMulCommClass.{u5, u4, u3} A R' M₂ (SMulZeroClass.toHasSmul.{u5, u3} A M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u5, u3} A M₂ (MulZeroClass.toHasZero.{u5} A (MulZeroOneClass.toMulZeroClass.{u5} A (MonoidWithZero.toMulZeroOneClass.{u5} A (Semiring.toMonoidWithZero.{u5} A _inst_22)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u5, u3} A M₂ (Semiring.toMonoidWithZero.{u5} A _inst_22) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (Module.toMulActionWithZero.{u5, u3} A M₂ _inst_22 _inst_5 _inst_24)))) (SMulZeroClass.toHasSmul.{u4, u3} R' M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (DistribSMul.toSmulZeroClass.{u4, u3} R' M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u4, u3} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5) _inst_25)))] (c : R') (f : ContinuousMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17), Eq.{max (succ u1) (succ u2) (succ u3)} (MultilinearMap.{u5, u2, u3, u1} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24) (ContinuousMultilinearMap.toMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17 (SMul.smul.{u4, max u1 u2 u3} R' (ContinuousMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.hasSmul.{u1, u2, u3, u4, u5} ι M₁ M₂ (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_15 i) _inst_17 R' A _inst_20 _inst_22 (fun (i : ι) => _inst_23 i) _inst_24 _inst_25 _inst_26 _inst_27) c f)) (SMul.smul.{u4, max u1 u2 u3} R' (MultilinearMap.{u5, u2, u3, u1} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24) (MultilinearMap.hasSmul.{u2, u3, u1, u4, u5} ι M₁ M₂ (fun (i : ι) => _inst_3 i) _inst_5 R' A _inst_20 _inst_22 (fun (i : ι) => _inst_23 i) _inst_25 _inst_24 _inst_27) c (ContinuousMultilinearMap.toMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17 f))
but is expected to have type
  forall {ι : Type.{u3}} {M₁ : ι -> Type.{u4}} {M₂ : Type.{u5}} [_inst_3 : forall (i : ι), AddCommMonoid.{u4} (M₁ i)] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_15 : forall (i : ι), TopologicalSpace.{u4} (M₁ i)] [_inst_17 : TopologicalSpace.{u5} M₂] {R' : Type.{u1}} {A : Type.{u2}} [_inst_20 : Monoid.{u1} R'] [_inst_22 : Semiring.{u2} A] [_inst_23 : forall (i : ι), Module.{u2, u4} A (M₁ i) _inst_22 (_inst_3 i)] [_inst_24 : Module.{u2, u5} A M₂ _inst_22 _inst_5] [_inst_25 : DistribMulAction.{u1, u5} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)] [_inst_26 : ContinuousConstSMul.{u1, u5} R' M₂ _inst_17 (SMulZeroClass.toSMul.{u1, u5} R' M₂ (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u1, u5} R' M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u5} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5) _inst_25)))] [_inst_27 : SMulCommClass.{u2, u1, u5} A R' M₂ (SMulZeroClass.toSMul.{u2, u5} A M₂ (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u2, u5} A M₂ (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_22)) (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u2, u5} A M₂ (Semiring.toMonoidWithZero.{u2} A _inst_22) (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (Module.toMulActionWithZero.{u2, u5} A M₂ _inst_22 _inst_5 _inst_24)))) (SMulZeroClass.toSMul.{u1, u5} R' M₂ (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribSMul.toSMulZeroClass.{u1, u5} R' M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u5} R' M₂ _inst_20 (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5) _inst_25)))] (c : R') (f : ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17), Eq.{max (max (succ u3) (succ u4)) (succ u5)} (MultilinearMap.{u2, u4, u5, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24) (ContinuousMultilinearMap.toMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17 (HSMul.hSMul.{u1, max (max u3 u4) u5, max (max u3 u4) u5} R' (ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (instHSMul.{u1, max (max u3 u4) u5} R' (ContinuousMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.instSMulContinuousMultilinearMap.{u3, u4, u5, u1, u2} ι M₁ M₂ (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_15 i) _inst_17 R' A _inst_20 _inst_22 (fun (i : ι) => _inst_23 i) _inst_24 _inst_25 _inst_26 _inst_27)) c f)) (HSMul.hSMul.{u1, max (max u3 u4) u5, max (max u3 u4) u5} R' (MultilinearMap.{u2, u4, u5, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24) (MultilinearMap.{u2, u4, u5, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24) (instHSMul.{u1, max (max u3 u4) u5} R' (MultilinearMap.{u2, u4, u5, u3} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24) (MultilinearMap.instSMulMultilinearMap.{u4, u5, u3, u1, u2} ι M₁ M₂ (fun (i : ι) => _inst_3 i) _inst_5 R' A _inst_20 _inst_22 (fun (i : ι) => _inst_23 i) _inst_25 _inst_24 _inst_27)) c (ContinuousMultilinearMap.toMultilinearMap.{u2, u3, u4, u5} A ι M₁ M₂ _inst_22 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_23 i) _inst_24 (fun (i : ι) => _inst_15 i) _inst_17 f))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.to_multilinear_map_smul ContinuousMultilinearMap.toMultilinearMap_smulₓ'. -/
@[simp]
theorem toMultilinearMap_smul (c : R') (f : ContinuousMultilinearMap A M₁ M₂) :
    (c • f).toMultilinearMap = c • f.toMultilinearMap :=
  rfl
#align continuous_multilinear_map.to_multilinear_map_smul ContinuousMultilinearMap.toMultilinearMap_smul

instance [SMulCommClass R' R'' M₂] : SMulCommClass R' R'' (ContinuousMultilinearMap A M₁ M₂) :=
  ⟨fun c₁ c₂ f => ext fun x => smul_comm _ _ _⟩

instance [SMul R' R''] [IsScalarTower R' R'' M₂] :
    IsScalarTower R' R'' (ContinuousMultilinearMap A M₁ M₂) :=
  ⟨fun c₁ c₂ f => ext fun x => smul_assoc _ _ _⟩

instance [DistribMulAction R'ᵐᵒᵖ M₂] [IsCentralScalar R' M₂] :
    IsCentralScalar R' (ContinuousMultilinearMap A M₁ M₂) :=
  ⟨fun c₁ f => ext fun x => op_smul_eq_smul _ _⟩

instance : MulAction R' (ContinuousMultilinearMap A M₁ M₂) :=
  Function.Injective.mulAction toMultilinearMap toMultilinearMap_injective fun _ _ => rfl

end SMul

section ContinuousAdd

variable [ContinuousAdd M₂]

instance : Add (ContinuousMultilinearMap R M₁ M₂) :=
  ⟨fun f f' => ⟨f.toMultilinearMap + f'.toMultilinearMap, f.cont.add f'.cont⟩⟩

/- warning: continuous_multilinear_map.add_apply -> ContinuousMultilinearMap.add_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (f' : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) [_inst_20 : ContinuousAdd.{u4} M₂ _inst_17 (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))] (m : forall (i : ι), M₁ i), Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (HAdd.hAdd.{max u2 u3 u4, max u2 u3 u4, max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (instHAdd.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.hasAdd.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 _inst_20)) f f') m) (HAdd.hAdd.{u4, u4, u4} M₂ M₂ M₂ (instHAdd.{u4} M₂ (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f m) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f' m))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (f' : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) [_inst_20 : ContinuousAdd.{u4} M₂ _inst_17 (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))] (m : forall (i : ι), M₁ i), Eq.{succ u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) (HAdd.hAdd.{max (max u2 u3) u4, max (max u2 u3) u4, max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (instHAdd.{max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.instAddContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 _inst_20)) f f') m) (HAdd.hAdd.{u4, u4, u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (instHAdd.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddZeroClass.toAdd.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddMonoid.toAddZeroClass.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) _inst_5)))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f m) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f' m))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.add_apply ContinuousMultilinearMap.add_applyₓ'. -/
@[simp]
theorem add_apply (m : ∀ i, M₁ i) : (f + f') m = f m + f' m :=
  rfl
#align continuous_multilinear_map.add_apply ContinuousMultilinearMap.add_apply

/- warning: continuous_multilinear_map.to_multilinear_map_add -> ContinuousMultilinearMap.toMultilinearMap_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_20 : ContinuousAdd.{u4} M₂ _inst_17 (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (g : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17), Eq.{max (succ u2) (succ u3) (succ u4)} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (ContinuousMultilinearMap.toMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 (HAdd.hAdd.{max u2 u3 u4, max u2 u3 u4, max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (instHAdd.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.hasAdd.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 _inst_20)) f g)) (HAdd.hAdd.{max u2 u3 u4, max u2 u3 u4, max u2 u3 u4} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (instHAdd.{max u2 u3 u4} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (MultilinearMap.hasAdd.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11)) (ContinuousMultilinearMap.toMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 f) (ContinuousMultilinearMap.toMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 g))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_20 : ContinuousAdd.{u4} M₂ _inst_17 (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (g : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17), Eq.{max (max (succ u2) (succ u3)) (succ u4)} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (ContinuousMultilinearMap.toMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 (HAdd.hAdd.{max (max u2 u3) u4, max (max u2 u3) u4, max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (instHAdd.{max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.instAddContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 _inst_20)) f g)) (HAdd.hAdd.{max (max u2 u3) u4, max (max u2 u3) u4, max (max u2 u3) u4} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (instHAdd.{max (max u2 u3) u4} (MultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11) (MultilinearMap.instAddMultilinearMap.{u1, u3, u4, u2} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11)) (ContinuousMultilinearMap.toMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 f) (ContinuousMultilinearMap.toMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 g))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.to_multilinear_map_add ContinuousMultilinearMap.toMultilinearMap_addₓ'. -/
@[simp]
theorem toMultilinearMap_add (f g : ContinuousMultilinearMap R M₁ M₂) :
    (f + g).toMultilinearMap = f.toMultilinearMap + g.toMultilinearMap :=
  rfl
#align continuous_multilinear_map.to_multilinear_map_add ContinuousMultilinearMap.toMultilinearMap_add

/- warning: continuous_multilinear_map.add_comm_monoid -> ContinuousMultilinearMap.addCommMonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_20 : ContinuousAdd.{u4} M₂ _inst_17 (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))], AddCommMonoid.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17)
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_20 : ContinuousAdd.{u4} M₂ _inst_17 (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))], AddCommMonoid.{max (max u4 u3) u2} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17)
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.add_comm_monoid ContinuousMultilinearMap.addCommMonoidₓ'. -/
instance addCommMonoid : AddCommMonoid (ContinuousMultilinearMap R M₁ M₂) :=
  toMultilinearMap_injective.AddCommMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl
#align continuous_multilinear_map.add_comm_monoid ContinuousMultilinearMap.addCommMonoid

/- warning: continuous_multilinear_map.apply_add_hom -> ContinuousMultilinearMap.applyAddHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_20 : ContinuousAdd.{u4} M₂ _inst_17 (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))], (forall (i : ι), M₁ i) -> (AddMonoidHom.{max u2 u3 u4, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) M₂ (AddMonoid.toAddZeroClass.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (AddCommMonoid.toAddMonoid.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.addCommMonoid.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 _inst_20))) (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_20 : ContinuousAdd.{u4} M₂ _inst_17 (AddZeroClass.toAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))], (forall (i : ι), M₁ i) -> (AddMonoidHom.{max (max u4 u3) u2, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) M₂ (AddMonoid.toAddZeroClass.{max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (AddCommMonoid.toAddMonoid.{max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.addCommMonoid.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 _inst_20))) (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.apply_add_hom ContinuousMultilinearMap.applyAddHomₓ'. -/
/-- Evaluation of a `continuous_multilinear_map` at a vector as an `add_monoid_hom`. -/
def applyAddHom (m : ∀ i, M₁ i) : ContinuousMultilinearMap R M₁ M₂ →+ M₂ :=
  ⟨fun f => f m, rfl, fun _ _ => rfl⟩
#align continuous_multilinear_map.apply_add_hom ContinuousMultilinearMap.applyAddHom

/- warning: continuous_multilinear_map.sum_apply -> ContinuousMultilinearMap.sum_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_20 : ContinuousAdd.{u4} M₂ _inst_17 (AddZeroClass.toHasAdd.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5)))] {α : Type.{u5}} (f : α -> (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17)) (m : forall (i : ι), M₁ i) {s : Finset.{u5} α}, Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (Finset.sum.{max u2 u3 u4, u5} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) α (ContinuousMultilinearMap.addCommMonoid.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 _inst_20) s (fun (a : α) => f a)) m) (Finset.sum.{u4, u5} M₂ α _inst_5 s (fun (a : α) => coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (f a) m))
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u3}} {M₁ : ι -> Type.{u4}} {M₂ : Type.{u5}} [_inst_1 : Semiring.{u2} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u4} (M₁ i)] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_9 : forall (i : ι), Module.{u2, u4} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u2, u5} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u4} (M₁ i)] [_inst_17 : TopologicalSpace.{u5} M₂] [_inst_20 : ContinuousAdd.{u5} M₂ _inst_17 (AddZeroClass.toAdd.{u5} M₂ (AddMonoid.toAddZeroClass.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)))] {α : Type.{u1}} (f : α -> (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17)) (m : forall (i : ι), M₁ i) {s : Finset.{u1} α}, Eq.{succ u5} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u5), max (succ u3) (succ u4), succ u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u3 u4) u5, max u3 u4, u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u3, u4} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) (Finset.sum.{max (max u3 u4) u5, u1} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) α (ContinuousMultilinearMap.addCommMonoid.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 _inst_20) s (fun (a : α) => f a)) m) (Finset.sum.{u5, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) α _inst_5 s (fun (a : α) => FunLike.coe.{max (max (succ u3) (succ u4)) (succ u5), max (succ u3) (succ u4), succ u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u3 u4) u5, max u3 u4, u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u3, u4} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) (f a) m))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.sum_apply ContinuousMultilinearMap.sum_applyₓ'. -/
@[simp]
theorem sum_apply {α : Type _} (f : α → ContinuousMultilinearMap R M₁ M₂) (m : ∀ i, M₁ i)
    {s : Finset α} : (∑ a in s, f a) m = ∑ a in s, f a m :=
  (applyAddHom m).map_sum f s
#align continuous_multilinear_map.sum_apply ContinuousMultilinearMap.sum_apply

end ContinuousAdd

#print ContinuousMultilinearMap.toContinuousLinearMap /-
/-- If `f` is a continuous multilinear map, then `f.to_continuous_linear_map m i` is the continuous
linear map obtained by fixing all coordinates but `i` equal to those of `m`, and varying the
`i`-th coordinate. -/
def toContinuousLinearMap [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) : M₁ i →L[R] M₂ :=
  { f.toMultilinearMap.toLinearMap m i with
    cont := f.cont.comp (continuous_const.update i continuous_id) }
#align continuous_multilinear_map.to_continuous_linear_map ContinuousMultilinearMap.toContinuousLinearMap
-/

/- warning: continuous_multilinear_map.prod -> ContinuousMultilinearMap.prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} {M₃ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : AddCommMonoid.{u5} M₃] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₃ _inst_1 _inst_6] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_18 : TopologicalSpace.{u5} M₃], (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) -> (ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ M₃ _inst_1 (fun (i : ι) => _inst_3 i) _inst_6 (fun (i : ι) => _inst_9 i) _inst_12 (fun (i : ι) => _inst_15 i) _inst_18) -> (ContinuousMultilinearMap.{u1, u2, u3, max u4 u5} R ι M₁ (Prod.{u4, u5} M₂ M₃) _inst_1 (fun (i : ι) => _inst_3 i) (Prod.addCommMonoid.{u4, u5} M₂ M₃ _inst_5 _inst_6) (fun (i : ι) => _inst_9 i) (Prod.module.{u1, u4, u5} R M₂ M₃ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (fun (i : ι) => _inst_15 i) (Prod.topologicalSpace.{u4, u5} M₂ M₃ _inst_17 _inst_18))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} {M₃ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : AddCommMonoid.{u5} M₃] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₃ _inst_1 _inst_6] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_18 : TopologicalSpace.{u5} M₃], (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) -> (ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ M₃ _inst_1 (fun (i : ι) => _inst_3 i) _inst_6 (fun (i : ι) => _inst_9 i) _inst_12 (fun (i : ι) => _inst_15 i) _inst_18) -> (ContinuousMultilinearMap.{u1, u2, u3, max u5 u4} R ι M₁ (Prod.{u4, u5} M₂ M₃) _inst_1 (fun (i : ι) => _inst_3 i) (Prod.instAddCommMonoidSum.{u4, u5} M₂ M₃ _inst_5 _inst_6) (fun (i : ι) => _inst_9 i) (Prod.module.{u1, u4, u5} R M₂ M₃ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (fun (i : ι) => _inst_15 i) (instTopologicalSpaceProd.{u4, u5} M₂ M₃ _inst_17 _inst_18))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.prod ContinuousMultilinearMap.prodₓ'. -/
/-- The cartesian product of two continuous multilinear maps, as a continuous multilinear map. -/
def prod (f : ContinuousMultilinearMap R M₁ M₂) (g : ContinuousMultilinearMap R M₁ M₃) :
    ContinuousMultilinearMap R M₁ (M₂ × M₃) :=
  { f.toMultilinearMap.Prod g.toMultilinearMap with cont := f.cont.prod_mk g.cont }
#align continuous_multilinear_map.prod ContinuousMultilinearMap.prod

#print ContinuousMultilinearMap.prod_apply /-
@[simp]
theorem prod_apply (f : ContinuousMultilinearMap R M₁ M₂) (g : ContinuousMultilinearMap R M₁ M₃)
    (m : ∀ i, M₁ i) : (f.Prod g) m = (f m, g m) :=
  rfl
#align continuous_multilinear_map.prod_apply ContinuousMultilinearMap.prod_apply
-/

#print ContinuousMultilinearMap.pi /-
/-- Combine a family of continuous multilinear maps with the same domain and codomains `M' i` into a
continuous multilinear map taking values in the space of functions `Π i, M' i`. -/
def pi {ι' : Type _} {M' : ι' → Type _} [∀ i, AddCommMonoid (M' i)] [∀ i, TopologicalSpace (M' i)]
    [∀ i, Module R (M' i)] (f : ∀ i, ContinuousMultilinearMap R M₁ (M' i)) :
    ContinuousMultilinearMap R M₁ (∀ i, M' i)
    where
  cont := continuous_pi fun i => (f i).coe_continuous
  toMultilinearMap := MultilinearMap.pi fun i => (f i).toMultilinearMap
#align continuous_multilinear_map.pi ContinuousMultilinearMap.pi
-/

/- warning: continuous_multilinear_map.coe_pi -> ContinuousMultilinearMap.coe_pi is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] {ι' : Type.{u4}} {M' : ι' -> Type.{u5}} [_inst_20 : forall (i : ι'), AddCommMonoid.{u5} (M' i)] [_inst_21 : forall (i : ι'), TopologicalSpace.{u5} (M' i)] [_inst_22 : forall (i : ι'), Module.{u1, u5} R (M' i) _inst_1 (_inst_20 i)] (f : forall (i : ι'), ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ (M' i) _inst_1 (fun (i : ι) => _inst_3 i) (_inst_20 i) (fun (i : ι) => _inst_9 i) (_inst_22 i) (fun (i : ι) => _inst_15 i) (_inst_21 i)), Eq.{max (max (succ u2) (succ u3)) (succ (max u4 u5))} ((forall (i : ι), M₁ i) -> (forall (i : ι'), M' i)) (coeFn.{max (succ u2) (succ u3) (succ (max u4 u5)), max (max (succ u2) (succ u3)) (succ (max u4 u5))} (ContinuousMultilinearMap.{u1, u2, u3, max u4 u5} R ι M₁ (forall (i : ι'), M' i) _inst_1 (fun (i : ι) => _inst_3 i) (Pi.addCommMonoid.{u4, u5} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i)) (fun (i : ι) => _inst_9 i) (Pi.module.{u4, u5, u1} ι' (fun (i : ι') => M' i) R _inst_1 (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_22 i)) (fun (i : ι) => _inst_15 i) (Pi.topologicalSpace.{u4, u5} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a))) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, max u4 u5} R ι M₁ (forall (i : ι'), M' i) _inst_1 (fun (i : ι) => _inst_3 i) (Pi.addCommMonoid.{u4, u5} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i)) (fun (i : ι) => _inst_9 i) (Pi.module.{u4, u5, u1} ι' (fun (i : ι') => M' i) R _inst_1 (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_22 i)) (fun (i : ι) => _inst_15 i) (Pi.topologicalSpace.{u4, u5} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a))) => (forall (i : ι), M₁ i) -> (forall (i : ι'), M' i)) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, max u4 u5} R ι M₁ (forall (i : ι'), M' i) _inst_1 (fun (i : ι) => _inst_3 i) (Pi.addCommMonoid.{u4, u5} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i)) (fun (i : ι) => _inst_9 i) (Pi.module.{u4, u5, u1} ι' (fun (i : ι') => M' i) R _inst_1 (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_22 i)) (fun (i : ι) => _inst_15 i) (Pi.topologicalSpace.{u4, u5} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a))) (ContinuousMultilinearMap.pi.{u1, u2, u3, u4, u5} R ι M₁ _inst_1 (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_9 i) (fun (i : ι) => _inst_15 i) ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_21 i) (fun (i : ι') => _inst_22 i) f)) (fun (m : forall (i : ι), M₁ i) (j : ι') => coeFn.{max (succ u2) (succ u3) (succ u5), max (max (succ u2) (succ u3)) (succ u5)} (ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ (M' j) _inst_1 (fun (i : ι) => _inst_3 i) (_inst_20 j) (fun (i : ι) => _inst_9 i) (_inst_22 j) (fun (i : ι) => _inst_15 i) (_inst_21 j)) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ (M' j) _inst_1 (fun (i : ι) => _inst_3 i) (_inst_20 j) (fun (i : ι) => _inst_9 i) (_inst_22 j) (fun (i : ι) => _inst_15 i) (_inst_21 j)) => (forall (i : ι), M₁ i) -> (M' j)) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u5} R ι M₁ (M' j) _inst_1 (fun (i : ι) => _inst_3 i) (_inst_20 j) (fun (i : ι) => _inst_9 i) (_inst_22 j) (fun (i : ι) => _inst_15 i) (_inst_21 j)) (f j) m)
but is expected to have type
  forall {R : Type.{u3}} {ι : Type.{u4}} {M₁ : ι -> Type.{u5}} [_inst_1 : Semiring.{u3} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u5} (M₁ i)] [_inst_9 : forall (i : ι), Module.{u3, u5} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_15 : forall (i : ι), TopologicalSpace.{u5} (M₁ i)] {ι' : Type.{u2}} {M' : ι' -> Type.{u1}} [_inst_20 : forall (i : ι'), AddCommMonoid.{u1} (M' i)] [_inst_21 : forall (i : ι'), TopologicalSpace.{u1} (M' i)] [_inst_22 : forall (i : ι'), Module.{u3, u1} R (M' i) _inst_1 (_inst_20 i)] (f : forall (i : ι'), ContinuousMultilinearMap.{u3, u4, u5, u1} R ι M₁ (M' i) _inst_1 (fun (i : ι) => _inst_3 i) (_inst_20 i) (fun (i : ι) => _inst_9 i) (_inst_22 i) (fun (i : ι) => _inst_15 i) (_inst_21 i)), Eq.{max (max (max (succ u4) (succ u5)) (succ u2)) (succ u1)} (forall (ᾰ : forall (i : ι), M₁ i), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => forall (i : ι'), M' i) ᾰ) (FunLike.coe.{max (max (succ u4) (succ u5)) (succ (max u2 u1)), max (succ u4) (succ u5), succ (max u2 u1)} (ContinuousMultilinearMap.{u3, u4, u5, max u2 u1} R ι M₁ (forall (i : ι'), M' i) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (Pi.addCommMonoid.{u2, u1} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i)) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (Pi.module.{u2, u1, u3} ι' (fun (i : ι') => M' i) R _inst_1 (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_22 i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (Pi.topologicalSpace.{u2, u1} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a))) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => forall (i : ι'), M' i) _x) (ContinuousMapClass.toFunLike.{max (max u4 u5) u2 u1, max u4 u5, max u2 u1} (ContinuousMultilinearMap.{u3, u4, u5, max u2 u1} R ι M₁ (forall (i : ι'), M' i) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (Pi.addCommMonoid.{u2, u1} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i)) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (Pi.module.{u2, u1, u3} ι' (fun (i : ι') => M' i) R _inst_1 (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_22 i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (Pi.topologicalSpace.{u2, u1} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a))) (forall (i : ι), M₁ i) (forall (i : ι'), M' i) (Pi.topologicalSpace.{u4, u5} ι (fun (i : ι) => M₁ i) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i)) (Pi.topologicalSpace.{u2, u1} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a)) (ContinuousMultilinearMap.continuousMapClass.{u3, u4, u5, max u2 u1} R ι M₁ (forall (i : ι'), M' i) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (Pi.addCommMonoid.{u2, u1} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i)) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (Pi.module.{u2, u1, u3} ι' (fun (i : ι') => M' i) R _inst_1 (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_22 i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (Pi.topologicalSpace.{u2, u1} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a)))) (ContinuousMultilinearMap.pi.{u3, u4, u5, u2, u1} R ι M₁ _inst_1 (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_9 i) (fun (i : ι) => _inst_15 i) ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_21 i) (fun (i : ι') => _inst_22 i) f)) (fun (m : forall (i : ι), M₁ i) (j : ι') => FunLike.coe.{max (max (succ u4) (succ u5)) (succ u1), max (succ u4) (succ u5), succ u1} (ContinuousMultilinearMap.{u3, u4, u5, u1} R ι M₁ (M' j) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (_inst_20 j) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (_inst_22 j) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (_inst_21 j)) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M' j) _x) (ContinuousMapClass.toFunLike.{max (max u4 u5) u1, max u4 u5, u1} (ContinuousMultilinearMap.{u3, u4, u5, u1} R ι M₁ (M' j) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (_inst_20 j) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (_inst_22 j) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (_inst_21 j)) (forall (i : ι), M₁ i) (M' j) (Pi.topologicalSpace.{u4, u5} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) (_inst_21 j) (ContinuousMultilinearMap.continuousMapClass.{u3, u4, u5, u1} R ι M₁ (M' j) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (_inst_20 j) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (_inst_22 j) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (_inst_21 j))) (f j) m)
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.coe_pi ContinuousMultilinearMap.coe_piₓ'. -/
@[simp]
theorem coe_pi {ι' : Type _} {M' : ι' → Type _} [∀ i, AddCommMonoid (M' i)]
    [∀ i, TopologicalSpace (M' i)] [∀ i, Module R (M' i)]
    (f : ∀ i, ContinuousMultilinearMap R M₁ (M' i)) : ⇑(pi f) = fun m j => f j m :=
  rfl
#align continuous_multilinear_map.coe_pi ContinuousMultilinearMap.coe_pi

/- warning: continuous_multilinear_map.pi_apply -> ContinuousMultilinearMap.pi_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] {ι' : Type.{u4}} {M' : ι' -> Type.{u5}} [_inst_20 : forall (i : ι'), AddCommMonoid.{u5} (M' i)] [_inst_21 : forall (i : ι'), TopologicalSpace.{u5} (M' i)] [_inst_22 : forall (i : ι'), Module.{u1, u5} R (M' i) _inst_1 (_inst_20 i)] (f : forall (i : ι'), ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ (M' i) _inst_1 (fun (i : ι) => _inst_3 i) (_inst_20 i) (fun (i : ι) => _inst_9 i) (_inst_22 i) (fun (i : ι) => _inst_15 i) (_inst_21 i)) (m : forall (i : ι), M₁ i) (j : ι'), Eq.{succ u5} ((fun (i : ι') => M' i) j) (coeFn.{max (succ u2) (succ u3) (succ (max u4 u5)), max (max (succ u2) (succ u3)) (succ (max u4 u5))} (ContinuousMultilinearMap.{u1, u2, u3, max u4 u5} R ι M₁ (forall (i : ι'), (fun (i : ι') => M' i) i) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (Pi.addCommMonoid.{u4, u5} ι' (fun (i : ι') => (fun (i : ι') => M' i) i) (fun (i : ι') => (fun (i : ι') => _inst_20 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (Pi.module.{u4, u5, u1} ι' (fun (i : ι') => (fun (i : ι') => M' i) i) R _inst_1 (fun (i : ι') => (fun (i : ι') => _inst_20 i) i) (fun (i : ι') => (fun (i : ι') => _inst_22 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (Pi.topologicalSpace.{u4, u5} ι' (fun (i : ι') => (fun (i : ι') => M' i) i) (fun (a : ι') => (fun (i : ι') => _inst_21 i) a))) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, max u4 u5} R ι M₁ (forall (i : ι'), (fun (i : ι') => M' i) i) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (Pi.addCommMonoid.{u4, u5} ι' (fun (i : ι') => (fun (i : ι') => M' i) i) (fun (i : ι') => (fun (i : ι') => _inst_20 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (Pi.module.{u4, u5, u1} ι' (fun (i : ι') => (fun (i : ι') => M' i) i) R _inst_1 (fun (i : ι') => (fun (i : ι') => _inst_20 i) i) (fun (i : ι') => (fun (i : ι') => _inst_22 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (Pi.topologicalSpace.{u4, u5} ι' (fun (i : ι') => (fun (i : ι') => M' i) i) (fun (a : ι') => (fun (i : ι') => _inst_21 i) a))) => (forall (i : ι), M₁ i) -> (forall (i : ι'), (fun (i : ι') => M' i) i)) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, max u4 u5} R ι M₁ (forall (i : ι'), (fun (i : ι') => M' i) i) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (Pi.addCommMonoid.{u4, u5} ι' (fun (i : ι') => (fun (i : ι') => M' i) i) (fun (i : ι') => (fun (i : ι') => _inst_20 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (Pi.module.{u4, u5, u1} ι' (fun (i : ι') => (fun (i : ι') => M' i) i) R _inst_1 (fun (i : ι') => (fun (i : ι') => _inst_20 i) i) (fun (i : ι') => (fun (i : ι') => _inst_22 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (Pi.topologicalSpace.{u4, u5} ι' (fun (i : ι') => (fun (i : ι') => M' i) i) (fun (a : ι') => (fun (i : ι') => _inst_21 i) a))) (ContinuousMultilinearMap.pi.{u1, u2, u3, u4, u5} R ι M₁ _inst_1 (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_9 i) (fun (i : ι) => _inst_15 i) ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_21 i) (fun (i : ι') => _inst_22 i) f) m j) (coeFn.{max (succ u2) (succ u3) (succ u5), max (max (succ u2) (succ u3)) (succ u5)} (ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ (M' j) _inst_1 (fun (i : ι) => _inst_3 i) (_inst_20 j) (fun (i : ι) => _inst_9 i) (_inst_22 j) (fun (i : ι) => _inst_15 i) (_inst_21 j)) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ (M' j) _inst_1 (fun (i : ι) => _inst_3 i) (_inst_20 j) (fun (i : ι) => _inst_9 i) (_inst_22 j) (fun (i : ι) => _inst_15 i) (_inst_21 j)) => (forall (i : ι), M₁ i) -> (M' j)) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u5} R ι M₁ (M' j) _inst_1 (fun (i : ι) => _inst_3 i) (_inst_20 j) (fun (i : ι) => _inst_9 i) (_inst_22 j) (fun (i : ι) => _inst_15 i) (_inst_21 j)) (f j) m)
but is expected to have type
  forall {R : Type.{u3}} {ι : Type.{u4}} {M₁ : ι -> Type.{u5}} [_inst_1 : Semiring.{u3} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u5} (M₁ i)] [_inst_9 : forall (i : ι), Module.{u3, u5} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_15 : forall (i : ι), TopologicalSpace.{u5} (M₁ i)] {ι' : Type.{u2}} {M' : ι' -> Type.{u1}} [_inst_20 : forall (i : ι'), AddCommMonoid.{u1} (M' i)] [_inst_21 : forall (i : ι'), TopologicalSpace.{u1} (M' i)] [_inst_22 : forall (i : ι'), Module.{u3, u1} R (M' i) _inst_1 (_inst_20 i)] (f : forall (i : ι'), ContinuousMultilinearMap.{u3, u4, u5, u1} R ι M₁ (M' i) _inst_1 (fun (i : ι) => _inst_3 i) (_inst_20 i) (fun (i : ι) => _inst_9 i) (_inst_22 i) (fun (i : ι) => _inst_15 i) (_inst_21 i)) (m : forall (i : ι), M₁ i) (j : ι'), Eq.{succ u1} (M' j) (FunLike.coe.{max (max (succ u4) (succ u5)) (succ (max u2 u1)), max (succ u4) (succ u5), succ (max u2 u1)} (ContinuousMultilinearMap.{u3, u4, u5, max u2 u1} R ι M₁ (forall (i : ι'), M' i) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (Pi.addCommMonoid.{u2, u1} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i)) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (Pi.module.{u2, u1, u3} ι' (fun (i : ι') => M' i) R _inst_1 (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_22 i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (Pi.topologicalSpace.{u2, u1} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a))) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => forall (i : ι'), M' i) _x) (ContinuousMapClass.toFunLike.{max (max u4 u5) u2 u1, max u4 u5, max u2 u1} (ContinuousMultilinearMap.{u3, u4, u5, max u2 u1} R ι M₁ (forall (i : ι'), M' i) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (Pi.addCommMonoid.{u2, u1} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i)) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (Pi.module.{u2, u1, u3} ι' (fun (i : ι') => M' i) R _inst_1 (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_22 i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (Pi.topologicalSpace.{u2, u1} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a))) (forall (i : ι), M₁ i) (forall (i : ι'), M' i) (Pi.topologicalSpace.{u4, u5} ι (fun (i : ι) => M₁ i) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i)) (Pi.topologicalSpace.{u2, u1} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a)) (ContinuousMultilinearMap.continuousMapClass.{u3, u4, u5, max u2 u1} R ι M₁ (forall (i : ι'), M' i) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (Pi.addCommMonoid.{u2, u1} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i)) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (Pi.module.{u2, u1, u3} ι' (fun (i : ι') => M' i) R _inst_1 (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_22 i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (Pi.topologicalSpace.{u2, u1} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_21 a)))) (ContinuousMultilinearMap.pi.{u3, u4, u5, u2, u1} R ι M₁ _inst_1 (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_9 i) (fun (i : ι) => _inst_15 i) ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_20 i) (fun (i : ι') => _inst_21 i) (fun (i : ι') => _inst_22 i) f) m j) (FunLike.coe.{max (max (succ u4) (succ u5)) (succ u1), max (succ u4) (succ u5), succ u1} (ContinuousMultilinearMap.{u3, u4, u5, u1} R ι M₁ (M' j) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (_inst_20 j) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (_inst_22 j) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (_inst_21 j)) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M' j) _x) (ContinuousMapClass.toFunLike.{max (max u4 u5) u1, max u4 u5, u1} (ContinuousMultilinearMap.{u3, u4, u5, u1} R ι M₁ (M' j) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (_inst_20 j) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (_inst_22 j) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (_inst_21 j)) (forall (i : ι), M₁ i) (M' j) (Pi.topologicalSpace.{u4, u5} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) (_inst_21 j) (ContinuousMultilinearMap.continuousMapClass.{u3, u4, u5, u1} R ι M₁ (M' j) _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) (_inst_20 j) (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) (_inst_22 j) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) (_inst_21 j))) (f j) m)
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.pi_apply ContinuousMultilinearMap.pi_applyₓ'. -/
theorem pi_apply {ι' : Type _} {M' : ι' → Type _} [∀ i, AddCommMonoid (M' i)]
    [∀ i, TopologicalSpace (M' i)] [∀ i, Module R (M' i)]
    (f : ∀ i, ContinuousMultilinearMap R M₁ (M' i)) (m : ∀ i, M₁ i) (j : ι') : pi f m j = f j m :=
  rfl
#align continuous_multilinear_map.pi_apply ContinuousMultilinearMap.pi_apply

section

variable (R M₂)

#print ContinuousMultilinearMap.ofSubsingleton /-
/-- The evaluation map from `ι → M₂` to `M₂` is multilinear at a given `i` when `ι` is subsingleton.
-/
@[simps toMultilinearMap apply]
def ofSubsingleton [Subsingleton ι] (i' : ι) : ContinuousMultilinearMap R (fun _ : ι => M₂) M₂
    where
  toMultilinearMap := MultilinearMap.ofSubsingleton R _ i'
  cont := continuous_apply _
#align continuous_multilinear_map.of_subsingleton ContinuousMultilinearMap.ofSubsingleton
-/

variable (M₁) {M₂}

#print ContinuousMultilinearMap.constOfIsEmpty /-
/-- The constant map is multilinear when `ι` is empty. -/
@[simps toMultilinearMap apply]
def constOfIsEmpty [IsEmpty ι] (m : M₂) : ContinuousMultilinearMap R M₁ M₂
    where
  toMultilinearMap := MultilinearMap.constOfIsEmpty R _ m
  cont := continuous_const
#align continuous_multilinear_map.const_of_is_empty ContinuousMultilinearMap.constOfIsEmpty
-/

end

#print ContinuousMultilinearMap.compContinuousLinearMap /-
/-- If `g` is continuous multilinear and `f` is a collection of continuous linear maps,
then `g (f₁ m₁, ..., fₙ mₙ)` is again a continuous multilinear map, that we call
`g.comp_continuous_linear_map f`. -/
def compContinuousLinearMap (g : ContinuousMultilinearMap R M₁' M₄)
    (f : ∀ i : ι, M₁ i →L[R] M₁' i) : ContinuousMultilinearMap R M₁ M₄ :=
  { g.toMultilinearMap.compLinearMap fun i => (f i).toLinearMap with
    cont := g.cont.comp <| continuous_pi fun j => (f j).cont.comp <| continuous_apply _ }
#align continuous_multilinear_map.comp_continuous_linear_map ContinuousMultilinearMap.compContinuousLinearMap
-/

/- warning: continuous_multilinear_map.comp_continuous_linear_map_apply -> ContinuousMultilinearMap.compContinuousLinearMap_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₁' : ι -> Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_4 : forall (i : ι), AddCommMonoid.{u4} (M₁' i)] [_inst_7 : AddCommMonoid.{u5} M₄] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_10 : forall (i : ι), Module.{u1, u4} R (M₁' i) _inst_1 (_inst_4 i)] [_inst_13 : Module.{u1, u5} R M₄ _inst_1 _inst_7] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_16 : forall (i : ι), TopologicalSpace.{u4} (M₁' i)] [_inst_19 : TopologicalSpace.{u5} M₄] (g : ContinuousMultilinearMap.{u1, u2, u4, u5} R ι M₁' M₄ _inst_1 (fun (i : ι) => _inst_4 i) _inst_7 (fun (i : ι) => _inst_10 i) _inst_13 (fun (i : ι) => _inst_16 i) _inst_19) (f : forall (i : ι), ContinuousLinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M₁ i) (_inst_15 i) (_inst_3 i) (M₁' i) (_inst_16 i) (_inst_4 i) (_inst_9 i) (_inst_10 i)) (m : forall (i : ι), M₁ i), Eq.{succ u5} M₄ (coeFn.{max (succ u2) (succ u3) (succ u5), max (max (succ u2) (succ u3)) (succ u5)} (ContinuousMultilinearMap.{u1, u2, u3, u5} R ι (fun (i : ι) => M₁ i) M₄ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_7 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_13 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_19) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u5} R ι (fun (i : ι) => M₁ i) M₄ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_7 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_13 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_19) => (forall (i : ι), M₁ i) -> M₄) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u5} R ι (fun (i : ι) => M₁ i) M₄ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_7 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_13 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_19) (ContinuousMultilinearMap.compContinuousLinearMap.{u1, u2, u3, u4, u5} R ι (fun (i : ι) => M₁ i) M₁' M₄ _inst_1 (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) _inst_7 (fun (i : ι) => _inst_9 i) (fun (i : ι) => _inst_10 i) _inst_13 (fun (i : ι) => _inst_15 i) (fun (i : ι) => _inst_16 i) _inst_19 g f) m) (coeFn.{max (succ u2) (succ u4) (succ u5), max (max (succ u2) (succ u4)) (succ u5)} (ContinuousMultilinearMap.{u1, u2, u4, u5} R ι M₁' M₄ _inst_1 (fun (i : ι) => _inst_4 i) _inst_7 (fun (i : ι) => _inst_10 i) _inst_13 (fun (i : ι) => _inst_16 i) _inst_19) (fun (_x : ContinuousMultilinearMap.{u1, u2, u4, u5} R ι M₁' M₄ _inst_1 (fun (i : ι) => _inst_4 i) _inst_7 (fun (i : ι) => _inst_10 i) _inst_13 (fun (i : ι) => _inst_16 i) _inst_19) => (forall (i : ι), M₁' i) -> M₄) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u4, u5} R ι M₁' M₄ _inst_1 (fun (i : ι) => _inst_4 i) _inst_7 (fun (i : ι) => _inst_10 i) _inst_13 (fun (i : ι) => _inst_16 i) _inst_19) g (fun (i : ι) => coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (ContinuousLinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M₁ i) (_inst_15 i) (_inst_3 i) (M₁' i) (_inst_16 i) (_inst_4 i) (_inst_9 i) (_inst_10 i)) (fun (_x : ContinuousLinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M₁ i) (_inst_15 i) (_inst_3 i) (M₁' i) (_inst_16 i) (_inst_4 i) (_inst_9 i) (_inst_10 i)) => (M₁ i) -> (M₁' i)) (ContinuousLinearMap.toFun.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M₁ i) (_inst_15 i) (_inst_3 i) (M₁' i) (_inst_16 i) (_inst_4 i) (_inst_9 i) (_inst_10 i)) (f i) (m i)))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₁' : ι -> Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_4 : forall (i : ι), AddCommMonoid.{u4} (M₁' i)] [_inst_7 : AddCommMonoid.{u5} M₄] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_10 : forall (i : ι), Module.{u1, u4} R (M₁' i) _inst_1 (_inst_4 i)] [_inst_13 : Module.{u1, u5} R M₄ _inst_1 _inst_7] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_16 : forall (i : ι), TopologicalSpace.{u4} (M₁' i)] [_inst_19 : TopologicalSpace.{u5} M₄] (g : ContinuousMultilinearMap.{u1, u2, u4, u5} R ι M₁' M₄ _inst_1 (fun (i : ι) => _inst_4 i) _inst_7 (fun (i : ι) => _inst_10 i) _inst_13 (fun (i : ι) => _inst_16 i) _inst_19) (f : forall (i : ι), ContinuousLinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M₁ i) (_inst_15 i) (_inst_3 i) (M₁' i) (_inst_16 i) (_inst_4 i) (_inst_9 i) (_inst_10 i)) (m : forall (i : ι), M₁ i), Eq.{succ u5} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), (fun (i : ι) => M₁ i) i) => M₄) m) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u5), max (succ u2) (succ u3), succ u5} (ContinuousMultilinearMap.{u1, u2, u3, u5} R ι (fun (i : ι) => M₁ i) M₄ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_7 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_13 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_19) (forall (i : ι), (fun (i : ι) => M₁ i) i) (fun (_x : forall (i : ι), (fun (i : ι) => M₁ i) i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), (fun (i : ι) => M₁ i) i) => M₄) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u5, max u2 u3, u5} (ContinuousMultilinearMap.{u1, u2, u3, u5} R ι (fun (i : ι) => M₁ i) M₄ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_7 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_13 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_19) (forall (i : ι), (fun (i : ι) => M₁ i) i) M₄ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M₁ i) i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_19 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u5} R ι (fun (i : ι) => M₁ i) M₄ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_7 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_13 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_19)) (ContinuousMultilinearMap.compContinuousLinearMap.{u1, u2, u3, u4, u5} R ι (fun (i : ι) => M₁ i) M₁' M₄ _inst_1 (fun (i : ι) => _inst_3 i) (fun (i : ι) => _inst_4 i) _inst_7 (fun (i : ι) => _inst_9 i) (fun (i : ι) => _inst_10 i) _inst_13 (fun (i : ι) => _inst_15 i) (fun (i : ι) => _inst_16 i) _inst_19 g f) m) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u5), max (succ u2) (succ u4), succ u5} (ContinuousMultilinearMap.{u1, u2, u4, u5} R ι M₁' M₄ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_7 (fun (i : ι) => (fun (i : ι) => _inst_10 i) i) _inst_13 (fun (i : ι) => (fun (i : ι) => _inst_16 i) i) _inst_19) (forall (i : ι), M₁' i) (fun (_x : forall (i : ι), M₁' i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁' i) => M₄) _x) (ContinuousMapClass.toFunLike.{max (max u2 u4) u5, max u2 u4, u5} (ContinuousMultilinearMap.{u1, u2, u4, u5} R ι M₁' M₄ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_7 (fun (i : ι) => (fun (i : ι) => _inst_10 i) i) _inst_13 (fun (i : ι) => (fun (i : ι) => _inst_16 i) i) _inst_19) (forall (i : ι), M₁' i) M₄ (Pi.topologicalSpace.{u2, u4} ι (fun (i : ι) => M₁' i) (fun (a : ι) => (fun (i : ι) => _inst_16 i) a)) _inst_19 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u4, u5} R ι M₁' M₄ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_7 (fun (i : ι) => (fun (i : ι) => _inst_10 i) i) _inst_13 (fun (i : ι) => (fun (i : ι) => _inst_16 i) i) _inst_19)) g (fun (i : ι) => FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (ContinuousLinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M₁ i) (_inst_15 i) (_inst_3 i) (M₁' i) (_inst_16 i) (_inst_4 i) (_inst_9 i) (_inst_10 i)) (M₁ i) (fun (_x : M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : M₁ i) => M₁' i) _x) (ContinuousMapClass.toFunLike.{max u3 u4, u3, u4} (ContinuousLinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M₁ i) (_inst_15 i) (_inst_3 i) (M₁' i) (_inst_16 i) (_inst_4 i) (_inst_9 i) (_inst_10 i)) (M₁ i) (M₁' i) (_inst_15 i) (_inst_16 i) (ContinuousSemilinearMapClass.toContinuousMapClass.{max u3 u4, u1, u1, u3, u4} (ContinuousLinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M₁ i) (_inst_15 i) (_inst_3 i) (M₁' i) (_inst_16 i) (_inst_4 i) (_inst_9 i) (_inst_10 i)) R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M₁ i) (_inst_15 i) (_inst_3 i) (M₁' i) (_inst_16 i) (_inst_4 i) (_inst_9 i) (_inst_10 i) (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M₁ i) (_inst_15 i) (_inst_3 i) (M₁' i) (_inst_16 i) (_inst_4 i) (_inst_9 i) (_inst_10 i)))) (f i) (m i)))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.comp_continuous_linear_map_apply ContinuousMultilinearMap.compContinuousLinearMap_applyₓ'. -/
@[simp]
theorem compContinuousLinearMap_apply (g : ContinuousMultilinearMap R M₁' M₄)
    (f : ∀ i : ι, M₁ i →L[R] M₁' i) (m : ∀ i, M₁ i) :
    g.compContinuousLinearMap f m = g fun i => f i <| m i :=
  rfl
#align continuous_multilinear_map.comp_continuous_linear_map_apply ContinuousMultilinearMap.compContinuousLinearMap_apply

#print ContinuousLinearMap.compContinuousMultilinearMap /-
/-- Composing a continuous multilinear map with a continuous linear map gives again a
continuous multilinear map. -/
def ContinuousLinearMap.compContinuousMultilinearMap (g : M₂ →L[R] M₃)
    (f : ContinuousMultilinearMap R M₁ M₂) : ContinuousMultilinearMap R M₁ M₃ :=
  { g.toLinearMap.compMultilinearMap f.toMultilinearMap with cont := g.cont.comp f.cont }
#align continuous_linear_map.comp_continuous_multilinear_map ContinuousLinearMap.compContinuousMultilinearMap
-/

/- warning: continuous_linear_map.comp_continuous_multilinear_map_coe -> ContinuousLinearMap.compContinuousMultilinearMap_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} {M₃ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : AddCommMonoid.{u5} M₃] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₃ _inst_1 _inst_6] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_18 : TopologicalSpace.{u5} M₃] (g : ContinuousLinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ _inst_17 _inst_5 M₃ _inst_18 _inst_6 _inst_11 _inst_12) (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17), Eq.{max (max (succ u2) (succ u3)) (succ u5)} ((fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ M₃ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_6 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_12 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_18) => (forall (i : ι), M₁ i) -> M₃) (ContinuousLinearMap.compContinuousMultilinearMap.{u1, u2, u3, u4, u5} R ι M₁ M₂ M₃ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 _inst_6 (fun (i : ι) => _inst_9 i) _inst_11 _inst_12 (fun (i : ι) => _inst_15 i) _inst_17 _inst_18 g f)) (coeFn.{max (succ u2) (succ u3) (succ u5), max (max (succ u2) (succ u3)) (succ u5)} (ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ M₃ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_6 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_12 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_18) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ M₃ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_6 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_12 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_18) => (forall (i : ι), M₁ i) -> M₃) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u5} R ι M₁ M₃ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_6 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_12 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_18) (ContinuousLinearMap.compContinuousMultilinearMap.{u1, u2, u3, u4, u5} R ι M₁ M₂ M₃ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 _inst_6 (fun (i : ι) => _inst_9 i) _inst_11 _inst_12 (fun (i : ι) => _inst_15 i) _inst_17 _inst_18 g f)) (Function.comp.{max (succ u2) (succ u3), succ u4, succ u5} (forall (i : ι), M₁ i) M₂ M₃ (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (ContinuousLinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ _inst_17 _inst_5 M₃ _inst_18 _inst_6 _inst_11 _inst_12) (fun (_x : ContinuousLinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ _inst_17 _inst_5 M₃ _inst_18 _inst_6 _inst_11 _inst_12) => M₂ -> M₃) (ContinuousLinearMap.toFun.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ _inst_17 _inst_5 M₃ _inst_18 _inst_6 _inst_11 _inst_12) g) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} {M₃ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : AddCommMonoid.{u5} M₃] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₃ _inst_1 _inst_6] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] [_inst_18 : TopologicalSpace.{u5} M₃] (g : ContinuousLinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ _inst_17 _inst_5 M₃ _inst_18 _inst_6 _inst_11 _inst_12) (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17), Eq.{max (max (succ u2) (succ u3)) (succ u5)} (forall (a : forall (i : ι), M₁ i), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₃) a) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u5), max (succ u2) (succ u3), succ u5} (ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ M₃ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_6 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_12 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_18) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₃) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u5, max u2 u3, u5} (ContinuousMultilinearMap.{u1, u2, u3, u5} R ι M₁ M₃ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_6 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_12 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_18) (forall (i : ι), M₁ i) M₃ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_18 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u5} R ι M₁ M₃ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_6 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_12 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_18)) (ContinuousLinearMap.compContinuousMultilinearMap.{u1, u2, u3, u4, u5} R ι M₁ M₂ M₃ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 _inst_6 (fun (i : ι) => _inst_9 i) _inst_11 _inst_12 (fun (i : ι) => _inst_15 i) _inst_17 _inst_18 g f)) (Function.comp.{max (succ u2) (succ u3), succ u4, succ u5} (forall (i : ι), M₁ i) M₂ M₃ (FunLike.coe.{max (succ u4) (succ u5), succ u4, succ u5} (ContinuousLinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ _inst_17 _inst_5 M₃ _inst_18 _inst_6 _inst_11 _inst_12) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : M₂) => M₃) _x) (ContinuousMapClass.toFunLike.{max u4 u5, u4, u5} (ContinuousLinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ _inst_17 _inst_5 M₃ _inst_18 _inst_6 _inst_11 _inst_12) M₂ M₃ _inst_17 _inst_18 (ContinuousSemilinearMapClass.toContinuousMapClass.{max u4 u5, u1, u1, u4, u5} (ContinuousLinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ _inst_17 _inst_5 M₃ _inst_18 _inst_6 _inst_11 _inst_12) R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ _inst_17 _inst_5 M₃ _inst_18 _inst_6 _inst_11 _inst_12 (ContinuousLinearMap.continuousSemilinearMapClass.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ _inst_17 _inst_5 M₃ _inst_18 _inst_6 _inst_11 _inst_12))) g) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f))
Case conversion may be inaccurate. Consider using '#align continuous_linear_map.comp_continuous_multilinear_map_coe ContinuousLinearMap.compContinuousMultilinearMap_coeₓ'. -/
@[simp]
theorem ContinuousLinearMap.compContinuousMultilinearMap_coe (g : M₂ →L[R] M₃)
    (f : ContinuousMultilinearMap R M₁ M₂) :
    (g.compContinuousMultilinearMap f : (∀ i, M₁ i) → M₃) =
      (g : M₂ → M₃) ∘ (f : (∀ i, M₁ i) → M₂) :=
  by
  ext m
  rfl
#align continuous_linear_map.comp_continuous_multilinear_map_coe ContinuousLinearMap.compContinuousMultilinearMap_coe

#print ContinuousMultilinearMap.piEquiv /-
/-- `continuous_multilinear_map.pi` as an `equiv`. -/
@[simps]
def piEquiv {ι' : Type _} {M' : ι' → Type _} [∀ i, AddCommMonoid (M' i)]
    [∀ i, TopologicalSpace (M' i)] [∀ i, Module R (M' i)] :
    (∀ i, ContinuousMultilinearMap R M₁ (M' i)) ≃ ContinuousMultilinearMap R M₁ (∀ i, M' i)
    where
  toFun := ContinuousMultilinearMap.pi
  invFun f i := (ContinuousLinearMap.proj i : _ →L[R] M' i).compContinuousMultilinearMap f
  left_inv f := by
    ext
    rfl
  right_inv f := by
    ext
    rfl
#align continuous_multilinear_map.pi_equiv ContinuousMultilinearMap.piEquiv
-/

/- warning: continuous_multilinear_map.cons_add -> ContinuousMultilinearMap.cons_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {n : Nat} {M : (Fin (Nat.succ n)) -> Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : forall (i : Fin (Nat.succ n)), AddCommMonoid.{u2} (M i)] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_8 : forall (i : Fin (Nat.succ n)), Module.{u1, u2} R (M i) _inst_1 (_inst_2 i)] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 _inst_5] [_inst_14 : forall (i : Fin (Nat.succ n)), TopologicalSpace.{u2} (M i)] [_inst_17 : TopologicalSpace.{u3} M₂] (f : ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) (m : forall (i : Fin n), M (Fin.succ n i)) (x : M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (OfNat.mk.{0} (Fin (Nat.succ n)) 0 (Zero.zero.{0} (Fin (Nat.succ n)) (Fin.hasZeroOfNeZero (Nat.succ n) (NeZero.succ n)))))) (y : M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (OfNat.mk.{0} (Fin (Nat.succ n)) 0 (Zero.zero.{0} (Fin (Nat.succ n)) (Fin.hasZeroOfNeZero (Nat.succ n) (NeZero.succ n)))))), Eq.{succ u3} M₂ (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) => (forall (i : Fin (Nat.succ n)), M i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) f (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) (HAdd.hAdd.{u2, u2, u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (instHAdd.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (AddZeroClass.toHasAdd.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (AddMonoid.toAddZeroClass.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (_inst_2 (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))))))) x y) m)) (HAdd.hAdd.{u3, u3, u3} M₂ M₂ M₂ (instHAdd.{u3} M₂ (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5)))) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) => (forall (i : Fin (Nat.succ n)), M i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) f (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) => (forall (i : Fin (Nat.succ n)), M i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) f (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) y m)))
but is expected to have type
  forall {R : Type.{u1}} {n : Nat} {M : (Fin (Nat.succ n)) -> Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : forall (i : Fin (Nat.succ n)), AddCommMonoid.{u2} (M i)] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_8 : forall (i : Fin (Nat.succ n)), Module.{u1, u2} R (M i) _inst_1 (_inst_2 i)] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 _inst_5] [_inst_14 : forall (i : Fin (Nat.succ n)), TopologicalSpace.{u2} (M i)] [_inst_17 : TopologicalSpace.{u3} M₂] (f : ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) (m : forall (i : Fin n), M (Fin.succ n i)) (x : M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (y : M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))), Eq.{succ u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) (HAdd.hAdd.{u2, u2, u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (instHAdd.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddZeroClass.toAdd.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddMonoid.toAddZeroClass.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (_inst_2 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))))))) x y) m)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17) (forall (i : Fin (Nat.succ n)), M i) (fun (_x : forall (i : Fin (Nat.succ n)), M i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17) (forall (i : Fin (Nat.succ n)), M i) M₂ (Pi.topologicalSpace.{0, u2} (Fin (Nat.succ n)) (fun (i : Fin (Nat.succ n)) => M i) (fun (a : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17)) f (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) (HAdd.hAdd.{u2, u2, u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (instHAdd.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddZeroClass.toAdd.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddMonoid.toAddZeroClass.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (_inst_2 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))))))) x y) m)) (HAdd.hAdd.{u3, u3, u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) y m)) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (instHAdd.{u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (AddZeroClass.toAdd.{u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (AddMonoid.toAddZeroClass.{u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) _inst_5)))) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17) (forall (i : Fin (Nat.succ n)), M i) (fun (_x : forall (i : Fin (Nat.succ n)), M i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17) (forall (i : Fin (Nat.succ n)), M i) M₂ (Pi.topologicalSpace.{0, u2} (Fin (Nat.succ n)) (fun (i : Fin (Nat.succ n)) => M i) (fun (a : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17)) f (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17) (forall (i : Fin (Nat.succ n)), M i) (fun (_x : forall (i : Fin (Nat.succ n)), M i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17) (forall (i : Fin (Nat.succ n)), M i) M₂ (Pi.topologicalSpace.{0, u2} (Fin (Nat.succ n)) (fun (i : Fin (Nat.succ n)) => M i) (fun (a : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17)) f (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) y m)))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.cons_add ContinuousMultilinearMap.cons_addₓ'. -/
/-- In the specific case of continuous multilinear maps on spaces indexed by `fin (n+1)`, where one
can build an element of `Π(i : fin (n+1)), M i` using `cons`, one can express directly the
additivity of a multilinear map along the first variable. -/
theorem cons_add (f : ContinuousMultilinearMap R M M₂) (m : ∀ i : Fin n, M i.succ) (x y : M 0) :
    f (cons (x + y) m) = f (cons x m) + f (cons y m) :=
  f.toMultilinearMap.cons_add m x y
#align continuous_multilinear_map.cons_add ContinuousMultilinearMap.cons_add

/- warning: continuous_multilinear_map.cons_smul -> ContinuousMultilinearMap.cons_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {n : Nat} {M : (Fin (Nat.succ n)) -> Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : forall (i : Fin (Nat.succ n)), AddCommMonoid.{u2} (M i)] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_8 : forall (i : Fin (Nat.succ n)), Module.{u1, u2} R (M i) _inst_1 (_inst_2 i)] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 _inst_5] [_inst_14 : forall (i : Fin (Nat.succ n)), TopologicalSpace.{u2} (M i)] [_inst_17 : TopologicalSpace.{u3} M₂] (f : ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) (m : forall (i : Fin n), M (Fin.succ n i)) (c : R) (x : M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (OfNat.mk.{0} (Fin (Nat.succ n)) 0 (Zero.zero.{0} (Fin (Nat.succ n)) (Fin.hasZeroOfNeZero (Nat.succ n) (NeZero.succ n)))))), Eq.{succ u3} M₂ (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) => (forall (i : Fin (Nat.succ n)), M i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) f (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) (SMul.smul.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (SMulZeroClass.toHasSmul.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (AddZeroClass.toHasZero.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (AddMonoid.toAddZeroClass.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (_inst_2 (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n))))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (AddMonoid.toAddZeroClass.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (_inst_2 (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n))))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (AddMonoid.toAddZeroClass.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (_inst_2 (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n))))))))) (Module.toMulActionWithZero.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) _inst_1 (_inst_2 (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (_inst_8 (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))))))) c x) m)) (SMul.smul.{u1, u3} R M₂ (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_5))) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_5 _inst_11)))) c (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) => (forall (i : Fin (Nat.succ n)), M i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) f (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)))
but is expected to have type
  forall {R : Type.{u1}} {n : Nat} {M : (Fin (Nat.succ n)) -> Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : forall (i : Fin (Nat.succ n)), AddCommMonoid.{u2} (M i)] [_inst_5 : AddCommMonoid.{u3} M₂] [_inst_8 : forall (i : Fin (Nat.succ n)), Module.{u1, u2} R (M i) _inst_1 (_inst_2 i)] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 _inst_5] [_inst_14 : forall (i : Fin (Nat.succ n)), TopologicalSpace.{u2} (M i)] [_inst_17 : TopologicalSpace.{u3} M₂] (f : ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => _inst_2 i) _inst_5 (fun (i : Fin (Nat.succ n)) => _inst_8 i) _inst_11 (fun (i : Fin (Nat.succ n)) => _inst_14 i) _inst_17) (m : forall (i : Fin n), M (Fin.succ n i)) (c : R) (x : M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))), Eq.{succ u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) (HSMul.hSMul.{u1, u2, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (instHSMul.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (SMulZeroClass.toSMul.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddMonoid.toZero.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (_inst_2 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (_inst_2 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (_inst_2 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))))) (Module.toMulActionWithZero.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) _inst_1 (_inst_2 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (_inst_8 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n))))))))) c x) m)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17) (forall (i : Fin (Nat.succ n)), M i) (fun (_x : forall (i : Fin (Nat.succ n)), M i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17) (forall (i : Fin (Nat.succ n)), M i) M₂ (Pi.topologicalSpace.{0, u2} (Fin (Nat.succ n)) (fun (i : Fin (Nat.succ n)) => M i) (fun (a : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17)) f (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) (HSMul.hSMul.{u1, u2, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (instHSMul.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (SMulZeroClass.toSMul.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddMonoid.toZero.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (_inst_2 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (_inst_2 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (AddCommMonoid.toAddMonoid.{u2} (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (_inst_2 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))))) (Module.toMulActionWithZero.{u1, u2} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) _inst_1 (_inst_2 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n)))) (_inst_8 (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n))))))))) c x) m)) (HSMul.hSMul.{u1, u3, u3} R ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (instHSMul.{u1, u3} R ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (SMulZeroClass.toSMul.{u1, u3} R ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u3} R ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u3} R ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) _inst_5)) (Module.toMulActionWithZero.{u1, u3} R ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)) _inst_1 _inst_5 _inst_11))))) c (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17) (forall (i : Fin (Nat.succ n)), M i) (fun (_x : forall (i : Fin (Nat.succ n)), M i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin (Nat.succ n)), M i) => M₂) _x) (ContinuousMapClass.toFunLike.{max u2 u3, u2, u3} (ContinuousMultilinearMap.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17) (forall (i : Fin (Nat.succ n)), M i) M₂ (Pi.topologicalSpace.{0, u2} (Fin (Nat.succ n)) (fun (i : Fin (Nat.succ n)) => M i) (fun (a : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, 0, u2, u3} R (Fin (Nat.succ n)) M M₂ _inst_1 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_2 i) i) _inst_5 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_8 i) i) _inst_11 (fun (i : Fin (Nat.succ n)) => (fun (i : Fin (Nat.succ n)) => _inst_14 i) i) _inst_17)) f (Fin.cons.{u2} n (fun (i : Fin (Nat.succ n)) => M i) x m)))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.cons_smul ContinuousMultilinearMap.cons_smulₓ'. -/
/-- In the specific case of continuous multilinear maps on spaces indexed by `fin (n+1)`, where one
can build an element of `Π(i : fin (n+1)), M i` using `cons`, one can express directly the
multiplicativity of a multilinear map along the first variable. -/
theorem cons_smul (f : ContinuousMultilinearMap R M M₂) (m : ∀ i : Fin n, M i.succ) (c : R)
    (x : M 0) : f (cons (c • x) m) = c • f (cons x m) :=
  f.toMultilinearMap.cons_smul m c x
#align continuous_multilinear_map.cons_smul ContinuousMultilinearMap.cons_smul

/- warning: continuous_multilinear_map.map_piecewise_add -> ContinuousMultilinearMap.map_piecewise_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) [_inst_20 : DecidableEq.{succ u2} ι] (m : forall (i : ι), M₁ i) (m' : forall (i : ι), M₁ i) (t : Finset.{u2} ι), Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (Finset.piecewise.{u2, succ u3} ι (fun (i : ι) => M₁ i) t (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (instHAdd.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instAdd.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddZeroClass.toHasAdd.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))))) m m') m' (fun (j : ι) => Finset.decidableMem.{u2} ι (fun (a : ι) (b : ι) => _inst_20 a b) j t))) (Finset.sum.{u4, u2} M₂ (Finset.{u2} ι) _inst_5 (Finset.powerset.{u2} ι t) (fun (s : Finset.{u2} ι) => coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (Finset.piecewise.{u2, succ u3} ι (fun (i : ι) => M₁ i) s m m' (fun (j : ι) => Finset.decidableMem.{u2} ι (fun (a : ι) (b : ι) => _inst_20 a b) j s))))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) [_inst_20 : DecidableEq.{succ u2} ι] (m : forall (i : ι), M₁ i) (m' : forall (i : ι), M₁ i) (t : Finset.{u2} ι), Eq.{succ u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Finset.piecewise.{u2, succ u3} ι (fun (i : ι) => M₁ i) t (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (instHAdd.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instAdd.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddZeroClass.toAdd.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))))) m m') m' (fun (j : ι) => Finset.decidableMem.{u2} ι (fun (a : ι) (b : ι) => _inst_20 a b) j t))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (Finset.piecewise.{u2, succ u3} ι (fun (i : ι) => M₁ i) t (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (instHAdd.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instAdd.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddZeroClass.toAdd.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))))) m m') m' (fun (j : ι) => Finset.decidableMem.{u2} ι (fun (a : ι) (b : ι) => _inst_20 a b) j t))) (Finset.sum.{u4, u2} M₂ (Finset.{u2} ι) _inst_5 (Finset.powerset.{u2} ι t) (fun (s : Finset.{u2} ι) => FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (Finset.piecewise.{u2, succ u3} ι (fun (i : ι) => M₁ i) s m m' (fun (j : ι) => Finset.decidableMem.{u2} ι (fun (a : ι) (b : ι) => _inst_20 a b) j s))))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.map_piecewise_add ContinuousMultilinearMap.map_piecewise_addₓ'. -/
theorem map_piecewise_add [DecidableEq ι] (m m' : ∀ i, M₁ i) (t : Finset ι) :
    f (t.piecewise (m + m') m') = ∑ s in t.powerset, f (s.piecewise m m') :=
  f.toMultilinearMap.map_piecewise_add _ _ _
#align continuous_multilinear_map.map_piecewise_add ContinuousMultilinearMap.map_piecewise_add

/- warning: continuous_multilinear_map.map_add_univ -> ContinuousMultilinearMap.map_add_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) [_inst_20 : DecidableEq.{succ u2} ι] [_inst_21 : Fintype.{u2} ι] (m : forall (i : ι), M₁ i) (m' : forall (i : ι), M₁ i), Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (instHAdd.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instAdd.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddZeroClass.toHasAdd.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))))) m m')) (Finset.sum.{u4, u2} M₂ (Finset.{u2} ι) _inst_5 (Finset.univ.{u2} (Finset.{u2} ι) (Finset.fintype.{u2} ι _inst_21)) (fun (s : Finset.{u2} ι) => coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (Finset.piecewise.{u2, succ u3} ι (fun (i : ι) => M₁ i) s m m' (fun (j : ι) => Finset.decidableMem.{u2} ι (fun (a : ι) (b : ι) => _inst_20 a b) j s))))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) [_inst_20 : DecidableEq.{succ u2} ι] [_inst_21 : Fintype.{u2} ι] (m : forall (i : ι), M₁ i) (m' : forall (i : ι), M₁ i), Eq.{succ u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (instHAdd.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instAdd.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddZeroClass.toAdd.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))))) m m')) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (forall (i : ι), M₁ i) (instHAdd.{max u2 u3} (forall (i : ι), M₁ i) (Pi.instAdd.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (i : ι) => AddZeroClass.toAdd.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))))) m m')) (Finset.sum.{u4, u2} M₂ (Finset.{u2} ι) _inst_5 (Finset.univ.{u2} (Finset.{u2} ι) (Finset.fintype.{u2} ι _inst_21)) (fun (s : Finset.{u2} ι) => FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (Finset.piecewise.{u2, succ u3} ι (fun (i : ι) => M₁ i) s m m' (fun (j : ι) => Finset.decidableMem.{u2} ι (fun (a : ι) (b : ι) => _inst_20 a b) j s))))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.map_add_univ ContinuousMultilinearMap.map_add_univₓ'. -/
/-- Additivity of a continuous multilinear map along all coordinates at the same time,
writing `f (m + m')` as the sum  of `f (s.piecewise m m')` over all sets `s`. -/
theorem map_add_univ [DecidableEq ι] [Fintype ι] (m m' : ∀ i, M₁ i) :
    f (m + m') = ∑ s : Finset ι, f (s.piecewise m m') :=
  f.toMultilinearMap.map_add_univ _ _
#align continuous_multilinear_map.map_add_univ ContinuousMultilinearMap.map_add_univ

section ApplySum

open Fintype Finset

variable {α : ι → Type _} [Fintype ι] (g : ∀ i, α i → M₁ i) (A : ∀ i, Finset (α i))

/- warning: continuous_multilinear_map.map_sum_finset -> ContinuousMultilinearMap.map_sum_finset is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) {α : ι -> Type.{u5}} [_inst_20 : Fintype.{u2} ι] (g : forall (i : ι), (α i) -> (M₁ i)) (A : forall (i : ι), Finset.{u5} (α i)) [_inst_21 : DecidableEq.{succ u2} ι], Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (fun (i : ι) => Finset.sum.{u3, u5} (M₁ i) (α i) (_inst_3 i) (A i) (fun (j : α i) => g i j))) (Finset.sum.{u4, max u2 u5} M₂ (forall (a : ι), α a) _inst_5 (Fintype.piFinset.{u2, u5} ι (fun (a : ι) (b : ι) => _inst_21 a b) _inst_20 (fun (i : ι) => α i) A) (fun (r : forall (a : ι), α a) => coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (fun (i : ι) => g i (r i))))
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u3}} {M₁ : ι -> Type.{u4}} {M₂ : Type.{u5}} [_inst_1 : Semiring.{u2} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u4} (M₁ i)] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_9 : forall (i : ι), Module.{u2, u4} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u2, u5} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u4} (M₁ i)] [_inst_17 : TopologicalSpace.{u5} M₂] (f : ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) {α : ι -> Type.{u1}} [_inst_20 : Fintype.{u3} ι] (g : forall (i : ι), (α i) -> (M₁ i)) (A : forall (i : ι), Finset.{u1} (α i)) [_inst_21 : DecidableEq.{succ u3} ι], Eq.{succ u5} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (fun (i : ι) => Finset.sum.{u4, u1} (M₁ i) (α i) (_inst_3 i) (A i) (fun (j : α i) => g i j))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u5), max (succ u3) (succ u4), succ u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u3 u4) u5, max u3 u4, u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u3, u4} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (fun (i : ι) => Finset.sum.{u4, u1} (M₁ i) (α i) (_inst_3 i) (A i) (fun (j : α i) => g i j))) (Finset.sum.{u5, max u1 u3} M₂ (forall (a : ι), α a) _inst_5 (Fintype.piFinset.{u3, u1} ι (fun (a : ι) (b : ι) => _inst_21 a b) _inst_20 (fun (i : ι) => α i) A) (fun (r : forall (a : ι), α a) => FunLike.coe.{max (max (succ u3) (succ u4)) (succ u5), max (succ u3) (succ u4), succ u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u3 u4) u5, max u3 u4, u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u3, u4} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (fun (i : ι) => g i (r i))))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.map_sum_finset ContinuousMultilinearMap.map_sum_finsetₓ'. -/
/-- If `f` is continuous multilinear, then `f (Σ_{j₁ ∈ A₁} g₁ j₁, ..., Σ_{jₙ ∈ Aₙ} gₙ jₙ)` is the
sum of `f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions with `r 1 ∈ A₁`, ...,
`r n ∈ Aₙ`. This follows from multilinearity by expanding successively with respect to each
coordinate. -/
theorem map_sum_finset [DecidableEq ι] :
    (f fun i => ∑ j in A i, g i j) = ∑ r in piFinset A, f fun i => g i (r i) :=
  f.toMultilinearMap.map_sum_finset _ _
#align continuous_multilinear_map.map_sum_finset ContinuousMultilinearMap.map_sum_finset

/- warning: continuous_multilinear_map.map_sum -> ContinuousMultilinearMap.map_sum is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) {α : ι -> Type.{u5}} [_inst_20 : Fintype.{u2} ι] (g : forall (i : ι), (α i) -> (M₁ i)) [_inst_21 : DecidableEq.{succ u2} ι] [_inst_22 : forall (i : ι), Fintype.{u5} (α i)], Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (fun (i : ι) => Finset.sum.{u3, u5} (M₁ i) (α i) (_inst_3 i) (Finset.univ.{u5} (α i) (_inst_22 i)) (fun (j : α i) => g i j))) (Finset.sum.{u4, max u2 u5} M₂ (forall (i : ι), α i) _inst_5 (Finset.univ.{max u2 u5} (forall (i : ι), α i) (Pi.fintype.{u2, u5} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_21 a b) _inst_20 (fun (a : ι) => _inst_22 a))) (fun (r : forall (i : ι), α i) => coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) f (fun (i : ι) => g i (r i))))
but is expected to have type
  forall {R : Type.{u2}} {ι : Type.{u3}} {M₁ : ι -> Type.{u4}} {M₂ : Type.{u5}} [_inst_1 : Semiring.{u2} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u4} (M₁ i)] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_9 : forall (i : ι), Module.{u2, u4} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u2, u5} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u4} (M₁ i)] [_inst_17 : TopologicalSpace.{u5} M₂] (f : ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) {α : ι -> Type.{u1}} [_inst_20 : Fintype.{u3} ι] (g : forall (i : ι), (α i) -> (M₁ i)) [_inst_21 : DecidableEq.{succ u3} ι] [_inst_22 : forall (i : ι), Fintype.{u1} (α i)], Eq.{succ u5} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (fun (i : ι) => Finset.sum.{u4, u1} (M₁ i) (α i) (_inst_3 i) (Finset.univ.{u1} (α i) (_inst_22 i)) (fun (j : α i) => g i j))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u5), max (succ u3) (succ u4), succ u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u3 u4) u5, max u3 u4, u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u3, u4} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (fun (i : ι) => Finset.sum.{u4, u1} (M₁ i) (α i) (_inst_3 i) (Finset.univ.{u1} (α i) (_inst_22 i)) (fun (j : α i) => g i j))) (Finset.sum.{u5, max u3 u1} M₂ (forall (i : ι), α i) _inst_5 (Finset.univ.{max u3 u1} (forall (i : ι), α i) (Pi.fintype.{u3, u1} ι (fun (i : ι) => α i) (fun (a : ι) (b : ι) => _inst_21 a b) _inst_20 (fun (a : ι) => _inst_22 a))) (fun (r : forall (i : ι), α i) => FunLike.coe.{max (max (succ u3) (succ u4)) (succ u5), max (succ u3) (succ u4), succ u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u3 u4) u5, max u3 u4, u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u3, u4} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f (fun (i : ι) => g i (r i))))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.map_sum ContinuousMultilinearMap.map_sumₓ'. -/
/-- If `f` is continuous multilinear, then `f (Σ_{j₁} g₁ j₁, ..., Σ_{jₙ} gₙ jₙ)` is the sum of
`f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions `r`. This follows from
multilinearity by expanding successively with respect to each coordinate. -/
theorem map_sum [DecidableEq ι] [∀ i, Fintype (α i)] :
    (f fun i => ∑ j, g i j) = ∑ r : ∀ i, α i, f fun i => g i (r i) :=
  f.toMultilinearMap.map_sum _
#align continuous_multilinear_map.map_sum ContinuousMultilinearMap.map_sum

end ApplySum

section RestrictScalar

variable (R) {A : Type _} [Semiring A] [SMul R A] [∀ i : ι, Module A (M₁ i)] [Module A M₂]
  [∀ i, IsScalarTower R A (M₁ i)] [IsScalarTower R A M₂]

#print ContinuousMultilinearMap.restrictScalars /-
/-- Reinterpret an `A`-multilinear map as an `R`-multilinear map, if `A` is an algebra over `R`
and their actions on all involved modules agree with the action of `R` on `A`. -/
def restrictScalars (f : ContinuousMultilinearMap A M₁ M₂) : ContinuousMultilinearMap R M₁ M₂
    where
  toMultilinearMap := f.toMultilinearMap.restrictScalars R
  cont := f.cont
#align continuous_multilinear_map.restrict_scalars ContinuousMultilinearMap.restrictScalars
-/

/- warning: continuous_multilinear_map.coe_restrict_scalars -> ContinuousMultilinearMap.coe_restrictScalars is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u3} (M₁ i)] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_9 : forall (i : ι), Module.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u1, u4} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_17 : TopologicalSpace.{u4} M₂] {A : Type.{u5}} [_inst_20 : Semiring.{u5} A] [_inst_21 : SMul.{u1, u5} R A] [_inst_22 : forall (i : ι), Module.{u5, u3} A (M₁ i) _inst_20 (_inst_3 i)] [_inst_23 : Module.{u5, u4} A M₂ _inst_20 _inst_5] [_inst_24 : forall (i : ι), IsScalarTower.{u1, u5, u3} R A (M₁ i) _inst_21 (SMulZeroClass.toHasSmul.{u5, u3} A (M₁ i) (AddZeroClass.toHasZero.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))) (SMulWithZero.toSmulZeroClass.{u5, u3} A (M₁ i) (MulZeroClass.toHasZero.{u5} A (MulZeroOneClass.toMulZeroClass.{u5} A (MonoidWithZero.toMulZeroOneClass.{u5} A (Semiring.toMonoidWithZero.{u5} A _inst_20)))) (AddZeroClass.toHasZero.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))) (MulActionWithZero.toSMulWithZero.{u5, u3} A (M₁ i) (Semiring.toMonoidWithZero.{u5} A _inst_20) (AddZeroClass.toHasZero.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))) (Module.toMulActionWithZero.{u5, u3} A (M₁ i) _inst_20 (_inst_3 i) (_inst_22 i))))) (SMulZeroClass.toHasSmul.{u1, u3} R (M₁ i) (AddZeroClass.toHasZero.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R (M₁ i) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R (M₁ i) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} (M₁ i) (AddMonoid.toAddZeroClass.{u3} (M₁ i) (AddCommMonoid.toAddMonoid.{u3} (M₁ i) (_inst_3 i)))) (Module.toMulActionWithZero.{u1, u3} R (M₁ i) _inst_1 (_inst_3 i) (_inst_9 i)))))] [_inst_25 : IsScalarTower.{u1, u5, u4} R A M₂ _inst_21 (SMulZeroClass.toHasSmul.{u5, u4} A M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u5, u4} A M₂ (MulZeroClass.toHasZero.{u5} A (MulZeroOneClass.toMulZeroClass.{u5} A (MonoidWithZero.toMulZeroOneClass.{u5} A (Semiring.toMonoidWithZero.{u5} A _inst_20)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u5, u4} A M₂ (Semiring.toMonoidWithZero.{u5} A _inst_20) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (Module.toMulActionWithZero.{u5, u4} A M₂ _inst_20 _inst_5 _inst_23)))) (SMulZeroClass.toHasSmul.{u1, u4} R M₂ (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₂ (AddMonoid.toAddZeroClass.{u4} M₂ (AddCommMonoid.toAddMonoid.{u4} M₂ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₂ _inst_1 _inst_5 _inst_11))))] (f : ContinuousMultilinearMap.{u5, u2, u3, u4} A ι M₁ M₂ _inst_20 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_22 i) _inst_23 (fun (i : ι) => _inst_15 i) _inst_17), Eq.{max (max (succ u2) (succ u3)) (succ u4)} ((forall (i : ι), M₁ i) -> M₂) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17) (ContinuousMultilinearMap.restrictScalars.{u1, u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 A _inst_20 _inst_21 (fun (i : ι) => _inst_22 i) _inst_23 (fun (i : ι) => _inst_24 i) _inst_25 f)) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u5, u2, u3, u4} A ι M₁ M₂ _inst_20 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_22 i) _inst_23 (fun (i : ι) => _inst_15 i) _inst_17) (fun (_x : ContinuousMultilinearMap.{u5, u2, u3, u4} A ι M₁ M₂ _inst_20 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_22 i) _inst_23 (fun (i : ι) => _inst_15 i) _inst_17) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u5, u2, u3, u4} A ι M₁ M₂ _inst_20 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_22 i) _inst_23 (fun (i : ι) => _inst_15 i) _inst_17) f)
but is expected to have type
  forall (R : Type.{u2}) {ι : Type.{u3}} {M₁ : ι -> Type.{u4}} {M₂ : Type.{u5}} [_inst_1 : Semiring.{u2} R] [_inst_3 : forall (i : ι), AddCommMonoid.{u4} (M₁ i)] [_inst_5 : AddCommMonoid.{u5} M₂] [_inst_9 : forall (i : ι), Module.{u2, u4} R (M₁ i) _inst_1 (_inst_3 i)] [_inst_11 : Module.{u2, u5} R M₂ _inst_1 _inst_5] [_inst_15 : forall (i : ι), TopologicalSpace.{u4} (M₁ i)] [_inst_17 : TopologicalSpace.{u5} M₂] {A : Type.{u1}} [_inst_20 : Semiring.{u1} A] [_inst_21 : SMul.{u2, u1} R A] [_inst_22 : forall (i : ι), Module.{u1, u4} A (M₁ i) _inst_20 (_inst_3 i)] [_inst_23 : Module.{u1, u5} A M₂ _inst_20 _inst_5] [_inst_24 : forall (i : ι), IsScalarTower.{u2, u1, u4} R A (M₁ i) _inst_21 (SMulZeroClass.toSMul.{u1, u4} A (M₁ i) (AddMonoid.toZero.{u4} (M₁ i) (AddCommMonoid.toAddMonoid.{u4} (M₁ i) (_inst_3 i))) (SMulWithZero.toSMulZeroClass.{u1, u4} A (M₁ i) (MonoidWithZero.toZero.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_20)) (AddMonoid.toZero.{u4} (M₁ i) (AddCommMonoid.toAddMonoid.{u4} (M₁ i) (_inst_3 i))) (MulActionWithZero.toSMulWithZero.{u1, u4} A (M₁ i) (Semiring.toMonoidWithZero.{u1} A _inst_20) (AddMonoid.toZero.{u4} (M₁ i) (AddCommMonoid.toAddMonoid.{u4} (M₁ i) (_inst_3 i))) (Module.toMulActionWithZero.{u1, u4} A (M₁ i) _inst_20 (_inst_3 i) (_inst_22 i))))) (SMulZeroClass.toSMul.{u2, u4} R (M₁ i) (AddMonoid.toZero.{u4} (M₁ i) (AddCommMonoid.toAddMonoid.{u4} (M₁ i) (_inst_3 i))) (SMulWithZero.toSMulZeroClass.{u2, u4} R (M₁ i) (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u4} (M₁ i) (AddCommMonoid.toAddMonoid.{u4} (M₁ i) (_inst_3 i))) (MulActionWithZero.toSMulWithZero.{u2, u4} R (M₁ i) (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u4} (M₁ i) (AddCommMonoid.toAddMonoid.{u4} (M₁ i) (_inst_3 i))) (Module.toMulActionWithZero.{u2, u4} R (M₁ i) _inst_1 (_inst_3 i) (_inst_9 i)))))] [_inst_25 : IsScalarTower.{u2, u1, u5} R A M₂ _inst_21 (SMulZeroClass.toSMul.{u1, u5} A M₂ (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u5} A M₂ (MonoidWithZero.toZero.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_20)) (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u5} A M₂ (Semiring.toMonoidWithZero.{u1} A _inst_20) (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (Module.toMulActionWithZero.{u1, u5} A M₂ _inst_20 _inst_5 _inst_23)))) (SMulZeroClass.toSMul.{u2, u5} R M₂ (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (SMulWithZero.toSMulZeroClass.{u2, u5} R M₂ (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (MulActionWithZero.toSMulWithZero.{u2, u5} R M₂ (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u5} M₂ (AddCommMonoid.toAddMonoid.{u5} M₂ _inst_5)) (Module.toMulActionWithZero.{u2, u5} R M₂ _inst_1 _inst_5 _inst_11))))] (f : ContinuousMultilinearMap.{u1, u3, u4, u5} A ι M₁ M₂ _inst_20 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_22 i) _inst_23 (fun (i : ι) => _inst_15 i) _inst_17), Eq.{max (max (succ u3) (succ u4)) (succ u5)} (forall (ᾰ : forall (i : ι), M₁ i), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) ᾰ) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u5), max (succ u3) (succ u4), succ u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u3 u4) u5, max u3 u4, u5} (ContinuousMultilinearMap.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u3, u4} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u2, u3, u4, u5} R ι M₁ M₂ _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_9 i) i) _inst_11 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) (ContinuousMultilinearMap.restrictScalars.{u2, u3, u4, u5, u1} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_3 i) _inst_5 (fun (i : ι) => _inst_9 i) _inst_11 (fun (i : ι) => _inst_15 i) _inst_17 A _inst_20 _inst_21 (fun (i : ι) => _inst_22 i) _inst_23 (fun (i : ι) => _inst_24 i) _inst_25 f)) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u5), max (succ u3) (succ u4), succ u5} (ContinuousMultilinearMap.{u1, u3, u4, u5} A ι M₁ M₂ _inst_20 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_22 i) i) _inst_23 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u3 u4) u5, max u3 u4, u5} (ContinuousMultilinearMap.{u1, u3, u4, u5} A ι M₁ M₂ _inst_20 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_22 i) i) _inst_23 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u3, u4} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_15 i) a)) _inst_17 (ContinuousMultilinearMap.continuousMapClass.{u1, u3, u4, u5} A ι M₁ M₂ _inst_20 (fun (i : ι) => (fun (i : ι) => _inst_3 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_22 i) i) _inst_23 (fun (i : ι) => (fun (i : ι) => _inst_15 i) i) _inst_17)) f)
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.coe_restrict_scalars ContinuousMultilinearMap.coe_restrictScalarsₓ'. -/
@[simp]
theorem coe_restrictScalars (f : ContinuousMultilinearMap A M₁ M₂) : ⇑(f.restrictScalars R) = f :=
  rfl
#align continuous_multilinear_map.coe_restrict_scalars ContinuousMultilinearMap.coe_restrictScalars

end RestrictScalar

end Semiring

section Ring

variable [Ring R] [∀ i, AddCommGroup (M₁ i)] [AddCommGroup M₂] [∀ i, Module R (M₁ i)] [Module R M₂]
  [∀ i, TopologicalSpace (M₁ i)] [TopologicalSpace M₂] (f f' : ContinuousMultilinearMap R M₁ M₂)

/- warning: continuous_multilinear_map.map_sub -> ContinuousMultilinearMap.map_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Ring.{u1} R] [_inst_2 : forall (i : ι), AddCommGroup.{u3} (M₁ i)] [_inst_3 : AddCommGroup.{u4} M₂] [_inst_4 : forall (i : ι), Module.{u1, u3} R (M₁ i) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i))] [_inst_5 : Module.{u1, u4} R M₂ (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3)] [_inst_6 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_7 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) [_inst_8 : DecidableEq.{succ u2} ι] (m : forall (i : ι), M₁ i) (i : ι) (x : M₁ i) (y : M₁ i), Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i (HSub.hSub.{u3, u3, u3} (M₁ i) (M₁ i) (M₁ i) (instHSub.{u3} (M₁ i) (SubNegMonoid.toHasSub.{u3} (M₁ i) (AddGroup.toSubNegMonoid.{u3} (M₁ i) (AddCommGroup.toAddGroup.{u3} (M₁ i) (_inst_2 i))))) x y))) (HSub.hSub.{u4, u4, u4} M₂ M₂ M₂ (instHSub.{u4} M₂ (SubNegMonoid.toHasSub.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_3)))) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i x)) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i y)))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Ring.{u1} R] [_inst_2 : forall (i : ι), AddCommGroup.{u3} (M₁ i)] [_inst_3 : AddCommGroup.{u4} M₂] [_inst_4 : forall (i : ι), Module.{u1, u3} R (M₁ i) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i))] [_inst_5 : Module.{u1, u4} R M₂ (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3)] [_inst_6 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_7 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) [_inst_8 : DecidableEq.{succ u2} ι] (m : forall (i : ι), M₁ i) (i : ι) (x : M₁ i) (y : M₁ i), Eq.{succ u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i (HSub.hSub.{u3, u3, u3} (M₁ i) (M₁ i) (M₁ i) (instHSub.{u3} (M₁ i) (SubNegMonoid.toSub.{u3} (M₁ i) (AddGroup.toSubNegMonoid.{u3} (M₁ i) (AddCommGroup.toAddGroup.{u3} (M₁ i) (_inst_2 i))))) x y))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_6 i) a)) _inst_7 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7)) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i (HSub.hSub.{u3, u3, u3} (M₁ i) (M₁ i) (M₁ i) (instHSub.{u3} (M₁ i) (SubNegMonoid.toSub.{u3} (M₁ i) (AddGroup.toSubNegMonoid.{u3} (M₁ i) (AddCommGroup.toAddGroup.{u3} (M₁ i) (_inst_2 i))))) x y))) (HSub.hSub.{u4, u4, u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i x)) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i y)) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i x)) (instHSub.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i x)) (SubNegMonoid.toSub.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i x)) (AddGroup.toSubNegMonoid.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i x)) (AddCommGroup.toAddGroup.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i x)) _inst_3)))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_6 i) a)) _inst_7 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7)) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i x)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_6 i) a)) _inst_7 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7)) f (Function.update.{succ u2, succ u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) (b : ι) => _inst_8 a b) m i y)))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.map_sub ContinuousMultilinearMap.map_subₓ'. -/
@[simp]
theorem map_sub [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i) :
    f (update m i (x - y)) = f (update m i x) - f (update m i y) :=
  f.toMultilinearMap.map_sub _ _ _ _
#align continuous_multilinear_map.map_sub ContinuousMultilinearMap.map_sub

section TopologicalAddGroup

variable [TopologicalAddGroup M₂]

instance : Neg (ContinuousMultilinearMap R M₁ M₂) :=
  ⟨fun f => { -f.toMultilinearMap with cont := f.cont.neg }⟩

/- warning: continuous_multilinear_map.neg_apply -> ContinuousMultilinearMap.neg_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Ring.{u1} R] [_inst_2 : forall (i : ι), AddCommGroup.{u3} (M₁ i)] [_inst_3 : AddCommGroup.{u4} M₂] [_inst_4 : forall (i : ι), Module.{u1, u3} R (M₁ i) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i))] [_inst_5 : Module.{u1, u4} R M₂ (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3)] [_inst_6 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_7 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) [_inst_8 : TopologicalAddGroup.{u4} M₂ _inst_7 (AddCommGroup.toAddGroup.{u4} M₂ _inst_3)] (m : forall (i : ι), M₁ i), Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (Neg.neg.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (ContinuousMultilinearMap.hasNeg.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_2 i) _inst_3 (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7 _inst_8) f) m) (Neg.neg.{u4} M₂ (SubNegMonoid.toHasNeg.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_3))) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) f m))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Ring.{u1} R] [_inst_2 : forall (i : ι), AddCommGroup.{u3} (M₁ i)] [_inst_3 : AddCommGroup.{u4} M₂] [_inst_4 : forall (i : ι), Module.{u1, u3} R (M₁ i) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i))] [_inst_5 : Module.{u1, u4} R M₂ (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3)] [_inst_6 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_7 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) [_inst_8 : TopologicalAddGroup.{u4} M₂ _inst_7 (AddCommGroup.toAddGroup.{u4} M₂ _inst_3)] (m : forall (i : ι), M₁ i), Eq.{succ u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_6 i) a)) _inst_7 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7)) (Neg.neg.{max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (ContinuousMultilinearMap.instNegContinuousMultilinearMapToSemiringToAddCommMonoidToAddCommMonoid.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_2 i) _inst_3 (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7 _inst_8) f) m) (Neg.neg.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (NegZeroClass.toNeg.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) _inst_3))))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_6 i) a)) _inst_7 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7)) f m))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.neg_apply ContinuousMultilinearMap.neg_applyₓ'. -/
@[simp]
theorem neg_apply (m : ∀ i, M₁ i) : (-f) m = -f m :=
  rfl
#align continuous_multilinear_map.neg_apply ContinuousMultilinearMap.neg_apply

instance : Sub (ContinuousMultilinearMap R M₁ M₂) :=
  ⟨fun f g => { f.toMultilinearMap - g.toMultilinearMap with cont := f.cont.sub g.cont }⟩

/- warning: continuous_multilinear_map.sub_apply -> ContinuousMultilinearMap.sub_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Ring.{u1} R] [_inst_2 : forall (i : ι), AddCommGroup.{u3} (M₁ i)] [_inst_3 : AddCommGroup.{u4} M₂] [_inst_4 : forall (i : ι), Module.{u1, u3} R (M₁ i) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i))] [_inst_5 : Module.{u1, u4} R M₂ (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3)] [_inst_6 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_7 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (f' : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) [_inst_8 : TopologicalAddGroup.{u4} M₂ _inst_7 (AddCommGroup.toAddGroup.{u4} M₂ _inst_3)] (m : forall (i : ι), M₁ i), Eq.{succ u4} M₂ (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (HSub.hSub.{max u2 u3 u4, max u2 u3 u4, max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (instHSub.{max u2 u3 u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (ContinuousMultilinearMap.hasSub.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_2 i) _inst_3 (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7 _inst_8)) f f') m) (HSub.hSub.{u4, u4, u4} M₂ M₂ M₂ (instHSub.{u4} M₂ (SubNegMonoid.toHasSub.{u4} M₂ (AddGroup.toSubNegMonoid.{u4} M₂ (AddCommGroup.toAddGroup.{u4} M₂ _inst_3)))) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) f m) (coeFn.{max (succ u2) (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) => (forall (i : ι), M₁ i) -> M₂) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) f' m))
but is expected to have type
  forall {R : Type.{u1}} {ι : Type.{u2}} {M₁ : ι -> Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Ring.{u1} R] [_inst_2 : forall (i : ι), AddCommGroup.{u3} (M₁ i)] [_inst_3 : AddCommGroup.{u4} M₂] [_inst_4 : forall (i : ι), Module.{u1, u3} R (M₁ i) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i))] [_inst_5 : Module.{u1, u4} R M₂ (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3)] [_inst_6 : forall (i : ι), TopologicalSpace.{u3} (M₁ i)] [_inst_7 : TopologicalSpace.{u4} M₂] (f : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (f' : ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) [_inst_8 : TopologicalAddGroup.{u4} M₂ _inst_7 (AddCommGroup.toAddGroup.{u4} M₂ _inst_3)] (m : forall (i : ι), M₁ i), Eq.{succ u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_6 i) a)) _inst_7 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7)) (HSub.hSub.{max (max u2 u3) u4, max (max u2 u3) u4, max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (instHSub.{max (max u2 u3) u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7) (ContinuousMultilinearMap.instSubContinuousMultilinearMapToSemiringToAddCommMonoidToAddCommMonoid.{u1, u2, u3, u4} R ι M₁ M₂ _inst_1 (fun (i : ι) => _inst_2 i) _inst_3 (fun (i : ι) => _inst_4 i) _inst_5 (fun (i : ι) => _inst_6 i) _inst_7 _inst_8)) f f') m) (HSub.hSub.{u4, u4, u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (instHSub.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (SubNegMonoid.toSub.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddGroup.toSubNegMonoid.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) (AddCommGroup.toAddGroup.{u4} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) m) _inst_3)))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_6 i) a)) _inst_7 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7)) f m) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) (fun (_x : forall (i : ι), M₁ i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), M₁ i) => M₂) _x) (ContinuousMapClass.toFunLike.{max (max u2 u3) u4, max u2 u3, u4} (ContinuousMultilinearMap.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7) (forall (i : ι), M₁ i) M₂ (Pi.topologicalSpace.{u2, u3} ι (fun (i : ι) => M₁ i) (fun (a : ι) => (fun (i : ι) => _inst_6 i) a)) _inst_7 (ContinuousMultilinearMap.continuousMapClass.{u1, u2, u3, u4} R ι M₁ M₂ (Ring.toSemiring.{u1} R _inst_1) (fun (i : ι) => (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (M₁ i) (_inst_2 i)) i) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_3) (fun (i : ι) => (fun (i : ι) => _inst_4 i) i) _inst_5 (fun (i : ι) => (fun (i : ι) => _inst_6 i) i) _inst_7)) f' m))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.sub_apply ContinuousMultilinearMap.sub_applyₓ'. -/
@[simp]
theorem sub_apply (m : ∀ i, M₁ i) : (f - f') m = f m - f' m :=
  rfl
#align continuous_multilinear_map.sub_apply ContinuousMultilinearMap.sub_apply

instance : AddCommGroup (ContinuousMultilinearMap R M₁ M₂) :=
  toMultilinearMap_injective.AddCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) fun _ _ => rfl

end TopologicalAddGroup

end Ring

section CommSemiring

variable [CommSemiring R] [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [∀ i, Module R (M₁ i)]
  [Module R M₂] [∀ i, TopologicalSpace (M₁ i)] [TopologicalSpace M₂]
  (f : ContinuousMultilinearMap R M₁ M₂)

#print ContinuousMultilinearMap.map_piecewise_smul /-
theorem map_piecewise_smul [DecidableEq ι] (c : ι → R) (m : ∀ i, M₁ i) (s : Finset ι) :
    f (s.piecewise (fun i => c i • m i) m) = (∏ i in s, c i) • f m :=
  f.toMultilinearMap.map_piecewise_smul _ _ _
#align continuous_multilinear_map.map_piecewise_smul ContinuousMultilinearMap.map_piecewise_smul
-/

#print ContinuousMultilinearMap.map_smul_univ /-
/-- Multiplicativity of a continuous multilinear map along all coordinates at the same time,
writing `f (λ i, c i • m i)` as `(∏ i, c i) • f m`. -/
theorem map_smul_univ [Fintype ι] (c : ι → R) (m : ∀ i, M₁ i) :
    (f fun i => c i • m i) = (∏ i, c i) • f m :=
  f.toMultilinearMap.map_smul_univ _ _
#align continuous_multilinear_map.map_smul_univ ContinuousMultilinearMap.map_smul_univ
-/

end CommSemiring

section DistribMulAction

variable {R' R'' A : Type _} [Monoid R'] [Monoid R''] [Semiring A] [∀ i, AddCommMonoid (M₁ i)]
  [AddCommMonoid M₂] [∀ i, TopologicalSpace (M₁ i)] [TopologicalSpace M₂] [∀ i, Module A (M₁ i)]
  [Module A M₂] [DistribMulAction R' M₂] [ContinuousConstSMul R' M₂] [SMulCommClass A R' M₂]
  [DistribMulAction R'' M₂] [ContinuousConstSMul R'' M₂] [SMulCommClass A R'' M₂]

instance [ContinuousAdd M₂] : DistribMulAction R' (ContinuousMultilinearMap A M₁ M₂) :=
  Function.Injective.distribMulAction
    ⟨toMultilinearMap, toMultilinearMap_zero, toMultilinearMap_add⟩ toMultilinearMap_injective
    fun _ _ => rfl

end DistribMulAction

section Module

variable {R' A : Type _} [Semiring R'] [Semiring A] [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂]
  [∀ i, TopologicalSpace (M₁ i)] [TopologicalSpace M₂] [ContinuousAdd M₂] [∀ i, Module A (M₁ i)]
  [Module A M₂] [Module R' M₂] [ContinuousConstSMul R' M₂] [SMulCommClass A R' M₂]

/-- The space of continuous multilinear maps over an algebra over `R` is a module over `R`, for the
pointwise addition and scalar multiplication. -/
instance : Module R' (ContinuousMultilinearMap A M₁ M₂) :=
  Function.Injective.module _ ⟨toMultilinearMap, toMultilinearMap_zero, toMultilinearMap_add⟩
    toMultilinearMap_injective fun _ _ => rfl

/- warning: continuous_multilinear_map.to_multilinear_map_linear -> ContinuousMultilinearMap.toMultilinearMapLinear is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M₁ : ι -> Type.{u2}} {M₂ : Type.{u3}} {R' : Type.{u4}} {A : Type.{u5}} [_inst_1 : Semiring.{u4} R'] [_inst_2 : Semiring.{u5} A] [_inst_3 : forall (i : ι), AddCommMonoid.{u2} (M₁ i)] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : forall (i : ι), TopologicalSpace.{u2} (M₁ i)] [_inst_6 : TopologicalSpace.{u3} M₂] [_inst_7 : ContinuousAdd.{u3} M₂ _inst_6 (AddZeroClass.toHasAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)))] [_inst_8 : forall (i : ι), Module.{u5, u2} A (M₁ i) _inst_2 (_inst_3 i)] [_inst_9 : Module.{u5, u3} A M₂ _inst_2 _inst_4] [_inst_10 : Module.{u4, u3} R' M₂ _inst_1 _inst_4] [_inst_11 : ContinuousConstSMul.{u4, u3} R' M₂ _inst_6 (SMulZeroClass.toHasSmul.{u4, u3} R' M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (SMulWithZero.toSmulZeroClass.{u4, u3} R' M₂ (MulZeroClass.toHasZero.{u4} R' (MulZeroOneClass.toMulZeroClass.{u4} R' (MonoidWithZero.toMulZeroOneClass.{u4} R' (Semiring.toMonoidWithZero.{u4} R' _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (MulActionWithZero.toSMulWithZero.{u4, u3} R' M₂ (Semiring.toMonoidWithZero.{u4} R' _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (Module.toMulActionWithZero.{u4, u3} R' M₂ _inst_1 _inst_4 _inst_10))))] [_inst_12 : SMulCommClass.{u5, u4, u3} A R' M₂ (SMulZeroClass.toHasSmul.{u5, u3} A M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (SMulWithZero.toSmulZeroClass.{u5, u3} A M₂ (MulZeroClass.toHasZero.{u5} A (MulZeroOneClass.toMulZeroClass.{u5} A (MonoidWithZero.toMulZeroOneClass.{u5} A (Semiring.toMonoidWithZero.{u5} A _inst_2)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (MulActionWithZero.toSMulWithZero.{u5, u3} A M₂ (Semiring.toMonoidWithZero.{u5} A _inst_2) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (Module.toMulActionWithZero.{u5, u3} A M₂ _inst_2 _inst_4 _inst_9)))) (SMulZeroClass.toHasSmul.{u4, u3} R' M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (SMulWithZero.toSmulZeroClass.{u4, u3} R' M₂ (MulZeroClass.toHasZero.{u4} R' (MulZeroOneClass.toMulZeroClass.{u4} R' (MonoidWithZero.toMulZeroOneClass.{u4} R' (Semiring.toMonoidWithZero.{u4} R' _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (MulActionWithZero.toSMulWithZero.{u4, u3} R' M₂ (Semiring.toMonoidWithZero.{u4} R' _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (Module.toMulActionWithZero.{u4, u3} R' M₂ _inst_1 _inst_4 _inst_10))))], LinearMap.{u4, u4, max u1 u2 u3, max u1 u2 u3} R' R' _inst_1 _inst_1 (RingHom.id.{u4} R' (Semiring.toNonAssocSemiring.{u4} R' _inst_1)) (ContinuousMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_2 (fun (i : ι) => _inst_3 i) _inst_4 (fun (i : ι) => _inst_8 i) _inst_9 (fun (i : ι) => _inst_5 i) _inst_6) (MultilinearMap.{u5, u2, u3, u1} A ι M₁ M₂ _inst_2 (fun (i : ι) => _inst_3 i) _inst_4 (fun (i : ι) => _inst_8 i) _inst_9) (ContinuousMultilinearMap.addCommMonoid.{u5, u1, u2, u3} A ι M₁ M₂ _inst_2 (fun (i : ι) => _inst_3 i) _inst_4 (fun (i : ι) => _inst_8 i) _inst_9 (fun (i : ι) => _inst_5 i) _inst_6 _inst_7) (MultilinearMap.addCommMonoid.{u5, u2, u3, u1} A ι M₁ M₂ _inst_2 (fun (i : ι) => _inst_3 i) _inst_4 (fun (i : ι) => _inst_8 i) _inst_9) (ContinuousMultilinearMap.module.{u1, u2, u3, u4, u5} ι M₁ M₂ R' A _inst_1 _inst_2 (fun (i : ι) => _inst_3 i) _inst_4 (fun (i : ι) => _inst_5 i) _inst_6 _inst_7 (fun (i : ι) => _inst_8 i) _inst_9 _inst_10 _inst_11 _inst_12) (MultilinearMap.module.{u2, u3, u1, u4, u5} ι M₁ M₂ (fun (i : ι) => _inst_3 i) _inst_4 R' A _inst_1 _inst_2 (fun (i : ι) => _inst_8 i) _inst_9 _inst_10 _inst_12)
but is expected to have type
  forall {ι : Type.{u1}} {M₁ : ι -> Type.{u2}} {M₂ : Type.{u3}} {R' : Type.{u4}} {A : Type.{u5}} [_inst_1 : Semiring.{u4} R'] [_inst_2 : Semiring.{u5} A] [_inst_3 : forall (i : ι), AddCommMonoid.{u2} (M₁ i)] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : forall (i : ι), TopologicalSpace.{u2} (M₁ i)] [_inst_6 : TopologicalSpace.{u3} M₂] [_inst_7 : ContinuousAdd.{u3} M₂ _inst_6 (AddZeroClass.toAdd.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)))] [_inst_8 : forall (i : ι), Module.{u5, u2} A (M₁ i) _inst_2 (_inst_3 i)] [_inst_9 : Module.{u5, u3} A M₂ _inst_2 _inst_4] [_inst_10 : Module.{u4, u3} R' M₂ _inst_1 _inst_4] [_inst_11 : ContinuousConstSMul.{u4, u3} R' M₂ _inst_6 (SMulZeroClass.toSMul.{u4, u3} R' M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (SMulWithZero.toSMulZeroClass.{u4, u3} R' M₂ (MonoidWithZero.toZero.{u4} R' (Semiring.toMonoidWithZero.{u4} R' _inst_1)) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (MulActionWithZero.toSMulWithZero.{u4, u3} R' M₂ (Semiring.toMonoidWithZero.{u4} R' _inst_1) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (Module.toMulActionWithZero.{u4, u3} R' M₂ _inst_1 _inst_4 _inst_10))))] [_inst_12 : SMulCommClass.{u5, u4, u3} A R' M₂ (SMulZeroClass.toSMul.{u5, u3} A M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (SMulWithZero.toSMulZeroClass.{u5, u3} A M₂ (MonoidWithZero.toZero.{u5} A (Semiring.toMonoidWithZero.{u5} A _inst_2)) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (MulActionWithZero.toSMulWithZero.{u5, u3} A M₂ (Semiring.toMonoidWithZero.{u5} A _inst_2) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (Module.toMulActionWithZero.{u5, u3} A M₂ _inst_2 _inst_4 _inst_9)))) (SMulZeroClass.toSMul.{u4, u3} R' M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (SMulWithZero.toSMulZeroClass.{u4, u3} R' M₂ (MonoidWithZero.toZero.{u4} R' (Semiring.toMonoidWithZero.{u4} R' _inst_1)) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (MulActionWithZero.toSMulWithZero.{u4, u3} R' M₂ (Semiring.toMonoidWithZero.{u4} R' _inst_1) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (Module.toMulActionWithZero.{u4, u3} R' M₂ _inst_1 _inst_4 _inst_10))))], LinearMap.{u4, u4, max (max u3 u2) u1, max (max u1 u3) u2} R' R' _inst_1 _inst_1 (RingHom.id.{u4} R' (Semiring.toNonAssocSemiring.{u4} R' _inst_1)) (ContinuousMultilinearMap.{u5, u1, u2, u3} A ι M₁ M₂ _inst_2 (fun (i : ι) => _inst_3 i) _inst_4 (fun (i : ι) => _inst_8 i) _inst_9 (fun (i : ι) => _inst_5 i) _inst_6) (MultilinearMap.{u5, u2, u3, u1} A ι M₁ M₂ _inst_2 (fun (i : ι) => _inst_3 i) _inst_4 (fun (i : ι) => _inst_8 i) _inst_9) (ContinuousMultilinearMap.addCommMonoid.{u5, u1, u2, u3} A ι M₁ M₂ _inst_2 (fun (i : ι) => _inst_3 i) _inst_4 (fun (i : ι) => _inst_8 i) _inst_9 (fun (i : ι) => _inst_5 i) _inst_6 _inst_7) (MultilinearMap.addCommMonoid.{u5, u2, u3, u1} A ι M₁ M₂ _inst_2 (fun (i : ι) => _inst_3 i) _inst_4 (fun (i : ι) => _inst_8 i) _inst_9) (ContinuousMultilinearMap.instModuleContinuousMultilinearMapAddCommMonoid.{u1, u2, u3, u4, u5} ι M₁ M₂ R' A _inst_1 _inst_2 (fun (i : ι) => _inst_3 i) _inst_4 (fun (i : ι) => _inst_5 i) _inst_6 _inst_7 (fun (i : ι) => _inst_8 i) _inst_9 _inst_10 _inst_11 _inst_12) (MultilinearMap.instModuleMultilinearMapAddCommMonoid.{u2, u3, u1, u4, u5} ι M₁ M₂ (fun (i : ι) => _inst_3 i) _inst_4 R' A _inst_1 _inst_2 (fun (i : ι) => _inst_8 i) _inst_9 _inst_10 _inst_12)
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.to_multilinear_map_linear ContinuousMultilinearMap.toMultilinearMapLinearₓ'. -/
/-- Linear map version of the map `to_multilinear_map` associating to a continuous multilinear map
the corresponding multilinear map. -/
@[simps]
def toMultilinearMapLinear : ContinuousMultilinearMap A M₁ M₂ →ₗ[R'] MultilinearMap A M₁ M₂
    where
  toFun := toMultilinearMap
  map_add' := toMultilinearMap_add
  map_smul' := toMultilinearMap_smul
#align continuous_multilinear_map.to_multilinear_map_linear ContinuousMultilinearMap.toMultilinearMapLinear

/- warning: continuous_multilinear_map.pi_linear_equiv -> ContinuousMultilinearMap.piLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M₁ : ι -> Type.{u2}} {R' : Type.{u3}} {A : Type.{u4}} [_inst_1 : Semiring.{u3} R'] [_inst_2 : Semiring.{u4} A] [_inst_3 : forall (i : ι), AddCommMonoid.{u2} (M₁ i)] [_inst_5 : forall (i : ι), TopologicalSpace.{u2} (M₁ i)] [_inst_8 : forall (i : ι), Module.{u4, u2} A (M₁ i) _inst_2 (_inst_3 i)] {ι' : Type.{u5}} {M' : ι' -> Type.{u6}} [_inst_13 : forall (i : ι'), AddCommMonoid.{u6} (M' i)] [_inst_14 : forall (i : ι'), TopologicalSpace.{u6} (M' i)] [_inst_15 : forall (i : ι'), ContinuousAdd.{u6} (M' i) (_inst_14 i) (AddZeroClass.toHasAdd.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))))] [_inst_16 : forall (i : ι'), Module.{u3, u6} R' (M' i) _inst_1 (_inst_13 i)] [_inst_17 : forall (i : ι'), Module.{u4, u6} A (M' i) _inst_2 (_inst_13 i)] [_inst_18 : forall (i : ι'), SMulCommClass.{u4, u3, u6} A R' (M' i) (SMulZeroClass.toHasSmul.{u4, u6} A (M' i) (AddZeroClass.toHasZero.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i)))) (SMulWithZero.toSmulZeroClass.{u4, u6} A (M' i) (MulZeroClass.toHasZero.{u4} A (MulZeroOneClass.toMulZeroClass.{u4} A (MonoidWithZero.toMulZeroOneClass.{u4} A (Semiring.toMonoidWithZero.{u4} A _inst_2)))) (AddZeroClass.toHasZero.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i)))) (MulActionWithZero.toSMulWithZero.{u4, u6} A (M' i) (Semiring.toMonoidWithZero.{u4} A _inst_2) (AddZeroClass.toHasZero.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i)))) (Module.toMulActionWithZero.{u4, u6} A (M' i) _inst_2 (_inst_13 i) (_inst_17 i))))) (SMulZeroClass.toHasSmul.{u3, u6} R' (M' i) (AddZeroClass.toHasZero.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i)))) (SMulWithZero.toSmulZeroClass.{u3, u6} R' (M' i) (MulZeroClass.toHasZero.{u3} R' (MulZeroOneClass.toMulZeroClass.{u3} R' (MonoidWithZero.toMulZeroOneClass.{u3} R' (Semiring.toMonoidWithZero.{u3} R' _inst_1)))) (AddZeroClass.toHasZero.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i)))) (MulActionWithZero.toSMulWithZero.{u3, u6} R' (M' i) (Semiring.toMonoidWithZero.{u3} R' _inst_1) (AddZeroClass.toHasZero.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i)))) (Module.toMulActionWithZero.{u3, u6} R' (M' i) _inst_1 (_inst_13 i) (_inst_16 i)))))] [_inst_19 : forall (i : ι'), ContinuousConstSMul.{u3, u6} R' (M' i) (_inst_14 i) (SMulZeroClass.toHasSmul.{u3, u6} R' (M' i) (AddZeroClass.toHasZero.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i)))) (SMulWithZero.toSmulZeroClass.{u3, u6} R' (M' i) (MulZeroClass.toHasZero.{u3} R' (MulZeroOneClass.toMulZeroClass.{u3} R' (MonoidWithZero.toMulZeroOneClass.{u3} R' (Semiring.toMonoidWithZero.{u3} R' _inst_1)))) (AddZeroClass.toHasZero.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i)))) (MulActionWithZero.toSMulWithZero.{u3, u6} R' (M' i) (Semiring.toMonoidWithZero.{u3} R' _inst_1) (AddZeroClass.toHasZero.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i)))) (Module.toMulActionWithZero.{u3, u6} R' (M' i) _inst_1 (_inst_13 i) (_inst_16 i)))))], LinearEquiv.{u3, u3, max u5 u1 u2 u6, max u1 u2 u5 u6} R' R' _inst_1 _inst_1 (RingHom.id.{u3} R' (Semiring.toNonAssocSemiring.{u3} R' _inst_1)) (RingHom.id.{u3} R' (Semiring.toNonAssocSemiring.{u3} R' _inst_1)) (RingHomInvPair.ids.{u3} R' _inst_1) (RingHomInvPair.ids.{u3} R' _inst_1) (forall (i : ι'), ContinuousMultilinearMap.{u4, u1, u2, u6} A ι M₁ (M' i) _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (fun (i : ι) => _inst_5 i) (_inst_14 i)) (ContinuousMultilinearMap.{u4, u1, u2, max u5 u6} A ι M₁ (forall (i : ι'), M' i) _inst_2 (fun (i : ι) => _inst_3 i) (Pi.addCommMonoid.{u5, u6} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_13 i)) (fun (i : ι) => _inst_8 i) (Pi.module.{u5, u6, u4} ι' (fun (i : ι') => M' i) A _inst_2 (fun (i : ι') => _inst_13 i) (fun (i : ι') => _inst_17 i)) (fun (i : ι) => _inst_5 i) (Pi.topologicalSpace.{u5, u6} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_14 a))) (Pi.addCommMonoid.{u5, max u1 u2 u6} ι' (fun (i : ι') => ContinuousMultilinearMap.{u4, u1, u2, u6} A ι M₁ (M' i) _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (fun (i : ι) => _inst_5 i) (_inst_14 i)) (fun (i : ι') => ContinuousMultilinearMap.addCommMonoid.{u4, u1, u2, u6} A ι M₁ (M' i) _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (fun (i : ι) => _inst_5 i) (_inst_14 i) (_inst_15 i))) (ContinuousMultilinearMap.addCommMonoid.{u4, u1, u2, max u5 u6} A ι M₁ (forall (i : ι'), M' i) _inst_2 (fun (i : ι) => _inst_3 i) (Pi.addCommMonoid.{u5, u6} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_13 i)) (fun (i : ι) => _inst_8 i) (Pi.module.{u5, u6, u4} ι' (fun (i : ι') => M' i) A _inst_2 (fun (i : ι') => _inst_13 i) (fun (i : ι') => _inst_17 i)) (fun (i : ι) => _inst_5 i) (Pi.topologicalSpace.{u5, u6} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_14 a)) (ContinuousMultilinearMap.piLinearEquiv._proof_1.{u5, u6} ι' M' _inst_13 _inst_14 _inst_15)) (Pi.module.{u5, max u1 u2 u6, u3} ι' (fun (i : ι') => ContinuousMultilinearMap.{u4, u1, u2, u6} A ι M₁ (M' i) _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (fun (i : ι) => _inst_5 i) (_inst_14 i)) R' _inst_1 (fun (i : ι') => ContinuousMultilinearMap.addCommMonoid.{u4, u1, u2, u6} A ι M₁ (M' i) _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (fun (i : ι) => _inst_5 i) (_inst_14 i) (_inst_15 i)) (fun (i : ι') => ContinuousMultilinearMap.module.{u1, u2, u6, u3, u4} ι M₁ (M' i) R' A _inst_1 _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_5 i) (_inst_14 i) (_inst_15 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (_inst_16 i) (_inst_19 i) (_inst_18 i))) (ContinuousMultilinearMap.module.{u1, u2, max u5 u6, u3, u4} ι M₁ (forall (i : ι'), M' i) R' A _inst_1 _inst_2 (fun (i : ι) => _inst_3 i) (Pi.addCommMonoid.{u5, u6} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_13 i)) (fun (i : ι) => _inst_5 i) (Pi.topologicalSpace.{u5, u6} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_14 a)) (ContinuousMultilinearMap.piLinearEquiv._proof_2.{u5, u6} ι' M' _inst_13 _inst_14 _inst_15) (fun (i : ι) => _inst_8 i) (Pi.module.{u5, u6, u4} ι' (fun (i : ι') => M' i) A _inst_2 (fun (i : ι') => _inst_13 i) (fun (i : ι') => _inst_17 i)) (Pi.module.{u5, u6, u3} ι' (fun (i : ι') => M' i) R' _inst_1 (fun (i : ι') => _inst_13 i) (fun (i : ι') => _inst_16 i)) (ContinuousMultilinearMap.piLinearEquiv._proof_3.{u3, u5, u6} R' _inst_1 ι' M' _inst_13 _inst_14 _inst_16 _inst_19) (ContinuousMultilinearMap.piLinearEquiv._proof_4.{u3, u4, u5, u6} R' A _inst_1 _inst_2 ι' M' _inst_13 _inst_16 _inst_17 _inst_18))
but is expected to have type
  forall {ι : Type.{u1}} {M₁ : ι -> Type.{u2}} {R' : Type.{u3}} {A : Type.{u4}} [_inst_1 : Semiring.{u3} R'] [_inst_2 : Semiring.{u4} A] [_inst_3 : forall (i : ι), AddCommMonoid.{u2} (M₁ i)] [_inst_5 : forall (i : ι), TopologicalSpace.{u2} (M₁ i)] [_inst_8 : forall (i : ι), Module.{u4, u2} A (M₁ i) _inst_2 (_inst_3 i)] {ι' : Type.{u5}} {M' : ι' -> Type.{u6}} [_inst_13 : forall (i : ι'), AddCommMonoid.{u6} (M' i)] [_inst_14 : forall (i : ι'), TopologicalSpace.{u6} (M' i)] [_inst_15 : forall (i : ι'), ContinuousAdd.{u6} (M' i) (_inst_14 i) (AddZeroClass.toAdd.{u6} (M' i) (AddMonoid.toAddZeroClass.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))))] [_inst_16 : forall (i : ι'), Module.{u3, u6} R' (M' i) _inst_1 (_inst_13 i)] [_inst_17 : forall (i : ι'), Module.{u4, u6} A (M' i) _inst_2 (_inst_13 i)] [_inst_18 : forall (i : ι'), SMulCommClass.{u4, u3, u6} A R' (M' i) (SMulZeroClass.toSMul.{u4, u6} A (M' i) (AddMonoid.toZero.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))) (SMulWithZero.toSMulZeroClass.{u4, u6} A (M' i) (MonoidWithZero.toZero.{u4} A (Semiring.toMonoidWithZero.{u4} A _inst_2)) (AddMonoid.toZero.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))) (MulActionWithZero.toSMulWithZero.{u4, u6} A (M' i) (Semiring.toMonoidWithZero.{u4} A _inst_2) (AddMonoid.toZero.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))) (Module.toMulActionWithZero.{u4, u6} A (M' i) _inst_2 (_inst_13 i) (_inst_17 i))))) (SMulZeroClass.toSMul.{u3, u6} R' (M' i) (AddMonoid.toZero.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))) (SMulWithZero.toSMulZeroClass.{u3, u6} R' (M' i) (MonoidWithZero.toZero.{u3} R' (Semiring.toMonoidWithZero.{u3} R' _inst_1)) (AddMonoid.toZero.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))) (MulActionWithZero.toSMulWithZero.{u3, u6} R' (M' i) (Semiring.toMonoidWithZero.{u3} R' _inst_1) (AddMonoid.toZero.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))) (Module.toMulActionWithZero.{u3, u6} R' (M' i) _inst_1 (_inst_13 i) (_inst_16 i)))))] [_inst_19 : forall (i : ι'), ContinuousConstSMul.{u3, u6} R' (M' i) (_inst_14 i) (SMulZeroClass.toSMul.{u3, u6} R' (M' i) (AddMonoid.toZero.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))) (SMulWithZero.toSMulZeroClass.{u3, u6} R' (M' i) (MonoidWithZero.toZero.{u3} R' (Semiring.toMonoidWithZero.{u3} R' _inst_1)) (AddMonoid.toZero.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))) (MulActionWithZero.toSMulWithZero.{u3, u6} R' (M' i) (Semiring.toMonoidWithZero.{u3} R' _inst_1) (AddMonoid.toZero.{u6} (M' i) (AddCommMonoid.toAddMonoid.{u6} (M' i) (_inst_13 i))) (Module.toMulActionWithZero.{u3, u6} R' (M' i) _inst_1 (_inst_13 i) (_inst_16 i)))))], LinearEquiv.{u3, u3, max (max (max u1 u2) u5) u6, max (max (max u5 u6) u2) u1} R' R' _inst_1 _inst_1 (RingHom.id.{u3} R' (Semiring.toNonAssocSemiring.{u3} R' _inst_1)) (RingHom.id.{u3} R' (Semiring.toNonAssocSemiring.{u3} R' _inst_1)) (RingHomInvPair.ids.{u3} R' _inst_1) (RingHomInvPair.ids.{u3} R' _inst_1) (forall (i : ι'), ContinuousMultilinearMap.{u4, u1, u2, u6} A ι M₁ (M' i) _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (fun (i : ι) => _inst_5 i) (_inst_14 i)) (ContinuousMultilinearMap.{u4, u1, u2, max u5 u6} A ι M₁ (forall (i : ι'), M' i) _inst_2 (fun (i : ι) => _inst_3 i) (Pi.addCommMonoid.{u5, u6} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_13 i)) (fun (i : ι) => _inst_8 i) (Pi.module.{u5, u6, u4} ι' (fun (i : ι') => M' i) A _inst_2 (fun (i : ι') => _inst_13 i) (fun (i : ι') => _inst_17 i)) (fun (i : ι) => _inst_5 i) (Pi.topologicalSpace.{u5, u6} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_14 a))) (Pi.addCommMonoid.{u5, max (max u1 u2) u6} ι' (fun (i : ι') => ContinuousMultilinearMap.{u4, u1, u2, u6} A ι M₁ (M' i) _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (fun (i : ι) => _inst_5 i) (_inst_14 i)) (fun (i : ι') => ContinuousMultilinearMap.addCommMonoid.{u4, u1, u2, u6} A ι M₁ (M' i) _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (fun (i : ι) => _inst_5 i) (_inst_14 i) (_inst_15 i))) (ContinuousMultilinearMap.addCommMonoid.{u4, u1, u2, max u5 u6} A ι M₁ (forall (i : ι'), M' i) _inst_2 (fun (i : ι) => _inst_3 i) (Pi.addCommMonoid.{u5, u6} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_13 i)) (fun (i : ι) => _inst_8 i) (Pi.module.{u5, u6, u4} ι' (fun (i : ι') => M' i) A _inst_2 (fun (i : ι') => _inst_13 i) (fun (i : ι') => _inst_17 i)) (fun (i : ι) => _inst_5 i) (Pi.topologicalSpace.{u5, u6} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_14 a)) (Pi.continuousAdd.{u5, u6} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_14 a) (fun (i : ι') => AddSemigroup.toAdd.{u6} ((fun (i : ι') => (fun (i : ι') => (fun (i : ι') => M' i) i) i) i) ((fun (i : ι') => AddMonoid.toAddSemigroup.{u6} ((fun (i : ι') => (fun (i : ι') => M' i) i) i) ((fun (i : ι') => AddCommMonoid.toAddMonoid.{u6} ((fun (i : ι') => M' i) i) ((fun (i : ι') => _inst_13 i) i)) i)) i)) (fun (i : ι') => _inst_15 i))) (Pi.module.{u5, max (max u1 u2) u6, u3} ι' (fun (i : ι') => ContinuousMultilinearMap.{u4, u1, u2, u6} A ι M₁ (M' i) _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (fun (i : ι) => _inst_5 i) (_inst_14 i)) R' _inst_1 (fun (i : ι') => ContinuousMultilinearMap.addCommMonoid.{u4, u1, u2, u6} A ι M₁ (M' i) _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (fun (i : ι) => _inst_5 i) (_inst_14 i) (_inst_15 i)) (fun (i : ι') => ContinuousMultilinearMap.instModuleContinuousMultilinearMapAddCommMonoid.{u1, u2, u6, u3, u4} ι M₁ (M' i) R' A _inst_1 _inst_2 (fun (i : ι) => _inst_3 i) (_inst_13 i) (fun (i : ι) => _inst_5 i) (_inst_14 i) (_inst_15 i) (fun (i : ι) => _inst_8 i) (_inst_17 i) (_inst_16 i) (_inst_19 i) (_inst_18 i))) (ContinuousMultilinearMap.instModuleContinuousMultilinearMapAddCommMonoid.{u1, u2, max u5 u6, u3, u4} ι M₁ (forall (i : ι'), M' i) R' A _inst_1 _inst_2 (fun (i : ι) => _inst_3 i) (Pi.addCommMonoid.{u5, u6} ι' (fun (i : ι') => M' i) (fun (i : ι') => _inst_13 i)) (fun (i : ι) => _inst_5 i) (Pi.topologicalSpace.{u5, u6} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_14 a)) (Pi.continuousAdd.{u5, u6} ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_14 a) (fun (i : ι') => AddSemigroup.toAdd.{u6} ((fun (i : ι') => (fun (i : ι') => (fun (i : ι') => M' i) i) i) i) ((fun (i : ι') => AddMonoid.toAddSemigroup.{u6} ((fun (i : ι') => (fun (i : ι') => M' i) i) i) ((fun (i : ι') => AddCommMonoid.toAddMonoid.{u6} ((fun (i : ι') => M' i) i) ((fun (i : ι') => _inst_13 i) i)) i)) i)) (fun (i : ι') => _inst_15 i)) (fun (i : ι) => _inst_8 i) (Pi.module.{u5, u6, u4} ι' (fun (i : ι') => M' i) A _inst_2 (fun (i : ι') => _inst_13 i) (fun (i : ι') => _inst_17 i)) (Pi.module.{u5, u6, u3} ι' (fun (i : ι') => M' i) R' _inst_1 (fun (i : ι') => _inst_13 i) (fun (i : ι') => _inst_16 i)) (instContinuousConstSMulForAllTopologicalSpaceInstSMul.{u3, u5, u6} R' ι' (fun (i : ι') => M' i) (fun (a : ι') => _inst_14 a) (fun (i : ι') => MulAction.toSMul.{u3, u6} R' ((fun (i : ι') => (fun (i : ι') => (fun (i : ι') => M' i) i) i) i) (MonoidWithZero.toMonoid.{u3} R' (Semiring.toMonoidWithZero.{u3} R' _inst_1)) ((fun (i : ι') => DistribMulAction.toMulAction.{u3, u6} R' ((fun (i : ι') => (fun (i : ι') => M' i) i) i) (MonoidWithZero.toMonoid.{u3} R' (Semiring.toMonoidWithZero.{u3} R' _inst_1)) ((fun (i : ι') => AddCommMonoid.toAddMonoid.{u6} ((fun (i : ι') => M' i) i) ((fun (i : ι') => _inst_13 i) i)) i) ((fun (i : ι') => Module.toDistribMulAction.{u3, u6} R' ((fun (i : ι') => M' i) i) _inst_1 ((fun (i : ι') => _inst_13 i) i) ((fun (i : ι') => _inst_16 i) i)) i)) i)) (fun (i : ι') => _inst_19 i)) (Pi.smulCommClass.{u5, u6, u4, u3} ι' (fun (i : ι') => M' i) A R' (fun (i : ι') => MulAction.toSMul.{u4, u6} A ((fun (i : ι') => (fun (i : ι') => (fun (i : ι') => M' i) i) i) i) (MonoidWithZero.toMonoid.{u4} A (Semiring.toMonoidWithZero.{u4} A _inst_2)) ((fun (i : ι') => DistribMulAction.toMulAction.{u4, u6} A ((fun (i : ι') => (fun (i : ι') => M' i) i) i) (MonoidWithZero.toMonoid.{u4} A (Semiring.toMonoidWithZero.{u4} A _inst_2)) ((fun (i : ι') => AddCommMonoid.toAddMonoid.{u6} ((fun (i : ι') => M' i) i) ((fun (i : ι') => _inst_13 i) i)) i) ((fun (i : ι') => Module.toDistribMulAction.{u4, u6} A ((fun (i : ι') => M' i) i) _inst_2 ((fun (i : ι') => _inst_13 i) i) ((fun (i : ι') => _inst_17 i) i)) i)) i)) (fun (i : ι') => MulAction.toSMul.{u3, u6} R' ((fun (i : ι') => (fun (i : ι') => (fun (i : ι') => M' i) i) i) i) (MonoidWithZero.toMonoid.{u3} R' (Semiring.toMonoidWithZero.{u3} R' _inst_1)) ((fun (i : ι') => DistribMulAction.toMulAction.{u3, u6} R' ((fun (i : ι') => (fun (i : ι') => M' i) i) i) (MonoidWithZero.toMonoid.{u3} R' (Semiring.toMonoidWithZero.{u3} R' _inst_1)) ((fun (i : ι') => AddCommMonoid.toAddMonoid.{u6} ((fun (i : ι') => M' i) i) ((fun (i : ι') => _inst_13 i) i)) i) ((fun (i : ι') => Module.toDistribMulAction.{u3, u6} R' ((fun (i : ι') => M' i) i) _inst_1 ((fun (i : ι') => _inst_13 i) i) ((fun (i : ι') => _inst_16 i) i)) i)) i)) (fun (i : ι') => _inst_18 i)))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.pi_linear_equiv ContinuousMultilinearMap.piLinearEquivₓ'. -/
/-- `continuous_multilinear_map.pi` as a `linear_equiv`. -/
@[simps (config := { simpRhs := true })]
def piLinearEquiv {ι' : Type _} {M' : ι' → Type _} [∀ i, AddCommMonoid (M' i)]
    [∀ i, TopologicalSpace (M' i)] [∀ i, ContinuousAdd (M' i)] [∀ i, Module R' (M' i)]
    [∀ i, Module A (M' i)] [∀ i, SMulCommClass A R' (M' i)] [∀ i, ContinuousConstSMul R' (M' i)] :
    (∀ i, ContinuousMultilinearMap A M₁ (M' i)) ≃ₗ[R'] ContinuousMultilinearMap A M₁ (∀ i, M' i) :=
  { piEquiv with
    map_add' := fun x y => rfl
    map_smul' := fun c x => rfl }
#align continuous_multilinear_map.pi_linear_equiv ContinuousMultilinearMap.piLinearEquiv

end Module

section CommAlgebra

variable (R ι) (A : Type _) [Fintype ι] [CommSemiring R] [CommSemiring A] [Algebra R A]
  [TopologicalSpace A] [ContinuousMul A]

/- warning: continuous_multilinear_map.mk_pi_algebra -> ContinuousMultilinearMap.mkPiAlgebra is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (ι : Type.{u2}) (A : Type.{u3}) [_inst_1 : Fintype.{u2} ι] [_inst_2 : CommSemiring.{u1} R] [_inst_3 : CommSemiring.{u3} A] [_inst_4 : Algebra.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3)] [_inst_5 : TopologicalSpace.{u3} A] [_inst_6 : ContinuousMul.{u3} A _inst_5 (Distrib.toHasMul.{u3} A (NonUnitalNonAssocSemiring.toDistrib.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))))], ContinuousMultilinearMap.{u1, u2, u3, u3} R ι (fun (i : ι) => A) A (CommSemiring.toSemiring.{u1} R _inst_2) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))) (fun (i : ι) => Algebra.toModule.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3) _inst_4) (Algebra.toModule.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3) _inst_4) (fun (i : ι) => _inst_5) _inst_5
but is expected to have type
  forall (R : Type.{u1}) (ι : Type.{u2}) (A : Type.{u3}) [_inst_1 : Fintype.{u2} ι] [_inst_2 : CommSemiring.{u1} R] [_inst_3 : CommSemiring.{u3} A] [_inst_4 : Algebra.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3)] [_inst_5 : TopologicalSpace.{u3} A] [_inst_6 : ContinuousMul.{u3} A _inst_5 (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3))))], ContinuousMultilinearMap.{u1, u2, u3, u3} R ι (fun (i : ι) => A) A (CommSemiring.toSemiring.{u1} R _inst_2) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (Semiring.toNonAssocSemiring.{u3} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (CommSemiring.toSemiring.{u3} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))) (fun (i : ι) => Algebra.toModule.{u1, u3} R ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_2 (CommSemiring.toSemiring.{u3} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_3) _inst_4) (Algebra.toModule.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3) _inst_4) (fun (i : ι) => _inst_5) _inst_5
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.mk_pi_algebra ContinuousMultilinearMap.mkPiAlgebraₓ'. -/
/-- The continuous multilinear map on `A^ι`, where `A` is a normed commutative algebra
over `𝕜`, associating to `m` the product of all the `m i`.

See also `continuous_multilinear_map.mk_pi_algebra_fin`. -/
protected def mkPiAlgebra : ContinuousMultilinearMap R (fun i : ι => A) A
    where
  cont := continuous_finset_prod _ fun i hi => continuous_apply _
  toMultilinearMap := MultilinearMap.mkPiAlgebra R ι A
#align continuous_multilinear_map.mk_pi_algebra ContinuousMultilinearMap.mkPiAlgebra

/- warning: continuous_multilinear_map.mk_pi_algebra_apply -> ContinuousMultilinearMap.mkPiAlgebra_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (ι : Type.{u2}) (A : Type.{u3}) [_inst_1 : Fintype.{u2} ι] [_inst_2 : CommSemiring.{u1} R] [_inst_3 : CommSemiring.{u3} A] [_inst_4 : Algebra.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3)] [_inst_5 : TopologicalSpace.{u3} A] [_inst_6 : ContinuousMul.{u3} A _inst_5 (Distrib.toHasMul.{u3} A (NonUnitalNonAssocSemiring.toDistrib.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))))] (m : ι -> A), Eq.{succ u3} A (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (ContinuousMultilinearMap.{u1, u2, u3, u3} R ι (fun (i : ι) => A) A (CommSemiring.toSemiring.{u1} R _inst_2) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))) (fun (i : ι) => Algebra.toModule.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3) _inst_4) (Algebra.toModule.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3) _inst_4) (fun (i : ι) => _inst_5) _inst_5) (fun (_x : ContinuousMultilinearMap.{u1, u2, u3, u3} R ι (fun (i : ι) => A) A (CommSemiring.toSemiring.{u1} R _inst_2) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))) (fun (i : ι) => Algebra.toModule.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3) _inst_4) (Algebra.toModule.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3) _inst_4) (fun (i : ι) => _inst_5) _inst_5) => (ι -> A) -> A) (ContinuousMultilinearMap.hasCoeToFun.{u1, u2, u3, u3} R ι (fun (i : ι) => A) A (CommSemiring.toSemiring.{u1} R _inst_2) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_3)))) (fun (i : ι) => Algebra.toModule.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3) _inst_4) (Algebra.toModule.{u1, u3} R A _inst_2 (CommSemiring.toSemiring.{u3} A _inst_3) _inst_4) (fun (i : ι) => _inst_5) _inst_5) (ContinuousMultilinearMap.mkPiAlgebra.{u1, u2, u3} R ι A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) m) (Finset.prod.{u3, u2} A ι (CommSemiring.toCommMonoid.{u3} A _inst_3) (Finset.univ.{u2} ι _inst_1) (fun (i : ι) => m i))
but is expected to have type
  forall (R : Type.{u2}) (ι : Type.{u3}) (A : Type.{u1}) [_inst_1 : Fintype.{u3} ι] [_inst_2 : CommSemiring.{u2} R] [_inst_3 : CommSemiring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A _inst_2 (CommSemiring.toSemiring.{u1} A _inst_3)] [_inst_5 : TopologicalSpace.{u1} A] [_inst_6 : ContinuousMul.{u1} A _inst_5 (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A _inst_3))))] (m : ι -> A), Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), (fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) => A) m) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), succ u1} (ContinuousMultilinearMap.{u2, u3, u1, u1} R ι (fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) A (CommSemiring.toSemiring.{u2} R _inst_2) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_3)))) i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A _inst_3)))) (fun (i : ι) => (fun (i : ι) => Algebra.toModule.{u2, u1} R ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_2 (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_3) _inst_4) i) (Algebra.toModule.{u2, u1} R A _inst_2 (CommSemiring.toSemiring.{u1} A _inst_3) _inst_4) (fun (i : ι) => (fun (i : ι) => _inst_5) i) _inst_5) (forall (i : ι), (fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (fun (_x : forall (i : ι), (fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : ι), (fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) => A) _x) (ContinuousMapClass.toFunLike.{max u3 u1, max u3 u1, u1} (ContinuousMultilinearMap.{u2, u3, u1, u1} R ι (fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) A (CommSemiring.toSemiring.{u2} R _inst_2) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_3)))) i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A _inst_3)))) (fun (i : ι) => (fun (i : ι) => Algebra.toModule.{u2, u1} R ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_2 (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_3) _inst_4) i) (Algebra.toModule.{u2, u1} R A _inst_2 (CommSemiring.toSemiring.{u1} A _inst_3) _inst_4) (fun (i : ι) => (fun (i : ι) => _inst_5) i) _inst_5) (forall (i : ι), (fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) A (Pi.topologicalSpace.{u3, u1} ι (fun (i : ι) => (fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (fun (a : ι) => (fun (i : ι) => _inst_5) a)) _inst_5 (ContinuousMultilinearMap.continuousMapClass.{u2, u3, u1, u1} R ι (fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) A (CommSemiring.toSemiring.{u2} R _inst_2) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_3)))) i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (CommSemiring.toSemiring.{u1} A _inst_3)))) (fun (i : ι) => (fun (i : ι) => Algebra.toModule.{u2, u1} R ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_2 (CommSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22059 : ι) => A) i) _inst_3) _inst_4) i) (Algebra.toModule.{u2, u1} R A _inst_2 (CommSemiring.toSemiring.{u1} A _inst_3) _inst_4) (fun (i : ι) => (fun (i : ι) => _inst_5) i) _inst_5)) (ContinuousMultilinearMap.mkPiAlgebra.{u2, u3, u1} R ι A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) m) (Finset.prod.{u1, u3} A ι (CommSemiring.toCommMonoid.{u1} A _inst_3) (Finset.univ.{u3} ι _inst_1) (fun (i : ι) => m i))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.mk_pi_algebra_apply ContinuousMultilinearMap.mkPiAlgebra_applyₓ'. -/
@[simp]
theorem mkPiAlgebra_apply (m : ι → A) : ContinuousMultilinearMap.mkPiAlgebra R ι A m = ∏ i, m i :=
  rfl
#align continuous_multilinear_map.mk_pi_algebra_apply ContinuousMultilinearMap.mkPiAlgebra_apply

end CommAlgebra

section Algebra

variable (R n) (A : Type _) [CommSemiring R] [Semiring A] [Algebra R A] [TopologicalSpace A]
  [ContinuousMul A]

/- warning: continuous_multilinear_map.mk_pi_algebra_fin -> ContinuousMultilinearMap.mkPiAlgebraFin is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (n : Nat) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} A] [_inst_5 : ContinuousMul.{u2} A _inst_4 (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))], ContinuousMultilinearMap.{u1, 0, u2, u2} R (Fin n) (fun (i : Fin n) => A) A (CommSemiring.toSemiring.{u1} R _inst_1) (fun (i : Fin n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (fun (i : Fin n) => Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (fun (i : Fin n) => _inst_4) _inst_4
but is expected to have type
  forall (R : Type.{u1}) (n : Nat) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} A] [_inst_5 : ContinuousMul.{u2} A _inst_4 (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))], ContinuousMultilinearMap.{u1, 0, u2, u2} R (Fin n) (fun (i : Fin n) => A) A (CommSemiring.toSemiring.{u1} R _inst_1) (fun (i : Fin n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (fun (i : Fin n) => Algebra.toModule.{u1, u2} R ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) _inst_1 _inst_2 _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (fun (i : Fin n) => _inst_4) _inst_4
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.mk_pi_algebra_fin ContinuousMultilinearMap.mkPiAlgebraFinₓ'. -/
/-- The continuous multilinear map on `A^n`, where `A` is a normed algebra over `𝕜`, associating to
`m` the product of all the `m i`.

See also: `continuous_multilinear_map.mk_pi_algebra`. -/
protected def mkPiAlgebraFin : A[×n]→L[R] A
    where
  cont := by
    change Continuous fun m => (List.ofFn m).Prod
    simp_rw [List.ofFn_eq_map]
    exact continuous_list_prod _ fun i hi => continuous_apply _
  toMultilinearMap := MultilinearMap.mkPiAlgebraFin R n A
#align continuous_multilinear_map.mk_pi_algebra_fin ContinuousMultilinearMap.mkPiAlgebraFin

variable {R n A}

/- warning: continuous_multilinear_map.mk_pi_algebra_fin_apply -> ContinuousMultilinearMap.mkPiAlgebraFin_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {n : Nat} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u2} A] [_inst_5 : ContinuousMul.{u2} A _inst_4 (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))] (m : (Fin n) -> A), Eq.{succ u2} A (coeFn.{succ u2, succ u2} (ContinuousMultilinearMap.{u1, 0, u2, u2} R (Fin n) (fun (i : Fin n) => A) A (CommSemiring.toSemiring.{u1} R _inst_1) (fun (i : Fin n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (fun (i : Fin n) => Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (fun (i : Fin n) => _inst_4) _inst_4) (fun (_x : ContinuousMultilinearMap.{u1, 0, u2, u2} R (Fin n) (fun (i : Fin n) => A) A (CommSemiring.toSemiring.{u1} R _inst_1) (fun (i : Fin n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (fun (i : Fin n) => Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (fun (i : Fin n) => _inst_4) _inst_4) => ((Fin n) -> A) -> A) (ContinuousMultilinearMap.hasCoeToFun.{u1, 0, u2, u2} R (Fin n) (fun (i : Fin n) => A) A (CommSemiring.toSemiring.{u1} R _inst_1) (fun (i : Fin n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (fun (i : Fin n) => Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3) (fun (i : Fin n) => _inst_4) _inst_4) (ContinuousMultilinearMap.mkPiAlgebraFin.{u1, u2} R n A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) m) (List.prod.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) (List.ofFn.{u2} A n m))
but is expected to have type
  forall {R : Type.{u2}} {n : Nat} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Semiring.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 _inst_2] [_inst_4 : TopologicalSpace.{u1} A] [_inst_5 : ContinuousMul.{u1} A _inst_4 (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))] (m : (Fin n) -> A), Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin n), (fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) => A) m) (FunLike.coe.{succ u1, succ u1, succ u1} (ContinuousMultilinearMap.{u2, 0, u1, u1} R (Fin n) (fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) A (CommSemiring.toSemiring.{u2} R _inst_1) (fun (i : Fin n) => (fun (i : Fin n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) _inst_2))) i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (fun (i : Fin n) => (fun (i : Fin n) => Algebra.toModule.{u2, u1} R ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) _inst_1 _inst_2 _inst_3) i) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3) (fun (i : Fin n) => (fun (i : Fin n) => _inst_4) i) _inst_4) (forall (i : Fin n), (fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) (fun (_x : forall (i : Fin n), (fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : forall (i : Fin n), (fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) => A) _x) (ContinuousMapClass.toFunLike.{u1, u1, u1} (ContinuousMultilinearMap.{u2, 0, u1, u1} R (Fin n) (fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) A (CommSemiring.toSemiring.{u2} R _inst_1) (fun (i : Fin n) => (fun (i : Fin n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) _inst_2))) i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (fun (i : Fin n) => (fun (i : Fin n) => Algebra.toModule.{u2, u1} R ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) _inst_1 _inst_2 _inst_3) i) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3) (fun (i : Fin n) => (fun (i : Fin n) => _inst_4) i) _inst_4) (forall (i : Fin n), (fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) A (Pi.topologicalSpace.{0, u1} (Fin n) (fun (i : Fin n) => (fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) (fun (a : Fin n) => (fun (i : Fin n) => _inst_4) a)) _inst_4 (ContinuousMultilinearMap.continuousMapClass.{u2, 0, u1, u1} R (Fin n) (fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) A (CommSemiring.toSemiring.{u2} R _inst_1) (fun (i : Fin n) => (fun (i : Fin n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) _inst_2))) i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (fun (i : Fin n) => (fun (i : Fin n) => Algebra.toModule.{u2, u1} R ((fun (i._@.Mathlib.Topology.Algebra.Module.Multilinear._hyg.22228 : Fin n) => A) i) _inst_1 _inst_2 _inst_3) i) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3) (fun (i : Fin n) => (fun (i : Fin n) => _inst_4) i) _inst_4)) (ContinuousMultilinearMap.mkPiAlgebraFin.{u2, u1} R n A _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) m) (List.prod.{u1} A (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Semiring.toOne.{u1} A _inst_2) (List.ofFn.{u1} A n m))
Case conversion may be inaccurate. Consider using '#align continuous_multilinear_map.mk_pi_algebra_fin_apply ContinuousMultilinearMap.mkPiAlgebraFin_applyₓ'. -/
@[simp]
theorem mkPiAlgebraFin_apply (m : Fin n → A) :
    ContinuousMultilinearMap.mkPiAlgebraFin R n A m = (List.ofFn m).Prod :=
  rfl
#align continuous_multilinear_map.mk_pi_algebra_fin_apply ContinuousMultilinearMap.mkPiAlgebraFin_apply

end Algebra

section SmulRight

variable [CommSemiring R] [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [∀ i, Module R (M₁ i)]
  [Module R M₂] [TopologicalSpace R] [∀ i, TopologicalSpace (M₁ i)] [TopologicalSpace M₂]
  [ContinuousSMul R M₂] (f : ContinuousMultilinearMap R M₁ R) (z : M₂)

#print ContinuousMultilinearMap.smulRight /-
/-- Given a continuous `R`-multilinear map `f` taking values in `R`, `f.smul_right z` is the
continuous multilinear map sending `m` to `f m • z`. -/
@[simps toMultilinearMap apply]
def smulRight : ContinuousMultilinearMap R M₁ M₂
    where
  toMultilinearMap := f.toMultilinearMap.smul_right z
  cont := f.cont.smul continuous_const
#align continuous_multilinear_map.smul_right ContinuousMultilinearMap.smulRight
-/

end SmulRight

end ContinuousMultilinearMap

