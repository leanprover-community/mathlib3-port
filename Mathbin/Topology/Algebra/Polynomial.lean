/-
Copyright (c) 2018 Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robert Y. Lewis

! This file was ported from Lean 3 source module topology.algebra.polynomial
! leanprover-community/mathlib commit 31ca6f9cf5f90a6206092cd7f84b359dcb6d52e0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Polynomial.AlgebraMap
import Mathbin.Data.Polynomial.Inductions
import Mathbin.Data.Polynomial.Splits
import Mathbin.RingTheory.Polynomial.Vieta
import Mathbin.Analysis.Normed.Field.Basic

/-!
# Polynomials and limits

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we prove the following lemmas.

* `polynomial.continuous_eval₂: `polynomial.eval₂` defines a continuous function.
* `polynomial.continuous_aeval: `polynomial.aeval` defines a continuous function;
  we also prove convenience lemmas `polynomial.continuous_at_aeval`,
  `polynomial.continuous_within_at_aeval`, `polynomial.continuous_on_aeval`.
* `polynomial.continuous`:  `polynomial.eval` defines a continuous functions;
  we also prove convenience lemmas `polynomial.continuous_at`, `polynomial.continuous_within_at`,
  `polynomial.continuous_on`.
* `polynomial.tendsto_norm_at_top`: `λ x, ‖polynomial.eval (z x) p‖` tends to infinity provided that
  `λ x, ‖z x‖` tends to infinity and `0 < degree p`;
* `polynomial.tendsto_abv_eval₂_at_top`, `polynomial.tendsto_abv_at_top`,
  `polynomial.tendsto_abv_aeval_at_top`: a few versions of the previous statement for
  `is_absolute_value abv` instead of norm.

## Tags

polynomial, continuity
-/


open IsAbsoluteValue Filter

namespace Polynomial

open Polynomial

section TopologicalSemiring

variable {R S : Type _} [Semiring R] [TopologicalSpace R] [TopologicalSemiring R] (p : R[X])

#print Polynomial.continuous_eval₂ /-
@[continuity]
protected theorem continuous_eval₂ [Semiring S] (p : S[X]) (f : S →+* R) :
    Continuous fun x => p.eval₂ f x :=
  by
  simp only [eval₂_eq_sum, Finsupp.sum]
  exact continuous_finset_sum _ fun c hc => continuous_const.mul (continuous_pow _)
#align polynomial.continuous_eval₂ Polynomial.continuous_eval₂
-/

#print Polynomial.continuous /-
@[continuity]
protected theorem continuous : Continuous fun x => p.eval x :=
  p.continuous_eval₂ _
#align polynomial.continuous Polynomial.continuous
-/

#print Polynomial.continuousAt /-
protected theorem continuousAt {a : R} : ContinuousAt (fun x => p.eval x) a :=
  p.Continuous.ContinuousAt
#align polynomial.continuous_at Polynomial.continuousAt
-/

#print Polynomial.continuousWithinAt /-
protected theorem continuousWithinAt {s a} : ContinuousWithinAt (fun x => p.eval x) s a :=
  p.Continuous.ContinuousWithinAt
#align polynomial.continuous_within_at Polynomial.continuousWithinAt
-/

#print Polynomial.continuousOn /-
protected theorem continuousOn {s} : ContinuousOn (fun x => p.eval x) s :=
  p.Continuous.ContinuousOn
#align polynomial.continuous_on Polynomial.continuousOn
-/

end TopologicalSemiring

section TopologicalAlgebra

variable {R A : Type _} [CommSemiring R] [Semiring A] [Algebra R A] [TopologicalSpace A]
  [TopologicalSemiring A] (p : R[X])

#print Polynomial.continuous_aeval /-
@[continuity]
protected theorem continuous_aeval : Continuous fun x : A => aeval x p :=
  p.continuous_eval₂ _
#align polynomial.continuous_aeval Polynomial.continuous_aeval
-/

#print Polynomial.continuousAt_aeval /-
protected theorem continuousAt_aeval {a : A} : ContinuousAt (fun x : A => aeval x p) a :=
  p.continuous_aeval.ContinuousAt
#align polynomial.continuous_at_aeval Polynomial.continuousAt_aeval
-/

#print Polynomial.continuousWithinAt_aeval /-
protected theorem continuousWithinAt_aeval {s a} :
    ContinuousWithinAt (fun x : A => aeval x p) s a :=
  p.continuous_aeval.ContinuousWithinAt
#align polynomial.continuous_within_at_aeval Polynomial.continuousWithinAt_aeval
-/

#print Polynomial.continuousOn_aeval /-
protected theorem continuousOn_aeval {s} : ContinuousOn (fun x : A => aeval x p) s :=
  p.continuous_aeval.ContinuousOn
#align polynomial.continuous_on_aeval Polynomial.continuousOn_aeval
-/

end TopologicalAlgebra

/- warning: polynomial.tendsto_abv_eval₂_at_top -> Polynomial.tendsto_abv_eval₂_atTop is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} {k : Type.{u3}} {α : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : LinearOrderedField.{u3} k] (f : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (abv : S -> k) [_inst_4 : IsAbsoluteValue.{u3, u2} k (StrictOrderedSemiring.toOrderedSemiring.{u3} k (StrictOrderedRing.toStrictOrderedSemiring.{u3} k (LinearOrderedRing.toStrictOrderedRing.{u3} k (LinearOrderedCommRing.toLinearOrderedRing.{u3} k (LinearOrderedField.toLinearOrderedCommRing.{u3} k _inst_3))))) S (Ring.toSemiring.{u2} S _inst_2) abv] (p : Polynomial.{u1} R _inst_1), (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toHasLt.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))) (Polynomial.degree.{u1} R _inst_1 p)) -> (Ne.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) f (Polynomial.leadingCoeff.{u1} R _inst_1 p)) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))))))))) -> (forall {l : Filter.{u4} α} {z : α -> S}, (Filter.Tendsto.{u4, u3} α k (Function.comp.{succ u4, succ u2, succ u3} α S k abv z) l (Filter.atTop.{u3} k (PartialOrder.toPreorder.{u3} k (OrderedAddCommGroup.toPartialOrder.{u3} k (StrictOrderedRing.toOrderedAddCommGroup.{u3} k (LinearOrderedRing.toStrictOrderedRing.{u3} k (LinearOrderedCommRing.toLinearOrderedRing.{u3} k (LinearOrderedField.toLinearOrderedCommRing.{u3} k _inst_3)))))))) -> (Filter.Tendsto.{u4, u3} α k (fun (x : α) => abv (Polynomial.eval₂.{u1, u2} R S _inst_1 (Ring.toSemiring.{u2} S _inst_2) f (z x) p)) l (Filter.atTop.{u3} k (PartialOrder.toPreorder.{u3} k (OrderedAddCommGroup.toPartialOrder.{u3} k (StrictOrderedRing.toOrderedAddCommGroup.{u3} k (LinearOrderedRing.toStrictOrderedRing.{u3} k (LinearOrderedCommRing.toLinearOrderedRing.{u3} k (LinearOrderedField.toLinearOrderedCommRing.{u3} k _inst_3)))))))))
but is expected to have type
  forall {R : Type.{u4}} {S : Type.{u3}} {k : Type.{u2}} {α : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Ring.{u3} S] [_inst_3 : LinearOrderedField.{u2} k] (f : RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) (abv : S -> k) [_inst_4 : IsAbsoluteValue.{u2, u3} k (OrderedCommSemiring.toOrderedSemiring.{u2} k (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} k (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} k (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} k (LinearOrderedField.toLinearOrderedSemifield.{u2} k _inst_3))))) S (Ring.toSemiring.{u3} S _inst_2) abv] (p : Polynomial.{u4} R _inst_1), (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))) (Polynomial.degree.{u4} R _inst_1 p)) -> (Ne.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Polynomial.leadingCoeff.{u4} R _inst_1 p)) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) R S (NonUnitalNonAssocSemiring.toMul.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2))) R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)) (RingHom.instRingHomClassRingHom.{u4, u3} R S (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S _inst_2)))))) f (Polynomial.leadingCoeff.{u4} R _inst_1 p)) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Polynomial.leadingCoeff.{u4} R _inst_1 p)) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Polynomial.leadingCoeff.{u4} R _inst_1 p)) (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Polynomial.leadingCoeff.{u4} R _inst_1 p)) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Polynomial.leadingCoeff.{u4} R _inst_1 p)) (Ring.toSemiring.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Polynomial.leadingCoeff.{u4} R _inst_1 p)) _inst_2)))))) -> (forall {l : Filter.{u1} α} {z : α -> S}, (Filter.Tendsto.{u1, u2} α k (Function.comp.{succ u1, succ u3, succ u2} α S k abv z) l (Filter.atTop.{u2} k (PartialOrder.toPreorder.{u2} k (StrictOrderedRing.toPartialOrder.{u2} k (LinearOrderedRing.toStrictOrderedRing.{u2} k (LinearOrderedCommRing.toLinearOrderedRing.{u2} k (LinearOrderedField.toLinearOrderedCommRing.{u2} k _inst_3))))))) -> (Filter.Tendsto.{u1, u2} α k (fun (x : α) => abv (Polynomial.eval₂.{u4, u3} R S _inst_1 (Ring.toSemiring.{u3} S _inst_2) f (z x) p)) l (Filter.atTop.{u2} k (PartialOrder.toPreorder.{u2} k (StrictOrderedRing.toPartialOrder.{u2} k (LinearOrderedRing.toStrictOrderedRing.{u2} k (LinearOrderedCommRing.toLinearOrderedRing.{u2} k (LinearOrderedField.toLinearOrderedCommRing.{u2} k _inst_3))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.tendsto_abv_eval₂_at_top Polynomial.tendsto_abv_eval₂_atTopₓ'. -/
theorem tendsto_abv_eval₂_atTop {R S k α : Type _} [Semiring R] [Ring S] [LinearOrderedField k]
    (f : R →+* S) (abv : S → k) [IsAbsoluteValue abv] (p : R[X]) (hd : 0 < degree p)
    (hf : f p.leadingCoeff ≠ 0) {l : Filter α} {z : α → S} (hz : Tendsto (abv ∘ z) l atTop) :
    Tendsto (fun x => abv (p.eval₂ f (z x))) l atTop :=
  by
  revert hf; refine' degree_pos_induction_on p hd _ _ _ <;> clear hd p
  · rintro c - hc
    rw [leading_coeff_mul_X, leading_coeff_C] at hc
    simpa [abv_mul abv] using hz.const_mul_at_top ((abv_pos abv).2 hc)
  · intro p hpd ihp hf
    rw [leading_coeff_mul_X] at hf
    simpa [abv_mul abv] using (ihp hf).atTop_mul_atTop hz
  · intro p a hd ihp hf
    rw [add_comm, leading_coeff_add_of_degree_lt (degree_C_le.trans_lt hd)] at hf
    refine' tendsto_at_top_of_add_const_right (abv (-f a)) _
    refine' tendsto_at_top_mono (fun _ => abv_add abv _ _) _
    simpa using ihp hf
#align polynomial.tendsto_abv_eval₂_at_top Polynomial.tendsto_abv_eval₂_atTop

/- warning: polynomial.tendsto_abv_at_top -> Polynomial.tendsto_abv_atTop is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {k : Type.{u2}} {α : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : LinearOrderedField.{u2} k] (abv : R -> k) [_inst_3 : IsAbsoluteValue.{u2, u1} k (StrictOrderedSemiring.toOrderedSemiring.{u2} k (StrictOrderedRing.toStrictOrderedSemiring.{u2} k (LinearOrderedRing.toStrictOrderedRing.{u2} k (LinearOrderedCommRing.toLinearOrderedRing.{u2} k (LinearOrderedField.toLinearOrderedCommRing.{u2} k _inst_2))))) R (Ring.toSemiring.{u1} R _inst_1) abv] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R _inst_1)), (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toHasLt.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))) (Polynomial.degree.{u1} R (Ring.toSemiring.{u1} R _inst_1) p)) -> (forall {l : Filter.{u3} α} {z : α -> R}, (Filter.Tendsto.{u3, u2} α k (Function.comp.{succ u3, succ u1, succ u2} α R k abv z) l (Filter.atTop.{u2} k (PartialOrder.toPreorder.{u2} k (OrderedAddCommGroup.toPartialOrder.{u2} k (StrictOrderedRing.toOrderedAddCommGroup.{u2} k (LinearOrderedRing.toStrictOrderedRing.{u2} k (LinearOrderedCommRing.toLinearOrderedRing.{u2} k (LinearOrderedField.toLinearOrderedCommRing.{u2} k _inst_2)))))))) -> (Filter.Tendsto.{u3, u2} α k (fun (x : α) => abv (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R _inst_1) (z x) p)) l (Filter.atTop.{u2} k (PartialOrder.toPreorder.{u2} k (OrderedAddCommGroup.toPartialOrder.{u2} k (StrictOrderedRing.toOrderedAddCommGroup.{u2} k (LinearOrderedRing.toStrictOrderedRing.{u2} k (LinearOrderedCommRing.toLinearOrderedRing.{u2} k (LinearOrderedField.toLinearOrderedCommRing.{u2} k _inst_2)))))))))
but is expected to have type
  forall {R : Type.{u3}} {k : Type.{u2}} {α : Type.{u1}} [_inst_1 : Ring.{u3} R] [_inst_2 : LinearOrderedField.{u2} k] (abv : R -> k) [_inst_3 : IsAbsoluteValue.{u2, u3} k (OrderedCommSemiring.toOrderedSemiring.{u2} k (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} k (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} k (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} k (LinearOrderedField.toLinearOrderedSemifield.{u2} k _inst_2))))) R (Ring.toSemiring.{u3} R _inst_1) abv] (p : Polynomial.{u3} R (Ring.toSemiring.{u3} R _inst_1)), (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))) (Polynomial.degree.{u3} R (Ring.toSemiring.{u3} R _inst_1) p)) -> (forall {l : Filter.{u1} α} {z : α -> R}, (Filter.Tendsto.{u1, u2} α k (Function.comp.{succ u1, succ u3, succ u2} α R k abv z) l (Filter.atTop.{u2} k (PartialOrder.toPreorder.{u2} k (StrictOrderedRing.toPartialOrder.{u2} k (LinearOrderedRing.toStrictOrderedRing.{u2} k (LinearOrderedCommRing.toLinearOrderedRing.{u2} k (LinearOrderedField.toLinearOrderedCommRing.{u2} k _inst_2))))))) -> (Filter.Tendsto.{u1, u2} α k (fun (x : α) => abv (Polynomial.eval.{u3} R (Ring.toSemiring.{u3} R _inst_1) (z x) p)) l (Filter.atTop.{u2} k (PartialOrder.toPreorder.{u2} k (StrictOrderedRing.toPartialOrder.{u2} k (LinearOrderedRing.toStrictOrderedRing.{u2} k (LinearOrderedCommRing.toLinearOrderedRing.{u2} k (LinearOrderedField.toLinearOrderedCommRing.{u2} k _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.tendsto_abv_at_top Polynomial.tendsto_abv_atTopₓ'. -/
theorem tendsto_abv_atTop {R k α : Type _} [Ring R] [LinearOrderedField k] (abv : R → k)
    [IsAbsoluteValue abv] (p : R[X]) (h : 0 < degree p) {l : Filter α} {z : α → R}
    (hz : Tendsto (abv ∘ z) l atTop) : Tendsto (fun x => abv (p.eval (z x))) l atTop :=
  tendsto_abv_eval₂_atTop _ _ _ h (mt leadingCoeff_eq_zero.1 <| ne_zero_of_degree_gt h) hz
#align polynomial.tendsto_abv_at_top Polynomial.tendsto_abv_atTop

/- warning: polynomial.tendsto_abv_aeval_at_top -> Polynomial.tendsto_abv_aeval_atTop is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {k : Type.{u3}} {α : Type.{u4}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2)] [_inst_4 : LinearOrderedField.{u3} k] (abv : A -> k) [_inst_5 : IsAbsoluteValue.{u3, u2} k (StrictOrderedSemiring.toOrderedSemiring.{u3} k (StrictOrderedRing.toStrictOrderedSemiring.{u3} k (LinearOrderedRing.toStrictOrderedRing.{u3} k (LinearOrderedCommRing.toLinearOrderedRing.{u3} k (LinearOrderedField.toLinearOrderedCommRing.{u3} k _inst_4))))) A (Ring.toSemiring.{u2} A _inst_2) abv] (p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)), (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toHasLt.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))) (Polynomial.degree.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p)) -> (Ne.{succ u2} A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (algebraMap.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2) _inst_3) (Polynomial.leadingCoeff.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1) p)) (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2))))))))) -> (forall {l : Filter.{u4} α} {z : α -> A}, (Filter.Tendsto.{u4, u3} α k (Function.comp.{succ u4, succ u2, succ u3} α A k abv z) l (Filter.atTop.{u3} k (PartialOrder.toPreorder.{u3} k (OrderedAddCommGroup.toPartialOrder.{u3} k (StrictOrderedRing.toOrderedAddCommGroup.{u3} k (LinearOrderedRing.toStrictOrderedRing.{u3} k (LinearOrderedCommRing.toLinearOrderedRing.{u3} k (LinearOrderedField.toLinearOrderedCommRing.{u3} k _inst_4)))))))) -> (Filter.Tendsto.{u4, u3} α k (fun (x : α) => abv (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AlgHom.{u1, u1, u2} R (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) A _inst_1 (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ring.toSemiring.{u2} A _inst_2) (Polynomial.algebraOfAlgebra.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)) _inst_3) (fun (_x : AlgHom.{u1, u1, u2} R (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) A _inst_1 (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ring.toSemiring.{u2} A _inst_2) (Polynomial.algebraOfAlgebra.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)) _inst_3) => (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) -> A) ([anonymous].{u1, u1, u2} R (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) A _inst_1 (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ring.toSemiring.{u2} A _inst_2) (Polynomial.algebraOfAlgebra.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)) _inst_3) (Polynomial.aeval.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2) _inst_3 (z x)) p)) l (Filter.atTop.{u3} k (PartialOrder.toPreorder.{u3} k (OrderedAddCommGroup.toPartialOrder.{u3} k (StrictOrderedRing.toOrderedAddCommGroup.{u3} k (LinearOrderedRing.toStrictOrderedRing.{u3} k (LinearOrderedCommRing.toLinearOrderedRing.{u3} k (LinearOrderedField.toLinearOrderedCommRing.{u3} k _inst_4)))))))))
but is expected to have type
  forall {R : Type.{u4}} {A : Type.{u3}} {k : Type.{u2}} {α : Type.{u1}} [_inst_1 : CommSemiring.{u4} R] [_inst_2 : Ring.{u3} A] [_inst_3 : Algebra.{u4, u3} R A _inst_1 (Ring.toSemiring.{u3} A _inst_2)] [_inst_4 : LinearOrderedField.{u2} k] (abv : A -> k) [_inst_5 : IsAbsoluteValue.{u2, u3} k (OrderedCommSemiring.toOrderedSemiring.{u2} k (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} k (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} k (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} k (LinearOrderedField.toLinearOrderedSemifield.{u2} k _inst_4))))) A (Ring.toSemiring.{u3} A _inst_2) abv] (p : Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)), (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))) (Polynomial.degree.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1) p)) -> (Ne.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) (Polynomial.leadingCoeff.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1) p)) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (RingHom.{u4, u3} R A (Semiring.toNonAssocSemiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u4 u3, u4, u3} (RingHom.{u4, u3} R A (Semiring.toNonAssocSemiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2))) R A (NonUnitalNonAssocSemiring.toMul.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R A (Semiring.toNonAssocSemiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u4 u3, u4, u3} (RingHom.{u4, u3} R A (Semiring.toNonAssocSemiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2))) R A (Semiring.toNonAssocSemiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2)) (RingHom.instRingHomClassRingHom.{u4, u3} R A (Semiring.toNonAssocSemiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2)))))) (algebraMap.{u4, u3} R A _inst_1 (Ring.toSemiring.{u3} A _inst_2) _inst_3) (Polynomial.leadingCoeff.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1) p)) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) (Polynomial.leadingCoeff.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1) p)) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) (Polynomial.leadingCoeff.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1) p)) (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) (Polynomial.leadingCoeff.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1) p)) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) (Polynomial.leadingCoeff.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1) p)) (Ring.toSemiring.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) (Polynomial.leadingCoeff.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1) p)) _inst_2)))))) -> (forall {l : Filter.{u1} α} {z : α -> A}, (Filter.Tendsto.{u1, u2} α k (Function.comp.{succ u1, succ u3, succ u2} α A k abv z) l (Filter.atTop.{u2} k (PartialOrder.toPreorder.{u2} k (StrictOrderedRing.toPartialOrder.{u2} k (LinearOrderedRing.toStrictOrderedRing.{u2} k (LinearOrderedCommRing.toLinearOrderedRing.{u2} k (LinearOrderedField.toLinearOrderedCommRing.{u2} k _inst_4))))))) -> (Filter.Tendsto.{u1, u2} α k (fun (x : α) => abv (FunLike.coe.{max (succ u3) (succ u4), succ u4, succ u3} (AlgHom.{u4, u4, u3} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) A _inst_1 (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Ring.toSemiring.{u3} A _inst_2) (Polynomial.algebraOfAlgebra.{u4, u4} R R _inst_1 (CommSemiring.toSemiring.{u4} R _inst_1) (Algebra.id.{u4} R _inst_1)) _inst_3) (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (fun (_x : Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) => A) _x) (SMulHomClass.toFunLike.{max u3 u4, u4, u4, u3} (AlgHom.{u4, u4, u3} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) A _inst_1 (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Ring.toSemiring.{u3} A _inst_2) (Polynomial.algebraOfAlgebra.{u4, u4} R R _inst_1 (CommSemiring.toSemiring.{u4} R _inst_1) (Algebra.id.{u4} R _inst_1)) _inst_3) R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) A (SMulZeroClass.toSMul.{u4, u4} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (AddMonoid.toZero.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1))))))) (DistribSMul.toSMulZeroClass.{u4, u4} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (AddMonoid.toAddZeroClass.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (AddCommMonoid.toAddMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1))))))) (DistribMulAction.toDistribSMul.{u4, u4} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1))) (AddCommMonoid.toAddMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)))))) (Module.toDistribMulAction.{u4, u4} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (CommSemiring.toSemiring.{u4} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1))))) (Algebra.toModule.{u4, u4} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) _inst_1 (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.algebraOfAlgebra.{u4, u4} R R _inst_1 (CommSemiring.toSemiring.{u4} R _inst_1) (Algebra.id.{u4} R _inst_1))))))) (SMulZeroClass.toSMul.{u4, u3} R A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2)))))) (DistribSMul.toSMulZeroClass.{u4, u3} R A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2)))))) (DistribMulAction.toDistribSMul.{u4, u3} R A (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1))) (AddCommMonoid.toAddMonoid.{u3} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2))))) (Module.toDistribMulAction.{u4, u3} R A (CommSemiring.toSemiring.{u4} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2)))) (Algebra.toModule.{u4, u3} R A _inst_1 (Ring.toSemiring.{u3} A _inst_2) _inst_3))))) (DistribMulActionHomClass.toSMulHomClass.{max u3 u4, u4, u4, u3} (AlgHom.{u4, u4, u3} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) A _inst_1 (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Ring.toSemiring.{u3} A _inst_2) (Polynomial.algebraOfAlgebra.{u4, u4} R R _inst_1 (CommSemiring.toSemiring.{u4} R _inst_1) (Algebra.id.{u4} R _inst_1)) _inst_3) R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) A (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1))) (AddCommMonoid.toAddMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)))))) (AddCommMonoid.toAddMonoid.{u3} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2))))) (Module.toDistribMulAction.{u4, u4} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (CommSemiring.toSemiring.{u4} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1))))) (Algebra.toModule.{u4, u4} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) _inst_1 (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.algebraOfAlgebra.{u4, u4} R R _inst_1 (CommSemiring.toSemiring.{u4} R _inst_1) (Algebra.id.{u4} R _inst_1)))) (Module.toDistribMulAction.{u4, u3} R A (CommSemiring.toSemiring.{u4} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2)))) (Algebra.toModule.{u4, u3} R A _inst_1 (Ring.toSemiring.{u3} A _inst_2) _inst_3)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u3 u4, u4, u4, u3} (AlgHom.{u4, u4, u3} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) A _inst_1 (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Ring.toSemiring.{u3} A _inst_2) (Polynomial.algebraOfAlgebra.{u4, u4} R R _inst_1 (CommSemiring.toSemiring.{u4} R _inst_1) (Algebra.id.{u4} R _inst_1)) _inst_3) R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) A (MonoidWithZero.toMonoid.{u4} R (Semiring.toMonoidWithZero.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2))) (Module.toDistribMulAction.{u4, u4} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (CommSemiring.toSemiring.{u4} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Semiring.toNonAssocSemiring.{u4} (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1))))) (Algebra.toModule.{u4, u4} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) _inst_1 (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Polynomial.algebraOfAlgebra.{u4, u4} R R _inst_1 (CommSemiring.toSemiring.{u4} R _inst_1) (Algebra.id.{u4} R _inst_1)))) (Module.toDistribMulAction.{u4, u3} R A (CommSemiring.toSemiring.{u4} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A _inst_2)))) (Algebra.toModule.{u4, u3} R A _inst_1 (Ring.toSemiring.{u3} A _inst_2) _inst_3)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u4, u4, u3, max u3 u4} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) A _inst_1 (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Ring.toSemiring.{u3} A _inst_2) (Polynomial.algebraOfAlgebra.{u4, u4} R R _inst_1 (CommSemiring.toSemiring.{u4} R _inst_1) (Algebra.id.{u4} R _inst_1)) _inst_3 (AlgHom.{u4, u4, u3} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) A _inst_1 (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Ring.toSemiring.{u3} A _inst_2) (Polynomial.algebraOfAlgebra.{u4, u4} R R _inst_1 (CommSemiring.toSemiring.{u4} R _inst_1) (Algebra.id.{u4} R _inst_1)) _inst_3) (AlgHom.algHomClass.{u4, u4, u3} R (Polynomial.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) A _inst_1 (Polynomial.semiring.{u4} R (CommSemiring.toSemiring.{u4} R _inst_1)) (Ring.toSemiring.{u3} A _inst_2) (Polynomial.algebraOfAlgebra.{u4, u4} R R _inst_1 (CommSemiring.toSemiring.{u4} R _inst_1) (Algebra.id.{u4} R _inst_1)) _inst_3))))) (Polynomial.aeval.{u4, u3} R A _inst_1 (Ring.toSemiring.{u3} A _inst_2) _inst_3 (z x)) p)) l (Filter.atTop.{u2} k (PartialOrder.toPreorder.{u2} k (StrictOrderedRing.toPartialOrder.{u2} k (LinearOrderedRing.toStrictOrderedRing.{u2} k (LinearOrderedCommRing.toLinearOrderedRing.{u2} k (LinearOrderedField.toLinearOrderedCommRing.{u2} k _inst_4))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.tendsto_abv_aeval_at_top Polynomial.tendsto_abv_aeval_atTopₓ'. -/
theorem tendsto_abv_aeval_atTop {R A k α : Type _} [CommSemiring R] [Ring A] [Algebra R A]
    [LinearOrderedField k] (abv : A → k) [IsAbsoluteValue abv] (p : R[X]) (hd : 0 < degree p)
    (h₀ : algebraMap R A p.leadingCoeff ≠ 0) {l : Filter α} {z : α → A}
    (hz : Tendsto (abv ∘ z) l atTop) : Tendsto (fun x => abv (aeval (z x) p)) l atTop :=
  tendsto_abv_eval₂_atTop _ abv p hd h₀ hz
#align polynomial.tendsto_abv_aeval_at_top Polynomial.tendsto_abv_aeval_atTop

variable {α R : Type _} [NormedRing R] [IsAbsoluteValue (norm : R → ℝ)]

/- warning: polynomial.tendsto_norm_at_top -> Polynomial.tendsto_norm_atTop is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : NormedRing.{u2} R] [_inst_2 : IsAbsoluteValue.{0, u2} Real Real.orderedSemiring R (Ring.toSemiring.{u2} R (NormedRing.toRing.{u2} R _inst_1)) (Norm.norm.{u2} R (NormedRing.toHasNorm.{u2} R _inst_1))] (p : Polynomial.{u2} R (Ring.toSemiring.{u2} R (NormedRing.toRing.{u2} R _inst_1))), (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toHasLt.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (OfNat.mk.{0} (WithBot.{0} Nat) 0 (Zero.zero.{0} (WithBot.{0} Nat) (WithBot.hasZero.{0} Nat Nat.hasZero)))) (Polynomial.degree.{u2} R (Ring.toSemiring.{u2} R (NormedRing.toRing.{u2} R _inst_1)) p)) -> (forall {l : Filter.{u1} α} {z : α -> R}, (Filter.Tendsto.{u1, 0} α Real (fun (x : α) => Norm.norm.{u2} R (NormedRing.toHasNorm.{u2} R _inst_1) (z x)) l (Filter.atTop.{0} Real Real.preorder)) -> (Filter.Tendsto.{u1, 0} α Real (fun (x : α) => Norm.norm.{u2} R (NormedRing.toHasNorm.{u2} R _inst_1) (Polynomial.eval.{u2} R (Ring.toSemiring.{u2} R (NormedRing.toRing.{u2} R _inst_1)) (z x) p)) l (Filter.atTop.{0} Real Real.preorder)))
but is expected to have type
  forall {α : Type.{u1}} {R : Type.{u2}} [_inst_1 : NormedRing.{u2} R] [_inst_2 : IsAbsoluteValue.{0, u2} Real Real.orderedSemiring R (Ring.toSemiring.{u2} R (NormedRing.toRing.{u2} R _inst_1)) (Norm.norm.{u2} R (NormedRing.toNorm.{u2} R _inst_1))] (p : Polynomial.{u2} R (Ring.toSemiring.{u2} R (NormedRing.toRing.{u2} R _inst_1))), (LT.lt.{0} (WithBot.{0} Nat) (Preorder.toLT.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (OfNat.ofNat.{0} (WithBot.{0} Nat) 0 (Zero.toOfNat0.{0} (WithBot.{0} Nat) (WithBot.zero.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))) (Polynomial.degree.{u2} R (Ring.toSemiring.{u2} R (NormedRing.toRing.{u2} R _inst_1)) p)) -> (forall {l : Filter.{u1} α} {z : α -> R}, (Filter.Tendsto.{u1, 0} α Real (fun (x : α) => Norm.norm.{u2} R (NormedRing.toNorm.{u2} R _inst_1) (z x)) l (Filter.atTop.{0} Real Real.instPreorderReal)) -> (Filter.Tendsto.{u1, 0} α Real (fun (x : α) => Norm.norm.{u2} R (NormedRing.toNorm.{u2} R _inst_1) (Polynomial.eval.{u2} R (Ring.toSemiring.{u2} R (NormedRing.toRing.{u2} R _inst_1)) (z x) p)) l (Filter.atTop.{0} Real Real.instPreorderReal)))
Case conversion may be inaccurate. Consider using '#align polynomial.tendsto_norm_at_top Polynomial.tendsto_norm_atTopₓ'. -/
theorem tendsto_norm_atTop (p : R[X]) (h : 0 < degree p) {l : Filter α} {z : α → R}
    (hz : Tendsto (fun x => ‖z x‖) l atTop) : Tendsto (fun x => ‖p.eval (z x)‖) l atTop :=
  p.tendsto_abv_atTop norm h hz
#align polynomial.tendsto_norm_at_top Polynomial.tendsto_norm_atTop

/- warning: polynomial.exists_forall_norm_le -> Polynomial.exists_forall_norm_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NormedRing.{u1} R] [_inst_2 : IsAbsoluteValue.{0, u1} Real Real.orderedSemiring R (Ring.toSemiring.{u1} R (NormedRing.toRing.{u1} R _inst_1)) (Norm.norm.{u1} R (NormedRing.toHasNorm.{u1} R _inst_1))] [_inst_3 : ProperSpace.{u1} R (SeminormedRing.toPseudoMetricSpace.{u1} R (NormedRing.toSeminormedRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (NormedRing.toRing.{u1} R _inst_1))), Exists.{succ u1} R (fun (x : R) => forall (y : R), LE.le.{0} Real Real.hasLe (Norm.norm.{u1} R (NormedRing.toHasNorm.{u1} R _inst_1) (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (NormedRing.toRing.{u1} R _inst_1)) x p)) (Norm.norm.{u1} R (NormedRing.toHasNorm.{u1} R _inst_1) (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (NormedRing.toRing.{u1} R _inst_1)) y p)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NormedRing.{u1} R] [_inst_2 : IsAbsoluteValue.{0, u1} Real Real.orderedSemiring R (Ring.toSemiring.{u1} R (NormedRing.toRing.{u1} R _inst_1)) (Norm.norm.{u1} R (NormedRing.toNorm.{u1} R _inst_1))] [_inst_3 : ProperSpace.{u1} R (SeminormedRing.toPseudoMetricSpace.{u1} R (NormedRing.toSeminormedRing.{u1} R _inst_1))] (p : Polynomial.{u1} R (Ring.toSemiring.{u1} R (NormedRing.toRing.{u1} R _inst_1))), Exists.{succ u1} R (fun (x : R) => forall (y : R), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} R (NormedRing.toNorm.{u1} R _inst_1) (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (NormedRing.toRing.{u1} R _inst_1)) x p)) (Norm.norm.{u1} R (NormedRing.toNorm.{u1} R _inst_1) (Polynomial.eval.{u1} R (Ring.toSemiring.{u1} R (NormedRing.toRing.{u1} R _inst_1)) y p)))
Case conversion may be inaccurate. Consider using '#align polynomial.exists_forall_norm_le Polynomial.exists_forall_norm_leₓ'. -/
theorem exists_forall_norm_le [ProperSpace R] (p : R[X]) : ∃ x, ∀ y, ‖p.eval x‖ ≤ ‖p.eval y‖ :=
  if hp0 : 0 < degree p then
    p.Continuous.norm.exists_forall_le <| p.tendsto_norm_atTop hp0 tendsto_norm_cocompact_atTop
  else ⟨p.coeff 0, by rw [eq_C_of_degree_le_zero (le_of_not_gt hp0)] <;> simp⟩
#align polynomial.exists_forall_norm_le Polynomial.exists_forall_norm_le

section Roots

open Polynomial NNReal

variable {F K : Type _} [CommRing F] [NormedField K]

open Multiset

/- warning: polynomial.eq_one_of_roots_le -> Polynomial.eq_one_of_roots_le is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} [_inst_3 : CommRing.{u1} F] [_inst_4 : NormedField.{u2} K] {p : Polynomial.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3))} {f : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (CommRing.toRing.{u1} F _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (NormedRing.toRing.{u2} K (NormedCommRing.toNormedRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4)))))} {B : Real}, (LT.lt.{0} Real Real.hasLt B (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Polynomial.Monic.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) p) -> (Polynomial.Splits.{u1, u2} F K _inst_3 (NormedField.toField.{u2} K _inst_4) f p) -> (forall (z : K), (Membership.Mem.{u2, u2} K (Multiset.{u2} K) (Multiset.hasMem.{u2} K) z (Polynomial.roots.{u2} K (SeminormedCommRing.toCommRing.{u2} K (NormedCommRing.toSeminormedCommRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4))) (Field.isDomain.{u2} K (NormedField.toField.{u2} K _inst_4)) (Polynomial.map.{u1, u2} F K (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (NormedRing.toRing.{u2} K (NormedCommRing.toNormedRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4)))) f p))) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{u2} K (NormedField.toHasNorm.{u2} K _inst_4) z) B)) -> (Eq.{succ u1} (Polynomial.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3))) p (OfNat.ofNat.{u1} (Polynomial.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3))) 1 (OfNat.mk.{u1} (Polynomial.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3))) 1 (One.one.{u1} (Polynomial.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3))) (Polynomial.hasOne.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)))))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} [_inst_3 : CommRing.{u2} F] [_inst_4 : NormedField.{u1} K] {p : Polynomial.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3))} {f : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K (NormedField.toField.{u1} K _inst_4)))))} {B : Real}, (LT.lt.{0} Real Real.instLTReal B (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal))) -> (Polynomial.Monic.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) p) -> (Polynomial.Splits.{u2, u1} F K _inst_3 (NormedField.toField.{u1} K _inst_4) f p) -> (forall (z : K), (Membership.mem.{u1, u1} K (Multiset.{u1} K) (Multiset.instMembershipMultiset.{u1} K) z (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K (NormedField.toField.{u1} K _inst_4))) (Field.isDomain.{u1} K (NormedField.toField.{u1} K _inst_4)) (Polynomial.map.{u2, u1} F K (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K (NormedField.toField.{u1} K _inst_4)))) f p))) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} K (NormedField.toNorm.{u1} K _inst_4) z) B)) -> (Eq.{succ u2} (Polynomial.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3))) p (OfNat.ofNat.{u2} (Polynomial.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3))) 1 (One.toOfNat1.{u2} (Polynomial.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3))) (Polynomial.one.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3))))))
Case conversion may be inaccurate. Consider using '#align polynomial.eq_one_of_roots_le Polynomial.eq_one_of_roots_leₓ'. -/
theorem eq_one_of_roots_le {p : F[X]} {f : F →+* K} {B : ℝ} (hB : B < 0) (h1 : p.Monic)
    (h2 : Splits f p) (h3 : ∀ z ∈ (map f p).roots, ‖z‖ ≤ B) : p = 1 :=
  h1.natDegree_eq_zero_iff_eq_one.mp
    (by
      contrapose! hB
      rw [← h1.nat_degree_map f, nat_degree_eq_card_roots' h2] at hB
      obtain ⟨z, hz⟩ := card_pos_iff_exists_mem.mp (zero_lt_iff.mpr hB)
      exact le_trans (norm_nonneg _) (h3 z hz))
#align polynomial.eq_one_of_roots_le Polynomial.eq_one_of_roots_le

/- warning: polynomial.coeff_le_of_roots_le -> Polynomial.coeff_le_of_roots_le is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} [_inst_3 : CommRing.{u1} F] [_inst_4 : NormedField.{u2} K] {p : Polynomial.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3))} {f : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (CommRing.toRing.{u1} F _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (NormedRing.toRing.{u2} K (NormedCommRing.toNormedRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4)))))} {B : Real} (i : Nat), (Polynomial.Monic.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) p) -> (Polynomial.Splits.{u1, u2} F K _inst_3 (NormedField.toField.{u2} K _inst_4) f p) -> (forall (z : K), (Membership.Mem.{u2, u2} K (Multiset.{u2} K) (Multiset.hasMem.{u2} K) z (Polynomial.roots.{u2} K (SeminormedCommRing.toCommRing.{u2} K (NormedCommRing.toSeminormedCommRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4))) (Field.isDomain.{u2} K (NormedField.toField.{u2} K _inst_4)) (Polynomial.map.{u1, u2} F K (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (NormedRing.toRing.{u2} K (NormedCommRing.toNormedRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4)))) f p))) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{u2} K (NormedField.toHasNorm.{u2} K _inst_4) z) B)) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{u2} K (NormedField.toHasNorm.{u2} K _inst_4) (Polynomial.coeff.{u2} K (Ring.toSemiring.{u2} K (NormedRing.toRing.{u2} K (NormedCommRing.toNormedRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4)))) (Polynomial.map.{u1, u2} F K (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (NormedRing.toRing.{u2} K (NormedCommRing.toNormedRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4)))) f p) i)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) B (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Polynomial.natDegree.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) p) i)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Nat.choose (Polynomial.natDegree.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) p) i))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} [_inst_3 : CommRing.{u2} F] [_inst_4 : NormedField.{u1} K] {p : Polynomial.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3))} {f : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K (NormedField.toField.{u1} K _inst_4)))))} {B : Real} (i : Nat), (Polynomial.Monic.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) p) -> (Polynomial.Splits.{u2, u1} F K _inst_3 (NormedField.toField.{u1} K _inst_4) f p) -> (forall (z : K), (Membership.mem.{u1, u1} K (Multiset.{u1} K) (Multiset.instMembershipMultiset.{u1} K) z (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K (NormedField.toField.{u1} K _inst_4))) (Field.isDomain.{u1} K (NormedField.toField.{u1} K _inst_4)) (Polynomial.map.{u2, u1} F K (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K (NormedField.toField.{u1} K _inst_4)))) f p))) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} K (NormedField.toNorm.{u1} K _inst_4) z) B)) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} K (NormedField.toNorm.{u1} K _inst_4) (Polynomial.coeff.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K (NormedField.toField.{u1} K _inst_4)))) (Polynomial.map.{u2, u1} F K (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K (NormedField.toField.{u1} K _inst_4)))) f p) i)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) B (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Polynomial.natDegree.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) p) i)) (Nat.cast.{0} Real Real.natCast (Nat.choose (Polynomial.natDegree.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) p) i))))
Case conversion may be inaccurate. Consider using '#align polynomial.coeff_le_of_roots_le Polynomial.coeff_le_of_roots_leₓ'. -/
theorem coeff_le_of_roots_le {p : F[X]} {f : F →+* K} {B : ℝ} (i : ℕ) (h1 : p.Monic)
    (h2 : Splits f p) (h3 : ∀ z ∈ (map f p).roots, ‖z‖ ≤ B) :
    ‖(map f p).coeff i‖ ≤ B ^ (p.natDegree - i) * p.natDegree.choose i :=
  by
  obtain hB | hB := lt_or_le B 0
  · rw [eq_one_of_roots_le hB h1 h2 h3, Polynomial.map_one, nat_degree_one, zero_tsub, pow_zero,
      one_mul, coeff_one]
    split_ifs <;> norm_num [h]
  rw [← h1.nat_degree_map f]
  obtain hi | hi := lt_or_le (map f p).natDegree i
  · rw [coeff_eq_zero_of_nat_degree_lt hi, norm_zero]
    positivity
  rw [coeff_eq_esymm_roots_of_splits ((splits_id_iff_splits f).2 h2) hi, (h1.map _).leadingCoeff,
    one_mul, norm_mul, norm_pow, norm_neg, norm_one, one_pow, one_mul]
  apply ((norm_multiset_sum_le _).trans <| sum_le_card_nsmul _ _ fun r hr => _).trans
  ·
    rw [Multiset.map_map, card_map, card_powerset_len, ← nat_degree_eq_card_roots' h2,
      Nat.choose_symm hi, mul_comm, nsmul_eq_mul]
  simp_rw [Multiset.mem_map] at hr
  obtain ⟨_, ⟨s, hs, rfl⟩, rfl⟩ := hr
  rw [mem_powerset_len] at hs
  lift B to ℝ≥0 using hB
  rw [← coe_nnnorm, ← NNReal.coe_pow, NNReal.coe_le_coe, ← nnnormHom_apply, ← MonoidHom.coe_coe,
    MonoidHom.map_multiset_prod]
  refine' (prod_le_pow_card _ B fun x hx => _).trans_eq (by rw [card_map, hs.2])
  obtain ⟨z, hz, rfl⟩ := Multiset.mem_map.1 hx
  exact h3 z (mem_of_le hs.1 hz)
#align polynomial.coeff_le_of_roots_le Polynomial.coeff_le_of_roots_le

/- warning: polynomial.coeff_bdd_of_roots_le -> Polynomial.coeff_bdd_of_roots_le is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {K : Type.{u2}} [_inst_3 : CommRing.{u1} F] [_inst_4 : NormedField.{u2} K] {B : Real} {d : Nat} (f : RingHom.{u1, u2} F K (NonAssocRing.toNonAssocSemiring.{u1} F (Ring.toNonAssocRing.{u1} F (CommRing.toRing.{u1} F _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} K (Ring.toNonAssocRing.{u2} K (NormedRing.toRing.{u2} K (NormedCommRing.toNormedRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4)))))) {p : Polynomial.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3))}, (Polynomial.Monic.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) p) -> (Polynomial.Splits.{u1, u2} F K _inst_3 (NormedField.toField.{u2} K _inst_4) f p) -> (LE.le.{0} Nat Nat.hasLe (Polynomial.natDegree.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) p) d) -> (forall (z : K), (Membership.Mem.{u2, u2} K (Multiset.{u2} K) (Multiset.hasMem.{u2} K) z (Polynomial.roots.{u2} K (SeminormedCommRing.toCommRing.{u2} K (NormedCommRing.toSeminormedCommRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4))) (Field.isDomain.{u2} K (NormedField.toField.{u2} K _inst_4)) (Polynomial.map.{u1, u2} F K (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (NormedRing.toRing.{u2} K (NormedCommRing.toNormedRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4)))) f p))) -> (LE.le.{0} Real Real.hasLe (Norm.norm.{u2} K (NormedField.toHasNorm.{u2} K _inst_4) z) B)) -> (forall (i : Nat), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} K (NormedField.toHasNorm.{u2} K _inst_4) (Polynomial.coeff.{u2} K (Ring.toSemiring.{u2} K (NormedRing.toRing.{u2} K (NormedCommRing.toNormedRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4)))) (Polynomial.map.{u1, u2} F K (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_3)) (Ring.toSemiring.{u2} K (NormedRing.toRing.{u2} K (NormedCommRing.toNormedRing.{u2} K (NormedField.toNormedCommRing.{u2} K _inst_4)))) f p) i)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.monoid)) (LinearOrder.max.{0} Real Real.linearOrder B (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))) d) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Real (HasLiftT.mk.{1, 1} Nat Real (CoeTCₓ.coe.{1, 1} Nat Real (Nat.castCoe.{0} Real Real.hasNatCast))) (Nat.choose d (HDiv.hDiv.{0, 0, 0} Nat Nat Nat (instHDiv.{0} Nat Nat.hasDiv) d (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))))))
but is expected to have type
  forall {F : Type.{u2}} {K : Type.{u1}} [_inst_3 : CommRing.{u2} F] [_inst_4 : NormedField.{u1} K] {B : Real} {d : Nat} (f : RingHom.{u2, u1} F K (Semiring.toNonAssocSemiring.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3))) (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K (NormedField.toField.{u1} K _inst_4)))))) {p : Polynomial.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3))}, (Polynomial.Monic.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) p) -> (Polynomial.Splits.{u2, u1} F K _inst_3 (NormedField.toField.{u1} K _inst_4) f p) -> (LE.le.{0} Nat instLENat (Polynomial.natDegree.{u2} F (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) p) d) -> (forall (z : K), (Membership.mem.{u1, u1} K (Multiset.{u1} K) (Multiset.instMembershipMultiset.{u1} K) z (Polynomial.roots.{u1} K (EuclideanDomain.toCommRing.{u1} K (Field.toEuclideanDomain.{u1} K (NormedField.toField.{u1} K _inst_4))) (Field.isDomain.{u1} K (NormedField.toField.{u1} K _inst_4)) (Polynomial.map.{u2, u1} F K (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K (NormedField.toField.{u1} K _inst_4)))) f p))) -> (LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} K (NormedField.toNorm.{u1} K _inst_4) z) B)) -> (forall (i : Nat), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} K (NormedField.toNorm.{u1} K _inst_4) (Polynomial.coeff.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K (NormedField.toField.{u1} K _inst_4)))) (Polynomial.map.{u2, u1} F K (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_3)) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K (NormedField.toField.{u1} K _inst_4)))) f p) i)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (HPow.hPow.{0, 0, 0} Real Nat Real (instHPow.{0, 0} Real Nat (Monoid.Pow.{0} Real Real.instMonoidReal)) (Max.max.{0} Real (LinearOrderedRing.toMax.{0} Real Real.instLinearOrderedRingReal) B (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))) d) (Nat.cast.{0} Real Real.natCast (Nat.choose d (HDiv.hDiv.{0, 0, 0} Nat Nat Nat (instHDiv.{0} Nat Nat.instDivNat) d (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))))
Case conversion may be inaccurate. Consider using '#align polynomial.coeff_bdd_of_roots_le Polynomial.coeff_bdd_of_roots_leₓ'. -/
/-- The coefficients of the monic polynomials of bounded degree with bounded roots are
uniformely bounded. -/
theorem coeff_bdd_of_roots_le {B : ℝ} {d : ℕ} (f : F →+* K) {p : F[X]} (h1 : p.Monic)
    (h2 : Splits f p) (h3 : p.natDegree ≤ d) (h4 : ∀ z ∈ (map f p).roots, ‖z‖ ≤ B) (i : ℕ) :
    ‖(map f p).coeff i‖ ≤ max B 1 ^ d * d.choose (d / 2) :=
  by
  obtain hB | hB := le_or_lt 0 B
  · apply (coeff_le_of_roots_le i h1 h2 h4).trans
    calc
      _ ≤ max B 1 ^ (p.nat_degree - i) * p.nat_degree.choose i :=
        mul_le_mul_of_nonneg_right (pow_le_pow_of_le_left hB (le_max_left _ _) _) _
      _ ≤ max B 1 ^ d * p.nat_degree.choose i :=
        (mul_le_mul_of_nonneg_right ((pow_mono (le_max_right _ _)) (le_trans (Nat.sub_le _ _) h3))
          _)
      _ ≤ max B 1 ^ d * d.choose (d / 2) :=
        mul_le_mul_of_nonneg_left
          (nat.cast_le.mpr ((i.choose_mono h3).trans (i.choose_le_middle d))) _
      
    all_goals positivity
  · rw [eq_one_of_roots_le hB h1 h2 h4, Polynomial.map_one, coeff_one]
    refine' trans _ (one_le_mul_of_one_le_of_one_le (one_le_pow_of_one_le (le_max_right B 1) d) _)
    · split_ifs <;> norm_num
    · exact_mod_cast nat.succ_le_iff.mpr (Nat.choose_pos (d.div_le_self 2))
#align polynomial.coeff_bdd_of_roots_le Polynomial.coeff_bdd_of_roots_le

end Roots

end Polynomial

