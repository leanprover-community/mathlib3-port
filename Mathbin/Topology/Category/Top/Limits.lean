import Mathbin.Topology.Category.Top.EpiMono 
import Mathbin.CategoryTheory.Limits.Preserves.Limits 
import Mathbin.CategoryTheory.Category.Ulift 
import Mathbin.CategoryTheory.Limits.Shapes.Types 
import Mathbin.CategoryTheory.Limits.ConcreteCategory

/-!
# The category of topological spaces has all limits and colimits

Further, these limits and colimits are preserved by the forgetful functor --- that is, the
underlying types are just the limits in the category of types.
-/


open TopologicalSpace

open CategoryTheory

open CategoryTheory.Limits

open Opposite

universe u v w

noncomputable theory

namespace Top

variable{J : Type u}[small_category J]

local notation "forget" => forget Top

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/--
A choice of limit cone for a functor `F : J ‚•§ Top`.
Generally you should just use `limit.cone F`, unless you need the actual definition
(which is in terms of `types.limit_cone`).
-/ def limit_cone (F : ¬´expr ‚•§ ¬ª(J, Top.{u})) : cone F :=
{ X := Top.of {u : ‚àÄ j : J, F.obj j | ‚àÄ {i j : J} (f : ¬´expr ‚ü∂ ¬ª(i, j)), ¬´expr = ¬ª(F.map f (u i), u j)},
  œÄ := { app := Œª
    j, { to_fun := Œª u, u.val j,
      continuous_to_fun := show continuous ¬´expr ‚àò ¬ª(Œª
       u : ‚àÄ j : J, F.obj j, u j, subtype.val), by continuity [] [] } } }

/--
A choice of limit cone for a functor `F : J ‚•§ Top` whose topology is defined as an
infimum of topologies infimum.
Generally you should just use `limit.cone F`, unless you need the actual definition
(which is in terms of `types.limit_cone`).
-/
def limit_cone_infi (F : J ‚•§ Top.{u}) : cone F :=
  { x := ‚ü®(types.limit_cone (F ‚ãô forget)).x, ‚®Öj, (F.obj j).str.induced ((types.limit_cone (F ‚ãô forget)).œÄ.app j)‚ü©,
    œÄ :=
      { app := fun j => ‚ü®(types.limit_cone (F ‚ãô forget)).œÄ.app j, continuous_iff_le_induced.mpr (infi_le _ _)‚ü©,
        naturality' := fun j j' f => ContinuousMap.coe_inj ((types.limit_cone (F ‚ãô forget)).œÄ.naturality f) } }

/--
The chosen cone `Top.limit_cone F` for a functor `F : J ‚•§ Top` is a limit cone.
Generally you should just use `limit.is_limit F`, unless you need the actual definition
(which is in terms of `types.limit_cone_is_limit`).
-/
def limit_cone_is_limit (F : J ‚•§ Top.{u}) : is_limit (limit_cone F) :=
  { lift :=
      fun S =>
        { toFun :=
            fun x =>
              ‚ü®fun j => S.œÄ.app _ x,
                fun i j f =>
                  by 
                    dsimp 
                    erw [‚ÜêS.w f]
                    rfl‚ü© },
    uniq' :=
      fun S m h =>
        by 
          ext : 3
          simpa [‚Üêh] }

/--
The chosen cone `Top.limit_cone_infi F` for a functor `F : J ‚•§ Top` is a limit cone.
Generally you should just use `limit.is_limit F`, unless you need the actual definition
(which is in terms of `types.limit_cone_is_limit`).
-/
def limit_cone_infi_is_limit (F : J ‚•§ Top.{u}) : is_limit (limit_cone_infi F) :=
  by 
    refine' is_limit.of_faithful forget (types.limit_cone_is_limit _) (fun s => ‚ü®_, _‚ü©) fun s => rfl 
    exact
      continuous_iff_coinduced_le.mpr
        (le_infi$ fun j => coinduced_le_iff_le_induced.mp$ (continuous_iff_coinduced_le.mp (s.œÄ.app j).Continuous : _))

instance Top_has_limits : has_limits.{u} Top.{u} :=
  { HasLimitsOfShape :=
      fun J ùí• =>
        by 
          exact { HasLimit := fun F => has_limit.mk { Cone := limit_cone F, IsLimit := limit_cone_is_limit F } } }

instance forget_preserves_limits : preserves_limits (forget : Top.{u} ‚•§ Type u) :=
  { PreservesLimitsOfShape :=
      fun J ùí• =>
        { PreservesLimit :=
            fun F =>
              by 
                exact
                  preserves_limit_of_preserves_limit_cone (limit_cone_is_limit F)
                    (types.limit_cone_is_limit (F ‚ãô forget)) } }

/--
A choice of colimit cocone for a functor `F : J ‚•§ Top`.
Generally you should just use `colimit.coone F`, unless you need the actual definition
(which is in terms of `types.colimit_cocone`).
-/
def colimit_cocone (F : J ‚•§ Top.{u}) : cocone F :=
  { x :=
      ‚ü®(types.colimit_cocone (F ‚ãô forget)).x,
        ‚®Üj, (F.obj j).str.coinduced ((types.colimit_cocone (F ‚ãô forget)).Œπ.app j)‚ü©,
    Œπ :=
      { app := fun j => ‚ü®(types.colimit_cocone (F ‚ãô forget)).Œπ.app j, continuous_iff_coinduced_le.mpr (le_supr _ j)‚ü©,
        naturality' := fun j j' f => ContinuousMap.coe_inj ((types.colimit_cocone (F ‚ãô forget)).Œπ.naturality f) } }

/--
The chosen cocone `Top.colimit_cocone F` for a functor `F : J ‚•§ Top` is a colimit cocone.
Generally you should just use `colimit.is_colimit F`, unless you need the actual definition
(which is in terms of `types.colimit_cocone_is_colimit`).
-/
def colimit_cocone_is_colimit (F : J ‚•§ Top.{u}) : is_colimit (colimit_cocone F) :=
  by 
    refine' is_colimit.of_faithful forget (types.colimit_cocone_is_colimit _) (fun s => ‚ü®_, _‚ü©) fun s => rfl 
    exact
      continuous_iff_le_induced.mpr
        (supr_le$ fun j => coinduced_le_iff_le_induced.mp$ (continuous_iff_coinduced_le.mp (s.Œπ.app j).Continuous : _))

instance Top_has_colimits : has_colimits.{u} Top.{u} :=
  { HasColimitsOfShape :=
      fun J ùí• =>
        by 
          exact
            { HasColimit :=
                fun F => has_colimit.mk { Cocone := colimit_cocone F, IsColimit := colimit_cocone_is_colimit F } } }

instance forget_preserves_colimits : preserves_colimits (forget : Top.{u} ‚•§ Type u) :=
  { PreservesColimitsOfShape :=
      fun J ùí• =>
        { PreservesColimit :=
            fun F =>
              by 
                exact
                  preserves_colimit_of_preserves_colimit_cocone (colimit_cocone_is_colimit F)
                    (types.colimit_cocone_is_colimit (F ‚ãô forget)) } }

/-- The projection from the product as a bundled continous map. -/
abbrev pi_œÄ {Œπ : Type u} (Œ± : Œπ ‚Üí Top.{u}) (i : Œπ) : Top.of (‚àÄ i, Œ± i) ‚ü∂ Œ± i :=
  ‚ü®fun f => f i, continuous_apply i‚ü©

/-- The explicit fan of a family of topological spaces given by the pi type. -/
@[simps x œÄ_app]
def pi_fan {Œπ : Type u} (Œ± : Œπ ‚Üí Top.{u}) : fan Œ± :=
  fan.mk (Top.of (‚àÄ i, Œ± i)) (pi_œÄ Œ±)

/-- The constructed fan is indeed a limit -/
def pi_fan_is_limit {Œπ : Type u} (Œ± : Œπ ‚Üí Top.{u}) : is_limit (pi_fan Œ±) :=
  { lift := fun S => { toFun := fun s i => S.œÄ.app i s },
    uniq' :=
      by 
        intro S m h 
        ext x i 
        simp [‚Üêh i] }

/--
The product is homeomorphic to the product of the underlying spaces,
equipped with the product topology.
-/
def pi_iso_pi {Œπ : Type u} (Œ± : Œπ ‚Üí Top.{u}) : ‚àè Œ± ‚âÖ Top.of (‚àÄ i, Œ± i) :=
  (limit.is_limit _).conePointUniqueUpToIso (pi_fan_is_limit Œ±)

@[simp, reassoc]
theorem pi_iso_pi_inv_œÄ {Œπ : Type u} (Œ± : Œπ ‚Üí Top) (i : Œπ) : (pi_iso_pi Œ±).inv ‚â´ pi.œÄ Œ± i = pi_œÄ Œ± i :=
  by 
    simp [pi_iso_pi]

@[simp]
theorem pi_iso_pi_inv_œÄ_apply {Œπ : Type u} (Œ± : Œπ ‚Üí Top.{u}) (i : Œπ) (x : ‚àÄ i, Œ± i) :
  (pi.œÄ Œ± i : _) ((pi_iso_pi Œ±).inv x) = x i :=
  concrete_category.congr_hom (pi_iso_pi_inv_œÄ Œ± i) x

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[simp]
theorem pi_iso_pi_hom_apply
{Œπ : Type u}
(Œ± : Œπ ‚Üí Top.{u})
(i : Œπ)
(x : ¬´expr‚àè ¬ª(Œ±)) : ¬´expr = ¬ª((pi_iso_pi Œ±).hom x i, (pi.œÄ Œ± i : _) x) :=
begin
  have [] [] [":=", expr pi_iso_pi_inv_œÄ Œ± i],
  rw [expr iso.inv_comp_eq] ["at", ident this],
  exact [expr concrete_category.congr_hom this x]
end

/-- The inclusion to the coproduct as a bundled continous map. -/
abbrev sigma_Œπ {Œπ : Type u} (Œ± : Œπ ‚Üí Top.{u}) (i : Œπ) : Œ± i ‚ü∂ Top.of (Œ£i, Œ± i) :=
  ‚ü®Sigma.mk i‚ü©

/-- The explicit cofan of a family of topological spaces given by the sigma type. -/
@[simps x Œπ_app]
def sigma_cofan {Œπ : Type u} (Œ± : Œπ ‚Üí Top.{u}) : cofan Œ± :=
  cofan.mk (Top.of (Œ£i, Œ± i)) (sigma_Œπ Œ±)

/-- The constructed cofan is indeed a colimit -/
def sigma_cofan_is_colimit {Œπ : Type u} (Œ± : Œπ ‚Üí Top.{u}) : is_colimit (sigma_cofan Œ±) :=
  { desc :=
      fun S =>
        { toFun := fun s => S.Œπ.app s.1 s.2,
          continuous_to_fun :=
            by 
              continuity 
              dsimp only 
              continuity },
    uniq' :=
      by 
        intro S m h 
        ext ‚ü®i, x‚ü©
        simp [‚Üêh i] }

/--
The coproduct is homeomorphic to the disjoint union of the topological spaces.
-/
def sigma_iso_sigma {Œπ : Type u} (Œ± : Œπ ‚Üí Top.{u}) : ‚àê Œ± ‚âÖ Top.of (Œ£i, Œ± i) :=
  (colimit.is_colimit _).coconePointUniqueUpToIso (sigma_cofan_is_colimit Œ±)

@[simp, reassoc]
theorem sigma_iso_sigma_hom_Œπ {Œπ : Type u} (Œ± : Œπ ‚Üí Top) (i : Œπ) :
  sigma.Œπ Œ± i ‚â´ (sigma_iso_sigma Œ±).Hom = sigma_Œπ Œ± i :=
  by 
    simp [sigma_iso_sigma]

@[simp]
theorem sigma_iso_sigma_hom_Œπ_apply {Œπ : Type u} (Œ± : Œπ ‚Üí Top) (i : Œπ) (x : Œ± i) :
  (sigma_iso_sigma Œ±).Hom ((sigma.Œπ Œ± i : _) x) = Sigma.mk i x :=
  concrete_category.congr_hom (sigma_iso_sigma_hom_Œπ Œ± i) x

@[simp]
theorem sigma_iso_sigma_inv_apply {Œπ : Type u} (Œ± : Œπ ‚Üí Top) (i : Œπ) (x : Œ± i) :
  (sigma_iso_sigma Œ±).inv ‚ü®i, x‚ü© = (sigma.Œπ Œ± i : _) x :=
  by 
    rw [‚Üêsigma_iso_sigma_hom_Œπ_apply, ‚Üêcomp_app]
    simp 

theorem induced_of_is_limit {F : J ‚•§ Top.{u}} (C : cone F) (hC : is_limit C) :
  C.X.topological_space = ‚®Öj, (F.obj j).TopologicalSpace.induced (C.œÄ.app j) :=
  by 
    let homeo := homeo_of_iso (hC.cone_point_unique_up_to_iso (limit_cone_infi_is_limit F))
    refine' homeo.inducing.induced.trans _ 
    change induced homeo (‚®Öj : J, _) = _ 
    simpa [induced_infi, induced_compose]

theorem limit_topology (F : J ‚•§ Top.{u}) :
  (limit F).TopologicalSpace = ‚®Öj, (F.obj j).TopologicalSpace.induced (limit.œÄ F j) :=
  induced_of_is_limit _ (limit.is_limit F)

section Prod

/-- The first projection from the product. -/
abbrev prod_fst {X Y : Top.{u}} : Top.of (X √ó Y) ‚ü∂ X :=
  ‚ü®Prod.fst‚ü©

/-- The second projection from the product. -/
abbrev prod_snd {X Y : Top.{u}} : Top.of (X √ó Y) ‚ü∂ Y :=
  ‚ü®Prod.snd‚ü©

/-- The explicit binary cofan of `X, Y` given by `X √ó Y`. -/
def prod_binary_fan (X Y : Top.{u}) : binary_fan X Y :=
  binary_fan.mk prod_fst prod_snd

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- The constructed binary fan is indeed a limit -/
def prod_binary_fan_is_limit (X Y : Top.{u}) : is_limit (prod_binary_fan X Y) :=
{ lift := Œª S : binary_fan X Y, { to_fun := Œª s, (S.fst s, S.snd s) },
  fac' := begin
    rintros [ident S, "(", "_", "|", "_", ")"],
    tidy []
  end,
  uniq' := begin
    intros [ident S, ident m, ident h],
    ext [] [ident x] [],
    { specialize [expr h walking_pair.left],
      apply_fun [expr Œª e, e x] ["at", ident h] [],
      exact [expr h] },
    { specialize [expr h walking_pair.right],
      apply_fun [expr Œª e, e x] ["at", ident h] [],
      exact [expr h] }
  end }

/--
The homeomorphism between `X ‚®Ø Y` and the set-theoretic product of `X` and `Y`,
equipped with the product topology.
-/
def prod_iso_prod (X Y : Top.{u}) : X ‚®Ø Y ‚âÖ Top.of (X √ó Y) :=
  (limit.is_limit _).conePointUniqueUpToIso (prod_binary_fan_is_limit X Y)

@[simp, reassoc]
theorem prod_iso_prod_hom_fst (X Y : Top.{u}) : (prod_iso_prod X Y).Hom ‚â´ prod_fst = limits.prod.fst :=
  by 
    simpa [‚Üêiso.eq_inv_comp, prod_iso_prod]

@[simp, reassoc]
theorem prod_iso_prod_hom_snd (X Y : Top.{u}) : (prod_iso_prod X Y).Hom ‚â´ prod_snd = limits.prod.snd :=
  by 
    simpa [‚Üêiso.eq_inv_comp, prod_iso_prod]

@[simp]
theorem prod_iso_prod_hom_apply {X Y : Top.{u}} (x : X ‚®Ø Y) :
  (prod_iso_prod X Y).Hom x = ((limits.prod.fst : X ‚®Ø Y ‚ü∂ _) x, (limits.prod.snd : X ‚®Ø Y ‚ü∂ _) x) :=
  by 
    ext
    ¬∑
      exact concrete_category.congr_hom (prod_iso_prod_hom_fst X Y) x
    ¬∑
      exact concrete_category.congr_hom (prod_iso_prod_hom_snd X Y) x

@[simp, reassoc, elementwise]
theorem prod_iso_prod_inv_fst (X Y : Top.{u}) : (prod_iso_prod X Y).inv ‚â´ limits.prod.fst = prod_fst :=
  by 
    simp [iso.inv_comp_eq]

@[simp, reassoc, elementwise]
theorem prod_iso_prod_inv_snd (X Y : Top.{u}) : (prod_iso_prod X Y).inv ‚â´ limits.prod.snd = prod_snd :=
  by 
    simp [iso.inv_comp_eq]

theorem prod_topology {X Y : Top} :
  (X ‚®Ø Y).TopologicalSpace =
    induced (limits.prod.fst : X ‚®Ø Y ‚ü∂ _)
        X.topological_space‚äìinduced (limits.prod.snd : X ‚®Ø Y ‚ü∂ _) Y.topological_space :=
  by 
    let homeo := homeo_of_iso (prod_iso_prod X Y)
    refine' homeo.inducing.induced.trans _ 
    change induced homeo (_‚äì_) = _ 
    simpa [induced_compose]

theorem range_prod_map {W X Y Z : Top.{u}} (f : W ‚ü∂ Y) (g : X ‚ü∂ Z) :
  Set.Range (limits.prod.map f g) =
    (limits.prod.fst : Y ‚®Ø Z ‚ü∂ _) ‚Åª¬π' Set.Range f ‚à© (limits.prod.snd : Y ‚®Ø Z ‚ü∂ _) ‚Åª¬π' Set.Range g :=
  by 
    ext 
    split 
    ¬∑
      rintro ‚ü®y, rfl‚ü©
      simp only [Set.mem_preimage, Set.mem_range, Set.mem_inter_eq, ‚Üêcomp_apply]
      simp only [limits.prod.map_fst, limits.prod.map_snd, exists_apply_eq_apply‚Çì, comp_apply, and_self‚Çì]
    ¬∑
      rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
      use (prod_iso_prod W X).inv (x‚ÇÅ, x‚ÇÇ)
      apply concrete.limit_ext 
      rintro ‚ü®‚ü©
      ¬∑
        simp only [‚Üêcomp_apply, category.assoc]
        erw [limits.prod.map_fst]
        simp [hx‚ÇÅ]
      ¬∑
        simp only [‚Üêcomp_apply, category.assoc]
        erw [limits.prod.map_snd]
        simp [hx‚ÇÇ]

theorem inducing_prod_map {W X Y Z : Top} {f : W ‚ü∂ X} {g : Y ‚ü∂ Z} (hf : Inducing f) (hg : Inducing g) :
  Inducing (limits.prod.map f g) :=
  by 
    constructor 
    simp only [prod_topology, induced_compose, ‚Üêcoe_comp, limits.prod.map_fst, limits.prod.map_snd, induced_inf]
    simp only [coe_comp]
    rw [‚Üê@induced_compose _ _ _ _ _ f, ‚Üê@induced_compose _ _ _ _ _ g, ‚Üêhf.induced, ‚Üêhg.induced]

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem embedding_prod_map
{W X Y Z : Top}
{f : ¬´expr ‚ü∂ ¬ª(W, X)}
{g : ¬´expr ‚ü∂ ¬ª(Y, Z)}
(hf : embedding f)
(hg : embedding g) : embedding (limits.prod.map f g) :=
‚ü®inducing_prod_map hf.to_inducing hg.to_inducing, begin
   haveI [] [] [":=", expr (Top.mono_iff_injective _).mpr hf.inj],
   haveI [] [] [":=", expr (Top.mono_iff_injective _).mpr hg.inj],
   exact [expr (Top.mono_iff_injective _).mp infer_instance]
 end‚ü©

end Prod

section Pullback

variable{X Y Z : Top.{u}}

/-- The first projection from the pullback. -/
abbrev pullback_fst (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : Top.of { p : X √ó Y // f p.1 = g p.2 } ‚ü∂ X :=
  ‚ü®Prod.fst ‚àò Subtype.val‚ü©

/-- The second projection from the pullback. -/
abbrev pullback_snd (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : Top.of { p : X √ó Y // f p.1 = g p.2 } ‚ü∂ Y :=
  ‚ü®Prod.snd ‚àò Subtype.val‚ü©

/-- The explicit pullback cone of `X, Y` given by `{ p : X √ó Y // f p.1 = g p.2 }`. -/
def pullback_cone (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : pullback_cone f g :=
  pullback_cone.mk (pullback_fst f g) (pullback_snd f g)
    (by 
      ext ‚ü®x, h‚ü©
      simp [h])

/-- The constructed cone is a limit. -/
def pullback_cone_is_limit (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : is_limit (pullback_cone f g) :=
  pullback_cone.is_limit_aux' _
    (by 
      intro s 
      split 
      swap 
      exact
        { toFun :=
            fun x =>
              ‚ü®‚ü®s.fst x, s.snd x‚ü©,
                by 
                  simpa using concrete_category.congr_hom s.condition x‚ü© }
      refine' ‚ü®_, _, _‚ü©
      ¬∑
        ext 
        delta' pullback_cone 
        simp 
      ¬∑
        ext 
        delta' pullback_cone 
        simp 
      ¬∑
        intro m h‚ÇÅ h‚ÇÇ 
        ext x
        ¬∑
          simpa using concrete_category.congr_hom h‚ÇÅ x
        ¬∑
          simpa using concrete_category.congr_hom h‚ÇÇ x)

/-- The pullback of two maps can be identified as a subspace of `X √ó Y`. -/
def pullback_iso_prod_subtype (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : pullback f g ‚âÖ Top.of { p : X √ó Y // f p.1 = g p.2 } :=
  (limit.is_limit _).conePointUniqueUpToIso (pullback_cone_is_limit f g)

@[simp, reassoc]
theorem pullback_iso_prod_subtype_inv_fst (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  (pullback_iso_prod_subtype f g).inv ‚â´ pullback.fst = pullback_fst f g :=
  by 
    simpa [pullback_iso_prod_subtype]

@[simp]
theorem pullback_iso_prod_subtype_inv_fst_apply (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (x : { p : X √ó Y // f p.1 = g p.2 }) :
  (pullback.fst : pullback f g ‚ü∂ _) ((pullback_iso_prod_subtype f g).inv x) = (x : X √ó Y).fst :=
  concrete_category.congr_hom (pullback_iso_prod_subtype_inv_fst f g) x

@[simp, reassoc]
theorem pullback_iso_prod_subtype_inv_snd (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  (pullback_iso_prod_subtype f g).inv ‚â´ pullback.snd = pullback_snd f g :=
  by 
    simpa [pullback_iso_prod_subtype]

@[simp]
theorem pullback_iso_prod_subtype_inv_snd_apply (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (x : { p : X √ó Y // f p.1 = g p.2 }) :
  (pullback.snd : pullback f g ‚ü∂ _) ((pullback_iso_prod_subtype f g).inv x) = (x : X √ó Y).snd :=
  concrete_category.congr_hom (pullback_iso_prod_subtype_inv_snd f g) x

theorem pullback_iso_prod_subtype_hom_fst (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  (pullback_iso_prod_subtype f g).Hom ‚â´ pullback_fst f g = pullback.fst :=
  by 
    rw [‚Üêiso.eq_inv_comp, pullback_iso_prod_subtype_inv_fst]

theorem pullback_iso_prod_subtype_hom_snd (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  (pullback_iso_prod_subtype f g).Hom ‚â´ pullback_snd f g = pullback.snd :=
  by 
    rw [‚Üêiso.eq_inv_comp, pullback_iso_prod_subtype_inv_snd]

@[simp]
theorem pullback_iso_prod_subtype_hom_apply {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (x : pullback f g) :
  (pullback_iso_prod_subtype f g).Hom x =
    ‚ü®‚ü®(pullback.fst : pullback f g ‚ü∂ _) x, (pullback.snd : pullback f g ‚ü∂ _) x‚ü©,
      by 
        simpa using concrete_category.congr_hom pullback.condition x‚ü© :=
  by 
    ext 
    exacts[concrete_category.congr_hom (pullback_iso_prod_subtype_hom_fst f g) x,
      concrete_category.congr_hom (pullback_iso_prod_subtype_hom_snd f g) x]

theorem pullback_topology {X Y Z : Top.{u}} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  (pullback f g).TopologicalSpace =
    induced (pullback.fst : pullback f g ‚ü∂ _)
        X.topological_space‚äìinduced (pullback.snd : pullback f g ‚ü∂ _) Y.topological_space :=
  by 
    let homeo := homeo_of_iso (pullback_iso_prod_subtype f g)
    refine' homeo.inducing.induced.trans _ 
    change induced homeo (induced _ (_‚äì_)) = _ 
    simpa [induced_compose]

theorem range_pullback_to_prod {X Y Z : Top} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  Set.Range (prod.lift pullback.fst pullback.snd : pullback f g ‚ü∂ X ‚®Ø Y) =
    { x | (limits.prod.fst ‚â´ f) x = (limits.prod.snd ‚â´ g) x } :=
  by 
    ext x 
    split 
    ¬∑
      rintro ‚ü®y, rfl‚ü©
      simp only [‚Üêcomp_apply, Set.mem_set_of_eq]
      congr 1
      simp [pullback.condition]
    ¬∑
      intro h 
      use (pullback_iso_prod_subtype f g).inv ‚ü®‚ü®_, _‚ü©, h‚ü©
      apply concrete.limit_ext 
      rintro ‚ü®‚ü© <;> simp 

theorem inducing_pullback_to_prod {X Y Z : Top} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  Inducing (¬´expr‚áë ¬ª (prod.lift pullback.fst pullback.snd : pullback f g ‚ü∂ X ‚®Ø Y)) :=
  ‚ü®by 
      simp [prod_topology, pullback_topology, induced_compose, ‚Üêcoe_comp]‚ü©

theorem embedding_pullback_to_prod {X Y Z : Top} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  Embedding (¬´expr‚áë ¬ª (prod.lift pullback.fst pullback.snd : pullback f g ‚ü∂ X ‚®Ø Y)) :=
  ‚ü®inducing_pullback_to_prod f g, (Top.mono_iff_injective _).mp inferInstance‚ü©

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If the map `S ‚ü∂ T` is mono, then there is a description of the image of `W √ó‚Çõ X ‚ü∂ Y √ó‚Çú Z`. -/
theorem range_pullback_map
{W X Y Z S T : Top}
(f‚ÇÅ : ¬´expr ‚ü∂ ¬ª(W, S))
(f‚ÇÇ : ¬´expr ‚ü∂ ¬ª(X, S))
(g‚ÇÅ : ¬´expr ‚ü∂ ¬ª(Y, T))
(g‚ÇÇ : ¬´expr ‚ü∂ ¬ª(Z, T))
(i‚ÇÅ : ¬´expr ‚ü∂ ¬ª(W, Y))
(i‚ÇÇ : ¬´expr ‚ü∂ ¬ª(X, Z))
(i‚ÇÉ : ¬´expr ‚ü∂ ¬ª(S, T))
[H‚ÇÉ : mono i‚ÇÉ]
(eq‚ÇÅ : ¬´expr = ¬ª(¬´expr ‚â´ ¬ª(f‚ÇÅ, i‚ÇÉ), ¬´expr ‚â´ ¬ª(i‚ÇÅ, g‚ÇÅ)))
(eq‚ÇÇ : ¬´expr = ¬ª(¬´expr ‚â´ ¬ª(f‚ÇÇ, i‚ÇÉ), ¬´expr ‚â´ ¬ª(i‚ÇÇ, g‚ÇÇ))) : ¬´expr = ¬ª(set.range (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ), ¬´expr ‚à© ¬ª(¬´expr ‚Åª¬π' ¬ª((pullback.fst : ¬´expr ‚ü∂ ¬ª(pullback g‚ÇÅ g‚ÇÇ, _)), set.range i‚ÇÅ), ¬´expr ‚Åª¬π' ¬ª((pullback.snd : ¬´expr ‚ü∂ ¬ª(pullback g‚ÇÅ g‚ÇÇ, _)), set.range i‚ÇÇ))) :=
begin
  ext [] [] [],
  split,
  { rintro ["‚ü®", ident y, ",", ident rfl, "‚ü©"],
    simp [] [] [] [] [] [] },
  rintros ["‚ü®", "‚ü®", ident x‚ÇÅ, ",", ident hx‚ÇÅ, "‚ü©", ",", "‚ü®", ident x‚ÇÇ, ",", ident hx‚ÇÇ, "‚ü©", "‚ü©"],
  have [] [":", expr ¬´expr = ¬ª(f‚ÇÅ x‚ÇÅ, f‚ÇÇ x‚ÇÇ)] [],
  { apply [expr (Top.mono_iff_injective _).mp H‚ÇÉ],
    simp [] [] ["only"] ["[", "<-", expr comp_apply, ",", expr eq‚ÇÅ, ",", expr eq‚ÇÇ, "]"] [] [],
    simp [] [] ["only"] ["[", expr comp_apply, ",", expr hx‚ÇÅ, ",", expr hx‚ÇÇ, "]"] [] [],
    simp [] [] ["only"] ["[", "<-", expr comp_apply, ",", expr pullback.condition, "]"] [] [] },
  use [expr (pullback_iso_prod_subtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©],
  apply [expr concrete.limit_ext],
  rintros ["(", "_", "|", "_", "|", "_", ")"],
  { simp [] [] ["only"] ["[", expr Top.comp_app, ",", expr limit.lift_œÄ_apply, ",", expr category.assoc, ",", expr pullback_cone.mk_œÄ_app_one, ",", expr hx‚ÇÅ, ",", expr pullback_iso_prod_subtype_inv_fst_apply, ",", expr subtype.coe_mk, "]"] [] [],
    simp [] [] ["only"] ["[", "<-", expr comp_apply, "]"] [] [],
    congr,
    apply [expr limit.w _ walking_cospan.hom.inl] },
  { simp [] [] [] ["[", expr hx‚ÇÅ, "]"] [] [] },
  { simp [] [] [] ["[", expr hx‚ÇÇ, "]"] [] [] }
end

theorem pullback_fst_range {X Y S : Top} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) :
  Set.Range (pullback.fst : pullback f g ‚ü∂ _) = { x:X | ‚àÉ y : Y, f x = g y } :=
  by 
    ext x 
    split 
    ¬∑
      rintro ‚ü®y, rfl‚ü©
      use (pullback.snd : pullback f g ‚ü∂ _) y 
      exact concrete_category.congr_hom pullback.condition y
    ¬∑
      rintro ‚ü®y, eq‚ü©
      use (Top.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®x, y‚ü©, Eq‚ü©
      simp 

theorem pullback_snd_range {X Y S : Top} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) :
  Set.Range (pullback.snd : pullback f g ‚ü∂ _) = { y:Y | ‚àÉ x : X, f x = g y } :=
  by 
    ext y 
    split 
    ¬∑
      rintro ‚ü®x, rfl‚ü©
      use (pullback.fst : pullback f g ‚ü∂ _) x 
      exact concrete_category.congr_hom pullback.condition x
    ¬∑
      rintro ‚ü®x, eq‚ü©
      use (Top.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®x, y‚ü©, Eq‚ü©
      simp 

/--
If there is a diagram where the morphisms `W ‚ü∂ Y` and `X ‚ü∂ Z` are embeddings,
then the induced morphism `W √ó‚Çõ X ‚ü∂ Y √ó‚Çú Z` is also an embedding.

  W  ‚ü∂  Y
    ‚Üò      ‚Üò
      S  ‚ü∂  T
    ‚Üó      ‚Üó
  X  ‚ü∂  Z
-/
theorem pullback_map_embedding_of_embeddings {W X Y Z S T : Top} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) (g‚ÇÅ : Y ‚ü∂ T) (g‚ÇÇ : Z ‚ü∂ T)
  {i‚ÇÅ : W ‚ü∂ Y} {i‚ÇÇ : X ‚ü∂ Z} (H‚ÇÅ : Embedding i‚ÇÅ) (H‚ÇÇ : Embedding i‚ÇÇ) (i‚ÇÉ : S ‚ü∂ T) (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ)
  (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) : Embedding (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) :=
  by 
    refine'
      embedding_of_embedding_compose (ContinuousMap.continuous_to_fun _)
        (show Continuous (prod.lift pullback.fst pullback.snd : pullback g‚ÇÅ g‚ÇÇ ‚ü∂ Y ‚®Ø Z) from
          ContinuousMap.continuous_to_fun _)
        _ 
    suffices  : Embedding (prod.lift pullback.fst pullback.snd ‚â´ limits.prod.map i‚ÇÅ i‚ÇÇ : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ _)
    ¬∑
      simpa [‚Üêcoe_comp] using this 
    rw [coe_comp]
    refine' Embedding.comp (embedding_prod_map H‚ÇÅ H‚ÇÇ) (embedding_pullback_to_prod _ _)

/--
If there is a diagram where the morphisms `W ‚ü∂ Y` and `X ‚ü∂ Z` are open embeddings, and `S ‚ü∂ T`
is mono, then the induced morphism `W √ó‚Çõ X ‚ü∂ Y √ó‚Çú Z` is also an open embedding.
  W  ‚ü∂  Y
    ‚Üò      ‚Üò
      S  ‚ü∂  T
    ‚Üó       ‚Üó
  X  ‚ü∂  Z
-/
theorem pullback_map_open_embedding_of_open_embeddings {W X Y Z S T : Top} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) (g‚ÇÅ : Y ‚ü∂ T)
  (g‚ÇÇ : Z ‚ü∂ T) {i‚ÇÅ : W ‚ü∂ Y} {i‚ÇÇ : X ‚ü∂ Z} (H‚ÇÅ : OpenEmbedding i‚ÇÅ) (H‚ÇÇ : OpenEmbedding i‚ÇÇ) (i‚ÇÉ : S ‚ü∂ T) [H‚ÇÉ : mono i‚ÇÉ]
  (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) : OpenEmbedding (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) :=
  by 
    split 
    ¬∑
      apply pullback_map_embedding_of_embeddings f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ H‚ÇÅ.to_embedding H‚ÇÇ.to_embedding i‚ÇÉ eq‚ÇÅ eq‚ÇÇ
    ¬∑
      rw [range_pullback_map]
      apply IsOpen.inter <;> apply Continuous.is_open_preimage 
      continuity 
      exacts[H‚ÇÅ.open_range, H‚ÇÇ.open_range]

theorem snd_embedding_of_left_embedding {X Y S : Top} {f : X ‚ü∂ S} (H : Embedding f) (g : Y ‚ü∂ S) :
  Embedding (¬´expr‚áë ¬ª (pullback.snd : pullback f g ‚ü∂ Y)) :=
  by 
    convert
      (homeo_of_iso (as_iso (pullback.snd : pullback (ùüô S) g ‚ü∂ _))).Embedding.comp
        (pullback_map_embedding_of_embeddings f g (ùüô _) g H (homeo_of_iso (iso.refl _)).Embedding (ùüô _) rfl
          (by 
            simp ))
    erw [‚Üêcoe_comp]
    simp 

theorem fst_embedding_of_right_embedding {X Y S : Top} (f : X ‚ü∂ S) {g : Y ‚ü∂ S} (H : Embedding g) :
  Embedding (¬´expr‚áë ¬ª (pullback.fst : pullback f g ‚ü∂ X)) :=
  by 
    convert
      (homeo_of_iso (as_iso (pullback.fst : pullback f (ùüô S) ‚ü∂ _))).Embedding.comp
        (pullback_map_embedding_of_embeddings f g f (ùüô _) (homeo_of_iso (iso.refl _)).Embedding H (ùüô _) rfl
          (by 
            simp ))
    erw [‚Üêcoe_comp]
    simp 

theorem embedding_of_pullback_embeddings {X Y S : Top} {f : X ‚ü∂ S} {g : Y ‚ü∂ S} (H‚ÇÅ : Embedding f) (H‚ÇÇ : Embedding g) :
  Embedding (limit.œÄ (cospan f g) walking_cospan.one) :=
  by 
    convert H‚ÇÇ.comp (snd_embedding_of_left_embedding H‚ÇÅ g)
    erw [‚Üêcoe_comp]
    congr 
    exact (limit.w _ walking_cospan.hom.inr).symm

theorem snd_open_embedding_of_left_open_embedding {X Y S : Top} {f : X ‚ü∂ S} (H : OpenEmbedding f) (g : Y ‚ü∂ S) :
  OpenEmbedding (¬´expr‚áë ¬ª (pullback.snd : pullback f g ‚ü∂ Y)) :=
  by 
    convert
      (homeo_of_iso (as_iso (pullback.snd : pullback (ùüô S) g ‚ü∂ _))).OpenEmbedding.comp
        (pullback_map_open_embedding_of_open_embeddings f g (ùüô _) g H (homeo_of_iso (iso.refl _)).OpenEmbedding (ùüô _)
          rfl
          (by 
            simp ))
    erw [‚Üêcoe_comp]
    simp 

theorem fst_open_embedding_of_right_open_embedding {X Y S : Top} (f : X ‚ü∂ S) {g : Y ‚ü∂ S} (H : OpenEmbedding g) :
  OpenEmbedding (¬´expr‚áë ¬ª (pullback.fst : pullback f g ‚ü∂ X)) :=
  by 
    convert
      (homeo_of_iso (as_iso (pullback.fst : pullback f (ùüô S) ‚ü∂ _))).OpenEmbedding.comp
        (pullback_map_open_embedding_of_open_embeddings f g f (ùüô _) (homeo_of_iso (iso.refl _)).OpenEmbedding H (ùüô _)
          rfl
          (by 
            simp ))
    erw [‚Üêcoe_comp]
    simp 

/-- If `X ‚ü∂ S`, `Y ‚ü∂ S` are open embeddings, then so is `X √ó‚Çõ Y ‚ü∂ S`. -/
theorem open_embedding_of_pullback_open_embeddings {X Y S : Top} {f : X ‚ü∂ S} {g : Y ‚ü∂ S} (H‚ÇÅ : OpenEmbedding f)
  (H‚ÇÇ : OpenEmbedding g) : OpenEmbedding (limit.œÄ (cospan f g) walking_cospan.one) :=
  by 
    convert H‚ÇÇ.comp (snd_open_embedding_of_left_open_embedding H‚ÇÅ g)
    erw [‚Üêcoe_comp]
    congr 
    exact (limit.w _ walking_cospan.hom.inr).symm

theorem fst_iso_of_right_embedding_range_subset {X Y S : Top} (f : X ‚ü∂ S) {g : Y ‚ü∂ S} (hg : Embedding g)
  (H : Set.Range f ‚äÜ Set.Range g) : is_iso (pullback.fst : pullback f g ‚ü∂ X) :=
  by 
    let this : (pullback f g : Top) ‚âÉ‚Çú X :=
      (Homeomorph.ofEmbedding _ (fst_embedding_of_right_embedding f hg)).trans
        { toFun := coe‚Çì,
          invFun :=
            fun x =>
              ‚ü®x,
                by 
                  rw [pullback_fst_range]
                  exact ‚ü®_, (H (Set.mem_range_self x)).some_spec.symm‚ü©‚ü©,
          left_inv := fun ‚ü®_, _‚ü© => rfl, right_inv := fun x => rfl }
    convert is_iso.of_iso (iso_of_homeo this)
    ext 
    rfl

theorem snd_iso_of_left_embedding_range_subset {X Y S : Top} {f : X ‚ü∂ S} (hf : Embedding f) (g : Y ‚ü∂ S)
  (H : Set.Range g ‚äÜ Set.Range f) : is_iso (pullback.snd : pullback f g ‚ü∂ Y) :=
  by 
    let this : (pullback f g : Top) ‚âÉ‚Çú Y :=
      (Homeomorph.ofEmbedding _ (snd_embedding_of_left_embedding hf g)).trans
        { toFun := coe‚Çì,
          invFun :=
            fun x =>
              ‚ü®x,
                by 
                  rw [pullback_snd_range]
                  exact ‚ü®_, (H (Set.mem_range_self x)).some_spec‚ü©‚ü©,
          left_inv := fun ‚ü®_, _‚ü© => rfl, right_inv := fun x => rfl }
    convert is_iso.of_iso (iso_of_homeo this)
    ext 
    rfl

end Pullback

theorem coinduced_of_is_colimit {F : J ‚•§ Top.{u}} (c : cocone F) (hc : is_colimit c) :
  c.X.topological_space = ‚®Üj, (F.obj j).TopologicalSpace.coinduced (c.Œπ.app j) :=
  by 
    let homeo := homeo_of_iso (hc.cocone_point_unique_up_to_iso (colimit_cocone_is_colimit F))
    ext 
    refine' homeo.symm.is_open_preimage.symm.trans (Iff.trans _ is_open_supr_iff.symm)
    exact is_open_supr_iff

theorem colimit_topology (F : J ‚•§ Top.{u}) :
  (colimit F).TopologicalSpace = ‚®Üj, (F.obj j).TopologicalSpace.coinduced (colimit.Œπ F j) :=
  coinduced_of_is_colimit _ (colimit.is_colimit F)

theorem colimit_is_open_iff (F : J ‚•§ Top.{u}) (U : Set ((colimit F : _) : Type u)) :
  IsOpen U ‚Üî ‚àÄ j, IsOpen (colimit.Œπ F j ‚Åª¬π' U) :=
  by 
    convLHS => rw [colimit_topology F]
    exact is_open_supr_iff

theorem coequalizer_is_open_iff (F : walking_parallel_pair ‚•§ Top.{u}) (U : Set ((colimit F : _) : Type u)) :
  IsOpen U ‚Üî IsOpen (colimit.Œπ F walking_parallel_pair.one ‚Åª¬π' U) :=
  by 
    rw [colimit_is_open_iff]
    split 
    ¬∑
      intro H 
      exact H _
    ¬∑
      intro H j 
      cases j
      ¬∑
        rw [‚Üêcolimit.w F walking_parallel_pair_hom.left]
        exact (F.map walking_parallel_pair_hom.left).continuous_to_fun.is_open_preimage _ H
      ¬∑
        exact H

end Top

namespace Top

section CofilteredLimit

variable{J : Type u}[small_category J][is_cofiltered J](F : J ‚•§ Top.{u})(C : cone F)(hC : is_limit C)

include hC

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/--
Given a *compatible* collection of topological bases for the factors in a cofiltered limit
which contain `set.univ` and are closed under intersections, the induced *naive* collection
of sets in the limit is, in fact, a topological basis.
-/
theorem is_topological_basis_cofiltered_limit
(T : ‚àÄ j, set (set (F.obj j)))
(hT : ‚àÄ j, is_topological_basis (T j))
(univ : ‚àÄ i : J, ¬´expr ‚àà ¬ª(set.univ, T i))
(inter : ‚àÄ (i) (U1 U2 : set (F.obj i)), ¬´expr ‚àà ¬ª(U1, T i) ‚Üí ¬´expr ‚àà ¬ª(U2, T i) ‚Üí ¬´expr ‚àà ¬ª(¬´expr ‚à© ¬ª(U1, U2), T i))
(compat : ‚àÄ
 (i j : J)
 (f : ¬´expr ‚ü∂ ¬ª(i, j))
 (V : set (F.obj j))
 (hV : ¬´expr ‚àà ¬ª(V, T j)), ¬´expr ‚àà ¬ª(¬´expr ‚Åª¬π' ¬ª(F.map f, V), T i)) : is_topological_basis {U : set C.X | ¬´expr‚àÉ , ¬ª((j)
 (V : set (F.obj j)), ¬´expr ‚àß ¬ª(¬´expr ‚àà ¬ª(V, T j), ¬´expr = ¬ª(U, ¬´expr ‚Åª¬π' ¬ª(C.œÄ.app j, V))))} :=
begin
  classical,
  let [ident D] [] [":=", expr limit_cone_infi F],
  let [ident E] [":", expr ¬´expr ‚âÖ ¬ª(C.X, D.X)] [":=", expr hC.cone_point_unique_up_to_iso (limit_cone_infi_is_limit _)],
  have [ident hE] [":", expr inducing E.hom] [":=", expr (Top.homeo_of_iso E).inducing],
  suffices [] [":", expr is_topological_basis {U : set D.X | ¬´expr‚àÉ , ¬ª((j)
    (V : set (F.obj j)), ¬´expr ‚àß ¬ª(¬´expr ‚àà ¬ª(V, T j), ¬´expr = ¬ª(U, ¬´expr ‚Åª¬π' ¬ª(D.œÄ.app j, V))))}],
  { convert [] [expr this.inducing hE] [],
    ext [] [ident U0] [],
    split,
    { rintro ["‚ü®", ident j, ",", ident V, ",", ident hV, ",", ident rfl, "‚ü©"],
      refine [expr ‚ü®¬´expr ‚Åª¬π' ¬ª(D.œÄ.app j, V), ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©] },
    { rintro ["‚ü®", ident W, ",", "‚ü®", ident j, ",", ident V, ",", ident hV, ",", ident rfl, "‚ü©", ",", ident rfl, "‚ü©"],
      refine [expr ‚ü®j, V, hV, rfl‚ü©] } },
  convert [] [expr is_topological_basis_infi hT (Œª (j) (x : D.X), D.œÄ.app j x)] [],
  ext [] [ident U0] [],
  split,
  { rintros ["‚ü®", ident j, ",", ident V, ",", ident hV, ",", ident rfl, "‚ü©"],
    let [ident U] [":", expr ‚àÄ
     i, set (F.obj i)] [":=", expr Œª i, if h : ¬´expr = ¬ª(i, j) then by { rw [expr h] [],
       exact [expr V] } else set.univ],
    refine [expr ‚ü®U, {j}, _, _‚ü©],
    { rintro [ident i, ident h],
      rw [expr finset.mem_singleton] ["at", ident h],
      dsimp [] ["[", expr U, "]"] [] [],
      rw [expr dif_pos h] [],
      subst [expr h],
      exact [expr hV] },
    { dsimp [] ["[", expr U, "]"] [] [],
      simp [] [] [] [] [] [] } },
  { rintros ["‚ü®", ident U, ",", ident G, ",", ident h1, ",", ident h2, "‚ü©"],
    obtain ["‚ü®", ident j, ",", ident hj, "‚ü©", ":=", expr is_cofiltered.inf_objs_exists G],
    let [ident g] [":", expr ‚àÄ (e) (he : ¬´expr ‚àà ¬ª(e, G)), ¬´expr ‚ü∂ ¬ª(j, e)] [":=", expr Œª _ he, (hj he).some],
    let [ident Vs] [":", expr J ‚Üí set (F.obj j)] [":=", expr Œª
     e, if h : ¬´expr ‚àà ¬ª(e, G) then ¬´expr ‚Åª¬π' ¬ª(F.map (g e h), U e) else set.univ],
    let [ident V] [":", expr set (F.obj j)] [":=", expr ¬´expr‚ãÇ , ¬ª((e : J) (he : ¬´expr ‚àà ¬ª(e, G)), Vs e)],
    refine [expr ‚ü®j, V, _, _‚ü©],
    { have [] [":", expr ‚àÄ
       (S : set (set (F.obj j)))
       (E : finset J)
       (P : J ‚Üí set (F.obj j))
       (univ : ¬´expr ‚àà ¬ª(set.univ, S))
       (inter : ‚àÄ A B : set (F.obj j), ¬´expr ‚àà ¬ª(A, S) ‚Üí ¬´expr ‚àà ¬ª(B, S) ‚Üí ¬´expr ‚àà ¬ª(¬´expr ‚à© ¬ª(A, B), S))
       (cond : ‚àÄ
        (e : J)
        (he : ¬´expr ‚àà ¬ª(e, E)), ¬´expr ‚àà ¬ª(P e, S)), ¬´expr ‚àà ¬ª(¬´expr‚ãÇ , ¬ª((e) (he : ¬´expr ‚àà ¬ª(e, E)), P e), S)] [],
      { intros [ident S, ident E],
        apply [expr E.induction_on],
        { intros [ident P, ident he, ident hh],
          simpa [] [] [] [] [] [] },
        { intros [ident a, ident E, ident ha, ident hh1, ident hh2, ident hh3, ident hh4, ident hh5],
          rw [expr finset.set_bInter_insert] [],
          refine [expr hh4 _ _ (hh5 _ (finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)],
          intros [ident e, ident he],
          exact [expr hh5 e (finset.mem_insert_of_mem he)] } },
      refine [expr this _ _ _ (univ _) (inter _) _],
      intros [ident e, ident he],
      dsimp [] ["[", expr Vs, "]"] [] [],
      rw [expr dif_pos he] [],
      exact [expr compat j e (g e he) (U e) (h1 e he)] },
    { rw [expr h2] [],
      dsimp [] ["[", expr V, "]"] [] [],
      rw [expr set.preimage_Inter] [],
      congr' [1] [],
      ext1 [] [ident e],
      rw [expr set.preimage_Inter] [],
      congr' [1] [],
      ext1 [] [ident he],
      dsimp [] ["[", expr Vs, "]"] [] [],
      rw ["[", expr dif_pos he, ",", "<-", expr set.preimage_comp, "]"] [],
      congr' [1] [],
      change [expr ¬´expr = ¬ª(_, ¬´expr‚áë ¬ª(¬´expr ‚â´ ¬ª(D.œÄ.app j, F.map (g e he))))] [] [],
      rw [expr D.w] [] } }
end

end CofilteredLimit

section TopologicalKonig

/-!
## Topological K≈ënig's lemma

A topological version of K≈ënig's lemma is that the inverse limit of nonempty compact Hausdorff
spaces is nonempty.  (Note: this can be generalized further to inverse limits of nonempty compact
T0 spaces, where all the maps are closed maps; see [Stone1979] --- however there is an erratum
for Theorem 4 that the element in the inverse limit can have cofinally many components that are
not closed points.)

We give this in a more general form, which is that cofiltered limits
of nonempty compact Hausdorff spaces are nonempty
(`nonempty_limit_cone_of_compact_t2_cofiltered_system`).

This also applies to inverse limits, where `{J : Type u} [directed_order J]` and `F : J·µí·µñ ‚•§ Top`.

The theorem is specialized to nonempty finite types (which are compact Hausdorff with the
discrete topology) in `nonempty_sections_of_fintype_cofiltered_system` and
`nonempty_sections_of_fintype_inverse_system`.

(See https://stacks.math.columbia.edu/tag/086J for the Set version.)
-/


variable{J : Type u}[small_category J]

variable(F : J ‚•§ Top.{u})

private abbrev finite_diagram_arrow {J : Type u} [small_category J] (G : Finset J) :=
  Œ£'(X Y : J)(mX : X ‚àà G)(mY : Y ‚àà G), X ‚ü∂ Y

private abbrev finite_diagram (J : Type u) [small_category J] :=
  Œ£G : Finset J, Finset (finite_diagram_arrow G)

/--
Partial sections of a cofiltered limit are sections when restricted to
a finite subset of objects and morphisms of `J`.
-/
def partial_sections {J : Type u} [small_category J] (F : J ‚•§ Top.{u}) {G : Finset J}
  (H : Finset (finite_diagram_arrow G)) : Set (‚àÄ j, F.obj j) :=
  { u | ‚àÄ {f : finite_diagram_arrow G} (hf : f ‚àà H), F.map f.2.2.2.2 (u f.1) = u f.2.1 }

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem partial_sections.nonempty
[is_cofiltered J]
[h : ‚àÄ j : J, nonempty (F.obj j)]
{G : finset J}
(H : finset (finite_diagram_arrow G)) : (partial_sections F H).nonempty :=
begin
  classical,
  use [expr Œª
   j : J, if hj : ¬´expr ‚àà ¬ª(j, G) then F.map (is_cofiltered.inf_to G H hj) (h (is_cofiltered.inf G H)).some else (h _).some],
  rintros ["‚ü®", ident X, ",", ident Y, ",", ident hX, ",", ident hY, ",", ident f, "‚ü©", ident hf],
  dsimp ["only"] [] [] [],
  rwa ["[", expr dif_pos hX, ",", expr dif_pos hY, ",", "<-", expr comp_app, ",", "<-", expr F.map_comp, ",", expr @is_cofiltered.inf_to_commutes _ _ _ G H, "]"] []
end

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem partial_sections.directed : directed superset (Œª G : finite_diagram J, partial_sections F G.2) :=
begin
  classical,
  intros [ident A, ident B],
  let [ident ŒπA] [":", expr finite_diagram_arrow A.1 ‚Üí finite_diagram_arrow ¬´expr ‚äî ¬ª(A.1, B.1)] [":=", expr Œª
   f, ‚ü®f.1, f.2.1, finset.mem_union_left _ f.2.2.1, finset.mem_union_left _ f.2.2.2.1, f.2.2.2.2‚ü©],
  let [ident ŒπB] [":", expr finite_diagram_arrow B.1 ‚Üí finite_diagram_arrow ¬´expr ‚äî ¬ª(A.1, B.1)] [":=", expr Œª
   f, ‚ü®f.1, f.2.1, finset.mem_union_right _ f.2.2.1, finset.mem_union_right _ f.2.2.2.1, f.2.2.2.2‚ü©],
  refine [expr ‚ü®‚ü®¬´expr ‚äî ¬ª(A.1, B.1), ¬´expr ‚äî ¬ª(A.2.image ŒπA, B.2.image ŒπB)‚ü©, _, _‚ü©],
  { rintro [ident u, ident hu, ident f, ident hf],
    have [] [":", expr ¬´expr ‚àà ¬ª(ŒπA f, ¬´expr ‚äî ¬ª(A.2.image ŒπA, B.2.image ŒπB))] [],
    { apply [expr finset.mem_union_left],
      rw [expr finset.mem_image] [],
      refine [expr ‚ü®f, hf, rfl‚ü©] },
    exact [expr hu this] },
  { rintro [ident u, ident hu, ident f, ident hf],
    have [] [":", expr ¬´expr ‚àà ¬ª(ŒπB f, ¬´expr ‚äî ¬ª(A.2.image ŒπA, B.2.image ŒπB))] [],
    { apply [expr finset.mem_union_right],
      rw [expr finset.mem_image] [],
      refine [expr ‚ü®f, hf, rfl‚ü©] },
    exact [expr hu this] }
end

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem partial_sections.closed
[‚àÄ j : J, t2_space (F.obj j)]
{G : finset J}
(H : finset (finite_diagram_arrow G)) : is_closed (partial_sections F H) :=
begin
  have [] [":", expr ¬´expr = ¬ª(partial_sections F H, ¬´expr‚ãÇ , ¬ª({f : finite_diagram_arrow G}
     (hf : ¬´expr ‚àà ¬ª(f, H)), {u | ¬´expr = ¬ª(F.map f.2.2.2.2 (u f.1), u f.2.1)}))] [],
  { ext1 [] [],
    simp [] [] ["only"] ["[", expr set.mem_Inter, ",", expr set.mem_set_of_eq, "]"] [] [],
    refl },
  rw [expr this] [],
  apply [expr is_closed_bInter],
  intros [ident f, ident hf],
  apply [expr is_closed_eq],
  continuity [] []
end

/--
Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.
--/
theorem nonempty_limit_cone_of_compact_t2_cofiltered_system [is_cofiltered J] [‚àÄ (j : J), Nonempty (F.obj j)]
  [‚àÄ (j : J), CompactSpace (F.obj j)] [‚àÄ (j : J), T2Space (F.obj j)] : Nonempty (Top.limitCone F).x :=
  by 
    classical 
    obtain ‚ü®u, hu‚ü© :=
      IsCompact.nonempty_Inter_of_directed_nonempty_compact_closed (fun G => partial_sections F _)
        (partial_sections.directed F) (fun G => partial_sections.nonempty F _)
        (fun G => IsClosed.is_compact (partial_sections.closed F _)) fun G => partial_sections.closed F _ 
    use u 
    intro X Y f 
    let G : finite_diagram J :=
      ‚ü®{X, Y},
        {‚ü®X, Y,
            by 
              simp only [true_or‚Çì, eq_self_iff_true, Finset.mem_insert],
            by 
              simp only [eq_self_iff_true, or_true‚Çì, Finset.mem_insert, Finset.mem_singleton],
            f‚ü©}‚ü©
    exact hu _ ‚ü®G, rfl‚ü© (Finset.mem_singleton_self _)

end TopologicalKonig

end Top

section FintypeKonig

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- This bootstraps `nonempty_sections_of_fintype_inverse_system`. In this version,
the `F` functor is between categories of the same universe, and it is an easy
corollary to `Top.nonempty_limit_cone_of_compact_t2_inverse_system`. -/
theorem nonempty_sections_of_fintype_cofiltered_system.init
{J : Type u}
[small_category J]
[is_cofiltered J]
(F : ¬´expr ‚•§ ¬ª(J, Type u))
[hf : ‚àÄ j : J, fintype (F.obj j)]
[hne : ‚àÄ j : J, nonempty (F.obj j)] : F.sections.nonempty :=
begin
  let [ident F'] [":", expr ¬´expr ‚•§ ¬ª(J, Top)] [":=", expr ¬´expr ‚ãô ¬ª(F, Top.discrete)],
  haveI [] [":", expr ‚àÄ j : J, fintype (F'.obj j)] [":=", expr hf],
  haveI [] [":", expr ‚àÄ j : J, nonempty (F'.obj j)] [":=", expr hne],
  obtain ["‚ü®", "‚ü®", ident u, ",", ident hu, "‚ü©", "‚ü©", ":=", expr Top.nonempty_limit_cone_of_compact_t2_cofiltered_system F'],
  exact [expr ‚ü®u, Œª _ _ f, hu f‚ü©]
end

-- error in Topology.Category.Top.Limits: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The cofiltered limit of nonempty finite types is nonempty.

See `nonempty_sections_of_fintype_inverse_system` for a specialization to inverse limits. -/
theorem nonempty_sections_of_fintype_cofiltered_system
{J : Type u}
[category.{w} J]
[is_cofiltered J]
(F : ¬´expr ‚•§ ¬ª(J, Type v))
[‚àÄ j : J, fintype (F.obj j)]
[‚àÄ j : J, nonempty (F.obj j)] : F.sections.nonempty :=
begin
  let [ident J'] [":", expr Type max w v u] [":=", expr as_small.{max w v} J],
  let [ident down] [":", expr ¬´expr ‚•§ ¬ª(J', J)] [":=", expr as_small.down],
  let [ident F'] [":", expr ¬´expr ‚•§ ¬ª(J', Type max u v w)] [":=", expr ¬´expr ‚ãô ¬ª(down, ¬´expr ‚ãô ¬ª(F, ulift_functor.{max u w, v}))],
  haveI [] [":", expr ‚àÄ i, nonempty (F'.obj i)] [":=", expr Œª i, ‚ü®‚ü®classical.arbitrary (F.obj (down.obj i))‚ü©‚ü©],
  haveI [] [":", expr ‚àÄ i, fintype (F'.obj i)] [":=", expr Œª i, fintype.of_equiv (F.obj (down.obj i)) equiv.ulift.symm],
  obtain ["‚ü®", ident u, ",", ident hu, "‚ü©", ":=", expr nonempty_sections_of_fintype_cofiltered_system.init F'],
  use [expr Œª j, (u ‚ü®j‚ü©).down],
  intros [ident j, ident j', ident f],
  have [ident h] [] [":=", expr @hu (‚ü®j‚ü© : J') (‚ü®j'‚ü© : J') (ulift.up f)],
  simp [] [] ["only"] ["[", expr as_small.down, ",", expr functor.comp_map, ",", expr ulift_functor_map, ",", expr functor.op_map, "]"] [] ["at", ident h],
  simp_rw ["[", "<-", expr h, "]"] [],
  refl
end

/-- The inverse limit of nonempty finite types is nonempty.

See `nonempty_sections_of_fintype_cofiltered_system` for a generalization to cofiltered limits.
That version applies in almost all cases, and the only difference is that this version
allows `J` to be empty.

This may be regarded as a generalization of K≈ënig's lemma.
To specialize: given a locally finite connected graph, take `J·µí·µñ` to be `‚Ñï` and
`F j` to be length-`j` paths that start from an arbitrary fixed vertex.
Elements of `F.sections` can be read off as infinite rays in the graph. -/
theorem nonempty_sections_of_fintype_inverse_system {J : Type u} [DirectedOrder J] (F : ¬´expr ·µí·µñ¬ª J ‚•§ Type v)
  [‚àÄ (j : ¬´expr ·µí·µñ¬ª J), Fintype (F.obj j)] [‚àÄ (j : ¬´expr ·µí·µñ¬ª J), Nonempty (F.obj j)] : F.sections.nonempty :=
  by 
    runTac 
      tactic.unfreeze_local_instances 
    byCases' h : Nonempty J
    ¬∑
      apply nonempty_sections_of_fintype_cofiltered_system
    ¬∑
      rw [not_nonempty_iff_imp_false] at h 
      exact ‚ü®fun j => False.elim (h j.unop), fun j => False.elim (h j.unop)‚ü©

end FintypeKonig

