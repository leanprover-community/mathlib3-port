/-
Copyright (c) 2017 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Scott Morrison, Mario Carneiro, Andrew Yang

! This file was ported from Lean 3 source module topology.category.Top.limits.products
! leanprover-community/mathlib commit 781cb2eed038c4caf53bdbd8d20a95e5822d77df
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Category.Top.EpiMono
import Mathbin.Topology.Category.Top.Limits.Basic

/-!
# Products and coproducts in the category of topological spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

-/


open TopologicalSpace

open CategoryTheory

open CategoryTheory.Limits

universe u v w

noncomputable section

namespace TopCat

variable {J : Type v} [SmallCategory J]

/- warning: Top.pi_π -> TopCat.piπ is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}) (i : ι), Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (α i)
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}) (i : ι), Quiver.Hom.{max (succ u2) (succ u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) (TopCat.of.{max u2 u1} (forall (i : ι), CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (Pi.topologicalSpace.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (α i)
Case conversion may be inaccurate. Consider using '#align Top.pi_π TopCat.piπₓ'. -/
/-- The projection from the product as a bundled continous map. -/
abbrev piπ {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) : TopCat.of (∀ i, α i) ⟶ α i :=
  ⟨fun f => f i, continuous_apply i⟩
#align Top.pi_π TopCat.piπ

/- warning: Top.pi_fan -> TopCat.piFan is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}), CategoryTheory.Limits.Fan.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}), CategoryTheory.Limits.Fan.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α
Case conversion may be inaccurate. Consider using '#align Top.pi_fan TopCat.piFanₓ'. -/
/-- The explicit fan of a family of topological spaces given by the pi type. -/
@[simps pt π_app]
def piFan {ι : Type v} (α : ι → TopCat.{max v u}) : Fan α :=
  Fan.mk (TopCat.of (∀ i, α i)) (piπ α)
#align Top.pi_fan TopCat.piFan

/- warning: Top.pi_fan_is_limit -> TopCat.piFanIsLimit is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}), CategoryTheory.Limits.IsLimit.{u2, max u2 u1, u2, succ (max u2 u1)} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.functor.{max u2 u1, u2, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} ι α) (TopCat.piFan.{u1, u2} ι α)
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}), CategoryTheory.Limits.IsLimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α) (TopCat.piFan.{u1, u2} ι α)
Case conversion may be inaccurate. Consider using '#align Top.pi_fan_is_limit TopCat.piFanIsLimitₓ'. -/
/-- The constructed fan is indeed a limit -/
def piFanIsLimit {ι : Type v} (α : ι → TopCat.{max v u}) : IsLimit (piFan α)
    where
  lift S := { toFun := fun s i => S.π.app ⟨i⟩ s }
  uniq := by
    intro S m h
    ext (x i)
    simp [← h ⟨i⟩]
  fac s j := by
    cases j
    tidy
#align Top.pi_fan_is_limit TopCat.piFanIsLimit

/- warning: Top.pi_iso_pi -> TopCat.piIsoPi is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}), CategoryTheory.Iso.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}), CategoryTheory.Iso.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Limits.piObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (forall (i : ι), CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (Pi.topologicalSpace.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a))))
Case conversion may be inaccurate. Consider using '#align Top.pi_iso_pi TopCat.piIsoPiₓ'. -/
/-- The product is homeomorphic to the product of the underlying spaces,
equipped with the product topology.
-/
def piIsoPi {ι : Type v} (α : ι → TopCat.{max v u}) : ∏ α ≅ TopCat.of (∀ i, α i) :=
  (limit.isLimit _).conePointUniqueUpToIso (piFanIsLimit α)
#align Top.pi_iso_pi TopCat.piIsoPi

/- warning: Top.pi_iso_pi_inv_π -> TopCat.piIsoPi_inv_π is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}) (i : ι), Eq.{succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (α i)) (CategoryTheory.CategoryStruct.comp.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α)) (α i) (CategoryTheory.Iso.inv.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (TopCat.piIsoPi.{u1, u2} ι α)) (CategoryTheory.Limits.Pi.π.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α) i)) (TopCat.piπ.{u1, u2} ι α i)
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}) (i : ι), Eq.{max (succ u2) (succ u1)} (Quiver.Hom.{succ (max u2 u1), max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (TopCat.of.{max u2 u1} (forall (i : ι), CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (Pi.topologicalSpace.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (α i)) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (TopCat.of.{max u2 u1} (forall (i : ι), CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (Pi.topologicalSpace.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (CategoryTheory.Limits.piObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (α i) (CategoryTheory.Iso.inv.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Limits.piObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (forall (i : ι), CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (Pi.topologicalSpace.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (TopCat.piIsoPi.{u1, u2} ι α)) (CategoryTheory.Limits.Pi.π.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α)) i)) (TopCat.piπ.{u1, u2} ι α i)
Case conversion may be inaccurate. Consider using '#align Top.pi_iso_pi_inv_π TopCat.piIsoPi_inv_πₓ'. -/
@[simp, reassoc]
theorem piIsoPi_inv_π {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) :
    (piIsoPi α).inv ≫ Pi.π α i = piπ α i := by simp [pi_iso_pi]
#align Top.pi_iso_pi_inv_π TopCat.piIsoPi_inv_π

/- warning: Top.pi_iso_pi_inv_π_apply -> TopCat.piIsoPi_inv_π_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}) (i : ι) (x : forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)), Eq.{succ (max u2 u1)} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α)) (α i)) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (CategoryTheory.Limits.Pi.π.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α) i) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α)))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α)))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α)))) (CategoryTheory.Iso.inv.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (TopCat.piIsoPi.{u1, u2} ι α)) x)) (x i)
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}) (i : ι) (x : forall (i : ι), CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (α i)) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.piObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (α i) (CategoryTheory.Limits.Pi.π.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α)) i) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (TopCat.of.{max u2 u1} (forall (i : ι), CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (Pi.topologicalSpace.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (CategoryTheory.Limits.piObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (CategoryTheory.Iso.inv.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Limits.piObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (forall (i : ι), CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (Pi.topologicalSpace.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (TopCat.piIsoPi.{u1, u2} ι α)) x)) (x i)
Case conversion may be inaccurate. Consider using '#align Top.pi_iso_pi_inv_π_apply TopCat.piIsoPi_inv_π_applyₓ'. -/
@[simp]
theorem piIsoPi_inv_π_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : ∀ i, α i) :
    (Pi.π α i : _) ((piIsoPi α).inv x) = x i :=
  ConcreteCategory.congr_hom (piIsoPi_inv_π α i) x
#align Top.pi_iso_pi_inv_π_apply TopCat.piIsoPi_inv_π_apply

/- warning: Top.pi_iso_pi_hom_apply -> TopCat.piIsoPi_hom_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}) (i : ι) (x : coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u2, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} ι α)))), Eq.{succ (max u2 u1)} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))))) (CategoryTheory.Iso.hom.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.piIsoPi._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (forall (i : ι), coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (Pi.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (TopCat.piIsoPi.{u1, u2} ι α)) x i) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u2, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} ι α))) (α i)) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u2, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} ι α)))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u2, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} ι α)))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u2, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} ι α)))) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u2, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} ι α)))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.piObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u2, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} ι α)))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (CategoryTheory.Limits.Pi.π.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u2, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} ι α)) i) x)
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}) (i : ι) (x : CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.piObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α)))), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.piObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (forall (i : ι), CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (Pi.topologicalSpace.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (CategoryTheory.Iso.hom.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Limits.piObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (forall (i : ι), CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (Pi.topologicalSpace.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (TopCat.piIsoPi.{u1, u2} ι α)) x i) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.piObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (α i) (CategoryTheory.Limits.Pi.π.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasLimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α)) i) x)
Case conversion may be inaccurate. Consider using '#align Top.pi_iso_pi_hom_apply TopCat.piIsoPi_hom_applyₓ'. -/
@[simp]
theorem piIsoPi_hom_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : ∏ α) :
    (piIsoPi α).Hom x i = (Pi.π α i : _) x :=
  by
  have := pi_iso_pi_inv_π α i
  rw [iso.inv_comp_eq] at this
  exact concrete_category.congr_hom this x
#align Top.pi_iso_pi_hom_apply TopCat.piIsoPi_hom_apply

/- warning: Top.sigma_ι -> TopCat.sigmaι is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}) (i : ι), Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (α i) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}) (i : ι), Quiver.Hom.{max (succ u2) (succ u1), max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (α i) (TopCat.of.{max u2 u1} (Sigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (instTopologicalSpaceSigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a))))
Case conversion may be inaccurate. Consider using '#align Top.sigma_ι TopCat.sigmaιₓ'. -/
/-- The inclusion to the coproduct as a bundled continous map. -/
abbrev sigmaι {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) : α i ⟶ TopCat.of (Σi, α i) :=
  ⟨Sigma.mk i⟩
#align Top.sigma_ι TopCat.sigmaι

/- warning: Top.sigma_cofan -> TopCat.sigmaCofan is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}), CategoryTheory.Limits.Cofan.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}), CategoryTheory.Limits.Cofan.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α
Case conversion may be inaccurate. Consider using '#align Top.sigma_cofan TopCat.sigmaCofanₓ'. -/
/-- The explicit cofan of a family of topological spaces given by the sigma type. -/
@[simps pt ι_app]
def sigmaCofan {ι : Type v} (α : ι → TopCat.{max v u}) : Cofan α :=
  Cofan.mk (TopCat.of (Σi, α i)) (sigmaι α)
#align Top.sigma_cofan TopCat.sigmaCofan

/- warning: Top.sigma_cofan_is_colimit -> TopCat.sigmaCofanIsColimit is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}), CategoryTheory.Limits.IsColimit.{u2, max u2 u1, u2, succ (max u2 u1)} (CategoryTheory.Discrete.{u2} ι) (CategoryTheory.discreteCategory.{u2} ι) TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Discrete.functor.{max u2 u1, u2, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} ι α) (TopCat.sigmaCofan.{u1, u2} ι α)
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}), CategoryTheory.Limits.IsColimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α) (TopCat.sigmaCofan.{u1, u2} ι α)
Case conversion may be inaccurate. Consider using '#align Top.sigma_cofan_is_colimit TopCat.sigmaCofanIsColimitₓ'. -/
/-- The constructed cofan is indeed a colimit -/
def sigmaCofanIsColimit {ι : Type v} (α : ι → TopCat.{max v u}) : IsColimit (sigmaCofan α)
    where
  desc S :=
    { toFun := fun s => S.ι.app ⟨s.1⟩ s.2
      continuous_toFun := continuous_sigma fun i => map_continuous (S.ι.app ⟨i⟩) }
  uniq := by
    intro S m h
    ext ⟨i, x⟩
    simp [← h ⟨i⟩]
  fac s j := by
    cases j
    tidy
#align Top.sigma_cofan_is_colimit TopCat.sigmaCofanIsColimit

/- warning: Top.sigma_iso_sigma -> TopCat.sigmaIsoSigma is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}), CategoryTheory.Iso.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}), CategoryTheory.Iso.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (Sigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (instTopologicalSpaceSigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a))))
Case conversion may be inaccurate. Consider using '#align Top.sigma_iso_sigma TopCat.sigmaIsoSigmaₓ'. -/
/-- The coproduct is homeomorphic to the disjoint union of the topological spaces.
-/
def sigmaIsoSigma {ι : Type v} (α : ι → TopCat.{max v u}) : ∐ α ≅ TopCat.of (Σi, α i) :=
  (colimit.isColimit _).coconePointUniqueUpToIso (sigmaCofanIsColimit α)
#align Top.sigma_iso_sigma TopCat.sigmaIsoSigma

/- warning: Top.sigma_iso_sigma_hom_ι -> TopCat.sigmaIsoSigma_hom_ι is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}) (i : ι), Eq.{succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (α i) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (CategoryTheory.CategoryStruct.comp.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (α i) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (CategoryTheory.Limits.Sigma.ι.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α) i) (CategoryTheory.Iso.hom.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (TopCat.sigmaIsoSigma.{u1, u2} ι α))) (TopCat.sigmaι.{u1, u2} ι α i)
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}) (i : ι), Eq.{max (succ u2) (succ u1)} (Quiver.Hom.{succ (max u2 u1), max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (α i) (TopCat.of.{max u2 u1} (Sigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (instTopologicalSpaceSigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a))))) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (α i) (CategoryTheory.Limits.sigmaObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (Sigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (instTopologicalSpaceSigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (CategoryTheory.Limits.Sigma.ι.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α)) i) (CategoryTheory.Iso.hom.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (Sigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (instTopologicalSpaceSigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (TopCat.sigmaIsoSigma.{u1, u2} ι α))) (TopCat.sigmaι.{u1, u2} ι α i)
Case conversion may be inaccurate. Consider using '#align Top.sigma_iso_sigma_hom_ι TopCat.sigmaIsoSigma_hom_ιₓ'. -/
@[simp, reassoc]
theorem sigmaIsoSigma_hom_ι {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) :
    Sigma.ι α i ≫ (sigmaIsoSigma α).Hom = sigmaι α i := by simp [sigma_iso_sigma]
#align Top.sigma_iso_sigma_hom_ι TopCat.sigmaIsoSigma_hom_ι

/- warning: Top.sigma_iso_sigma_hom_ι_apply -> TopCat.sigmaIsoSigma_hom_ι_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}) (i : ι) (x : coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)), Eq.{succ (max u2 u1)} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))))) (CategoryTheory.Iso.hom.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (TopCat.sigmaIsoSigma.{u1, u2} ι α)) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (α i) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)))) (CategoryTheory.Limits.Sigma.ι.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α) i) x)) (Sigma.mk.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) i x)
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}) (i : ι) (x : CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (TopCat.of.{max u2 u1} (Sigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (instTopologicalSpaceSigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a))))) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.sigmaObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (Sigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (instTopologicalSpaceSigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (CategoryTheory.Iso.hom.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (Sigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (instTopologicalSpaceSigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (TopCat.sigmaIsoSigma.{u1, u2} ι α)) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (α i) (CategoryTheory.Limits.sigmaObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (CategoryTheory.Limits.Sigma.ι.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α)) i) x)) (Sigma.mk.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) i x)
Case conversion may be inaccurate. Consider using '#align Top.sigma_iso_sigma_hom_ι_apply TopCat.sigmaIsoSigma_hom_ι_applyₓ'. -/
@[simp]
theorem sigmaIsoSigma_hom_ι_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : α i) :
    (sigmaIsoSigma α).Hom ((Sigma.ι α i : _) x) = Sigma.mk i x :=
  ConcreteCategory.congr_hom (sigmaIsoSigma_hom_ι α i) x
#align Top.sigma_iso_sigma_hom_ι_apply TopCat.sigmaIsoSigma_hom_ι_apply

/- warning: Top.sigma_iso_sigma_inv_apply -> TopCat.sigmaIsoSigma_inv_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} (α : ι -> TopCat.{max u2 u1}) (i : ι) (x : coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)), Eq.{succ (max u2 u1)} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a))))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)))) (CategoryTheory.Iso.inv.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)) (TopCat.of.{max u2 u1} (Sigma.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i))) (Sigma.topologicalSpace.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace.{max u2 u1} (α a)))) (TopCat.sigmaIsoSigma.{u1, u2} ι α)) (Sigma.mk.{u2, max u2 u1} ι (fun (i : ι) => coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (α i)) i x)) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (α i) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (α i)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α)))) (CategoryTheory.Limits.Sigma.ι.{u2, max u2 u1, succ (max u2 u1)} ι TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} α (TopCat.sigmaIsoSigma._proof_1.{u1, u2} ι α) i) x)
but is expected to have type
  forall {ι : Type.{u1}} (α : ι -> TopCatMax.{u1, u2}) (i : ι) (x : CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)), Eq.{max (succ u2) (succ u1)} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.sigmaObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α)))) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (TopCat.of.{max u2 u1} (Sigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (instTopologicalSpaceSigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (CategoryTheory.Limits.sigmaObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (CategoryTheory.Iso.inv.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Limits.sigmaObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (TopCat.of.{max u2 u1} (Sigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i))) (instTopologicalSpaceSigma.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) (fun (a : ι) => TopCat.topologicalSpace_coe.{max u2 u1} (α a)))) (TopCat.sigmaIsoSigma.{u1, u2} ι α)) (Sigma.mk.{u1, max u2 u1} ι (fun (i : ι) => CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (α i)) i x)) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (α i) (CategoryTheory.Limits.sigmaObj.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α))) (CategoryTheory.Limits.Sigma.ι.{u1, max u2 u1, max (succ u2) (succ u1)} ι TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} α (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Discrete.{u1} ι) (CategoryTheory.discreteCategory.{u1} ι) TopCat.topCat_hasColimitsOfSize.{u1, u2}) (CategoryTheory.Discrete.functor.{max u2 u1, u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} ι α)) i) x)
Case conversion may be inaccurate. Consider using '#align Top.sigma_iso_sigma_inv_apply TopCat.sigmaIsoSigma_inv_applyₓ'. -/
@[simp]
theorem sigmaIsoSigma_inv_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : α i) :
    (sigmaIsoSigma α).inv ⟨i, x⟩ = (Sigma.ι α i : _) x :=
  by
  rw [← sigma_iso_sigma_hom_ι_apply, ← comp_app]
  simp
#align Top.sigma_iso_sigma_inv_apply TopCat.sigmaIsoSigma_inv_apply

/- warning: Top.induced_of_is_limit -> TopCat.induced_of_isLimit is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.SmallCategory.{u2} J] {F : CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}} (C : CategoryTheory.Limits.Cone.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F), (CategoryTheory.Limits.IsLimit.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C) -> (Eq.{succ (max u2 u1)} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C))) (TopCat.topologicalSpace.{max u2 u1} (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C)) (iInf.{max u2 u1, succ u2} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C))) (ConditionallyCompleteLattice.toHasInf.{max u2 u1} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u1} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C))) (TopologicalSpace.completeLattice.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C))))) J (fun (j : J) => TopologicalSpace.induced.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C)) j) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C)) j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C)) j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C)) j)) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C)) j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C)) j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j))) (CategoryTheory.NatTrans.app.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C)) F (CategoryTheory.Limits.Cone.π.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F C) j)) (TopCat.topologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)))))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}} (C : CategoryTheory.Limits.Cone.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F), (CategoryTheory.Limits.IsLimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C) -> (Eq.{max (succ u2) (succ u1)} (TopologicalSpace.{max u1 u2} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C)) (iInf.{max u2 u1, succ u1} (TopologicalSpace.{max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C))) (ConditionallyCompleteLattice.toInfSet.{max u2 u1} (TopologicalSpace.{max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u1} (TopologicalSpace.{max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C))) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C))))) J (fun (j : J) => TopologicalSpace.induced.{max u2 u1, max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C)) (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j)) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C))) j) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Limits.Cone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C)) F (CategoryTheory.Limits.Cone.π.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F C) j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j)))))
Case conversion may be inaccurate. Consider using '#align Top.induced_of_is_limit TopCat.induced_of_isLimitₓ'. -/
theorem induced_of_isLimit {F : J ⥤ TopCat.{max v u}} (C : Cone F) (hC : IsLimit C) :
    C.pt.TopologicalSpace = ⨅ j, (F.obj j).TopologicalSpace.induced (C.π.app j) :=
  by
  let homeo := homeo_of_iso (hC.cone_point_unique_up_to_iso (limit_cone_infi_is_limit F))
  refine' homeo.inducing.induced.trans _
  change induced homeo (⨅ j : J, _) = _
  simpa [induced_iInf, induced_compose]
#align Top.induced_of_is_limit TopCat.induced_of_isLimit

/- warning: Top.limit_topology -> TopCat.limit_topology is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.SmallCategory.{u2} J] (F : CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}), Eq.{succ (max u2 u1)} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)))) (TopCat.topologicalSpace.{max u2 u1} (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F))) (iInf.{max u2 u1, succ u2} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)))) (ConditionallyCompleteLattice.toHasInf.{max u2 u1} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u1} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)))) (TopologicalSpace.completeLattice.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)))))) J (fun (j : J) => TopologicalSpace.induced.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F))) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F))) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.limit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j))) (CategoryTheory.Limits.limit.π.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F) j)) (TopCat.topologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j))))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}), Eq.{max (succ u2) (succ u1)} (TopologicalSpace.{max u1 u2} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F))) (iInf.{max u2 u1, succ u1} (TopologicalSpace.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)))) (ConditionallyCompleteLattice.toInfSet.{max u2 u1} (TopologicalSpace.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u1} (TopologicalSpace.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)))) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)))))) J (fun (j : J) => TopologicalSpace.induced.{max u2 u1, max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F))) (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j)) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.limit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F)) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j) (CategoryTheory.Limits.limit.π.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasLimitsOfSize.{u1, u2}) F) j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j))))
Case conversion may be inaccurate. Consider using '#align Top.limit_topology TopCat.limit_topologyₓ'. -/
theorem limit_topology (F : J ⥤ TopCat.{max v u}) :
    (limit F).TopologicalSpace = ⨅ j, (F.obj j).TopologicalSpace.induced (limit.π F j) :=
  induced_of_isLimit _ (limit.isLimit F)
#align Top.limit_topology TopCat.limit_topology

section Prod

/- warning: Top.prod_fst -> TopCat.prodFst is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}}, Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))) X
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}}, Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))) X
Case conversion may be inaccurate. Consider using '#align Top.prod_fst TopCat.prodFstₓ'. -/
/-- The first projection from the product. -/
abbrev prodFst {X Y : TopCat.{u}} : TopCat.of (X × Y) ⟶ X :=
  ⟨Prod.fst⟩
#align Top.prod_fst TopCat.prodFst

/- warning: Top.prod_snd -> TopCat.prodSnd is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}}, Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))) Y
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}}, Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))) Y
Case conversion may be inaccurate. Consider using '#align Top.prod_snd TopCat.prodSndₓ'. -/
/-- The second projection from the product. -/
abbrev prodSnd {X Y : TopCat.{u}} : TopCat.of (X × Y) ⟶ Y :=
  ⟨Prod.snd⟩
#align Top.prod_snd TopCat.prodSnd

#print TopCat.prodBinaryFan /-
/-- The explicit binary cofan of `X, Y` given by `X × Y`. -/
def prodBinaryFan (X Y : TopCat.{u}) : BinaryFan X Y :=
  BinaryFan.mk prodFst prodSnd
#align Top.prod_binary_fan TopCat.prodBinaryFan
-/

#print TopCat.prodBinaryFanIsLimit /-
/-- The constructed binary fan is indeed a limit -/
def prodBinaryFanIsLimit (X Y : TopCat.{u}) : IsLimit (prodBinaryFan X Y)
    where
  lift := fun S : BinaryFan X Y => { toFun := fun s => (S.fst s, S.snd s) }
  fac := by
    rintro S (_ | _)
    tidy
  uniq := by
    intro S m h
    ext x
    · specialize h ⟨walking_pair.left⟩
      apply_fun fun e => e x  at h
      exact h
    · specialize h ⟨walking_pair.right⟩
      apply_fun fun e => e x  at h
      exact h
#align Top.prod_binary_fan_is_limit TopCat.prodBinaryFanIsLimit
-/

/- warning: Top.prod_iso_prod -> TopCat.prodIsoProd is a dubious translation:
lean 3 declaration is
  forall (X : TopCat.{u1}) (Y : TopCat.{u1}), CategoryTheory.Iso.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y)) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))
but is expected to have type
  forall (X : TopCat.{u1}) (Y : TopCat.{u1}), CategoryTheory.Iso.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))
Case conversion may be inaccurate. Consider using '#align Top.prod_iso_prod TopCat.prodIsoProdₓ'. -/
/-- The homeomorphism between `X ⨯ Y` and the set-theoretic product of `X` and `Y`,
equipped with the product topology.
-/
def prodIsoProd (X Y : TopCat.{u}) : X ⨯ Y ≅ TopCat.of (X × Y) :=
  (limit.isLimit _).conePointUniqueUpToIso (prodBinaryFanIsLimit X Y)
#align Top.prod_iso_prod TopCat.prodIsoProd

#print TopCat.prodIsoProd_hom_fst /-
@[simp, reassoc]
theorem prodIsoProd_hom_fst (X Y : TopCat.{u}) :
    (prodIsoProd X Y).Hom ≫ prodFst = Limits.prod.fst := by simpa [← iso.eq_inv_comp, prod_iso_prod]
#align Top.prod_iso_prod_hom_fst TopCat.prodIsoProd_hom_fst
-/

#print TopCat.prodIsoProd_hom_snd /-
@[simp, reassoc]
theorem prodIsoProd_hom_snd (X Y : TopCat.{u}) :
    (prodIsoProd X Y).Hom ≫ prodSnd = Limits.prod.snd := by simpa [← iso.eq_inv_comp, prod_iso_prod]
#align Top.prod_iso_prod_hom_snd TopCat.prodIsoProd_hom_snd
-/

/- warning: Top.prod_iso_prod_hom_apply -> TopCat.prodIsoProd_hom_apply is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} (x : coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))), Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y)) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (CategoryTheory.Iso.hom.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y)) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))) (TopCat.prodIsoProd.{u1} X Y)) x) (Prod.mk.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.prod.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.prod.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))) x))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} (x : CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))), Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))) (CategoryTheory.Iso.hom.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))) (TopCat.prodIsoProd.{u1} X Y)) x) (Prod.mk.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) X (CategoryTheory.Limits.prod.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) x) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) Y (CategoryTheory.Limits.prod.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) x))
Case conversion may be inaccurate. Consider using '#align Top.prod_iso_prod_hom_apply TopCat.prodIsoProd_hom_applyₓ'. -/
@[simp]
theorem prodIsoProd_hom_apply {X Y : TopCat.{u}} (x : X ⨯ Y) :
    (prodIsoProd X Y).Hom x = ((Limits.prod.fst : X ⨯ Y ⟶ _) x, (Limits.prod.snd : X ⨯ Y ⟶ _) x) :=
  by
  ext
  · exact concrete_category.congr_hom (prod_iso_prod_hom_fst X Y) x
  · exact concrete_category.congr_hom (prod_iso_prod_hom_snd X Y) x
#align Top.prod_iso_prod_hom_apply TopCat.prodIsoProd_hom_apply

/- warning: Top.prod_iso_prod_inv_fst -> TopCat.prodIsoProd_inv_fst is a dubious translation:
lean 3 declaration is
  forall (X : TopCat.{u1}) (Y : TopCat.{u1}), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))) X) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y)) X (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y)) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))) (TopCat.prodIsoProd.{u1} X Y)) (CategoryTheory.Limits.prod.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y))) (TopCat.prodFst.{u1} X Y)
but is expected to have type
  forall (X : TopCat.{u1}) (Y : TopCat.{u1}), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))) X) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) X (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))) (TopCat.prodIsoProd.{u1} X Y)) (CategoryTheory.Limits.prod.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (TopCat.prodFst.{u1} X Y)
Case conversion may be inaccurate. Consider using '#align Top.prod_iso_prod_inv_fst TopCat.prodIsoProd_inv_fstₓ'. -/
@[simp, reassoc, elementwise]
theorem prodIsoProd_inv_fst (X Y : TopCat.{u}) :
    (prodIsoProd X Y).inv ≫ Limits.prod.fst = prodFst := by simp [iso.inv_comp_eq]
#align Top.prod_iso_prod_inv_fst TopCat.prodIsoProd_inv_fst

/- warning: Top.prod_iso_prod_inv_snd -> TopCat.prodIsoProd_inv_snd is a dubious translation:
lean 3 declaration is
  forall (X : TopCat.{u1}) (Y : TopCat.{u1}), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))) Y) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y)) Y (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y)) (TopCat.of.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))) (TopCat.prodIsoProd.{u1} X Y)) (CategoryTheory.Limits.prod.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (TopCat.prodIsoProd._proof_1.{u1} X Y))) (TopCat.prodSnd.{u1} X Y)
but is expected to have type
  forall (X : TopCat.{u1}) (Y : TopCat.{u1}), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))) Y) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) Y (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) (TopCat.of.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))) (TopCat.prodIsoProd.{u1} X Y)) (CategoryTheory.Limits.prod.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (TopCat.prodSnd.{u1} X Y)
Case conversion may be inaccurate. Consider using '#align Top.prod_iso_prod_inv_snd TopCat.prodIsoProd_inv_sndₓ'. -/
@[simp, reassoc, elementwise]
theorem prodIsoProd_inv_snd (X Y : TopCat.{u}) :
    (prodIsoProd X Y).inv ≫ Limits.prod.snd = prodSnd := by simp [iso.inv_comp_eq]
#align Top.prod_iso_prod_inv_snd TopCat.prodIsoProd_inv_snd

/- warning: Top.prod_topology -> TopCat.prod_topology is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}}, Eq.{succ u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (Inf.inf.{u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) (SemilatticeInf.toHasInf.{u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) (Lattice.toSemilatticeInf.{u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) (TopologicalSpace.completeLattice.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))))))) (TopologicalSpace.induced.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.prod.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (TopCat.topologicalSpace.{u1} X)) (TopologicalSpace.induced.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.prod.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (TopCat.topologicalSpace.{u1} Y)))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}}, Eq.{succ u1} (TopologicalSpace.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (Inf.inf.{u1} (TopologicalSpace.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))))) (Lattice.toInf.{u1} (TopologicalSpace.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))))) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))))) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))))))) (TopologicalSpace.induced.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) X (CategoryTheory.Limits.prod.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (TopologicalSpace.induced.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) Y (CategoryTheory.Limits.prod.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)))
Case conversion may be inaccurate. Consider using '#align Top.prod_topology TopCat.prod_topologyₓ'. -/
theorem prod_topology {X Y : TopCat} :
    (X ⨯ Y).TopologicalSpace =
      induced (Limits.prod.fst : X ⨯ Y ⟶ _) X.TopologicalSpace ⊓
        induced (Limits.prod.snd : X ⨯ Y ⟶ _) Y.TopologicalSpace :=
  by
  let homeo := homeo_of_iso (prod_iso_prod X Y)
  refine' homeo.inducing.induced.trans _
  change induced homeo (_ ⊓ _) = _
  simpa [induced_compose]
#align Top.prod_topology TopCat.prod_topology

/- warning: Top.range_prod_map -> TopCat.range_prod_map is a dubious translation:
lean 3 declaration is
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W Y) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z), Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z))))) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z))))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z))))) (CategoryTheory.Limits.prod.map.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X)) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)) f g))) (Inter.inter.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z))))) (Set.hasInter.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z))))) (Set.preimage.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.prod.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) f))) (Set.preimage.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z))) Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) (CategoryTheory.Limits.prod.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z)))) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g))))
but is expected to have type
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W Y) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z), Eq.{succ u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z))))) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z))) (CategoryTheory.Limits.prod.map.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X)) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z)) f g))) (Inter.inter.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z))))) (Set.instInterSet.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z))))) (Set.preimage.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z))) Y (CategoryTheory.Limits.prod.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z)))) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W Y f))) (Set.preimage.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z))) Z (CategoryTheory.Limits.prod.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z)))) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z g))))
Case conversion may be inaccurate. Consider using '#align Top.range_prod_map TopCat.range_prod_mapₓ'. -/
theorem range_prod_map {W X Y Z : TopCat.{u}} (f : W ⟶ Y) (g : X ⟶ Z) :
    Set.range (Limits.prod.map f g) =
      (Limits.prod.fst : Y ⨯ Z ⟶ _) ⁻¹' Set.range f ∩
        (Limits.prod.snd : Y ⨯ Z ⟶ _) ⁻¹' Set.range g :=
  by
  ext
  constructor
  · rintro ⟨y, rfl⟩
    simp only [Set.mem_preimage, Set.mem_range, Set.mem_inter_iff, ← comp_apply]
    simp only [limits.prod.map_fst, limits.prod.map_snd, exists_apply_eq_apply, comp_apply,
      and_self_iff]
  · rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩⟩
    use (prod_iso_prod W X).inv (x₁, x₂)
    apply concrete.limit_ext
    rintro ⟨⟨⟩⟩
    · simp only [← comp_apply, category.assoc]
      erw [limits.prod.map_fst]
      simp [hx₁]
    · simp only [← comp_apply, category.assoc]
      erw [limits.prod.map_snd]
      simp [hx₂]
#align Top.range_prod_map TopCat.range_prod_map

/- warning: Top.inducing_prod_map -> TopCat.inducing_prod_map is a dubious translation:
lean 3 declaration is
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W X} {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z}, (Inducing.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (TopCat.topologicalSpace.{u1} W) (TopCat.topologicalSpace.{u1} X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) f)) -> (Inducing.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (TopCat.topologicalSpace.{u1} Y) (TopCat.topologicalSpace.{u1} Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g)) -> (Inducing.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z))))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z))))) (CategoryTheory.Limits.prod.map.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)) f g)))
but is expected to have type
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W X} {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z}, (Inducing.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (TopCat.topologicalSpace_forget.{u1} W) (TopCat.topologicalSpace_forget.{u1} X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W X f)) -> (Inducing.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (TopCat.topologicalSpace_forget.{u1} Y) (TopCat.topologicalSpace_forget.{u1} Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g)) -> (Inducing.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z))) (CategoryTheory.Limits.prod.map.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y)) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z)) f g)))
Case conversion may be inaccurate. Consider using '#align Top.inducing_prod_map TopCat.inducing_prod_mapₓ'. -/
theorem inducing_prod_map {W X Y Z : TopCat} {f : W ⟶ X} {g : Y ⟶ Z} (hf : Inducing f)
    (hg : Inducing g) : Inducing (Limits.prod.map f g) :=
  by
  constructor
  simp only [prod_topology, induced_compose, ← coe_comp, limits.prod.map_fst, limits.prod.map_snd,
    induced_inf]
  simp only [coe_comp]
  rw [← @induced_compose _ _ _ _ _ f, ← @induced_compose _ _ _ _ _ g, ← hf.induced, ← hg.induced]
#align Top.inducing_prod_map TopCat.inducing_prod_map

/- warning: Top.embedding_prod_map -> TopCat.embedding_prod_map is a dubious translation:
lean 3 declaration is
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W X} {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z}, (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (TopCat.topologicalSpace.{u1} W) (TopCat.topologicalSpace.{u1} X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) f)) -> (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (TopCat.topologicalSpace.{u1} Y) (TopCat.topologicalSpace.{u1} Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g)) -> (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z))))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z))))) (CategoryTheory.Limits.prod.map.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W Y)) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Z)) f g)))
but is expected to have type
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W X} {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z}, (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (TopCat.topologicalSpace_forget.{u1} W) (TopCat.topologicalSpace_forget.{u1} X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W X f)) -> (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (TopCat.topologicalSpace_forget.{u1} Y) (TopCat.topologicalSpace_forget.{u1} Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g)) -> (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z))) (CategoryTheory.Limits.prod.map.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y X Z (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W Y)) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Z)) f g)))
Case conversion may be inaccurate. Consider using '#align Top.embedding_prod_map TopCat.embedding_prod_mapₓ'. -/
theorem embedding_prod_map {W X Y Z : TopCat} {f : W ⟶ X} {g : Y ⟶ Z} (hf : Embedding f)
    (hg : Embedding g) : Embedding (Limits.prod.map f g) :=
  ⟨inducing_prod_map hf.to_inducing hg.to_inducing,
    by
    haveI := (TopCat.mono_iff_injective _).mpr hf.inj
    haveI := (TopCat.mono_iff_injective _).mpr hg.inj
    exact (TopCat.mono_iff_injective _).mp inferInstance⟩
#align Top.embedding_prod_map TopCat.embedding_prod_map

end Prod

#print TopCat.binaryCofan /-
/-- The binary coproduct cofan in `Top`. -/
protected def binaryCofan (X Y : TopCat.{u}) : BinaryCofan X Y :=
  BinaryCofan.mk (⟨Sum.inl⟩ : X ⟶ TopCat.of (Sum X Y)) ⟨Sum.inr⟩
#align Top.binary_cofan TopCat.binaryCofan
-/

#print TopCat.binaryCofanIsColimit /-
/-- The constructed binary coproduct cofan in `Top` is the coproduct. -/
def binaryCofanIsColimit (X Y : TopCat.{u}) : IsColimit (TopCat.binaryCofan X Y) :=
  by
  refine' limits.binary_cofan.is_colimit_mk (fun s => ⟨Sum.elim s.inl s.inr⟩) _ _ _
  · intro s
    ext
    rfl
  · intro s
    ext
    rfl
  · intro s m h₁ h₂
    ext (x | x)
    exacts[(concrete_category.congr_hom h₁ x : _), (concrete_category.congr_hom h₂ x : _)]
#align Top.binary_cofan_is_colimit TopCat.binaryCofanIsColimit
-/

/- warning: Top.binary_cofan_is_colimit_iff -> TopCat.binaryCofan_isColimit_iff is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} (c : CategoryTheory.Limits.BinaryCofan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y), Iff (Nonempty.{succ (succ u1)} (CategoryTheory.Limits.IsColimit.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (And (OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CategoryTheory.Limits.BinaryCofan.inl.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y c))) (And (OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)))) (CategoryTheory.Limits.BinaryCofan.inr.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y c))) (IsCompl.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (Set.completeBooleanAlgebra.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (Set.completeBooleanAlgebra.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))))))) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CategoryTheory.Limits.BinaryCofan.inl.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y c))) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y) c)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)))) (CategoryTheory.Limits.BinaryCofan.inr.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y c))))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} (c : CategoryTheory.Limits.BinaryCofan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y), Iff (Nonempty.{succ (succ u1)} (CategoryTheory.Limits.IsColimit.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c)) (And (OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (TopCat.topologicalSpace_forget.{u1} (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (TopCat.topologicalSpace_forget.{u1} (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)) (CategoryTheory.Limits.BinaryCofan.inl.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y c))) (And (OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (TopCat.topologicalSpace_forget.{u1} (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (TopCat.topologicalSpace_forget.{u1} (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)) (CategoryTheory.Limits.BinaryCofan.inr.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y c))) (IsCompl.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (Set.instCompleteBooleanAlgebraSet.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))) (Set.instCompleteBooleanAlgebraSet.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)))))))) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left)) (CategoryTheory.Limits.BinaryCofan.inl.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y c))) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.left))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)) (Prefunctor.obj.{1, succ u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.CategoryStruct.toQuiver.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Category.toCategoryStruct.{0, 0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Functor.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.category.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Functor.const.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, succ u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y) c))) (CategoryTheory.Discrete.mk.{0} CategoryTheory.Limits.WalkingPair CategoryTheory.Limits.WalkingPair.right)) (CategoryTheory.Limits.BinaryCofan.inr.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y c))))))
Case conversion may be inaccurate. Consider using '#align Top.binary_cofan_is_colimit_iff TopCat.binaryCofan_isColimit_iffₓ'. -/
theorem binaryCofan_isColimit_iff {X Y : TopCat} (c : BinaryCofan X Y) :
    Nonempty (IsColimit c) ↔
      OpenEmbedding c.inl ∧ OpenEmbedding c.inr ∧ IsCompl (Set.range c.inl) (Set.range c.inr) :=
  by
  classical
    constructor
    · rintro ⟨h⟩
      rw [←
        show _ = c.inl from
          h.comp_cocone_point_unique_up_to_iso_inv (binary_cofan_is_colimit X Y)
            ⟨walking_pair.left⟩,
        ←
        show _ = c.inr from
          h.comp_cocone_point_unique_up_to_iso_inv (binary_cofan_is_colimit X Y)
            ⟨walking_pair.right⟩]
      dsimp
      refine'
        ⟨(homeo_of_iso <|
                    h.cocone_point_unique_up_to_iso
                      (binary_cofan_is_colimit X Y)).symm.OpenEmbedding.comp
            openEmbedding_inl,
          (homeo_of_iso <|
                    h.cocone_point_unique_up_to_iso
                      (binary_cofan_is_colimit X Y)).symm.OpenEmbedding.comp
            openEmbedding_inr,
          _⟩
      erw [Set.range_comp, ← eq_compl_iff_isCompl, Set.range_comp _ Sum.inr, ←
        Set.image_compl_eq
          (homeo_of_iso <|
                h.cocone_point_unique_up_to_iso (binary_cofan_is_colimit X Y)).symm.Bijective]
      congr 1
      exact set.compl_range_inr.symm
    · rintro ⟨h₁, h₂, h₃⟩
      have : ∀ x, x ∈ Set.range c.inl ∨ x ∈ Set.range c.inr :=
        by
        rw [eq_compl_iff_is_compl.mpr h₃.symm]
        exact fun _ => or_not
      refine' ⟨binary_cofan.is_colimit.mk _ _ _ _ _⟩
      · intro T f g
        refine' ContinuousMap.mk _ _
        ·
          exact fun x =>
            if h : x ∈ Set.range c.inl then f ((Equiv.ofInjective _ h₁.inj).symm ⟨x, h⟩)
            else g ((Equiv.ofInjective _ h₂.inj).symm ⟨x, (this x).resolve_left h⟩)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases x ∈ Set.range c.inl
        · revert h x
          apply (IsOpen.continuousOn_iff _).mp
          · rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f ∘ (Homeomorph.ofEmbedding _ h₁.to_embedding).symm)
            · ext ⟨x, hx⟩
              exact dif_pos hx
            continuity
          · exact h₁.open_range
        · revert h x
          apply (IsOpen.continuousOn_iff _).mp
          · rw [continuousOn_iff_continuous_restrict]
            have : ∀ a, a ∉ Set.range c.inl → a ∈ Set.range c.inr :=
              by
              rintro a (h : a ∈ Set.range c.inlᶜ)
              rwa [eq_compl_iff_is_compl.mpr h₃.symm]
            convert_to Continuous
                (g ∘ (Homeomorph.ofEmbedding _ h₂.to_embedding).symm ∘ Subtype.map _ this)
            · ext ⟨x, hx⟩
              exact dif_neg hx
            continuity
            rw [embedding_subtype_coe.to_inducing.continuous_iff]
            exact continuous_subtype_val
          · change IsOpen (Set.range c.inlᶜ)
            rw [← eq_compl_iff_is_compl.mpr h₃.symm]
            exact h₂.open_range
      · intro T f g
        ext x
        refine' (dif_pos _).trans _
        · exact ⟨x, rfl⟩
        · rw [Equiv.ofInjective_symm_apply]
      · intro T f g
        ext x
        refine' (dif_neg _).trans _
        · rintro ⟨y, e⟩
          have : c.inr x ∈ Set.range c.inl ⊓ Set.range c.inr := ⟨⟨_, e⟩, ⟨_, rfl⟩⟩
          rwa [disjoint_iff.mp h₃.1] at this
        · exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      · rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ⟨_, _⟩).symm
#align Top.binary_cofan_is_colimit_iff TopCat.binaryCofan_isColimit_iff

--TODO: Add analogous constructions for `pushout`.
end TopCat

