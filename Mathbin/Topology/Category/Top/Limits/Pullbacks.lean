/-
Copyright (c) 2017 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Scott Morrison, Mario Carneiro, Andrew Yang

! This file was ported from Lean 3 source module topology.category.Top.limits.pullbacks
! leanprover-community/mathlib commit 6cf5900728239efa287df7761ec2a1ac9cf39b29
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Category.Top.Limits.Products
import Mathbin.CategoryTheory.ConcreteCategory.Elementwise

/-!
# Pullbacks in the category of topological spaces.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

-/


open TopologicalSpace

open CategoryTheory

open CategoryTheory.Limits

universe u v w

noncomputable section

namespace TopCat

variable {J : Type v} [SmallCategory J]

section Pullback

variable {X Y Z : TopCat.{u}}

/- warning: Top.pullback_fst -> TopCat.pullbackFst is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z), Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) X
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z), Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) X
Case conversion may be inaccurate. Consider using '#align Top.pullback_fst TopCat.pullbackFstₓ'. -/
/-- The first projection from the pullback. -/
abbrev pullbackFst (f : X ⟶ Z) (g : Y ⟶ Z) : TopCat.of { p : X × Y // f p.1 = g p.2 } ⟶ X :=
  ⟨Prod.fst ∘ Subtype.val⟩
#align Top.pullback_fst TopCat.pullbackFst

/- warning: Top.pullback_snd -> TopCat.pullbackSnd is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z), Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) Y
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z), Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) Y
Case conversion may be inaccurate. Consider using '#align Top.pullback_snd TopCat.pullbackSndₓ'. -/
/-- The second projection from the pullback. -/
abbrev pullbackSnd (f : X ⟶ Z) (g : Y ⟶ Z) : TopCat.of { p : X × Y // f p.1 = g p.2 } ⟶ Y :=
  ⟨Prod.snd ∘ Subtype.val⟩
#align Top.pullback_snd TopCat.pullbackSnd

#print TopCat.pullbackCone /-
/-- The explicit pullback cone of `X, Y` given by `{ p : X × Y // f p.1 = g p.2 }`. -/
def pullbackCone (f : X ⟶ Z) (g : Y ⟶ Z) : PullbackCone f g :=
  PullbackCone.mk (pullbackFst f g) (pullbackSnd f g)
    (by
      ext ⟨x, h⟩
      simp [h])
#align Top.pullback_cone TopCat.pullbackCone
-/

#print TopCat.pullbackConeIsLimit /-
/-- The constructed cone is a limit. -/
def pullbackConeIsLimit (f : X ⟶ Z) (g : Y ⟶ Z) : IsLimit (pullbackCone f g) :=
  PullbackCone.isLimitAux' _
    (by
      intro s
      constructor; swap
      exact
        {
          toFun := fun x =>
            ⟨⟨s.fst x, s.snd x⟩, by simpa using concrete_category.congr_hom s.condition x⟩ }
      refine' ⟨_, _, _⟩
      · ext
        delta pullback_cone
        simp
      · ext
        delta pullback_cone
        simp
      · intro m h₁ h₂
        ext x
        · simpa using concrete_category.congr_hom h₁ x
        · simpa using concrete_category.congr_hom h₂ x)
#align Top.pullback_cone_is_limit TopCat.pullbackConeIsLimit
-/

/- warning: Top.pullback_iso_prod_subtype -> TopCat.pullbackIsoProdSubtype is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z), CategoryTheory.Iso.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z), CategoryTheory.Iso.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))))
Case conversion may be inaccurate. Consider using '#align Top.pullback_iso_prod_subtype TopCat.pullbackIsoProdSubtypeₓ'. -/
/-- The pullback of two maps can be identified as a subspace of `X × Y`. -/
def pullbackIsoProdSubtype (f : X ⟶ Z) (g : Y ⟶ Z) :
    pullback f g ≅ TopCat.of { p : X × Y // f p.1 = g p.2 } :=
  (limit.isLimit _).conePointUniqueUpToIso (pullbackConeIsLimit f g)
#align Top.pullback_iso_prod_subtype TopCat.pullbackIsoProdSubtype

/- warning: Top.pullback_iso_prod_subtype_inv_fst -> TopCat.pullbackIsoProdSubtype_inv_fst is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) X) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)) X (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (TopCat.pullbackIsoProdSubtype.{u1} X Y Z f g)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (TopCat.pullbackFst.{u1} X Y Z f g)
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) X) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (TopCat.pullbackIsoProdSubtype.{u1} X Y Z f g)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (TopCat.pullbackFst.{u1} X Y Z f g)
Case conversion may be inaccurate. Consider using '#align Top.pullback_iso_prod_subtype_inv_fst TopCat.pullbackIsoProdSubtype_inv_fstₓ'. -/
@[simp, reassoc]
theorem pullbackIsoProdSubtype_inv_fst (f : X ⟶ Z) (g : Y ⟶ Z) :
    (pullbackIsoProdSubtype f g).inv ≫ pullback.fst = pullbackFst f g := by
  simpa [pullback_iso_prod_subtype]
#align Top.pullback_iso_prod_subtype_inv_fst TopCat.pullbackIsoProdSubtype_inv_fst

/- warning: Top.pullback_iso_prod_subtype_inv_fst_apply -> TopCat.pullbackIsoProdSubtype_inv_fst_apply is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (x : Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))), Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)))) (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (TopCat.pullbackIsoProdSubtype.{u1} X Y Z f g)) x)) (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (coeBase.{succ u1, succ u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (coeSubtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))))))) x))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z) (x : Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))), Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (TopCat.pullbackIsoProdSubtype.{u1} X Y Z f g)) x)) (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (Subtype.val.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) x))
Case conversion may be inaccurate. Consider using '#align Top.pullback_iso_prod_subtype_inv_fst_apply TopCat.pullbackIsoProdSubtype_inv_fst_applyₓ'. -/
@[simp]
theorem pullbackIsoProdSubtype_inv_fst_apply (f : X ⟶ Z) (g : Y ⟶ Z)
    (x : { p : X × Y // f p.1 = g p.2 }) :
    (pullback.fst : pullback f g ⟶ _) ((pullbackIsoProdSubtype f g).inv x) = (x : X × Y).fst :=
  ConcreteCategory.congr_hom (pullbackIsoProdSubtype_inv_fst f g) x
#align Top.pullback_iso_prod_subtype_inv_fst_apply TopCat.pullbackIsoProdSubtype_inv_fst_apply

/- warning: Top.pullback_iso_prod_subtype_inv_snd -> TopCat.pullbackIsoProdSubtype_inv_snd is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) Y) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)) Y (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (TopCat.pullbackIsoProdSubtype.{u1} X Y Z f g)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (TopCat.pullbackSnd.{u1} X Y Z f g)
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z), Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) Y) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (TopCat.pullbackIsoProdSubtype.{u1} X Y Z f g)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (TopCat.pullbackSnd.{u1} X Y Z f g)
Case conversion may be inaccurate. Consider using '#align Top.pullback_iso_prod_subtype_inv_snd TopCat.pullbackIsoProdSubtype_inv_sndₓ'. -/
@[simp, reassoc]
theorem pullbackIsoProdSubtype_inv_snd (f : X ⟶ Z) (g : Y ⟶ Z) :
    (pullbackIsoProdSubtype f g).inv ≫ pullback.snd = pullbackSnd f g := by
  simpa [pullback_iso_prod_subtype]
#align Top.pullback_iso_prod_subtype_inv_snd TopCat.pullbackIsoProdSubtype_inv_snd

/- warning: Top.pullback_iso_prod_subtype_inv_snd_apply -> TopCat.pullbackIsoProdSubtype_inv_snd_apply is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (x : Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))), Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)))) (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (TopCat.pullbackIsoProdSubtype.{u1} X Y Z f g)) x)) (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (coeBase.{succ u1, succ u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (coeSubtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))))))) x))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z) (x : Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))), Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (CategoryTheory.Iso.inv.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (TopCat.pullbackIsoProdSubtype.{u1} X Y Z f g)) x)) (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (Subtype.val.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) x))
Case conversion may be inaccurate. Consider using '#align Top.pullback_iso_prod_subtype_inv_snd_apply TopCat.pullbackIsoProdSubtype_inv_snd_applyₓ'. -/
@[simp]
theorem pullbackIsoProdSubtype_inv_snd_apply (f : X ⟶ Z) (g : Y ⟶ Z)
    (x : { p : X × Y // f p.1 = g p.2 }) :
    (pullback.snd : pullback f g ⟶ _) ((pullbackIsoProdSubtype f g).inv x) = (x : X × Y).snd :=
  ConcreteCategory.congr_hom (pullbackIsoProdSubtype_inv_snd f g) x
#align Top.pullback_iso_prod_subtype_inv_snd_apply TopCat.pullbackIsoProdSubtype_inv_snd_apply

#print TopCat.pullbackIsoProdSubtype_hom_fst /-
theorem pullbackIsoProdSubtype_hom_fst (f : X ⟶ Z) (g : Y ⟶ Z) :
    (pullbackIsoProdSubtype f g).Hom ≫ pullbackFst f g = pullback.fst := by
  rw [← iso.eq_inv_comp, pullback_iso_prod_subtype_inv_fst]
#align Top.pullback_iso_prod_subtype_hom_fst TopCat.pullbackIsoProdSubtype_hom_fst
-/

#print TopCat.pullbackIsoProdSubtype_hom_snd /-
theorem pullbackIsoProdSubtype_hom_snd (f : X ⟶ Z) (g : Y ⟶ Z) :
    (pullbackIsoProdSubtype f g).Hom ≫ pullbackSnd f g = pullback.snd := by
  rw [← iso.eq_inv_comp, pullback_iso_prod_subtype_inv_snd]
#align Top.pullback_iso_prod_subtype_hom_snd TopCat.pullbackIsoProdSubtype_hom_snd
-/

/- warning: Top.pullback_iso_prod_subtype_hom_apply -> TopCat.pullbackIsoProdSubtype_hom_apply is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z} {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z} (x : coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))), Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y))))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))))) (CategoryTheory.Iso.hom.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (TopCat.pullbackIsoProdSubtype._proof_1.{u1} X Y Z f g)) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)))) (Subtype.topologicalSpace.{u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.topologicalSpace.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Y)))) (TopCat.pullbackIsoProdSubtype.{u1} X Y Z f g)) x) (Subtype.mk.{succ u1} (Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) (fun (p : Prod.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) p))) (Prod.mk.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x)) (Eq.mpr.{0} (Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (Prod.mk.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (Prod.mk.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x))))) (Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x))) (id_tag Tactic.IdTag.simp (Eq.{1} Prop (Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (Prod.fst.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (Prod.mk.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (Prod.snd.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (Prod.mk.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x))))) (Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x)))) (rfl.{1} Prop (Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x))))) (Eq.mp.{0} (Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) (fun (f_1 : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) => (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z)) (CategoryTheory.ConcreteCategory.hasCoeToFun.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X Z (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) f) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) (fun (f_1 : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) => (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z)) (CategoryTheory.ConcreteCategory.hasCoeToFun.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y Z (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) g) x)) (Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x))) ((fun (a : coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) (a_1 : coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) (e_1 : Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) a a_1) (ᾰ : coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) (ᾰ_1 : coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) (e_2 : Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) ᾰ ᾰ_1) => congr.{succ u1, 1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) Prop (Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) a) (Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) a_1) ᾰ ᾰ_1 (congr_arg.{succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) ((coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z) -> Prop) a a_1 (Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z)) e_1) e_2) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) (fun (f_1 : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) => (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z)) (CategoryTheory.ConcreteCategory.hasCoeToFun.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X Z (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) f) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x)) (TopCat.comp_app.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X Z (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) f x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) (fun (f_1 : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) => (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} (CategoryTheory.ConcreteCategory.hasCoeToSort.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1}) Z)) (CategoryTheory.ConcreteCategory.hasCoeToFun.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y Z (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) g) x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x)) (TopCat.comp_app.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y Z (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) g x)) (CategoryTheory.ConcreteCategory.congr_hom.{succ u1, u1, u1} TopCat.{u1} TopCat.largeCategory.{u1} TopCat.concreteCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Z (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X Z (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) f) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y Z (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) g) (CategoryTheory.Limits.pullback.condition.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) x))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z} {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z} (x : Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.ConcreteCategory.forget.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))), Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y))))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (CategoryTheory.Iso.hom.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (TopCat.of.{u1} (Subtype.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)))) (instTopologicalSpaceSubtype.{u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (instTopologicalSpaceProd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (TopCat.topologicalSpace_coe.{u1} X) (TopCat.topologicalSpace_coe.{u1} Y)))) (TopCat.pullbackIsoProdSubtype.{u1} X Y Z f g)) x) (Subtype.mk.{succ u1} (Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) (fun (p : Prod.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) p))) (Prod.mk.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x)) (id.{0} (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prod.fst.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (Prod.mk.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prod.snd.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (Prod.mk.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x))))) (Eq.mp.{0} (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Z (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X Z (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) f) x) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Z (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y Z (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) g) x)) (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x))) (congr.{succ u1, 1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) Prop (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Z (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X Z (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) f) x)) (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Z (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y Z (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) g) x) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x)) (congrArg.{succ u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) ((Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) -> Prop) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Z (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X Z (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) f) x) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x)) (Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z)) (CategoryTheory.FunctorToTypes.map_comp_apply.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X Z (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) f x)) (CategoryTheory.FunctorToTypes.map_comp_apply.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y Z (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) g x)) (CategoryTheory.ConcreteCategory.congr_hom.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Z (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X Z (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) f) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y Z (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) g) (CategoryTheory.Limits.pullback.condition.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) x))))
Case conversion may be inaccurate. Consider using '#align Top.pullback_iso_prod_subtype_hom_apply TopCat.pullbackIsoProdSubtype_hom_applyₓ'. -/
@[simp]
theorem pullbackIsoProdSubtype_hom_apply {f : X ⟶ Z} {g : Y ⟶ Z} (x : pullback f g) :
    (pullbackIsoProdSubtype f g).Hom x =
      ⟨⟨(pullback.fst : pullback f g ⟶ _) x, (pullback.snd : pullback f g ⟶ _) x⟩, by
        simpa using concrete_category.congr_hom pullback.condition x⟩ :=
  by
  ext
  exacts[concrete_category.congr_hom (pullback_iso_prod_subtype_hom_fst f g) x,
    concrete_category.congr_hom (pullback_iso_prod_subtype_hom_snd f g) x]
#align Top.pullback_iso_prod_subtype_hom_apply TopCat.pullbackIsoProdSubtype_hom_apply

/- warning: Top.pullback_topology -> TopCat.pullback_topology is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z), Eq.{succ u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (Inf.inf.{u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))))) (SemilatticeInf.toHasInf.{u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))))) (Lattice.toSemilatticeInf.{u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))))) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))))) (TopologicalSpace.completeLattice.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))))))))) (TopologicalSpace.induced.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (TopCat.topologicalSpace.{u1} X)) (TopologicalSpace.induced.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (TopCat.topologicalSpace.{u1} Y)))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z), Eq.{succ u1} (TopologicalSpace.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Inf.inf.{u1} (TopologicalSpace.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))))) (Lattice.toInf.{u1} (TopologicalSpace.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))))) (ConditionallyCompleteLattice.toLattice.{u1} (TopologicalSpace.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (TopologicalSpace.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))))) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))))))) (TopologicalSpace.induced.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (TopologicalSpace.induced.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)))
Case conversion may be inaccurate. Consider using '#align Top.pullback_topology TopCat.pullback_topologyₓ'. -/
theorem pullback_topology {X Y Z : TopCat.{u}} (f : X ⟶ Z) (g : Y ⟶ Z) :
    (pullback f g).TopologicalSpace =
      induced (pullback.fst : pullback f g ⟶ _) X.TopologicalSpace ⊓
        induced (pullback.snd : pullback f g ⟶ _) Y.TopologicalSpace :=
  by
  let homeo := homeo_of_iso (pullback_iso_prod_subtype f g)
  refine' homeo.inducing.induced.trans _
  change induced homeo (induced _ (_ ⊓ _)) = _
  simpa [induced_compose]
#align Top.pullback_topology TopCat.pullback_topology

/- warning: Top.range_pullback_to_prod -> TopCat.range_pullback_to_prod is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u_1}} {Y : TopCat.{u_1}} {Z : TopCat.{u_1}} (f : Quiver.Hom.{succ u_1, succ u_1} TopCat.{u_1} (CategoryTheory.CategoryStruct.toQuiver.{u_1, succ u_1} TopCat.{u_1} (CategoryTheory.Category.toCategoryStruct.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1})) X Z) (g : Quiver.Hom.{succ u_1, succ u_1} TopCat.{u_1} (CategoryTheory.CategoryStruct.toQuiver.{u_1, succ u_1} TopCat.{u_1} (CategoryTheory.Category.toCategoryStruct.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1})) Y Z), Eq.{max (succ u_1) 1} (Set.{u_1} (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y))))) (Set.range.{u_1, succ u_1} (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.pullback.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (fun (J : Type.{u_1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u_1, u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.WidePullbackShape.{u_1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u_1} J) TopCat.topCat_hasLimits.{u_1})) (CategoryTheory.Limits.cospan.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g)))) (coeFn.{succ u_1, succ u_1} (Quiver.Hom.{succ u_1, succ u_1} TopCat.{u_1} (CategoryTheory.CategoryStruct.toQuiver.{u_1, succ u_1} TopCat.{u_1} (CategoryTheory.Category.toCategoryStruct.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1})) (CategoryTheory.Limits.pullback.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (fun (J : Type.{u_1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u_1, u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.WidePullbackShape.{u_1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u_1} J) TopCat.topCat_hasLimits.{u_1})) (CategoryTheory.Limits.cospan.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g))) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (fun (_x : ContinuousMap.{u_1, u_1} (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.pullback.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (fun (J : Type.{u_1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u_1, u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.WidePullbackShape.{u_1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u_1} J) TopCat.topCat_hasLimits.{u_1})) (CategoryTheory.Limits.cospan.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g)))) (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} (CategoryTheory.Limits.pullback.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (fun (J : Type.{u_1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u_1, u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.WidePullbackShape.{u_1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u_1} J) TopCat.topCat_hasLimits.{u_1})) (CategoryTheory.Limits.cospan.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y))))) => (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.pullback.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (fun (J : Type.{u_1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u_1, u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.WidePullbackShape.{u_1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u_1} J) TopCat.topCat_hasLimits.{u_1})) (CategoryTheory.Limits.cospan.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g)))) -> (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y))))) (ContinuousMap.hasCoeToFun.{u_1, u_1} (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.pullback.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (fun (J : Type.{u_1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u_1, u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.WidePullbackShape.{u_1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u_1} J) TopCat.topCat_hasLimits.{u_1})) (CategoryTheory.Limits.cospan.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g)))) (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} (CategoryTheory.Limits.pullback.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (fun (J : Type.{u_1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u_1, u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.WidePullbackShape.{u_1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u_1} J) TopCat.topCat_hasLimits.{u_1})) (CategoryTheory.Limits.cospan.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y))))) (CategoryTheory.Limits.prod.lift.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.pullback.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (fun (J : Type.{u_1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u_1, u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.WidePullbackShape.{u_1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u_1} J) TopCat.topCat_hasLimits.{u_1})) (CategoryTheory.Limits.cospan.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g))) X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)) (CategoryTheory.Limits.pullback.fst.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (fun (J : Type.{u_1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u_1, u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.WidePullbackShape.{u_1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u_1} J) TopCat.topCat_hasLimits.{u_1})) (CategoryTheory.Limits.cospan.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g))) (CategoryTheory.Limits.pullback.snd.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (fun (J : Type.{u_1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u_1, u_1, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Limits.WidePullbackShape.{u_1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u_1} J) TopCat.topCat_hasLimits.{u_1})) (CategoryTheory.Limits.cospan.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y Z f g)))))) (setOf.{u_1} (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (fun (x : coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) => Eq.{succ u_1} (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) Z) (coeFn.{succ u_1, succ u_1} (Quiver.Hom.{succ u_1, succ u_1} TopCat.{u_1} (CategoryTheory.CategoryStruct.toQuiver.{u_1, succ u_1} TopCat.{u_1} (CategoryTheory.Category.toCategoryStruct.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1})) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y))) Z) (fun (_x : ContinuousMap.{u_1, u_1} (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) Z) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} Z)) => (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) -> (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) Z)) (ContinuousMap.hasCoeToFun.{u_1, u_1} (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) Z) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} Z)) (CategoryTheory.CategoryStruct.comp.{u_1, succ u_1} TopCat.{u_1} (CategoryTheory.Category.toCategoryStruct.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y))) X Z (CategoryTheory.Limits.prod.fst.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y))) f) x) (coeFn.{succ u_1, succ u_1} (Quiver.Hom.{succ u_1, succ u_1} TopCat.{u_1} (CategoryTheory.CategoryStruct.toQuiver.{u_1, succ u_1} TopCat.{u_1} (CategoryTheory.Category.toCategoryStruct.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1})) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y))) Z) (fun (_x : ContinuousMap.{u_1, u_1} (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) Z) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} Z)) => (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) -> (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) Z)) (ContinuousMap.hasCoeToFun.{u_1, u_1} (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (coeSort.{succ (succ u_1), succ (succ u_1)} (CategoryTheory.Bundled.{u_1, u_1} TopologicalSpace.{u_1}) Type.{u_1} (CategoryTheory.Bundled.hasCoeToSort.{u_1, u_1} TopologicalSpace.{u_1}) Z) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y)))) (CategoryTheory.Bundled.str.{u_1, u_1} TopologicalSpace.{u_1} Z)) (CategoryTheory.CategoryStruct.comp.{u_1, succ u_1} TopCat.{u_1} (CategoryTheory.Category.toCategoryStruct.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1}) (CategoryTheory.Limits.prod.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y))) Y Z (CategoryTheory.Limits.prod.snd.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u_1, 0}) (CategoryTheory.Limits.pair.{u_1, succ u_1} TopCat.{u_1} TopCat.largeCategory.{u_1} X Y))) g) x)))
but is expected to have type
  forall {X : TopCat.{0}} {Y : TopCat.{0}} {Z : TopCat.{0}} (f : Quiver.Hom.{1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) X Z) (g : Quiver.Hom.{1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) Y Z), Eq.{1} (Set.{0} (Prefunctor.obj.{1, 1, 1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) Type (CategoryTheory.CategoryStruct.toQuiver.{0, 1} Type (CategoryTheory.Category.toCategoryStruct.{0, 1} Type CategoryTheory.types.{0})) (CategoryTheory.Functor.toPrefunctor.{0, 0, 1, 1} TopCat.{0} instTopCatLargeCategory.{0} Type CategoryTheory.types.{0} (CategoryTheory.forget.{1, 0, 0} TopCat.{0} instTopCatLargeCategory.{0} TopCat.concreteCategory.{0})) (CategoryTheory.Limits.prod.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y))))) (Set.range.{0, 1} (Prefunctor.obj.{1, 1, 1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) Type (CategoryTheory.CategoryStruct.toQuiver.{0, 1} Type (CategoryTheory.Category.toCategoryStruct.{0, 1} Type CategoryTheory.types.{0})) (CategoryTheory.Functor.toPrefunctor.{0, 0, 1, 1} TopCat.{0} instTopCatLargeCategory.{0} Type CategoryTheory.types.{0} (CategoryTheory.forget.{1, 0, 0} TopCat.{0} instTopCatLargeCategory.{0} TopCat.concreteCategory.{0})) (CategoryTheory.Limits.prod.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y)))) (Prefunctor.obj.{1, 1, 1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) Type (CategoryTheory.CategoryStruct.toQuiver.{0, 1} Type (CategoryTheory.Category.toCategoryStruct.{0, 1} Type CategoryTheory.types.{0})) (CategoryTheory.Functor.toPrefunctor.{0, 0, 1, 1} TopCat.{0} instTopCatLargeCategory.{0} Type CategoryTheory.types.{0} (CategoryTheory.forget.{1, 0, 0} TopCat.{0} instTopCatLargeCategory.{0} TopCat.concreteCategory.{0})) (CategoryTheory.Limits.pullback.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (fun (J : Type) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Limits.WidePullbackShape.{0} J) (CategoryTheory.Limits.WidePullbackShape.category.{0} J) TopCat.topCat_hasLimits.{0})) (CategoryTheory.Limits.cospan.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y Z f g)))) (Prefunctor.map.{1, 1, 1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) Type (CategoryTheory.CategoryStruct.toQuiver.{0, 1} Type (CategoryTheory.Category.toCategoryStruct.{0, 1} Type CategoryTheory.types.{0})) (CategoryTheory.Functor.toPrefunctor.{0, 0, 1, 1} TopCat.{0} instTopCatLargeCategory.{0} Type CategoryTheory.types.{0} (CategoryTheory.forget.{1, 0, 0} TopCat.{0} instTopCatLargeCategory.{0} TopCat.concreteCategory.{0})) (CategoryTheory.Limits.pullback.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (fun (J : Type) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Limits.WidePullbackShape.{0} J) (CategoryTheory.Limits.WidePullbackShape.category.{0} J) TopCat.topCat_hasLimits.{0})) (CategoryTheory.Limits.cospan.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y Z f g))) (CategoryTheory.Limits.prod.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y))) (CategoryTheory.Limits.prod.lift.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Limits.pullback.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (fun (J : Type) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Limits.WidePullbackShape.{0} J) (CategoryTheory.Limits.WidePullbackShape.category.{0} J) TopCat.topCat_hasLimits.{0})) (CategoryTheory.Limits.cospan.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y Z f g))) X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y)) (CategoryTheory.Limits.pullback.fst.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (fun (J : Type) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Limits.WidePullbackShape.{0} J) (CategoryTheory.Limits.WidePullbackShape.category.{0} J) TopCat.topCat_hasLimits.{0})) (CategoryTheory.Limits.cospan.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y Z f g))) (CategoryTheory.Limits.pullback.snd.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (fun (J : Type) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Limits.WidePullbackShape.{0} J) (CategoryTheory.Limits.WidePullbackShape.category.{0} J) TopCat.topCat_hasLimits.{0})) (CategoryTheory.Limits.cospan.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y Z f g)))))) (setOf.{0} (Prefunctor.obj.{1, 1, 1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) Type (CategoryTheory.CategoryStruct.toQuiver.{0, 1} Type (CategoryTheory.Category.toCategoryStruct.{0, 1} Type CategoryTheory.types.{0})) (CategoryTheory.Functor.toPrefunctor.{0, 0, 1, 1} TopCat.{0} instTopCatLargeCategory.{0} Type CategoryTheory.types.{0} (CategoryTheory.forget.{1, 0, 0} TopCat.{0} instTopCatLargeCategory.{0} TopCat.concreteCategory.{0})) (CategoryTheory.Limits.prod.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y)))) (fun (x : Prefunctor.obj.{1, 1, 1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) Type (CategoryTheory.CategoryStruct.toQuiver.{0, 1} Type (CategoryTheory.Category.toCategoryStruct.{0, 1} Type CategoryTheory.types.{0})) (CategoryTheory.Functor.toPrefunctor.{0, 0, 1, 1} TopCat.{0} instTopCatLargeCategory.{0} Type CategoryTheory.types.{0} (CategoryTheory.forget.{1, 0, 0} TopCat.{0} instTopCatLargeCategory.{0} TopCat.concreteCategory.{0})) (CategoryTheory.Limits.prod.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y)))) => Eq.{1} (Prefunctor.obj.{1, 1, 1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) Type (CategoryTheory.CategoryStruct.toQuiver.{0, 1} Type (CategoryTheory.Category.toCategoryStruct.{0, 1} Type CategoryTheory.types.{0})) (CategoryTheory.Functor.toPrefunctor.{0, 0, 1, 1} TopCat.{0} instTopCatLargeCategory.{0} Type CategoryTheory.types.{0} (CategoryTheory.forget.{1, 0, 0} TopCat.{0} instTopCatLargeCategory.{0} TopCat.concreteCategory.{0})) Z) (Prefunctor.map.{1, 1, 1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) Type (CategoryTheory.CategoryStruct.toQuiver.{0, 1} Type (CategoryTheory.Category.toCategoryStruct.{0, 1} Type CategoryTheory.types.{0})) (CategoryTheory.Functor.toPrefunctor.{0, 0, 1, 1} TopCat.{0} instTopCatLargeCategory.{0} Type CategoryTheory.types.{0} (CategoryTheory.forget.{1, 0, 0} TopCat.{0} instTopCatLargeCategory.{0} TopCat.concreteCategory.{0})) (CategoryTheory.Limits.prod.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y))) Z (CategoryTheory.CategoryStruct.comp.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0}) (CategoryTheory.Limits.prod.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y))) X Z (CategoryTheory.Limits.prod.fst.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y))) f) x) (Prefunctor.map.{1, 1, 1, 1} TopCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0})) Type (CategoryTheory.CategoryStruct.toQuiver.{0, 1} Type (CategoryTheory.Category.toCategoryStruct.{0, 1} Type CategoryTheory.types.{0})) (CategoryTheory.Functor.toPrefunctor.{0, 0, 1, 1} TopCat.{0} instTopCatLargeCategory.{0} Type CategoryTheory.types.{0} (CategoryTheory.forget.{1, 0, 0} TopCat.{0} instTopCatLargeCategory.{0} TopCat.concreteCategory.{0})) (CategoryTheory.Limits.prod.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y))) Z (CategoryTheory.CategoryStruct.comp.{0, 1} TopCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} TopCat.{0} instTopCatLargeCategory.{0}) (CategoryTheory.Limits.prod.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y))) Y Z (CategoryTheory.Limits.prod.snd.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, 0, 1} TopCat.{0} instTopCatLargeCategory.{0} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimits.{0}) (CategoryTheory.Limits.pair.{0, 1} TopCat.{0} instTopCatLargeCategory.{0} X Y))) g) x)))
Case conversion may be inaccurate. Consider using '#align Top.range_pullback_to_prod TopCat.range_pullback_to_prodₓ'. -/
theorem range_pullback_to_prod {X Y Z : TopCat} (f : X ⟶ Z) (g : Y ⟶ Z) :
    Set.range (prod.lift pullback.fst pullback.snd : pullback f g ⟶ X ⨯ Y) =
      { x | (Limits.prod.fst ≫ f) x = (Limits.prod.snd ≫ g) x } :=
  by
  ext x
  constructor
  · rintro ⟨y, rfl⟩
    simp only [← comp_apply, Set.mem_setOf_eq]
    congr 1
    simp [pullback.condition]
  · intro h
    use (pullback_iso_prod_subtype f g).inv ⟨⟨_, _⟩, h⟩
    apply concrete.limit_ext
    rintro ⟨⟨⟩⟩ <;> simp
#align Top.range_pullback_to_prod TopCat.range_pullback_to_prod

/- warning: Top.inducing_pullback_to_prod -> TopCat.inducing_pullback_to_prod is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z), Inducing.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) (CategoryTheory.Limits.prod.lift.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z), Inducing.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) (CategoryTheory.Limits.prod.lift.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))))
Case conversion may be inaccurate. Consider using '#align Top.inducing_pullback_to_prod TopCat.inducing_pullback_to_prodₓ'. -/
theorem inducing_pullback_to_prod {X Y Z : TopCat} (f : X ⟶ Z) (g : Y ⟶ Z) :
    Inducing ⇑(prod.lift pullback.fst pullback.snd : pullback f g ⟶ X ⨯ Y) :=
  ⟨by simp [prod_topology, pullbackTopology, induced_compose, ← coe_comp]⟩
#align Top.inducing_pullback_to_prod TopCat.inducing_pullback_to_prod

/- warning: Top.embedding_pullback_to_prod -> TopCat.embedding_pullback_to_prod is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z), Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y))))) (CategoryTheory.Limits.prod.lift.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{u1, 0}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z), Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (CategoryTheory.Limits.prod.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y))) (CategoryTheory.Limits.prod.lift.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X Y (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Discrete.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.discreteCategory.{0} CategoryTheory.Limits.WalkingPair) TopCat.topCat_hasLimitsOfSize.{0, u1}) (CategoryTheory.Limits.pair.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))))
Case conversion may be inaccurate. Consider using '#align Top.embedding_pullback_to_prod TopCat.embedding_pullback_to_prodₓ'. -/
theorem embedding_pullback_to_prod {X Y Z : TopCat} (f : X ⟶ Z) (g : Y ⟶ Z) :
    Embedding ⇑(prod.lift pullback.fst pullback.snd : pullback f g ⟶ X ⨯ Y) :=
  ⟨inducing_pullback_to_prod f g, (TopCat.mono_iff_injective _).mp inferInstance⟩
#align Top.embedding_pullback_to_prod TopCat.embedding_pullback_to_prod

/- warning: Top.range_pullback_map -> TopCat.range_pullback_map is a dubious translation:
lean 3 declaration is
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {S : TopCat.{u1}} {T : TopCat.{u1}} (f₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W S) (f₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (g₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y T) (g₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Z T) (i₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W Y) (i₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (i₃ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) S T) [H₃ : CategoryTheory.Mono.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} S T i₃] (eq₁ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) W S T f₁ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) W Y T i₁ g₁)) (eq₂ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) X S T f₂ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) X Z T i₂ g₂)), Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) (CategoryTheory.Limits.pullback.map.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X Y Z S T f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)) g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)) i₁ i₂ i₃ eq₁ eq₂))) (Inter.inter.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) (Set.hasInter.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) (Set.preimage.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) i₁))) (Set.preimage.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))) Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) i₂))))
but is expected to have type
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {S : TopCat.{u1}} {T : TopCat.{u1}} (f₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W S) (f₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S) (g₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y T) (g₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Z T) (i₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W Y) (i₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (i₃ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) S T) [H₃ : CategoryTheory.Mono.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} S T i₃] (eq₁ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) W S T f₁ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) W Y T i₁ g₁)) (eq₂ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) X S T f₂ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) X Z T i₂ g₂)), Eq.{succ u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂))))) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂))) (CategoryTheory.Limits.pullback.map.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X Y Z S T f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂)) g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)) i₁ i₂ i₃ eq₁ eq₂))) (Inter.inter.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂))))) (Set.instInterSet.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂))))) (Set.preimage.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂))) Y (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)))) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W Y i₁))) (Set.preimage.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂))) Z (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)))) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z i₂))))
Case conversion may be inaccurate. Consider using '#align Top.range_pullback_map TopCat.range_pullback_mapₓ'. -/
/-- If the map `S ⟶ T` is mono, then there is a description of the image of `W ×ₛ X ⟶ Y ×ₜ Z`. -/
theorem range_pullback_map {W X Y Z S T : TopCat} (f₁ : W ⟶ S) (f₂ : X ⟶ S) (g₁ : Y ⟶ T)
    (g₂ : Z ⟶ T) (i₁ : W ⟶ Y) (i₂ : X ⟶ Z) (i₃ : S ⟶ T) [H₃ : Mono i₃] (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁)
    (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) :
    Set.range (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) =
      (pullback.fst : pullback g₁ g₂ ⟶ _) ⁻¹' Set.range i₁ ∩
        (pullback.snd : pullback g₁ g₂ ⟶ _) ⁻¹' Set.range i₂ :=
  by
  ext
  constructor
  · rintro ⟨y, rfl⟩
    simp
  rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩⟩
  have : f₁ x₁ = f₂ x₂ := by
    apply (TopCat.mono_iff_injective _).mp H₃
    simp only [← comp_apply, eq₁, eq₂]
    simp only [comp_apply, hx₁, hx₂]
    simp only [← comp_apply, pullback.condition]
  use (pullback_iso_prod_subtype f₁ f₂).inv ⟨⟨x₁, x₂⟩, this⟩
  apply concrete.limit_ext
  rintro (_ | _ | _)
  · simp only [TopCat.comp_app, limit.lift_π_apply, category.assoc, pullback_cone.mk_π_app_one, hx₁,
      pullback_iso_prod_subtype_inv_fst_apply, Subtype.coe_mk]
    simp only [← comp_apply]
    congr
    apply limit.w _ walking_cospan.hom.inl
  · simp [hx₁]
  · simp [hx₂]
#align Top.range_pullback_map TopCat.range_pullback_map

/- warning: Top.pullback_fst_range -> TopCat.pullback_fst_range is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S), Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))))) (setOf.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) => Exists.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) f x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) g y))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y S), Eq.{succ u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X)) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))))) (setOf.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (fun (x : CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) => Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (fun (y : CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X S f x) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y S g y))))
Case conversion may be inaccurate. Consider using '#align Top.pullback_fst_range TopCat.pullback_fst_rangeₓ'. -/
theorem pullback_fst_range {X Y S : TopCat} (f : X ⟶ S) (g : Y ⟶ S) :
    Set.range (pullback.fst : pullback f g ⟶ _) = { x : X | ∃ y : Y, f x = g y } :=
  by
  ext x
  constructor
  · rintro ⟨y, rfl⟩
    use (pullback.snd : pullback f g ⟶ _) y
    exact concrete_category.congr_hom pullback.condition y
  · rintro ⟨y, eq⟩
    use (TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨x, y⟩, Eq⟩
    simp
#align Top.pullback_fst_range TopCat.pullback_fst_range

/- warning: Top.pullback_snd_range -> TopCat.pullback_snd_range is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S), Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))))) (setOf.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y) => Exists.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X) => Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) f x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) g y))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y S), Eq.{succ u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y)) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))))) (setOf.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) (fun (y : CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y) => Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) (fun (x : CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X) => Eq.{succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X S f x) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y S g y))))
Case conversion may be inaccurate. Consider using '#align Top.pullback_snd_range TopCat.pullback_snd_rangeₓ'. -/
theorem pullback_snd_range {X Y S : TopCat} (f : X ⟶ S) (g : Y ⟶ S) :
    Set.range (pullback.snd : pullback f g ⟶ _) = { y : Y | ∃ x : X, f x = g y } :=
  by
  ext y
  constructor
  · rintro ⟨x, rfl⟩
    use (pullback.fst : pullback f g ⟶ _) x
    exact concrete_category.congr_hom pullback.condition x
  · rintro ⟨x, eq⟩
    use (TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨x, y⟩, Eq⟩
    simp
#align Top.pullback_snd_range TopCat.pullback_snd_range

/- warning: Top.pullback_map_embedding_of_embeddings -> TopCat.pullback_map_embedding_of_embeddings is a dubious translation:
lean 3 declaration is
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {S : TopCat.{u1}} {T : TopCat.{u1}} (f₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W S) (f₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (g₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y T) (g₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Z T) {i₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W Y} {i₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z}, (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (TopCat.topologicalSpace.{u1} W) (TopCat.topologicalSpace.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) i₁)) -> (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) i₂)) -> (forall (i₃ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) S T) (eq₁ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) W S T f₁ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) W Y T i₁ g₁)) (eq₂ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) X S T f₂ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) X Z T i₂ g₂)), Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) (CategoryTheory.Limits.pullback.map.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X Y Z S T f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)) g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)) i₁ i₂ i₃ eq₁ eq₂)))
but is expected to have type
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {S : TopCat.{u1}} {T : TopCat.{u1}} (f₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W S) (f₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S) (g₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y T) (g₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Z T) {i₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W Y} {i₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z}, (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (TopCat.topologicalSpace_forget.{u1} W) (TopCat.topologicalSpace_forget.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W Y i₁)) -> (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z i₂)) -> (forall (i₃ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) S T) (eq₁ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) W S T f₁ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) W Y T i₁ g₁)) (eq₂ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) X S T f₂ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) X Z T i₂ g₂)), Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂))) (CategoryTheory.Limits.pullback.map.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X Y Z S T f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂)) g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)) i₁ i₂ i₃ eq₁ eq₂)))
Case conversion may be inaccurate. Consider using '#align Top.pullback_map_embedding_of_embeddings TopCat.pullback_map_embedding_of_embeddingsₓ'. -/
/-- If there is a diagram where the morphisms `W ⟶ Y` and `X ⟶ Z` are embeddings,
then the induced morphism `W ×ₛ X ⟶ Y ×ₜ Z` is also an embedding.

  W  ⟶  Y
    ↘      ↘
      S  ⟶  T
    ↗      ↗
  X  ⟶  Z
-/
theorem pullback_map_embedding_of_embeddings {W X Y Z S T : TopCat} (f₁ : W ⟶ S) (f₂ : X ⟶ S)
    (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) {i₁ : W ⟶ Y} {i₂ : X ⟶ Z} (H₁ : Embedding i₁) (H₂ : Embedding i₂)
    (i₃ : S ⟶ T) (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁) (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) :
    Embedding (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) :=
  by
  refine'
    embedding_of_embedding_compose (ContinuousMap.continuous_toFun _)
      (show Continuous (prod.lift pullback.fst pullback.snd : pullback g₁ g₂ ⟶ Y ⨯ Z) from
        ContinuousMap.continuous_toFun _)
      _
  suffices
    Embedding (prod.lift pullback.fst pullback.snd ≫ limits.prod.map i₁ i₂ : pullback f₁ f₂ ⟶ _) by
    simpa [← coe_comp] using this
  rw [coe_comp]
  refine' Embedding.comp (embedding_prod_map H₁ H₂) (embedding_pullback_to_prod _ _)
#align Top.pullback_map_embedding_of_embeddings TopCat.pullback_map_embedding_of_embeddings

/- warning: Top.pullback_map_open_embedding_of_open_embeddings -> TopCat.pullback_map_openEmbedding_of_open_embeddings is a dubious translation:
lean 3 declaration is
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {S : TopCat.{u1}} {T : TopCat.{u1}} (f₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W S) (f₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (g₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y T) (g₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Z T) {i₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W Y} {i₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z}, (OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (TopCat.topologicalSpace.{u1} W) (TopCat.topologicalSpace.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) W) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} W) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) i₁)) -> (OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) i₂)) -> (forall (i₃ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) S T) [H₃ : CategoryTheory.Mono.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} S T i₃] (eq₁ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) W T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) W S T f₁ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) W Y T i₁ g₁)) (eq₂ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) X S T f₂ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1}) X Z T i₂ g₂)), OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂))))) (CategoryTheory.Limits.pullback.map.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X Y Z S T f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} W X S f₁ f₂)) g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} Y Z T g₁ g₂)) i₁ i₂ i₃ eq₁ eq₂)))
but is expected to have type
  forall {W : TopCat.{u1}} {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} {S : TopCat.{u1}} {T : TopCat.{u1}} (f₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W S) (f₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S) (g₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y T) (g₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Z T) {i₁ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W Y} {i₂ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z}, (OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (TopCat.topologicalSpace_forget.{u1} W) (TopCat.topologicalSpace_forget.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) W Y i₁)) -> (OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z i₂)) -> (forall (i₃ : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) S T) [H₃ : CategoryTheory.Mono.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} S T i₃] (eq₁ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) W T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) W S T f₁ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) W Y T i₁ g₁)) (eq₂ : Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X T) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) X S T f₂ i₃) (CategoryTheory.CategoryStruct.comp.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1}) X Z T i₂ g₂)), OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂)))) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂))) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂))) (CategoryTheory.Limits.pullback.map.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X Y Z S T f₁ f₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} W X S f₁ f₂)) g₁ g₂ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Y Z T g₁ g₂)) i₁ i₂ i₃ eq₁ eq₂)))
Case conversion may be inaccurate. Consider using '#align Top.pullback_map_open_embedding_of_open_embeddings TopCat.pullback_map_openEmbedding_of_open_embeddingsₓ'. -/
/-- If there is a diagram where the morphisms `W ⟶ Y` and `X ⟶ Z` are open embeddings, and `S ⟶ T`
is mono, then the induced morphism `W ×ₛ X ⟶ Y ×ₜ Z` is also an open embedding.
  W  ⟶  Y
    ↘      ↘
      S  ⟶  T
    ↗       ↗
  X  ⟶  Z
-/
theorem pullback_map_openEmbedding_of_open_embeddings {W X Y Z S T : TopCat} (f₁ : W ⟶ S)
    (f₂ : X ⟶ S) (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) {i₁ : W ⟶ Y} {i₂ : X ⟶ Z} (H₁ : OpenEmbedding i₁)
    (H₂ : OpenEmbedding i₂) (i₃ : S ⟶ T) [H₃ : Mono i₃] (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁)
    (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) : OpenEmbedding (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) :=
  by
  constructor
  ·
    apply
      pullback_map_embedding_of_embeddings f₁ f₂ g₁ g₂ H₁.to_embedding H₂.to_embedding i₃ eq₁ eq₂
  · rw [range_pullback_map]
    apply IsOpen.inter <;> apply Continuous.isOpen_preimage
    continuity
    exacts[H₁.open_range, H₂.open_range]
#align Top.pullback_map_open_embedding_of_open_embeddings TopCat.pullback_map_openEmbedding_of_open_embeddings

/- warning: Top.snd_embedding_of_left_embedding -> TopCat.snd_embedding_of_left_embedding is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S}, (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) f)) -> (forall (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S), Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S}, (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X S f)) -> (forall (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y S), Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace_forget.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))))
Case conversion may be inaccurate. Consider using '#align Top.snd_embedding_of_left_embedding TopCat.snd_embedding_of_left_embeddingₓ'. -/
theorem snd_embedding_of_left_embedding {X Y S : TopCat} {f : X ⟶ S} (H : Embedding f) (g : Y ⟶ S) :
    Embedding ⇑(pullback.snd : pullback f g ⟶ Y) :=
  by
  convert(homeo_of_iso (as_iso (pullback.snd : pullback (𝟙 S) g ⟶ _))).Embedding.comp
      (pullback_map_embedding_of_embeddings f g (𝟙 _) g H (homeo_of_iso (iso.refl _)).Embedding
        (𝟙 _) rfl (by simp))
  erw [← coe_comp]
  simp
#align Top.snd_embedding_of_left_embedding TopCat.snd_embedding_of_left_embedding

/- warning: Top.fst_embedding_of_right_embedding -> TopCat.fst_embedding_of_right_embedding is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S}, (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (TopCat.topologicalSpace.{u1} Y) (TopCat.topologicalSpace.{u1} S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) g)) -> (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace.{u1} X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S) {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y S}, (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (TopCat.topologicalSpace_forget.{u1} Y) (TopCat.topologicalSpace_forget.{u1} S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y S g)) -> (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace_forget.{u1} X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))))
Case conversion may be inaccurate. Consider using '#align Top.fst_embedding_of_right_embedding TopCat.fst_embedding_of_right_embeddingₓ'. -/
theorem fst_embedding_of_right_embedding {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}
    (H : Embedding g) : Embedding ⇑(pullback.fst : pullback f g ⟶ X) :=
  by
  convert(homeo_of_iso (as_iso (pullback.fst : pullback f (𝟙 S) ⟶ _))).Embedding.comp
      (pullback_map_embedding_of_embeddings f g f (𝟙 _) (homeo_of_iso (iso.refl _)).Embedding H
        (𝟙 _) rfl (by simp))
  erw [← coe_comp]
  simp
#align Top.fst_embedding_of_right_embedding TopCat.fst_embedding_of_right_embedding

/- warning: Top.embedding_of_pullback_embeddings -> TopCat.embedding_of_pullback_embeddings is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S} {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S}, (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) f)) -> (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (TopCat.topologicalSpace.{u1} Y) (TopCat.topologicalSpace.{u1} S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) g)) -> (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one)) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one)) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one)) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one)) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one))) (CategoryTheory.Limits.limit.π.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)) CategoryTheory.Limits.WalkingCospan.one)))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S} {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y S}, (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X S f)) -> (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (TopCat.topologicalSpace_forget.{u1} Y) (TopCat.topologicalSpace_forget.{u1} S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y S g)) -> (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)) CategoryTheory.Limits.WalkingCospan.one)) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace_forget.{u1} (Prefunctor.obj.{1, succ u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)) CategoryTheory.Limits.WalkingCospan.one)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))) (Prefunctor.obj.{1, succ u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)) CategoryTheory.Limits.WalkingCospan.one) (CategoryTheory.Limits.limit.π.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)) CategoryTheory.Limits.WalkingCospan.one)))
Case conversion may be inaccurate. Consider using '#align Top.embedding_of_pullback_embeddings TopCat.embedding_of_pullback_embeddingsₓ'. -/
theorem embedding_of_pullback_embeddings {X Y S : TopCat} {f : X ⟶ S} {g : Y ⟶ S} (H₁ : Embedding f)
    (H₂ : Embedding g) : Embedding (limit.π (cospan f g) WalkingCospan.one) :=
  by
  convert H₂.comp (snd_embedding_of_left_embedding H₁ g)
  erw [← coe_comp]
  congr
  exact (limit.w _ walking_cospan.hom.inr).symm
#align Top.embedding_of_pullback_embeddings TopCat.embedding_of_pullback_embeddings

/- warning: Top.snd_open_embedding_of_left_open_embedding -> TopCat.snd_openEmbedding_of_left_openEmbedding is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S}, (OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) f)) -> (forall (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S), OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace.{u1} Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S}, (OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X S f)) -> (forall (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y S), OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace_forget.{u1} Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))))
Case conversion may be inaccurate. Consider using '#align Top.snd_open_embedding_of_left_open_embedding TopCat.snd_openEmbedding_of_left_openEmbeddingₓ'. -/
theorem snd_openEmbedding_of_left_openEmbedding {X Y S : TopCat} {f : X ⟶ S} (H : OpenEmbedding f)
    (g : Y ⟶ S) : OpenEmbedding ⇑(pullback.snd : pullback f g ⟶ Y) :=
  by
  convert(homeo_of_iso (as_iso (pullback.snd : pullback (𝟙 S) g ⟶ _))).OpenEmbedding.comp
      (pullback_map_open_embedding_of_open_embeddings f g (𝟙 _) g H
        (homeo_of_iso (iso.refl _)).OpenEmbedding (𝟙 _) rfl (by simp))
  erw [← coe_comp]
  simp
#align Top.snd_open_embedding_of_left_open_embedding TopCat.snd_openEmbedding_of_left_openEmbedding

/- warning: Top.fst_open_embedding_of_right_open_embedding -> TopCat.fst_openEmbedding_of_right_openEmbedding is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S}, (OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (TopCat.topologicalSpace.{u1} Y) (TopCat.topologicalSpace.{u1} S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) g)) -> (OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace.{u1} X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S) {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y S}, (OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (TopCat.topologicalSpace_forget.{u1} Y) (TopCat.topologicalSpace_forget.{u1} S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y S g)) -> (OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace_forget.{u1} X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))))
Case conversion may be inaccurate. Consider using '#align Top.fst_open_embedding_of_right_open_embedding TopCat.fst_openEmbedding_of_right_openEmbeddingₓ'. -/
theorem fst_openEmbedding_of_right_openEmbedding {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}
    (H : OpenEmbedding g) : OpenEmbedding ⇑(pullback.fst : pullback f g ⟶ X) :=
  by
  convert(homeo_of_iso (as_iso (pullback.fst : pullback f (𝟙 S) ⟶ _))).OpenEmbedding.comp
      (pullback_map_open_embedding_of_open_embeddings f g f (𝟙 _)
        (homeo_of_iso (iso.refl _)).OpenEmbedding H (𝟙 _) rfl (by simp))
  erw [← coe_comp]
  simp
#align Top.fst_open_embedding_of_right_open_embedding TopCat.fst_openEmbedding_of_right_openEmbedding

/- warning: Top.open_embedding_of_pullback_open_embeddings -> TopCat.openEmbedding_of_pullback_open_embeddings is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S} {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S}, (OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) f)) -> (OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (TopCat.topologicalSpace.{u1} Y) (TopCat.topologicalSpace.{u1} S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) g)) -> (OpenEmbedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one)) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one)) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one)) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one)) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) CategoryTheory.Limits.WalkingCospan.one))) (CategoryTheory.Limits.limit.π.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)) CategoryTheory.Limits.WalkingCospan.one)))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S} {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y S}, (OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X S f)) -> (OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (TopCat.topologicalSpace_forget.{u1} Y) (TopCat.topologicalSpace_forget.{u1} S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y S g)) -> (OpenEmbedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)) CategoryTheory.Limits.WalkingCospan.one)) (TopCat.topologicalSpace_forget.{u1} (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))) (TopCat.topologicalSpace_forget.{u1} (Prefunctor.obj.{1, succ u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)) CategoryTheory.Limits.WalkingCospan.one)) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.limit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))) (Prefunctor.obj.{1, succ u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair))) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)) CategoryTheory.Limits.WalkingCospan.one) (CategoryTheory.Limits.limit.π.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)) CategoryTheory.Limits.WalkingCospan.one)))
Case conversion may be inaccurate. Consider using '#align Top.open_embedding_of_pullback_open_embeddings TopCat.openEmbedding_of_pullback_open_embeddingsₓ'. -/
/-- If `X ⟶ S`, `Y ⟶ S` are open embeddings, then so is `X ×ₛ Y ⟶ S`. -/
theorem openEmbedding_of_pullback_open_embeddings {X Y S : TopCat} {f : X ⟶ S} {g : Y ⟶ S}
    (H₁ : OpenEmbedding f) (H₂ : OpenEmbedding g) :
    OpenEmbedding (limit.π (cospan f g) WalkingCospan.one) :=
  by
  convert H₂.comp (snd_open_embedding_of_left_open_embedding H₁ g)
  erw [← coe_comp]
  congr
  exact (limit.w _ walking_cospan.hom.inr).symm
#align Top.open_embedding_of_pullback_open_embeddings TopCat.openEmbedding_of_pullback_open_embeddings

/- warning: Top.fst_iso_of_right_embedding_range_subset -> TopCat.fst_iso_of_right_embedding_range_subset is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S}, (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (TopCat.topologicalSpace.{u1} Y) (TopCat.topologicalSpace.{u1} S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) g)) -> (HasSubset.Subset.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (Set.hasSubset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) f)) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) g))) -> (CategoryTheory.IsIso.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S) {g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y S}, (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (TopCat.topologicalSpace_forget.{u1} Y) (TopCat.topologicalSpace_forget.{u1} S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y S g)) -> (HasSubset.Subset.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S)) (Set.instHasSubsetSet.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S)) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X S f)) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y S g))) -> (CategoryTheory.IsIso.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))))
Case conversion may be inaccurate. Consider using '#align Top.fst_iso_of_right_embedding_range_subset TopCat.fst_iso_of_right_embedding_range_subsetₓ'. -/
theorem fst_iso_of_right_embedding_range_subset {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}
    (hg : Embedding g) (H : Set.range f ⊆ Set.range g) : IsIso (pullback.fst : pullback f g ⟶ X) :=
  by
  let this : (pullback f g : TopCat) ≃ₜ X :=
    (Homeomorph.ofEmbedding _ (fst_embedding_of_right_embedding f hg)).trans
      { toFun := coe
        invFun := fun x =>
          ⟨x, by
            rw [pullback_fst_range]
            exact ⟨_, (H (Set.mem_range_self x)).choose_spec.symm⟩⟩
        left_inv := fun ⟨_, _⟩ => rfl
        right_inv := fun x => rfl }
  convert is_iso.of_iso (iso_of_homeo this)
  ext
  rfl
#align Top.fst_iso_of_right_embedding_range_subset TopCat.fst_iso_of_right_embedding_range_subset

/- warning: Top.snd_iso_of_left_embedding_range_subset -> TopCat.snd_iso_of_left_embedding_range_subset is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S}, (Embedding.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (TopCat.topologicalSpace.{u1} X) (TopCat.topologicalSpace.{u1} S) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) f)) -> (forall (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S), (HasSubset.Subset.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (Set.hasSubset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) g)) (Set.range.{u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X S) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) S) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} S)) f))) -> (CategoryTheory.IsIso.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y S f g)))))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {S : TopCat.{u1}} {f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X S}, (Embedding.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (TopCat.topologicalSpace_forget.{u1} X) (TopCat.topologicalSpace_forget.{u1} S) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X S f)) -> (forall (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y S), (HasSubset.Subset.{u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S)) (Set.instHasSubsetSet.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S)) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y S g)) (Set.range.{u1, succ u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) S) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X S f))) -> (CategoryTheory.IsIso.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y S f g)))))
Case conversion may be inaccurate. Consider using '#align Top.snd_iso_of_left_embedding_range_subset TopCat.snd_iso_of_left_embedding_range_subsetₓ'. -/
theorem snd_iso_of_left_embedding_range_subset {X Y S : TopCat} {f : X ⟶ S} (hf : Embedding f)
    (g : Y ⟶ S) (H : Set.range g ⊆ Set.range f) : IsIso (pullback.snd : pullback f g ⟶ Y) :=
  by
  let this : (pullback f g : TopCat) ≃ₜ Y :=
    (Homeomorph.ofEmbedding _ (snd_embedding_of_left_embedding hf g)).trans
      { toFun := coe
        invFun := fun x =>
          ⟨x, by
            rw [pullback_snd_range]
            exact ⟨_, (H (Set.mem_range_self x)).choose_spec⟩⟩
        left_inv := fun ⟨_, _⟩ => rfl
        right_inv := fun x => rfl }
  convert is_iso.of_iso (iso_of_homeo this)
  ext
  rfl
#align Top.snd_iso_of_left_embedding_range_subset TopCat.snd_iso_of_left_embedding_range_subset

/- warning: Top.pullback_snd_image_fst_preimage -> TopCat.pullback_snd_image_fst_preimage is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (U : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} X)), Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (Set.image.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (Set.preimage.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) U)) (Set.preimage.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g) (Set.image.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f) U))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z) (U : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} X)), Eq.{succ u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y)) (Set.image.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Set.preimage.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) U)) (Set.preimage.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g) (Set.image.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f) U))
Case conversion may be inaccurate. Consider using '#align Top.pullback_snd_image_fst_preimage TopCat.pullback_snd_image_fst_preimageₓ'. -/
theorem pullback_snd_image_fst_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set X) :
    (pullback.snd : pullback f g ⟶ _) '' ((pullback.fst : pullback f g ⟶ _) ⁻¹' U) =
      g ⁻¹' (f '' U) :=
  by
  ext x
  constructor
  · rintro ⟨y, hy, rfl⟩
    exact
      ⟨(pullback.fst : pullback f g ⟶ _) y, hy, concrete_category.congr_hom pullback.condition y⟩
  · rintro ⟨y, hy, eq⟩
    exact ⟨(TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨_, _⟩, Eq⟩, by simpa, by simp⟩
#align Top.pullback_snd_image_fst_preimage TopCat.pullback_snd_image_fst_preimage

/- warning: Top.pullback_fst_image_snd_preimage -> TopCat.pullback_fst_image_snd_preimage is a dubious translation:
lean 3 declaration is
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (U : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} Y)), Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (Set.image.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) X) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X)) (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (Set.preimage.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g))) Y) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y)) (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} X Y Z f g)))) U)) (Set.preimage.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) X Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) X) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} X) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) f) (Set.image.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) Y Z) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z)) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Y) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) Z) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Y) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} Z)) g) U))
but is expected to have type
  forall {X : TopCat.{u1}} {Y : TopCat.{u1}} {Z : TopCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) X Z) (g : Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Y Z) (U : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} Y)), Eq.{succ u1} (Set.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X)) (Set.image.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) X (CategoryTheory.Limits.pullback.fst.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Set.preimage.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.pullback.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g))) Y (CategoryTheory.Limits.pullback.snd.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingCospan (CategoryTheory.Limits.WidePullbackShape.category.{0} CategoryTheory.Limits.WalkingPair) (CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks.{u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (fun (J : Type.{u1}) => CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) TopCat.topCat_hasLimits.{u1})) (CategoryTheory.Limits.cospan.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} X Y Z f g)))) U)) (Set.preimage.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) X Z f) (Set.image.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Z) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) Y Z g) U))
Case conversion may be inaccurate. Consider using '#align Top.pullback_fst_image_snd_preimage TopCat.pullback_fst_image_snd_preimageₓ'. -/
theorem pullback_fst_image_snd_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set Y) :
    (pullback.fst : pullback f g ⟶ _) '' ((pullback.snd : pullback f g ⟶ _) ⁻¹' U) =
      f ⁻¹' (g '' U) :=
  by
  ext x
  constructor
  · rintro ⟨y, hy, rfl⟩
    exact
      ⟨(pullback.snd : pullback f g ⟶ _) y, hy,
        (concrete_category.congr_hom pullback.condition y).symm⟩
  · rintro ⟨y, hy, eq⟩
    exact ⟨(TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨_, _⟩, Eq.symm⟩, by simpa, by simp⟩
#align Top.pullback_fst_image_snd_preimage TopCat.pullback_fst_image_snd_preimage

end Pullback

/- warning: Top.coinduced_of_is_colimit -> TopCat.coinduced_of_isColimit is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.SmallCategory.{u2} J] {F : CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}} (c : CategoryTheory.Limits.Cocone.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F), (CategoryTheory.Limits.IsColimit.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c) -> (Eq.{succ (max u2 u1)} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c))) (TopCat.topologicalSpace.{max u2 u1} (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c)) (iSup.{max u2 u1, succ u2} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c))) (ConditionallyCompleteLattice.toHasSup.{max u2 u1} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u1} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c))) (TopologicalSpace.completeLattice.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c))))) J (fun (j : J) => TopologicalSpace.coinduced.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c)) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c)) j)) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c)) j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c)) j))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c)) j))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c)) j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c)) j))) (CategoryTheory.NatTrans.app.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, succ (max u2 u1), max u2 (max u2 u1) u2 (succ (max u2 u1))} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} (CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (CategoryTheory.Limits.Cocone.pt.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c)) (CategoryTheory.Limits.Cocone.ι.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F c) j)) (TopCat.topologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)))))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] {F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}} (c : CategoryTheory.Limits.Cocone.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F), (CategoryTheory.Limits.IsColimit.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c) -> (Eq.{max (succ u2) (succ u1)} (TopologicalSpace.{max u1 u2} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c)) (iSup.{max u2 u1, succ u1} (TopologicalSpace.{max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c))) (ConditionallyCompleteLattice.toSupSet.{max u2 u1} (TopologicalSpace.{max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u1} (TopologicalSpace.{max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c))) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c))))) J (fun (j : J) => TopologicalSpace.coinduced.{max u2 u1, max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j)) (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c)) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c))) j) (CategoryTheory.NatTrans.app.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (Prefunctor.obj.{succ (max u2 u1), max (succ u1) (succ (max u2 u1)), max (succ u2) (succ u1), max (max u2 u1) (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u1 (succ u2) (succ u1)) u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max (succ u2) (succ u1), max (max u1 (succ u2) (succ u1)) u2 u1} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} (CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.category.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (CategoryTheory.Functor.const.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Limits.Cocone.pt.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c)) (CategoryTheory.Limits.Cocone.ι.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F c) j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j)))))
Case conversion may be inaccurate. Consider using '#align Top.coinduced_of_is_colimit TopCat.coinduced_of_isColimitₓ'. -/
theorem coinduced_of_isColimit {F : J ⥤ TopCat.{max v u}} (c : Cocone F) (hc : IsColimit c) :
    c.pt.TopologicalSpace = ⨆ j, (F.obj j).TopologicalSpace.coinduced (c.ι.app j) :=
  by
  let homeo := homeo_of_iso (hc.cocone_point_unique_up_to_iso (colimit_cocone_is_colimit F))
  ext
  refine' homeo.symm.is_open_preimage.symm.trans (Iff.trans _ is_open_supr_iff.symm)
  exact isOpen_iSup_iff
#align Top.coinduced_of_is_colimit TopCat.coinduced_of_isColimit

/- warning: Top.colimit_topology -> TopCat.colimit_topology is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.SmallCategory.{u2} J] (F : CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}), Eq.{succ (max u2 u1)} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (TopCat.topologicalSpace.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (iSup.{max u2 u1, succ u2} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (ConditionallyCompleteLattice.toHasSup.{max u2 u1} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u1} (TopologicalSpace.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (TopologicalSpace.completeLattice.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))))) J (fun (j : J) => TopologicalSpace.coinduced.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j) (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (CategoryTheory.Limits.colimit.ι.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F) j)) (TopCat.topologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j))))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}), Eq.{max (succ u2) (succ u1)} (TopologicalSpace.{max u1 u2} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (iSup.{max u2 u1, succ u1} (TopologicalSpace.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (ConditionallyCompleteLattice.toSupSet.{max u2 u1} (TopologicalSpace.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u1} (TopologicalSpace.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))))) J (fun (j : J) => TopologicalSpace.coinduced.{max u2 u1, max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j)) (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)) (CategoryTheory.Limits.colimit.ι.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F) j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u1 u2} (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j))))
Case conversion may be inaccurate. Consider using '#align Top.colimit_topology TopCat.colimit_topologyₓ'. -/
theorem colimit_topology (F : J ⥤ TopCat.{max v u}) :
    (colimit F).TopologicalSpace = ⨆ j, (F.obj j).TopologicalSpace.coinduced (colimit.ι F j) :=
  coinduced_of_isColimit _ (colimit.isColimit F)
#align Top.colimit_topology TopCat.colimit_topology

/- warning: Top.colimit_is_open_iff -> TopCat.colimit_isOpen_iff is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.SmallCategory.{u2} J] (F : CategoryTheory.Functor.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1}) (U : Set.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))), Iff (IsOpen.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} TopCat.{max u2 u1} Type.{max u2 u1} TopCat.hasCoeToSort.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (TopCat.topologicalSpace.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) U) (forall (j : J), IsOpen.{max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (TopCat.topologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (Set.preimage.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1})) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j) (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (fun (_x : ContinuousMap.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) => (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) -> (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (ContinuousMap.hasCoeToFun.{max u2 u1, max u2 u1} (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (coeSort.{succ (succ (max u2 u1)), succ (succ (max u2 u1))} (CategoryTheory.Bundled.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) Type.{max u2 u1} (CategoryTheory.Bundled.hasCoeToSort.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1}) (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Functor.obj.{u2, max u2 u1, u2, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F j)) (CategoryTheory.Bundled.str.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.colimit.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))) (CategoryTheory.Limits.colimit.ι.{u2, u2, max u2 u1, succ (max u2 u1)} J _inst_1 TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u2, u2, max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} TopCat.largeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F) j)) U))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] (F : CategoryTheory.Functor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1}) (U : Set.{max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)))), Iff (IsOpen.{max u2 u1} (CategoryTheory.Bundled.α.{max u2 u1, max u2 u1} TopologicalSpace.{max u2 u1} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (TopCat.topologicalSpace_coe.{max u2 u1} (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) U) (forall (j : J), IsOpen.{max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j)) (TopCat.topologicalSpace_forget.{max u2 u1} (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j)) (Set.preimage.{max u2 u1, max u2 u1} (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j)) (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F))) (Prefunctor.map.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1})) Type.{max u2 u1} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, succ (max u2 u1)} Type.{max u2 u1} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, succ (max u2 u1), succ (max u2 u1)} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} Type.{max u2 u1} CategoryTheory.types.{max u2 u1} (CategoryTheory.forget.{succ (max u2 u1), max u2 u1, max u2 u1} TopCat.{max u2 u1} instTopCatLargeCategory.{max u2 u1} TopCat.concreteCategory.{max u2 u1})) (Prefunctor.obj.{succ u1, succ (max u2 u1), u1, max (succ u2) (succ u1)} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) TopCatMax.{u1, u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F) j) (CategoryTheory.Limits.colimit.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F)) (CategoryTheory.Limits.colimit.ι.{u1, u1, max u2 u1, max (succ u2) (succ u1)} J _inst_1 TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, max u2 u1, max (succ u2) (succ u1)} TopCatMax.{u1, u2} instTopCatLargeCategory.{max u2 u1} J _inst_1 TopCat.topCat_hasColimitsOfSize.{u1, u2}) F) j)) U))
Case conversion may be inaccurate. Consider using '#align Top.colimit_is_open_iff TopCat.colimit_isOpen_iffₓ'. -/
theorem colimit_isOpen_iff (F : J ⥤ TopCat.{max v u}) (U : Set ((colimit F : _) : Type max v u)) :
    IsOpen U ↔ ∀ j, IsOpen (colimit.ι F j ⁻¹' U) :=
  by
  conv_lhs => rw [colimit_topology F]
  exact isOpen_iSup_iff
#align Top.colimit_is_open_iff TopCat.colimit_isOpen_iff

/- warning: Top.coequalizer_is_open_iff -> TopCat.coequalizer_isOpen_iff is a dubious translation:
lean 3 declaration is
  forall (F : CategoryTheory.Functor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1}) (U : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F)))), Iff (IsOpen.{u1} (coeSort.{succ (succ u1), succ (succ u1)} TopCat.{u1} Type.{u1} TopCat.hasCoeToSort.{u1} (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F))) (TopCat.topologicalSpace.{u1} (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F))) U) (IsOpen.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F CategoryTheory.Limits.WalkingParallelPair.one)) (TopCat.topologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F CategoryTheory.Limits.WalkingParallelPair.one)) (Set.preimage.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F CategoryTheory.Limits.WalkingParallelPair.one)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F))) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1})) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F))) (fun (_x : ContinuousMap.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F CategoryTheory.Limits.WalkingParallelPair.one)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F CategoryTheory.Limits.WalkingParallelPair.one)) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F CategoryTheory.Limits.WalkingParallelPair.one)) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F)))) (ContinuousMap.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F CategoryTheory.Limits.WalkingParallelPair.one)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} TopologicalSpace.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} TopologicalSpace.{u1}) (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F))) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Functor.obj.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F CategoryTheory.Limits.WalkingParallelPair.one)) (CategoryTheory.Bundled.str.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F)))) (CategoryTheory.Limits.colimit.ι.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} TopCat.largeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} TopCat.largeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{u1, 0}) F) CategoryTheory.Limits.WalkingParallelPair.one)) U))
but is expected to have type
  forall (F : CategoryTheory.Functor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1}) (U : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{0, u1}) F)))), Iff (IsOpen.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{0, u1}) F))) (TopCat.topologicalSpace_coe.{u1} (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{0, u1}) F))) U) (IsOpen.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1} F) CategoryTheory.Limits.WalkingParallelPair.one)) (TopCat.topologicalSpace_forget.{u1} (Prefunctor.obj.{1, succ u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1} F) CategoryTheory.Limits.WalkingParallelPair.one)) (Set.preimage.{u1, u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1} F) CategoryTheory.Limits.WalkingParallelPair.one)) (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{0, u1}) F))) (Prefunctor.map.{succ u1, succ u1, succ u1, succ u1} TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.forget.{succ u1, u1, u1} TopCat.{u1} instTopCatLargeCategory.{u1} TopCat.concreteCategory.{u1})) (Prefunctor.obj.{1, succ u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) TopCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} TopCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1})) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1} F) CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.Limits.colimit.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{0, u1}) F)) (CategoryTheory.Limits.colimit.ι.{0, 0, u1, succ u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.{u1} instTopCatLargeCategory.{u1} F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{0, 0, u1, succ u1} TopCat.{u1} instTopCatLargeCategory.{u1} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory TopCat.topCat_hasColimitsOfSize.{0, u1}) F) CategoryTheory.Limits.WalkingParallelPair.one)) U))
Case conversion may be inaccurate. Consider using '#align Top.coequalizer_is_open_iff TopCat.coequalizer_isOpen_iffₓ'. -/
theorem coequalizer_isOpen_iff (F : WalkingParallelPair ⥤ TopCat.{u})
    (U : Set ((colimit F : _) : Type u)) :
    IsOpen U ↔ IsOpen (colimit.ι F WalkingParallelPair.one ⁻¹' U) :=
  by
  rw [colimit_isOpen_iff.{u}]
  constructor
  · intro H
    exact H _
  · intro H j
    cases j
    · rw [← colimit.w F walking_parallel_pair_hom.left]
      exact (F.map walking_parallel_pair_hom.left).continuous_toFun.isOpen_preimage _ H
    · exact H
#align Top.coequalizer_is_open_iff TopCat.coequalizer_isOpen_iff

end TopCat

