/-
Copyright (c) 2021 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov

! This file was ported from Lean 3 source module topology.partition_of_unity
! leanprover-community/mathlib commit a2706b55e8d7f7e9b1f93143f0b88f2e34a11eea
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.BigOperators.Finprod
import Mathbin.SetTheory.Ordinal.Basic
import Mathbin.Topology.ContinuousFunction.Algebra
import Mathbin.Topology.Paracompact
import Mathbin.Topology.ShrinkingLemma
import Mathbin.Topology.UrysohnsLemma

/-!
# Continuous partition of unity

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define `partition_of_unity (Œπ X : Type*) [topological_space X] (s : set X := univ)`
to be a continuous partition of unity on `s` indexed by `Œπ`. More precisely, `f : partition_of_unity
Œπ X s` is a collection of continuous functions `f i : C(X, ‚Ñù)`, `i : Œπ`, such that

* the supports of `f i` form a locally finite family of sets;
* each `f i` is nonnegative;
* `‚àë·∂† i, f i x = 1` for all `x ‚àà s`;
* `‚àë·∂† i, f i x ‚â§ 1` for all `x : X`.

In the case `s = univ` the last assumption follows from the previous one but it is convenient to
have this assumption in the case `s ‚â† univ`.

We also define a bump function covering,
`bump_covering (Œπ X : Type*) [topological_space X] (s : set X := univ)`, to be a collection of
functions `f i : C(X, ‚Ñù)`, `i : Œπ`, such that

* the supports of `f i` form a locally finite family of sets;
* each `f i` is nonnegative;
* for each `x ‚àà s` there exists `i : Œπ` such that `f i y = 1` in a neighborhood of `x`.

The term is motivated by the smooth case.

If `f` is a bump function covering indexed by a linearly ordered type, then
`g i x = f i x * ‚àè·∂† j < i, (1 - f j x)` is a partition of unity, see
`bump_covering.to_partition_of_unity`. Note that only finitely many terms `1 - f j x` are not equal
to one, so this product is well-defined.

Note that `g i x = ‚àè·∂† j ‚â§ i, (1 - f j x) - ‚àè·∂† j < i, (1 - f j x)`, so most terms in the sum
`‚àë·∂† i, g i x` cancel, and we get `‚àë·∂† i, g i x = 1 - ‚àè·∂† i, (1 - f i x)`, and the latter product
equals zero because one of `f i x` is equal to one.

We say that a partition of unity or a bump function covering `f` is *subordinate* to a family of
sets `U i`, `i : Œπ`, if the closure of the support of each `f i` is included in `U i`. We use
Urysohn's Lemma to prove that a locally finite open covering of a normal topological space admits a
subordinate bump function covering (hence, a subordinate partition of unity), see
`bump_covering.exists_is_subordinate_of_locally_finite`. If `X` is a paracompact space, then any
open covering admits a locally finite refinement, hence it admits a subordinate bump function
covering and a subordinate partition of unity, see `bump_covering.exists_is_subordinate`.

We also provide two slightly more general versions of these lemmas,
`bump_covering.exists_is_subordinate_of_locally_finite_of_prop` and
`bump_covering.exists_is_subordinate_of_prop`, to be used later in the construction of a smooth
partition of unity.

## Implementation notes

Most (if not all) books only define a partition of unity of the whole space. However, quite a few
proofs only deal with `f i` such that `tsupport (f i)` meets a specific closed subset, and
it is easier to formalize these proofs if we don't have other functions right away.

We use `well_ordering_rel j i` instead of `j < i` in the definition of
`bump_covering.to_partition_of_unity` to avoid a `[linear_order Œπ]` assumption. While
`well_ordering_rel j i` is a well order, not only a strict linear order, we never use this property.

## Tags

partition of unity, bump function, Urysohn's lemma, normal space, paracompact space
-/


universe u v

open Function Set Filter

open BigOperators Topology Classical

noncomputable section

#print PartitionOfUnity /-
/-- A continuous partition of unity on a set `s : set X` is a collection of continuous functions
`f i` such that

* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there
  exists a neighborhood `U ‚àã x` such that all but finitely many functions `f i` are zero on `U`;
* the functions `f i` are nonnegative;
* the sum `‚àë·∂† i, f i x` is equal to one for every `x ‚àà s` and is less than or equal to one
  otherwise.

If `X` is a normal paracompact space, then `partition_of_unity.exists_is_subordinate` guarantees
that for every open covering `U : set (set X)` of `s` there exists a partition of unity that is
subordinate to `U`.
-/
structure PartitionOfUnity (Œπ X : Type _) [TopologicalSpace X] (s : Set X := univ) where
  toFun : Œπ ‚Üí C(X, ‚Ñù)
  locally_finite' : LocallyFinite fun i => support (to_fun i)
  nonneg' : 0 ‚â§ to_fun
  sum_eq_one' : ‚àÄ x ‚àà s, (‚àë·∂† i, to_fun i x) = 1
  sum_le_one' : ‚àÄ x, (‚àë·∂† i, to_fun i x) ‚â§ 1
#align partition_of_unity PartitionOfUnity
-/

#print BumpCovering /-
/-- A `bump_covering Œπ X s` is an indexed family of functions `f i`, `i : Œπ`, such that

* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there
  exists a neighborhood `U ‚àã x` such that all but finitely many functions `f i` are zero on `U`;
* for all `i`, `x` we have `0 ‚â§ f i x ‚â§ 1`;
* each point `x ‚àà s` belongs to the interior of `{x | f i x = 1}` for some `i`.

One of the main use cases for a `bump_covering` is to define a `partition_of_unity`, see
`bump_covering.to_partition_of_unity`, but some proofs can directly use a `bump_covering` instead of
a `partition_of_unity`.

If `X` is a normal paracompact space, then `bump_covering.exists_is_subordinate` guarantees that for
every open covering `U : set (set X)` of `s` there exists a `bump_covering` of `s` that is
subordinate to `U`.
-/
structure BumpCovering (Œπ X : Type _) [TopologicalSpace X] (s : Set X := univ) where
  toFun : Œπ ‚Üí C(X, ‚Ñù)
  locally_finite' : LocallyFinite fun i => support (to_fun i)
  nonneg' : 0 ‚â§ to_fun
  le_one' : to_fun ‚â§ 1
  eventuallyEq_one' : ‚àÄ x ‚àà s, ‚àÉ i, to_fun i =·∂†[ùìù x] 1
#align bump_covering BumpCovering
-/

variable {Œπ : Type u} {X : Type v} [TopologicalSpace X]

namespace PartitionOfUnity

variable {E : Type _} [AddCommMonoid E] [SMulWithZero ‚Ñù E] [TopologicalSpace E] [ContinuousSMul ‚Ñù E]
  {s : Set X} (f : PartitionOfUnity Œπ X s)

instance : CoeFun (PartitionOfUnity Œπ X s) fun _ => Œπ ‚Üí C(X, ‚Ñù) :=
  ‚ü®toFun‚ü©

/- warning: partition_of_unity.locally_finite -> PartitionOfUnity.locallyFinite is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s), LocallyFinite.{u1, u2} Œπ X _inst_1 (fun (i : Œπ) => Function.support.{u2, 0} X Real Real.hasZero (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s), LocallyFinite.{u1, u2} Œπ X _inst_1 (fun (i : Œπ) => Function.support.{u2, 0} X Real Real.instZeroReal (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s f i)))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.locally_finite PartitionOfUnity.locallyFinite‚Çì'. -/
protected theorem locallyFinite : LocallyFinite fun i => support (f i) :=
  f.locally_finite'
#align partition_of_unity.locally_finite PartitionOfUnity.locallyFinite

/- warning: partition_of_unity.locally_finite_tsupport -> PartitionOfUnity.locallyFinite_tsupport is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s), LocallyFinite.{u1, u2} Œπ X _inst_1 (fun (i : Œπ) => tsupport.{u2, 0} X Real Real.hasZero _inst_1 (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s), LocallyFinite.{u1, u2} Œπ X _inst_1 (fun (i : Œπ) => tsupport.{u2, 0} X Real Real.instZeroReal _inst_1 (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s f i)))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.locally_finite_tsupport PartitionOfUnity.locallyFinite_tsupport‚Çì'. -/
theorem locallyFinite_tsupport : LocallyFinite fun i => tsupport (f i) :=
  f.LocallyFinite.closure
#align partition_of_unity.locally_finite_tsupport PartitionOfUnity.locallyFinite_tsupport

/- warning: partition_of_unity.nonneg -> PartitionOfUnity.nonneg is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x)
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), LE.le.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instLEReal (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal)) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s f i) x)
Case conversion may be inaccurate. Consider using '#align partition_of_unity.nonneg PartitionOfUnity.nonneg‚Çì'. -/
theorem nonneg (i : Œπ) (x : X) : 0 ‚â§ f i x :=
  f.nonneg' i x
#align partition_of_unity.nonneg PartitionOfUnity.nonneg

/- warning: partition_of_unity.sum_eq_one -> PartitionOfUnity.sum_eq_one is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) {x : X}, (Membership.Mem.{u2, u2} X (Set.{u2} X) (Set.hasMem.{u2} X) x s) -> (Eq.{1} Real (finsum.{0, succ u1} Real Œπ Real.addCommMonoid (fun (i : Œπ) => coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) {x : X}, (Membership.mem.{u2, u2} X (Set.{u2} X) (Set.instMembershipSet.{u2} X) x s) -> (Eq.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (finsum.{0, succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Œπ Real.instAddCommMonoidReal (fun (i : Œπ) => FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s f i) x)) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal)))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.sum_eq_one PartitionOfUnity.sum_eq_one‚Çì'. -/
theorem sum_eq_one {x : X} (hx : x ‚àà s) : (‚àë·∂† i, f i x) = 1 :=
  f.sum_eq_one' x hx
#align partition_of_unity.sum_eq_one PartitionOfUnity.sum_eq_one

/- warning: partition_of_unity.exists_pos -> PartitionOfUnity.exists_pos is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) {x : X}, (Membership.Mem.{u2, u2} X (Set.{u2} X) (Set.hasMem.{u2} X) x s) -> (Exists.{succ u1} Œπ (fun (i : Œπ) => LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) {x : X}, (Membership.mem.{u2, u2} X (Set.{u2} X) (Set.instMembershipSet.{u2} X) x s) -> (Exists.{succ u1} Œπ (fun (i : Œπ) => LT.lt.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instLTReal (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal)) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s f i) x)))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.exists_pos PartitionOfUnity.exists_pos‚Çì'. -/
/-- If `f` is a partition of unity on `s`, then for every `x ‚àà s` there exists an index `i` such
that `0 < f i x`. -/
theorem exists_pos {x : X} (hx : x ‚àà s) : ‚àÉ i, 0 < f i x :=
  by
  have H := f.sum_eq_one hx
  contrapose! H
  simpa only [fun i => (H i).antisymm (f.nonneg i x), finsum_zero] using zero_ne_one
#align partition_of_unity.exists_pos PartitionOfUnity.exists_pos

/- warning: partition_of_unity.sum_le_one -> PartitionOfUnity.sum_le_one is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (x : X), LE.le.{0} Real Real.hasLe (finsum.{0, succ u1} Real Œπ Real.addCommMonoid (fun (i : Œπ) => coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x)) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (x : X), LE.le.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instLEReal (finsum.{0, succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Œπ Real.instAddCommMonoidReal (fun (i : Œπ) => FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s f i) x)) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.sum_le_one PartitionOfUnity.sum_le_one‚Çì'. -/
theorem sum_le_one (x : X) : (‚àë·∂† i, f i x) ‚â§ 1 :=
  f.sum_le_one' x
#align partition_of_unity.sum_le_one PartitionOfUnity.sum_le_one

/- warning: partition_of_unity.sum_nonneg -> PartitionOfUnity.sum_nonneg is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (x : X), LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (finsum.{0, succ u1} Real Œπ Real.addCommMonoid (fun (i : Œπ) => coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (x : X), LE.le.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instLEReal (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal)) (finsum.{0, succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Œπ Real.instAddCommMonoidReal (fun (i : Œπ) => FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s f i) x))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.sum_nonneg PartitionOfUnity.sum_nonneg‚Çì'. -/
theorem sum_nonneg (x : X) : 0 ‚â§ ‚àë·∂† i, f i x :=
  finsum_nonneg fun i => f.NonNeg i x
#align partition_of_unity.sum_nonneg PartitionOfUnity.sum_nonneg

/- warning: partition_of_unity.le_one -> PartitionOfUnity.le_one is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), LE.le.{0} Real Real.hasLe (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), LE.le.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instLEReal (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s f i) x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.le_one PartitionOfUnity.le_one‚Çì'. -/
theorem le_one (i : Œπ) (x : X) : f i x ‚â§ 1 :=
  (single_le_finsum i (f.LocallyFinite.point_finite x) fun j => f.NonNeg j x).trans (f.sum_le_one x)
#align partition_of_unity.le_one PartitionOfUnity.le_one

/- warning: partition_of_unity.continuous_smul -> PartitionOfUnity.continuous_smul is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {E : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : SMulWithZero.{0, u3} Real E Real.hasZero (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)))] [_inst_4 : TopologicalSpace.{u3} E] [_inst_5 : ContinuousSMul.{0, u3} Real E (SMulZeroClass.toHasSmul.{0, u3} Real E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) (SMulWithZero.toSmulZeroClass.{0, u3} Real E Real.hasZero (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) _inst_3)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_4] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) {g : X -> E} {i : Œπ}, (forall (x : X), (Membership.Mem.{u2, u2} X (Set.{u2} X) (Set.hasMem.{u2} X) x (tsupport.{u2, 0} X Real Real.hasZero _inst_1 (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i)))) -> (ContinuousAt.{u2, u3} X E _inst_1 _inst_4 g x)) -> (Continuous.{u2, u3} X E _inst_1 _inst_4 (fun (x : X) => SMul.smul.{0, u3} Real E (SMulZeroClass.toHasSmul.{0, u3} Real E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) (SMulWithZero.toSmulZeroClass.{0, u3} Real E Real.hasZero (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) _inst_3)) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (g x)))
but is expected to have type
  forall {Œπ : Type.{u2}} {X : Type.{u3}} [_inst_1 : TopologicalSpace.{u3} X] {E : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : SMulWithZero.{0, u1} Real E Real.instZeroReal (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2))] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : ContinuousSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) _inst_3)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_4] {s : Set.{u3} X} (f : PartitionOfUnity.{u2, u3} Œπ X _inst_1 s) {g : X -> E} {i : Œπ}, (forall (x : X), (Membership.mem.{u3, u3} X (Set.{u3} X) (Set.instMembershipSet.{u3} X) x (tsupport.{u3, 0} X Real Real.instZeroReal _inst_1 (FunLike.coe.{succ u3, succ u3, 1} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u3, u3, 0} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u2, u3} Œπ X _inst_1 s f i)))) -> (ContinuousAt.{u3, u1} X E _inst_1 _inst_4 g x)) -> (Continuous.{u3, u1} X E _inst_1 _inst_4 (fun (x : X) => HSMul.hSMul.{0, u1, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E E (instHSMul.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E (SMulZeroClass.toSMul.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E Real.instZeroReal (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) _inst_3))) (FunLike.coe.{succ u3, succ u3, 1} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u3, u3, 0} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u2, u3} Œπ X _inst_1 s f i) x) (g x)))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.continuous_smul PartitionOfUnity.continuous_smul‚Çì'. -/
/-- If `f` is a partition of unity on `s : set X` and `g : X ‚Üí E` is continuous at every point of
the topological support of some `f i`, then `Œª x, f i x ‚Ä¢ g x` is continuous on the whole space. -/
theorem continuous_smul {g : X ‚Üí E} {i : Œπ} (hg : ‚àÄ x ‚àà tsupport (f i), ContinuousAt g x) :
    Continuous fun x => f i x ‚Ä¢ g x :=
  continuous_of_tsupport fun x hx =>
    ((f i).ContinuousAt x).smul <| hg x <| tsupport_smul_subset_left _ _ hx
#align partition_of_unity.continuous_smul PartitionOfUnity.continuous_smul

/- warning: partition_of_unity.continuous_finsum_smul -> PartitionOfUnity.continuous_finsum_smul is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {E : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : SMulWithZero.{0, u3} Real E Real.hasZero (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)))] [_inst_4 : TopologicalSpace.{u3} E] [_inst_5 : ContinuousSMul.{0, u3} Real E (SMulZeroClass.toHasSmul.{0, u3} Real E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) (SMulWithZero.toSmulZeroClass.{0, u3} Real E Real.hasZero (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) _inst_3)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_4] {s : Set.{u2} X} (f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) [_inst_6 : ContinuousAdd.{u3} E _inst_4 (AddZeroClass.toHasAdd.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)))] {g : Œπ -> X -> E}, (forall (i : Œπ) (x : X), (Membership.Mem.{u2, u2} X (Set.{u2} X) (Set.hasMem.{u2} X) x (tsupport.{u2, 0} X Real Real.hasZero _inst_1 (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i)))) -> (ContinuousAt.{u2, u3} X E _inst_1 _inst_4 (g i) x)) -> (Continuous.{u2, u3} X E _inst_1 _inst_4 (fun (x : X) => finsum.{u3, succ u1} E Œπ _inst_2 (fun (i : Œπ) => SMul.smul.{0, u3} Real E (SMulZeroClass.toHasSmul.{0, u3} Real E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) (SMulWithZero.toSmulZeroClass.{0, u3} Real E Real.hasZero (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) _inst_3)) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (g i x))))
but is expected to have type
  forall {Œπ : Type.{u2}} {X : Type.{u3}} [_inst_1 : TopologicalSpace.{u3} X] {E : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : SMulWithZero.{0, u1} Real E Real.instZeroReal (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2))] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : ContinuousSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) _inst_3)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_4] {s : Set.{u3} X} (f : PartitionOfUnity.{u2, u3} Œπ X _inst_1 s) [_inst_6 : ContinuousAdd.{u1} E _inst_4 (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))] {g : Œπ -> X -> E}, (forall (i : Œπ) (x : X), (Membership.mem.{u3, u3} X (Set.{u3} X) (Set.instMembershipSet.{u3} X) x (tsupport.{u3, 0} X Real Real.instZeroReal _inst_1 (FunLike.coe.{succ u3, succ u3, 1} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u3, u3, 0} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u2, u3} Œπ X _inst_1 s f i)))) -> (ContinuousAt.{u3, u1} X E _inst_1 _inst_4 (g i) x)) -> (Continuous.{u3, u1} X E _inst_1 _inst_4 (fun (x : X) => finsum.{u1, succ u2} E Œπ _inst_2 (fun (i : Œπ) => HSMul.hSMul.{0, u1, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E E (instHSMul.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E (SMulZeroClass.toSMul.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E Real.instZeroReal (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) _inst_3))) (FunLike.coe.{succ u3, succ u3, 1} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u3, u3, 0} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u2, u3} Œπ X _inst_1 s f i) x) (g i x))))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.continuous_finsum_smul PartitionOfUnity.continuous_finsum_smul‚Çì'. -/
/-- If `f` is a partition of unity on a set `s : set X` and `g : Œπ ‚Üí X ‚Üí E` is a family of functions
such that each `g i` is continuous at every point of the topological support of `f i`, then the sum
`Œª x, ‚àë·∂† i, f i x ‚Ä¢ g i x` is continuous on the whole space. -/
theorem continuous_finsum_smul [ContinuousAdd E] {g : Œπ ‚Üí X ‚Üí E}
    (hg : ‚àÄ (i), ‚àÄ x ‚àà tsupport (f i), ContinuousAt (g i) x) :
    Continuous fun x => ‚àë·∂† i, f i x ‚Ä¢ g i x :=
  (continuous_finsum fun i => f.continuous_smul (hg i)) <|
    f.LocallyFinite.Subset fun i => support_smul_subset_left _ _
#align partition_of_unity.continuous_finsum_smul PartitionOfUnity.continuous_finsum_smul

#print PartitionOfUnity.IsSubordinate /-
/-- A partition of unity `f i` is subordinate to a family of sets `U i` indexed by the same type if
for each `i` the closure of the support of `f i` is a subset of `U i`. -/
def IsSubordinate (U : Œπ ‚Üí Set X) : Prop :=
  ‚àÄ i, tsupport (f i) ‚äÜ U i
#align partition_of_unity.is_subordinate PartitionOfUnity.IsSubordinate
-/

variable {f}

/- warning: partition_of_unity.exists_finset_nhd_support_subset -> PartitionOfUnity.exists_finset_nhd_support_subset is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} {f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s} {U : Œπ -> (Set.{u2} X)}, (PartitionOfUnity.IsSubordinate.{u1, u2} Œπ X _inst_1 s f U) -> (forall (i : Œπ), IsOpen.{u2} X _inst_1 (U i)) -> (forall (x : X), Exists.{succ u1} (Finset.{u1} Œπ) (fun (is : Finset.{u1} Œπ) => Exists.{succ u2} (Set.{u2} X) (fun {n : Set.{u2} X} => Exists.{0} (Membership.Mem.{u2, u2} (Set.{u2} X) (Filter.{u2} X) (Filter.hasMem.{u2} X) n (nhds.{u2} X _inst_1 x)) (fun (hn‚ÇÅ : Membership.Mem.{u2, u2} (Set.{u2} X) (Filter.{u2} X) (Filter.hasMem.{u2} X) n (nhds.{u2} X _inst_1 x)) => Exists.{0} (HasSubset.Subset.{u2} (Set.{u2} X) (Set.hasSubset.{u2} X) n (Set.inter·µ¢.{u2, succ u1} X Œπ (fun (i : Œπ) => Set.inter·µ¢.{u2, 0} X (Membership.Mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.hasMem.{u1} Œπ) i is) (fun (H : Membership.Mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.hasMem.{u1} Œπ) i is) => U i)))) (fun (hn‚ÇÇ : HasSubset.Subset.{u2} (Set.{u2} X) (Set.hasSubset.{u2} X) n (Set.inter·µ¢.{u2, succ u1} X Œπ (fun (i : Œπ) => Set.inter·µ¢.{u2, 0} X (Membership.Mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.hasMem.{u1} Œπ) i is) (fun (H : Membership.Mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.hasMem.{u1} Œπ) i is) => U i)))) => forall (z : X), (Membership.Mem.{u2, u2} X (Set.{u2} X) (Set.hasMem.{u2} X) z n) -> (HasSubset.Subset.{u1} (Set.{u1} Œπ) (Set.hasSubset.{u1} Œπ) (Function.support.{u1, 0} Œπ Real Real.hasZero (fun (i : Œπ) => coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) z)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} Œπ) (Set.{u1} Œπ) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} Œπ) (Set.{u1} Œπ) (CoeTC‚Çì.coe.{succ u1, succ u1} (Finset.{u1} Œπ) (Set.{u1} Œπ) (Finset.Set.hasCoeT.{u1} Œπ))) is)))))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} {f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s} {U : Œπ -> (Set.{u2} X)}, (PartitionOfUnity.IsSubordinate.{u1, u2} Œπ X _inst_1 s f U) -> (forall (i : Œπ), IsOpen.{u2} X _inst_1 (U i)) -> (forall (x : X), Exists.{succ u1} (Finset.{u1} Œπ) (fun (is : Finset.{u1} Œπ) => Exists.{succ u2} (Set.{u2} X) (fun (n : Set.{u2} X) => Exists.{0} (Membership.mem.{u2, u2} (Set.{u2} X) (Filter.{u2} X) (instMembershipSetFilter.{u2} X) n (nhds.{u2} X _inst_1 x)) (fun (hn‚ÇÅ : Membership.mem.{u2, u2} (Set.{u2} X) (Filter.{u2} X) (instMembershipSetFilter.{u2} X) n (nhds.{u2} X _inst_1 x)) => Exists.{0} (HasSubset.Subset.{u2} (Set.{u2} X) (Set.instHasSubsetSet.{u2} X) n (Set.inter·µ¢.{u2, succ u1} X Œπ (fun (i : Œπ) => Set.inter·µ¢.{u2, 0} X (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i is) (fun (H : Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i is) => U i)))) (fun (hn‚ÇÇ : HasSubset.Subset.{u2} (Set.{u2} X) (Set.instHasSubsetSet.{u2} X) n (Set.inter·µ¢.{u2, succ u1} X Œπ (fun (i : Œπ) => Set.inter·µ¢.{u2, 0} X (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i is) (fun (H : Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) i is) => U i)))) => forall (z : X), (Membership.mem.{u2, u2} X (Set.{u2} X) (Set.instMembershipSet.{u2} X) z n) -> (HasSubset.Subset.{u1} (Set.{u1} Œπ) (Set.instHasSubsetSet.{u1} Œπ) (Function.support.{u1, 0} Œπ ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) z) Real.instZeroReal (fun (i : Œπ) => FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s f i) z)) (Finset.toSet.{u1} Œπ is)))))))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.exists_finset_nhd_support_subset PartitionOfUnity.exists_finset_nhd_support_subset‚Çì'. -/
theorem exists_finset_nhd_support_subset {U : Œπ ‚Üí Set X} (hso : f.IsSubordinate U)
    (ho : ‚àÄ i, IsOpen (U i)) (x : X) :
    ‚àÉ (is : Finset Œπ)(n : Set X)(hn‚ÇÅ : n ‚àà ùìù x)(hn‚ÇÇ : n ‚äÜ ‚ãÇ i ‚àà is, U i),
      ‚àÄ z ‚àà n, (support fun i => f i z) ‚äÜ is :=
  f.LocallyFinite.exists_finset_nhd_support_subset hso ho x
#align partition_of_unity.exists_finset_nhd_support_subset PartitionOfUnity.exists_finset_nhd_support_subset

/- warning: partition_of_unity.is_subordinate.continuous_finsum_smul -> PartitionOfUnity.IsSubordinate.continuous_finsum_smul is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {E : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} E] [_inst_3 : SMulWithZero.{0, u3} Real E Real.hasZero (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)))] [_inst_4 : TopologicalSpace.{u3} E] [_inst_5 : ContinuousSMul.{0, u3} Real E (SMulZeroClass.toHasSmul.{0, u3} Real E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) (SMulWithZero.toSmulZeroClass.{0, u3} Real E Real.hasZero (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) _inst_3)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_4] {s : Set.{u2} X} {f : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s} [_inst_6 : ContinuousAdd.{u3} E _inst_4 (AddZeroClass.toHasAdd.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2)))] {U : Œπ -> (Set.{u2} X)}, (forall (i : Œπ), IsOpen.{u2} X _inst_1 (U i)) -> (PartitionOfUnity.IsSubordinate.{u1, u2} Œπ X _inst_1 s f U) -> (forall {g : Œπ -> X -> E}, (forall (i : Œπ), ContinuousOn.{u2, u3} X E _inst_1 _inst_4 (g i) (U i)) -> (Continuous.{u2, u3} X E _inst_1 _inst_4 (fun (x : X) => finsum.{u3, succ u1} E Œπ _inst_2 (fun (i : Œπ) => SMul.smul.{0, u3} Real E (SMulZeroClass.toHasSmul.{0, u3} Real E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) (SMulWithZero.toSmulZeroClass.{0, u3} Real E Real.hasZero (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (AddCommMonoid.toAddMonoid.{u3} E _inst_2))) _inst_3)) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (g i x)))))
but is expected to have type
  forall {Œπ : Type.{u2}} {X : Type.{u3}} [_inst_1 : TopologicalSpace.{u3} X] {E : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} E] [_inst_3 : SMulWithZero.{0, u1} Real E Real.instZeroReal (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2))] [_inst_4 : TopologicalSpace.{u1} E] [_inst_5 : ContinuousSMul.{0, u1} Real E (SMulZeroClass.toSMul.{0, u1} Real E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{0, u1} Real E Real.instZeroReal (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) _inst_3)) (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) _inst_4] {s : Set.{u3} X} {f : PartitionOfUnity.{u2, u3} Œπ X _inst_1 s} [_inst_6 : ContinuousAdd.{u1} E _inst_4 (AddZeroClass.toAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)))] {U : Œπ -> (Set.{u3} X)}, (forall (i : Œπ), IsOpen.{u3} X _inst_1 (U i)) -> (PartitionOfUnity.IsSubordinate.{u2, u3} Œπ X _inst_1 s f U) -> (forall {g : Œπ -> X -> E}, (forall (i : Œπ), ContinuousOn.{u3, u1} X E _inst_1 _inst_4 (g i) (U i)) -> (Continuous.{u3, u1} X E _inst_1 _inst_4 (fun (x : X) => finsum.{u1, succ u2} E Œπ _inst_2 (fun (i : Œπ) => HSMul.hSMul.{0, u1, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E E (instHSMul.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E (SMulZeroClass.toSMul.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) (SMulWithZero.toSMulZeroClass.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) E Real.instZeroReal (AddMonoid.toZero.{u1} E (AddCommMonoid.toAddMonoid.{u1} E _inst_2)) _inst_3))) (FunLike.coe.{succ u3, succ u3, 1} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u3, u3, 0} (ContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u3, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u2, u3} Œπ X _inst_1 s f i) x) (g i x)))))
Case conversion may be inaccurate. Consider using '#align partition_of_unity.is_subordinate.continuous_finsum_smul PartitionOfUnity.IsSubordinate.continuous_finsum_smul‚Çì'. -/
/-- If `f` is a partition of unity that is subordinate to a family of open sets `U i` and
`g : Œπ ‚Üí X ‚Üí E` is a family of functions such that each `g i` is continuous on `U i`, then the sum
`Œª x, ‚àë·∂† i, f i x ‚Ä¢ g i x` is a continuous function. -/
theorem IsSubordinate.continuous_finsum_smul [ContinuousAdd E] {U : Œπ ‚Üí Set X}
    (ho : ‚àÄ i, IsOpen (U i)) (hf : f.IsSubordinate U) {g : Œπ ‚Üí X ‚Üí E}
    (hg : ‚àÄ i, ContinuousOn (g i) (U i)) : Continuous fun x => ‚àë·∂† i, f i x ‚Ä¢ g i x :=
  f.continuous_finsum_smul fun i x hx => (hg i).ContinuousAt <| (ho i).mem_nhds <| hf i hx
#align partition_of_unity.is_subordinate.continuous_finsum_smul PartitionOfUnity.IsSubordinate.continuous_finsum_smul

end PartitionOfUnity

namespace BumpCovering

variable {s : Set X} (f : BumpCovering Œπ X s)

instance : CoeFun (BumpCovering Œπ X s) fun _ => Œπ ‚Üí C(X, ‚Ñù) :=
  ‚ü®toFun‚ü©

/- warning: bump_covering.locally_finite -> BumpCovering.locallyFinite is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s), LocallyFinite.{u1, u2} Œπ X _inst_1 (fun (i : Œπ) => Function.support.{u2, 0} X Real Real.hasZero (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s), LocallyFinite.{u1, u2} Œπ X _inst_1 (fun (i : Œπ) => Function.support.{u2, 0} X Real Real.instZeroReal (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i)))
Case conversion may be inaccurate. Consider using '#align bump_covering.locally_finite BumpCovering.locallyFinite‚Çì'. -/
protected theorem locallyFinite : LocallyFinite fun i => support (f i) :=
  f.locally_finite'
#align bump_covering.locally_finite BumpCovering.locallyFinite

/- warning: bump_covering.locally_finite_tsupport -> BumpCovering.locallyFinite_tsupport is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s), LocallyFinite.{u1, u2} Œπ X _inst_1 (fun (i : Œπ) => tsupport.{u2, 0} X Real Real.hasZero _inst_1 (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s), LocallyFinite.{u1, u2} Œπ X _inst_1 (fun (i : Œπ) => tsupport.{u2, 0} X Real Real.instZeroReal _inst_1 (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i)))
Case conversion may be inaccurate. Consider using '#align bump_covering.locally_finite_tsupport BumpCovering.locallyFinite_tsupport‚Çì'. -/
theorem locallyFinite_tsupport : LocallyFinite fun i => tsupport (f i) :=
  f.LocallyFinite.closure
#align bump_covering.locally_finite_tsupport BumpCovering.locallyFinite_tsupport

/- warning: bump_covering.point_finite -> BumpCovering.point_finite is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (x : X), Set.Finite.{u1} Œπ (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{1} Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (x : X), Set.Finite.{u1} Œπ (setOf.{u1} Œπ (fun (i : Œπ) => Ne.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i) x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal))))
Case conversion may be inaccurate. Consider using '#align bump_covering.point_finite BumpCovering.point_finite‚Çì'. -/
protected theorem point_finite (x : X) : { i | f i x ‚â† 0 }.Finite :=
  f.LocallyFinite.point_finite x
#align bump_covering.point_finite BumpCovering.point_finite

/- warning: bump_covering.nonneg -> BumpCovering.nonneg is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x)
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), LE.le.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instLEReal (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal)) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i) x)
Case conversion may be inaccurate. Consider using '#align bump_covering.nonneg BumpCovering.nonneg‚Çì'. -/
theorem nonneg (i : Œπ) (x : X) : 0 ‚â§ f i x :=
  f.nonneg' i x
#align bump_covering.nonneg BumpCovering.nonneg

/- warning: bump_covering.le_one -> BumpCovering.le_one is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), LE.le.{0} Real Real.hasLe (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), LE.le.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instLEReal (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i) x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align bump_covering.le_one BumpCovering.le_one‚Çì'. -/
theorem le_one (i : Œπ) (x : X) : f i x ‚â§ 1 :=
  f.le_one' i x
#align bump_covering.le_one BumpCovering.le_one

#print BumpCovering.single /-
/-- A `bump_covering` that consists of a single function, uniformly equal to one, defined as an
example for `inhabited` instance. -/
protected def single (i : Œπ) (s : Set X) : BumpCovering Œπ X s
    where
  toFun := Pi.single i 1
  locally_finite' x := by
    refine' ‚ü®univ, univ_mem, (finite_singleton i).Subset _‚ü©
    rintro j ‚ü®x, hx, -‚ü©
    contrapose! hx
    rw [mem_singleton_iff] at hx
    simp [hx]
  nonneg' := le_update_iff.2 ‚ü®fun x => zero_le_one, fun _ _ => le_rfl‚ü©
  le_one' := update_le_iff.2 ‚ü®le_rfl, fun _ _ _ => zero_le_one‚ü©
  eventuallyEq_one' x _ := ‚ü®i, by simp‚ü©
#align bump_covering.single BumpCovering.single
-/

/- warning: bump_covering.coe_single -> BumpCovering.coe_single is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] (i : Œπ) (s : Set.{u2} X), Eq.{max (succ u1) (succ u2)} (Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) (BumpCovering.single.{u1, u2} Œπ X _inst_1 i s)) (Pi.single.{u1, u2} Œπ (fun (i : Œπ) => ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (a : Œπ) (b : Œπ) => Classical.propDecidable (Eq.{succ u1} Œπ a b)) (fun (i : Œπ) => ContinuousMap.hasZero.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.hasZero) i (OfNat.ofNat.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) 1 (OfNat.mk.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) 1 (One.one.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.hasOne.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.hasOne)))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] (i : Œπ) (s : Set.{u2} X), Eq.{max (succ u1) (succ u2)} (Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s (BumpCovering.single.{u1, u2} Œπ X _inst_1 i s)) (Pi.single.{u1, u2} Œπ (fun (i : Œπ) => ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (a : Œπ) (b : Œπ) => Classical.propDecidable (Eq.{succ u1} Œπ a b)) (fun (i : Œπ) => ContinuousMap.instZeroContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instZeroReal) i (OfNat.ofNat.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) 1 (One.toOfNat1.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.instOneContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instOneReal))))
Case conversion may be inaccurate. Consider using '#align bump_covering.coe_single BumpCovering.coe_single‚Çì'. -/
@[simp]
theorem coe_single (i : Œπ) (s : Set X) : ‚áë(BumpCovering.single i s) = Pi.single i 1 :=
  rfl
#align bump_covering.coe_single BumpCovering.coe_single

instance [Inhabited Œπ] : Inhabited (BumpCovering Œπ X s) :=
  ‚ü®BumpCovering.single default s‚ü©

#print BumpCovering.IsSubordinate /-
/-- A collection of bump functions `f i` is subordinate to a family of sets `U i` indexed by the
same type if for each `i` the closure of the support of `f i` is a subset of `U i`. -/
def IsSubordinate (f : BumpCovering Œπ X s) (U : Œπ ‚Üí Set X) : Prop :=
  ‚àÄ i, tsupport (f i) ‚äÜ U i
#align bump_covering.is_subordinate BumpCovering.IsSubordinate
-/

#print BumpCovering.IsSubordinate.mono /-
theorem IsSubordinate.mono {f : BumpCovering Œπ X s} {U V : Œπ ‚Üí Set X} (hU : f.IsSubordinate U)
    (hV : ‚àÄ i, U i ‚äÜ V i) : f.IsSubordinate V := fun i => Subset.trans (hU i) (hV i)
#align bump_covering.is_subordinate.mono BumpCovering.IsSubordinate.mono
-/

/- warning: bump_covering.exists_is_subordinate_of_locally_finite_of_prop -> BumpCovering.exists_isSubordinate_of_locallyFinite_of_prop is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} [_inst_2 : NormalSpace.{u2} X _inst_1] (p : (X -> Real) -> Prop), (forall (s : Set.{u2} X) (t : Set.{u2} X), (IsClosed.{u2} X _inst_1 s) -> (IsClosed.{u2} X _inst_1 t) -> (Disjoint.{u2} (Set.{u2} X) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} X) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} X) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} X) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} X) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} X) (Set.completeBooleanAlgebra.{u2} X)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u2} (Set.{u2} X) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} (Set.{u2} X) (Set.booleanAlgebra.{u2} X))) s t) -> (Exists.{succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (f : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => And (p (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f)) (And (Set.EqOn.{u2, 0} X Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f) (OfNat.ofNat.{u2} (X -> Real) 0 (OfNat.mk.{u2} (X -> Real) 0 (Zero.zero.{u2} (X -> Real) (Pi.instZero.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasZero))))) s) (And (Set.EqOn.{u2, 0} X Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f) (OfNat.ofNat.{u2} (X -> Real) 1 (OfNat.mk.{u2} (X -> Real) 1 (One.one.{u2} (X -> Real) (Pi.instOne.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasOne))))) t) (forall (x : X), Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f x) (Set.Icc.{0} Real Real.preorder (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))))))))) -> (IsClosed.{u2} X _inst_1 s) -> (forall (U : Œπ -> (Set.{u2} X)), (forall (i : Œπ), IsOpen.{u2} X _inst_1 (U i)) -> (LocallyFinite.{u1, u2} Œπ X _inst_1 U) -> (HasSubset.Subset.{u2} (Set.{u2} X) (Set.hasSubset.{u2} X) s (Set.union·µ¢.{u2, succ u1} X Œπ (fun (i : Œπ) => U i))) -> (Exists.{max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) => And (forall (i : Œπ), p (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i))) (BumpCovering.IsSubordinate.{u1, u2} Œπ X _inst_1 s f U))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} [_inst_2 : NormalSpace.{u2} X _inst_1] (p : (X -> Real) -> Prop), (forall (s : Set.{u2} X) (t : Set.{u2} X), (IsClosed.{u2} X _inst_1 s) -> (IsClosed.{u2} X _inst_1 t) -> (Disjoint.{u2} (Set.{u2} X) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} X) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} X) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} X) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} X) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} X) (Set.instCompleteBooleanAlgebraSet.{u2} X)))))) (BoundedOrder.toOrderBot.{u2} (Set.{u2} X) (Preorder.toLE.{u2} (Set.{u2} X) (PartialOrder.toPreorder.{u2} (Set.{u2} X) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} X) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} X) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} X) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} X) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} X) (Set.instCompleteBooleanAlgebraSet.{u2} X)))))))) (CompleteLattice.toBoundedOrder.{u2} (Set.{u2} X) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} X) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} X) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} X) (Set.instCompleteBooleanAlgebraSet.{u2} X)))))) s t) -> (Exists.{succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (f : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => And (p (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f)) (And (Set.EqOn.{u2, 0} X Real (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f) (OfNat.ofNat.{u2} (X -> Real) 0 (Zero.toOfNat0.{u2} (X -> Real) (Pi.instZero.{u2, 0} X (fun (a._@.Mathlib.Data.Set.Function._hyg.1349 : X) => Real) (fun (i : X) => Real.instZeroReal)))) s) (And (Set.EqOn.{u2, 0} X Real (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f) (OfNat.ofNat.{u2} (X -> Real) 1 (One.toOfNat1.{u2} (X -> Real) (Pi.instOne.{u2, 0} X (fun (a._@.Mathlib.Data.Set.Function._hyg.1349 : X) => Real) (fun (i : X) => Real.instOneReal)))) t) (forall (x : X), Membership.mem.{0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (Set.{0} Real) (Set.instMembershipSet.{0} Real) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f x) (Set.Icc.{0} Real Real.instPreorderReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))))))))) -> (IsClosed.{u2} X _inst_1 s) -> (forall (U : Œπ -> (Set.{u2} X)), (forall (i : Œπ), IsOpen.{u2} X _inst_1 (U i)) -> (LocallyFinite.{u1, u2} Œπ X _inst_1 U) -> (HasSubset.Subset.{u2} (Set.{u2} X) (Set.instHasSubsetSet.{u2} X) s (Set.union·µ¢.{u2, succ u1} X Œπ (fun (i : Œπ) => U i))) -> (Exists.{max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) => And (forall (i : Œπ), p (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i))) (BumpCovering.IsSubordinate.{u1, u2} Œπ X _inst_1 s f U))))
Case conversion may be inaccurate. Consider using '#align bump_covering.exists_is_subordinate_of_locally_finite_of_prop BumpCovering.exists_isSubordinate_of_locallyFinite_of_prop‚Çì'. -/
/-- If `X` is a normal topological space and `U i`, `i : Œπ`, is a locally finite open covering of a
closed set `s`, then there exists a `bump_covering Œπ X s` that is subordinate to `U`. If `X` is a
paracompact space, then the assumption `hf : locally_finite U` can be omitted, see
`bump_covering.exists_is_subordinate`. This version assumes that `p : (X ‚Üí ‚Ñù) ‚Üí Prop` is a predicate
that satisfies Urysohn's lemma, and provides a `bump_covering` such that each function of the
covering satisfies `p`. -/
theorem exists_isSubordinate_of_locallyFinite_of_prop [NormalSpace X] (p : (X ‚Üí ‚Ñù) ‚Üí Prop)
    (h01 :
      ‚àÄ s t,
        IsClosed s ‚Üí
          IsClosed t ‚Üí
            Disjoint s t ‚Üí ‚àÉ f : C(X, ‚Ñù), p f ‚àß EqOn f 0 s ‚àß EqOn f 1 t ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1)
    (hs : IsClosed s) (U : Œπ ‚Üí Set X) (ho : ‚àÄ i, IsOpen (U i)) (hf : LocallyFinite U)
    (hU : s ‚äÜ ‚ãÉ i, U i) : ‚àÉ f : BumpCovering Œπ X s, (‚àÄ i, p (f i)) ‚àß f.IsSubordinate U :=
  by
  rcases exists_subset_union·µ¢_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    ‚ü®V, hsV, hVo, hVU‚ü©
  have hVU' : ‚àÄ i, V i ‚äÜ U i := fun i => subset.trans subset_closure (hVU i)
  rcases exists_subset_union·µ¢_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    ‚ü®W, hsW, hWo, hWV‚ü©
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : ‚àÄ i, support (f i) ‚äÜ V i := fun i => support_subset_iff'.2 (hf0 i)
  refine'
    ‚ü®‚ü®f, hf.subset fun i => subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1, fun i x =>
        (hf01 i x).2, fun x hx => _‚ü©,
      hfp, fun i => subset.trans (closure_mono (hsupp i)) (hVU i)‚ü©
  rcases mem_Union.1 (hsW hx) with ‚ü®i, hi‚ü©
  exact ‚ü®i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)‚ü©
#align bump_covering.exists_is_subordinate_of_locally_finite_of_prop BumpCovering.exists_isSubordinate_of_locallyFinite_of_prop

#print BumpCovering.exists_isSubordinate_of_locallyFinite /-
/-- If `X` is a normal topological space and `U i`, `i : Œπ`, is a locally finite open covering of a
closed set `s`, then there exists a `bump_covering Œπ X s` that is subordinate to `U`. If `X` is a
paracompact space, then the assumption `hf : locally_finite U` can be omitted, see
`bump_covering.exists_is_subordinate`. -/
theorem exists_isSubordinate_of_locallyFinite [NormalSpace X] (hs : IsClosed s) (U : Œπ ‚Üí Set X)
    (ho : ‚àÄ i, IsOpen (U i)) (hf : LocallyFinite U) (hU : s ‚äÜ ‚ãÉ i, U i) :
    ‚àÉ f : BumpCovering Œπ X s, f.IsSubordinate U :=
  let ‚ü®f, _, hfU‚ü© :=
    exists_isSubordinate_of_locallyFinite_of_prop (fun _ => True)
      (fun s t hs ht hd =>
        (exists_continuous_zero_one_of_closed hs ht hd).imp fun f hf => ‚ü®trivial, hf‚ü©)
      hs U ho hf hU
  ‚ü®f, hfU‚ü©
#align bump_covering.exists_is_subordinate_of_locally_finite BumpCovering.exists_isSubordinate_of_locallyFinite
-/

/- warning: bump_covering.exists_is_subordinate_of_prop -> BumpCovering.exists_isSubordinate_of_prop is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} [_inst_2 : NormalSpace.{u2} X _inst_1] [_inst_3 : ParacompactSpace.{u2} X _inst_1] (p : (X -> Real) -> Prop), (forall (s : Set.{u2} X) (t : Set.{u2} X), (IsClosed.{u2} X _inst_1 s) -> (IsClosed.{u2} X _inst_1 t) -> (Disjoint.{u2} (Set.{u2} X) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} X) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} X) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} X) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} X) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} X) (Set.completeBooleanAlgebra.{u2} X)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u2} (Set.{u2} X) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} (Set.{u2} X) (Set.booleanAlgebra.{u2} X))) s t) -> (Exists.{succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (f : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => And (p (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f)) (And (Set.EqOn.{u2, 0} X Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f) (OfNat.ofNat.{u2} (X -> Real) 0 (OfNat.mk.{u2} (X -> Real) 0 (Zero.zero.{u2} (X -> Real) (Pi.instZero.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasZero))))) s) (And (Set.EqOn.{u2, 0} X Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f) (OfNat.ofNat.{u2} (X -> Real) 1 (OfNat.mk.{u2} (X -> Real) 1 (One.one.{u2} (X -> Real) (Pi.instOne.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasOne))))) t) (forall (x : X), Membership.Mem.{0, 0} Real (Set.{0} Real) (Set.hasMem.{0} Real) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f x) (Set.Icc.{0} Real Real.preorder (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))))))))) -> (IsClosed.{u2} X _inst_1 s) -> (forall (U : Œπ -> (Set.{u2} X)), (forall (i : Œπ), IsOpen.{u2} X _inst_1 (U i)) -> (HasSubset.Subset.{u2} (Set.{u2} X) (Set.hasSubset.{u2} X) s (Set.union·µ¢.{u2, succ u1} X Œπ (fun (i : Œπ) => U i))) -> (Exists.{max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) => And (forall (i : Œπ), p (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i))) (BumpCovering.IsSubordinate.{u1, u2} Œπ X _inst_1 s f U))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} [_inst_2 : NormalSpace.{u2} X _inst_1] [_inst_3 : ParacompactSpace.{u2} X _inst_1] (p : (X -> Real) -> Prop), (forall (s : Set.{u2} X) (t : Set.{u2} X), (IsClosed.{u2} X _inst_1 s) -> (IsClosed.{u2} X _inst_1 t) -> (Disjoint.{u2} (Set.{u2} X) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} X) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} X) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} X) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} X) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} X) (Set.instCompleteBooleanAlgebraSet.{u2} X)))))) (BoundedOrder.toOrderBot.{u2} (Set.{u2} X) (Preorder.toLE.{u2} (Set.{u2} X) (PartialOrder.toPreorder.{u2} (Set.{u2} X) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} X) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} X) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} X) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} X) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} X) (Set.instCompleteBooleanAlgebraSet.{u2} X)))))))) (CompleteLattice.toBoundedOrder.{u2} (Set.{u2} X) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} X) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} X) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} X) (Set.instCompleteBooleanAlgebraSet.{u2} X)))))) s t) -> (Exists.{succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (f : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => And (p (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f)) (And (Set.EqOn.{u2, 0} X Real (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f) (OfNat.ofNat.{u2} (X -> Real) 0 (Zero.toOfNat0.{u2} (X -> Real) (Pi.instZero.{u2, 0} X (fun (a._@.Mathlib.Data.Set.Function._hyg.1349 : X) => Real) (fun (i : X) => Real.instZeroReal)))) s) (And (Set.EqOn.{u2, 0} X Real (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f) (OfNat.ofNat.{u2} (X -> Real) 1 (One.toOfNat1.{u2} (X -> Real) (Pi.instOne.{u2, 0} X (fun (a._@.Mathlib.Data.Set.Function._hyg.1349 : X) => Real) (fun (i : X) => Real.instOneReal)))) t) (forall (x : X), Membership.mem.{0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (Set.{0} Real) (Set.instMembershipSet.{0} Real) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f x) (Set.Icc.{0} Real Real.instPreorderReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal))))))))) -> (IsClosed.{u2} X _inst_1 s) -> (forall (U : Œπ -> (Set.{u2} X)), (forall (i : Œπ), IsOpen.{u2} X _inst_1 (U i)) -> (HasSubset.Subset.{u2} (Set.{u2} X) (Set.instHasSubsetSet.{u2} X) s (Set.union·µ¢.{u2, succ u1} X Œπ (fun (i : Œπ) => U i))) -> (Exists.{max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) => And (forall (i : Œπ), p (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i))) (BumpCovering.IsSubordinate.{u1, u2} Œπ X _inst_1 s f U))))
Case conversion may be inaccurate. Consider using '#align bump_covering.exists_is_subordinate_of_prop BumpCovering.exists_isSubordinate_of_prop‚Çì'. -/
/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set
`s`, then there exists a `bump_covering Œπ X s` that is subordinate to `U`. This version assumes that
`p : (X ‚Üí ‚Ñù) ‚Üí Prop` is a predicate that satisfies Urysohn's lemma, and provides a
`bump_covering` such that each function of the covering satisfies `p`. -/
theorem exists_isSubordinate_of_prop [NormalSpace X] [ParacompactSpace X] (p : (X ‚Üí ‚Ñù) ‚Üí Prop)
    (h01 :
      ‚àÄ s t,
        IsClosed s ‚Üí
          IsClosed t ‚Üí
            Disjoint s t ‚Üí ‚àÉ f : C(X, ‚Ñù), p f ‚àß EqOn f 0 s ‚àß EqOn f 1 t ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1)
    (hs : IsClosed s) (U : Œπ ‚Üí Set X) (ho : ‚àÄ i, IsOpen (U i)) (hU : s ‚äÜ ‚ãÉ i, U i) :
    ‚àÉ f : BumpCovering Œπ X s, (‚àÄ i, p (f i)) ‚àß f.IsSubordinate U :=
  by
  rcases precise_refinement_set hs _ ho hU with ‚ü®V, hVo, hsV, hVf, hVU‚ü©
  rcases exists_is_subordinate_of_locally_finite_of_prop p h01 hs V hVo hVf hsV with ‚ü®f, hfp, hf‚ü©
  exact ‚ü®f, hfp, hf.mono hVU‚ü©
#align bump_covering.exists_is_subordinate_of_prop BumpCovering.exists_isSubordinate_of_prop

#print BumpCovering.exists_isSubordinate /-
/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set
`s`, then there exists a `bump_covering Œπ X s` that is subordinate to `U`. -/
theorem exists_isSubordinate [NormalSpace X] [ParacompactSpace X] (hs : IsClosed s) (U : Œπ ‚Üí Set X)
    (ho : ‚àÄ i, IsOpen (U i)) (hU : s ‚äÜ ‚ãÉ i, U i) : ‚àÉ f : BumpCovering Œπ X s, f.IsSubordinate U :=
  by
  rcases precise_refinement_set hs _ ho hU with ‚ü®V, hVo, hsV, hVf, hVU‚ü©
  rcases exists_is_subordinate_of_locally_finite hs V hVo hVf hsV with ‚ü®f, hf‚ü©
  exact ‚ü®f, hf.mono hVU‚ü©
#align bump_covering.exists_is_subordinate BumpCovering.exists_isSubordinate
-/

#print BumpCovering.ind /-
/-- Index of a bump function such that `fs i =·∂†[ùìù x] 1`. -/
def ind (x : X) (hx : x ‚àà s) : Œπ :=
  (f.eventuallyEq_one' x hx).some
#align bump_covering.ind BumpCovering.ind
-/

/- warning: bump_covering.eventually_eq_one -> BumpCovering.eventuallyEq_one is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (x : X) (hx : Membership.Mem.{u2, u2} X (Set.{u2} X) (Set.hasMem.{u2} X) x s), Filter.EventuallyEq.{u2, 0} X Real (nhds.{u2} X _inst_1 x) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f (BumpCovering.ind.{u1, u2} Œπ X _inst_1 s f x hx))) (OfNat.ofNat.{u2} (X -> Real) 1 (OfNat.mk.{u2} (X -> Real) 1 (One.one.{u2} (X -> Real) (Pi.instOne.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasOne)))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (x : X) (hx : Membership.mem.{u2, u2} X (Set.{u2} X) (Set.instMembershipSet.{u2} X) x s), Filter.EventuallyEq.{u2, 0} X Real (nhds.{u2} X _inst_1 x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f (BumpCovering.ind.{u1, u2} Œπ X _inst_1 s f x hx))) (OfNat.ofNat.{u2} (X -> Real) 1 (One.toOfNat1.{u2} (X -> Real) (Pi.instOne.{u2, 0} X (fun (a._@.Mathlib.Order.Filter.Basic._hyg.19133 : X) => Real) (fun (i : X) => Real.instOneReal))))
Case conversion may be inaccurate. Consider using '#align bump_covering.eventually_eq_one BumpCovering.eventuallyEq_one‚Çì'. -/
theorem eventuallyEq_one (x : X) (hx : x ‚àà s) : f (f.ind x hx) =·∂†[ùìù x] 1 :=
  (f.eventuallyEq_one' x hx).choose_spec
#align bump_covering.eventually_eq_one BumpCovering.eventuallyEq_one

/- warning: bump_covering.ind_apply -> BumpCovering.ind_apply is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (x : X) (hx : Membership.Mem.{u2, u2} X (Set.{u2} X) (Set.hasMem.{u2} X) x s), Eq.{1} Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f (BumpCovering.ind.{u1, u2} Œπ X _inst_1 s f x hx)) x) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (x : X) (hx : Membership.mem.{u2, u2} X (Set.{u2} X) (Set.instMembershipSet.{u2} X) x s), Eq.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f (BumpCovering.ind.{u1, u2} Œπ X _inst_1 s f x hx)) x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal))
Case conversion may be inaccurate. Consider using '#align bump_covering.ind_apply BumpCovering.ind_apply‚Çì'. -/
theorem ind_apply (x : X) (hx : x ‚àà s) : f (f.ind x hx) x = 1 :=
  (f.eventuallyEq_one x hx).eq_of_nhds
#align bump_covering.ind_apply BumpCovering.ind_apply

#print BumpCovering.toPouFun /-
/-- Partition of unity defined by a `bump_covering`. We use this auxiliary definition to prove some
properties of the new family of functions before bundling it into a `partition_of_unity`. Do not use
this definition, use `bump_function.to_partition_of_unity` instead.

The partition of unity is given by the formula `g i x = f i x * ‚àè·∂† j < i, (1 - f j x)`. In other
words, `g i x = ‚àè·∂† j < i, (1 - f j x) - ‚àè·∂† j ‚â§ i, (1 - f j x)`, so
`‚àë·∂† i, g i x = 1 - ‚àè·∂† j, (1 - f j x)`. If `x ‚àà s`, then one of `f j x` equals one, hence the product
of `1 - f j x` vanishes, and `‚àë·∂† i, g i x = 1`.

In order to avoid an assumption `linear_order Œπ`, we use `well_ordering_rel` instead of `(<)`. -/
def toPouFun (i : Œπ) (x : X) : ‚Ñù :=
  f i x * ‚àè·∂† (j) (hj : WellOrderingRel j i), 1 - f j x
#align bump_covering.to_pou_fun BumpCovering.toPouFun
-/

/- warning: bump_covering.to_pou_fun_zero_of_zero -> BumpCovering.toPouFun_zero_of_zero is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) {i : Œπ} {x : X}, (Eq.{1} Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Eq.{1} Real (BumpCovering.toPouFun.{u1, u2} Œπ X _inst_1 s f i x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) {i : Œπ} {x : X}, (Eq.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i) x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal))) -> (Eq.{1} Real (BumpCovering.toPouFun.{u1, u2} Œπ X _inst_1 s f i x) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align bump_covering.to_pou_fun_zero_of_zero BumpCovering.toPouFun_zero_of_zero‚Çì'. -/
theorem toPouFun_zero_of_zero {i : Œπ} {x : X} (h : f i x = 0) : f.toPouFun i x = 0 := by
  rw [to_pou_fun, h, MulZeroClass.zero_mul]
#align bump_covering.to_pou_fun_zero_of_zero BumpCovering.toPouFun_zero_of_zero

/- warning: bump_covering.support_to_pou_fun_subset -> BumpCovering.support_toPouFun_subset is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ), HasSubset.Subset.{u2} (Set.{u2} X) (Set.hasSubset.{u2} X) (Function.support.{u2, 0} X Real Real.hasZero (BumpCovering.toPouFun.{u1, u2} Œπ X _inst_1 s f i)) (Function.support.{u2, 0} X Real Real.hasZero (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ), HasSubset.Subset.{u2} (Set.{u2} X) (Set.instHasSubsetSet.{u2} X) (Function.support.{u2, 0} X Real Real.instZeroReal (BumpCovering.toPouFun.{u1, u2} Œπ X _inst_1 s f i)) (Function.support.{u2, 0} X Real Real.instZeroReal (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i)))
Case conversion may be inaccurate. Consider using '#align bump_covering.support_to_pou_fun_subset BumpCovering.support_toPouFun_subset‚Çì'. -/
theorem support_toPouFun_subset (i : Œπ) : support (f.toPouFun i) ‚äÜ support (f i) := fun x =>
  mt <| f.toPouFun_zero_of_zero
#align bump_covering.support_to_pou_fun_subset BumpCovering.support_toPouFun_subset

/- warning: bump_covering.to_pou_fun_eq_mul_prod -> BumpCovering.toPouFun_eq_mul_prod is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X) (t : Finset.{u1} Œπ), (forall (j : Œπ), (WellOrderingRel.{u1} Œπ j i) -> (Ne.{1} Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f j) x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Membership.Mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.hasMem.{u1} Œπ) j t)) -> (Eq.{1} Real (BumpCovering.toPouFun.{u1, u2} Œπ X _inst_1 s f i x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (Finset.prod.{0, u1} Real Œπ Real.commMonoid (Finset.filter.{u1} Œπ (fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) (fun (a : Œπ) => Classical.propDecidable ((fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) a)) t) (fun (j : Œπ) => HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f j) x)))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X) (t : Finset.{u1} Œπ), (forall (j : Œπ), (WellOrderingRel.{u1} Œπ j i) -> (Ne.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f j) x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal))) -> (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) j t)) -> (Eq.{1} Real (BumpCovering.toPouFun.{u1, u2} Œπ X _inst_1 s f i x) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (instHMul.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instMulReal) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i) x) (Finset.prod.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Œπ Real.instCommMonoidReal (Finset.filter.{u1} Œπ (fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) (fun (a : Œπ) => Classical.propDecidable ((fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) a)) t) (fun (j : Œπ) => HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instSubReal) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal)) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f j) x)))))
Case conversion may be inaccurate. Consider using '#align bump_covering.to_pou_fun_eq_mul_prod BumpCovering.toPouFun_eq_mul_prod‚Çì'. -/
theorem toPouFun_eq_mul_prod (i : Œπ) (x : X) (t : Finset Œπ)
    (ht : ‚àÄ j, WellOrderingRel j i ‚Üí f j x ‚â† 0 ‚Üí j ‚àà t) :
    f.toPouFun i x = f i x * ‚àè j in t.filter‚Çì fun j => WellOrderingRel j i, 1 - f j x :=
  by
  refine' congr_arg _ (finprod_cond_eq_prod_of_cond_iff _ fun j hj => _)
  rw [Ne.def, sub_eq_self] at hj
  rw [Finset.mem_filter, Iff.comm, and_iff_right_iff_imp]
  exact flip (ht j) hj
#align bump_covering.to_pou_fun_eq_mul_prod BumpCovering.toPouFun_eq_mul_prod

/- warning: bump_covering.sum_to_pou_fun_eq -> BumpCovering.sum_toPouFun_eq is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (x : X), Eq.{1} Real (finsum.{0, succ u1} Real Œπ Real.addCommMonoid (fun (i : Œπ) => BumpCovering.toPouFun.{u1, u2} Œπ X _inst_1 s f i x)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (finprod.{0, succ u1} Real Œπ Real.commMonoid (fun (i : Œπ) => HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (x : X), Eq.{1} Real (finsum.{0, succ u1} Real Œπ Real.instAddCommMonoidReal (fun (i : Œπ) => BumpCovering.toPouFun.{u1, u2} Œπ X _inst_1 s f i x)) (HSub.hSub.{0, 0, 0} Real ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real (instHSub.{0} Real Real.instSubReal) (OfNat.ofNat.{0} Real 1 (One.toOfNat1.{0} Real Real.instOneReal)) (finprod.{0, succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Œπ Real.instCommMonoidReal (fun (i : Œπ) => HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instSubReal) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal)) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i) x))))
Case conversion may be inaccurate. Consider using '#align bump_covering.sum_to_pou_fun_eq BumpCovering.sum_toPouFun_eq‚Çì'. -/
theorem sum_toPouFun_eq (x : X) : (‚àë·∂† i, f.toPouFun i x) = 1 - ‚àè·∂† i, 1 - f i x :=
  by
  set s := (f.point_finite x).toFinset
  have hs : (s : Set Œπ) = { i | f i x ‚â† 0 } := finite.coe_to_finset _
  have A : (support fun i => to_pou_fun f i x) ‚äÜ s :=
    by
    rw [hs]
    exact fun i hi => f.support_to_pou_fun_subset i hi
  have B : (mul_support fun i => 1 - f i x) ‚äÜ s :=
    by
    rw [hs, mul_support_one_sub]
    exact fun i => id
  letI : LinearOrder Œπ := linearOrderOfSTO WellOrderingRel
  rw [finsum_eq_sum_of_support_subset _ A, finprod_eq_prod_of_mulSupport_subset _ B,
    Finset.prod_one_sub_ordered, sub_sub_cancel]
  refine' Finset.sum_congr rfl fun i hi => _
  convert f.to_pou_fun_eq_mul_prod _ _ _ fun j hji hj => _
  rwa [finite.mem_to_finset]
#align bump_covering.sum_to_pou_fun_eq BumpCovering.sum_toPouFun_eq

/- warning: bump_covering.exists_finset_to_pou_fun_eventually_eq -> BumpCovering.exists_finset_toPouFun_eventuallyEq is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), Exists.{succ u1} (Finset.{u1} Œπ) (fun (t : Finset.{u1} Œπ) => Filter.EventuallyEq.{u2, 0} X Real (nhds.{u2} X _inst_1 x) (BumpCovering.toPouFun.{u1, u2} Œπ X _inst_1 s f i) (HMul.hMul.{u2, u2, u2} (X -> Real) (X -> Real) (X -> Real) (instHMul.{u2} (X -> Real) (Pi.instMul.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasMul))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i)) (Finset.prod.{u2, u1} (X -> Real) Œπ (Pi.commMonoid.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.commMonoid)) (Finset.filter.{u1} Œπ (fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) (fun (a : Œπ) => Classical.propDecidable ((fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) a)) t) (fun (j : Œπ) => HSub.hSub.{u2, u2, u2} (X -> Real) (X -> Real) (X -> Real) (instHSub.{u2} (X -> Real) (Pi.instSub.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasSub))) (OfNat.ofNat.{u2} (X -> Real) 1 (OfNat.mk.{u2} (X -> Real) 1 (One.one.{u2} (X -> Real) (Pi.instOne.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasOne))))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f j))))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), Exists.{succ u1} (Finset.{u1} Œπ) (fun (t : Finset.{u1} Œπ) => Filter.EventuallyEq.{u2, 0} X Real (nhds.{u2} X _inst_1 x) (BumpCovering.toPouFun.{u1, u2} Œπ X _inst_1 s f i) (HMul.hMul.{u2, u2, u2} (forall (·æ∞ : X), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) ·æ∞) (forall (·æ∞ : X), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) ·æ∞) (forall (·æ∞ : X), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) ·æ∞) (instHMul.{u2} (forall (·æ∞ : X), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) ·æ∞) (Pi.instMul.{u2, 0} X (fun (·æ∞ : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) ·æ∞) (fun (i : X) => Real.instMulReal))) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i)) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (a : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) a) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (Finset.prod.{u2, u1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) Œπ (ContinuousMap.instCommMonoidContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instCommMonoidReal (TopologicalSemiring.toContinuousMul.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} Real (NonAssocRing.toNonUnitalNonAssocRing.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (TopologicalRing.toTopologicalSemiring.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (NonAssocRing.toNonUnitalNonAssocRing.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)) instTopologicalRingRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceToNonUnitalNonAssocRingToNonAssocRingInstRingReal))) (Finset.filter.{u1} Œπ (fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) (fun (a : Œπ) => Classical.propDecidable ((fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) a)) t) (fun (j : Œπ) => HSub.hSub.{u2, u2, u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (instHSub.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.instSubContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instSubReal (TopologicalAddGroup.to_continuousSub.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instAddGroupReal instTopologicalAddGroupRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstAddGroupReal))) (OfNat.ofNat.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) 1 (One.toOfNat1.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.instOneContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instOneReal))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f j))))))
Case conversion may be inaccurate. Consider using '#align bump_covering.exists_finset_to_pou_fun_eventually_eq BumpCovering.exists_finset_toPouFun_eventuallyEq‚Çì'. -/
theorem exists_finset_toPouFun_eventuallyEq (i : Œπ) (x : X) :
    ‚àÉ t : Finset Œπ,
      f.toPouFun i =·∂†[ùìù x] f i * ‚àè j in t.filter‚Çì fun j => WellOrderingRel j i, 1 - f j :=
  by
  rcases f.locally_finite x with ‚ü®U, hU, hf‚ü©
  use hf.to_finset
  filter_upwards [hU]with y hyU
  simp only [Pi.mul_apply, Finset.prod_apply]
  apply to_pou_fun_eq_mul_prod
  intro j hji hj
  exact hf.mem_to_finset.2 ‚ü®y, ‚ü®hj, hyU‚ü©‚ü©
#align bump_covering.exists_finset_to_pou_fun_eventually_eq BumpCovering.exists_finset_toPouFun_eventuallyEq

#print BumpCovering.continuous_toPouFun /-
theorem continuous_toPouFun (i : Œπ) : Continuous (f.toPouFun i) :=
  by
  refine'
    (f i).Continuous.mul <|
      continuous_finprod_cond (fun j _ => continuous_const.sub (f j).Continuous) _
  simp only [mul_support_one_sub]
  exact f.locally_finite
#align bump_covering.continuous_to_pou_fun BumpCovering.continuous_toPouFun
-/

#print BumpCovering.toPartitionOfUnity /-
/-- The partition of unity defined by a `bump_covering`.

The partition of unity is given by the formula `g i x = f i x * ‚àè·∂† j < i, (1 - f j x)`. In other
words, `g i x = ‚àè·∂† j < i, (1 - f j x) - ‚àè·∂† j ‚â§ i, (1 - f j x)`, so
`‚àë·∂† i, g i x = 1 - ‚àè·∂† j, (1 - f j x)`. If `x ‚àà s`, then one of `f j x` equals one, hence the product
of `1 - f j x` vanishes, and `‚àë·∂† i, g i x = 1`.

In order to avoid an assumption `linear_order Œπ`, we use `well_ordering_rel` instead of `(<)`. -/
def toPartitionOfUnity : PartitionOfUnity Œπ X s
    where
  toFun i := ‚ü®f.toPouFun i, f.continuous_toPouFun i‚ü©
  locally_finite' := f.LocallyFinite.Subset f.support_toPouFun_subset
  nonneg' i x :=
    mul_nonneg (f.NonNeg i x) (finprod_cond_nonneg fun j hj => sub_nonneg.2 <| f.le_one j x)
  sum_eq_one' x hx :=
    by
    simp only [ContinuousMap.coe_mk, sum_to_pou_fun_eq, sub_eq_self]
    apply finprod_eq_zero (fun i => 1 - f i x) (f.ind x hx)
    ¬∑ simp only [f.ind_apply x hx, sub_self]
    ¬∑ rw [mul_support_one_sub]
      exact f.point_finite x
  sum_le_one' x :=
    by
    simp only [ContinuousMap.coe_mk, sum_to_pou_fun_eq, sub_le_self_iff]
    exact finprod_nonneg fun i => sub_nonneg.2 <| f.le_one i x
#align bump_covering.to_partition_of_unity BumpCovering.toPartitionOfUnity
-/

/- warning: bump_covering.to_partition_of_unity_apply -> BumpCovering.toPartitionOfUnity_apply is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), Eq.{1} Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i) x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (finprod.{0, succ u1} Real Œπ Real.commMonoid (fun (j : Œπ) => finprod.{0, 0} Real (WellOrderingRel.{u1} Œπ j i) Real.commMonoid (fun (hj : WellOrderingRel.{u1} Œπ j i) => HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f j) x)))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), Eq.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i) x) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (instHMul.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instMulReal) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i) x) (finprod.{0, succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Œπ Real.instCommMonoidReal (fun (j : Œπ) => finprod.{0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (WellOrderingRel.{u1} Œπ j i) Real.instCommMonoidReal (fun (hj : WellOrderingRel.{u1} Œπ j i) => HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instSubReal) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal)) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f j) x)))))
Case conversion may be inaccurate. Consider using '#align bump_covering.to_partition_of_unity_apply BumpCovering.toPartitionOfUnity_apply‚Çì'. -/
theorem toPartitionOfUnity_apply (i : Œπ) (x : X) :
    f.toPartitionOfUnity i x = f i x * ‚àè·∂† (j) (hj : WellOrderingRel j i), 1 - f j x :=
  rfl
#align bump_covering.to_partition_of_unity_apply BumpCovering.toPartitionOfUnity_apply

/- warning: bump_covering.to_partition_of_unity_eq_mul_prod -> BumpCovering.toPartitionOfUnity_eq_mul_prod is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X) (t : Finset.{u1} Œπ), (forall (j : Œπ), (WellOrderingRel.{u1} Œπ j i) -> (Ne.{1} Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f j) x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Membership.Mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.hasMem.{u1} Œπ) j t)) -> (Eq.{1} Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i) x) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (Finset.prod.{0, u1} Real Œπ Real.commMonoid (Finset.filter.{u1} Œπ (fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) (fun (a : Œπ) => Classical.propDecidable ((fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) a)) t) (fun (j : Œπ) => HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f j) x)))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X) (t : Finset.{u1} Œπ), (forall (j : Œπ), (WellOrderingRel.{u1} Œπ j i) -> (Ne.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f j) x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal))) -> (Membership.mem.{u1, u1} Œπ (Finset.{u1} Œπ) (Finset.instMembershipFinset.{u1} Œπ) j t)) -> (Eq.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i) x) (HMul.hMul.{0, 0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (instHMul.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instMulReal) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i) x) (Finset.prod.{0, u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Œπ Real.instCommMonoidReal (Finset.filter.{u1} Œπ (fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) (fun (a : Œπ) => Classical.propDecidable ((fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) a)) t) (fun (j : Œπ) => HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instSubReal) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal)) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f j) x)))))
Case conversion may be inaccurate. Consider using '#align bump_covering.to_partition_of_unity_eq_mul_prod BumpCovering.toPartitionOfUnity_eq_mul_prod‚Çì'. -/
theorem toPartitionOfUnity_eq_mul_prod (i : Œπ) (x : X) (t : Finset Œπ)
    (ht : ‚àÄ j, WellOrderingRel j i ‚Üí f j x ‚â† 0 ‚Üí j ‚àà t) :
    f.toPartitionOfUnity i x = f i x * ‚àè j in t.filter‚Çì fun j => WellOrderingRel j i, 1 - f j x :=
  f.toPouFun_eq_mul_prod i x t ht
#align bump_covering.to_partition_of_unity_eq_mul_prod BumpCovering.toPartitionOfUnity_eq_mul_prod

/- warning: bump_covering.exists_finset_to_partition_of_unity_eventually_eq -> BumpCovering.exists_finset_toPartitionOfUnity_eventuallyEq is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), Exists.{succ u1} (Finset.{u1} Œπ) (fun (t : Finset.{u1} Œπ) => Filter.EventuallyEq.{u2, 0} X Real (nhds.{u2} X _inst_1 x) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i)) (HMul.hMul.{u2, u2, u2} (X -> Real) (X -> Real) (X -> Real) (instHMul.{u2} (X -> Real) (Pi.instMul.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasMul))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i)) (Finset.prod.{u2, u1} (X -> Real) Œπ (Pi.commMonoid.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.commMonoid)) (Finset.filter.{u1} Œπ (fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) (fun (a : Œπ) => Classical.propDecidable ((fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) a)) t) (fun (j : Œπ) => HSub.hSub.{u2, u2, u2} (X -> Real) (X -> Real) (X -> Real) (instHSub.{u2} (X -> Real) (Pi.instSub.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasSub))) (OfNat.ofNat.{u2} (X -> Real) 1 (OfNat.mk.{u2} (X -> Real) 1 (One.one.{u2} (X -> Real) (Pi.instOne.{u2, 0} X (fun (·æ∞ : X) => Real) (fun (i : X) => Real.hasOne))))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f j))))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ) (x : X), Exists.{succ u1} (Finset.{u1} Œπ) (fun (t : Finset.{u1} Œπ) => Filter.EventuallyEq.{u2, 0} X Real (nhds.{u2} X _inst_1 x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i)) (HMul.hMul.{u2, u2, u2} (forall (·æ∞ : X), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) ·æ∞) (forall (·æ∞ : X), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) ·æ∞) (forall (·æ∞ : X), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) ·æ∞) (instHMul.{u2} (forall (·æ∞ : X), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) ·æ∞) (Pi.instMul.{u2, 0} X (fun (·æ∞ : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) ·æ∞) (fun (i : X) => Real.instMulReal))) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i)) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (a : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) a) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (Finset.prod.{u2, u1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) Œπ (ContinuousMap.instCommMonoidContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instCommMonoidReal (TopologicalSemiring.toContinuousMul.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} Real (NonAssocRing.toNonUnitalNonAssocRing.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal))) (TopologicalRing.toTopologicalSemiring.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (NonAssocRing.toNonUnitalNonAssocRing.{0} Real (Ring.toNonAssocRing.{0} Real Real.instRingReal)) instTopologicalRingRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceToNonUnitalNonAssocRingToNonAssocRingInstRingReal))) (Finset.filter.{u1} Œπ (fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) (fun (a : Œπ) => Classical.propDecidable ((fun (j : Œπ) => WellOrderingRel.{u1} Œπ j i) a)) t) (fun (j : Œπ) => HSub.hSub.{u2, u2, u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (instHSub.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.instSubContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instSubReal (TopologicalAddGroup.to_continuousSub.{0} Real (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instAddGroupReal instTopologicalAddGroupRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstAddGroupReal))) (OfNat.ofNat.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) 1 (One.toOfNat1.{u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.instOneContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) Real.instOneReal))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f j))))))
Case conversion may be inaccurate. Consider using '#align bump_covering.exists_finset_to_partition_of_unity_eventually_eq BumpCovering.exists_finset_toPartitionOfUnity_eventuallyEq‚Çì'. -/
theorem exists_finset_toPartitionOfUnity_eventuallyEq (i : Œπ) (x : X) :
    ‚àÉ t : Finset Œπ,
      f.toPartitionOfUnity i =·∂†[ùìù x] f i * ‚àè j in t.filter‚Çì fun j => WellOrderingRel j i, 1 - f j :=
  f.exists_finset_toPouFun_eventuallyEq i x
#align bump_covering.exists_finset_to_partition_of_unity_eventually_eq BumpCovering.exists_finset_toPartitionOfUnity_eventuallyEq

/- warning: bump_covering.to_partition_of_unity_zero_of_zero -> BumpCovering.toPartitionOfUnity_zero_of_zero is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) {i : Œπ} {x : X}, (Eq.{1} Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero)))) -> (Eq.{1} Real (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i) x) (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) {i : Œπ} {x : X}, (Eq.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i) x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal))) -> (Eq.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i) x) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 0 (Zero.toOfNat0.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instZeroReal)))
Case conversion may be inaccurate. Consider using '#align bump_covering.to_partition_of_unity_zero_of_zero BumpCovering.toPartitionOfUnity_zero_of_zero‚Çì'. -/
theorem toPartitionOfUnity_zero_of_zero {i : Œπ} {x : X} (h : f i x = 0) :
    f.toPartitionOfUnity i x = 0 :=
  f.toPouFun_zero_of_zero h
#align bump_covering.to_partition_of_unity_zero_of_zero BumpCovering.toPartitionOfUnity_zero_of_zero

/- warning: bump_covering.support_to_partition_of_unity_subset -> BumpCovering.support_toPartitionOfUnity_subset is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ), HasSubset.Subset.{u2} (Set.{u2} X) (Set.hasSubset.{u2} X) (Function.support.{u2, 0} X Real Real.hasZero (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i))) (Function.support.{u2, 0} X Real Real.hasZero (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i)))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (i : Œπ), HasSubset.Subset.{u2} (Set.{u2} X) (Set.instHasSubsetSet.{u2} X) (Function.support.{u2, 0} X Real Real.instZeroReal (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i))) (Function.support.{u2, 0} X Real Real.instZeroReal (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i)))
Case conversion may be inaccurate. Consider using '#align bump_covering.support_to_partition_of_unity_subset BumpCovering.support_toPartitionOfUnity_subset‚Çì'. -/
theorem support_toPartitionOfUnity_subset (i : Œπ) :
    support (f.toPartitionOfUnity i) ‚äÜ support (f i) :=
  f.support_toPouFun_subset i
#align bump_covering.support_to_partition_of_unity_subset BumpCovering.support_toPartitionOfUnity_subset

/- warning: bump_covering.sum_to_partition_of_unity_eq -> BumpCovering.sum_toPartitionOfUnity_eq is a dubious translation:
lean 3 declaration is
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (x : X), Eq.{1} Real (finsum.{0, succ u1} Real Œπ Real.addCommMonoid (fun (i : Œπ) => coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) (fun (_x : PartitionOfUnity.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i) x)) (HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (finprod.{0, succ u1} Real Œπ Real.commMonoid (fun (i : Œπ) => HSub.hSub.{0, 0, 0} Real Real Real (instHSub.{0} Real Real.hasSub) (OfNat.ofNat.{0} Real 1 (OfNat.mk.{0} Real 1 (One.one.{0} Real Real.hasOne))) (coeFn.{succ u2, succ u2} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => X -> Real) (ContinuousMap.hasCoeToFun.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BumpCovering.{u1, u2} Œπ X _inst_1 s) (fun (_x : BumpCovering.{u1, u2} Œπ X _inst_1 s) => Œπ -> (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.hasCoeToFun.{u1, u2} Œπ X _inst_1 s) f i) x))))
but is expected to have type
  forall {Œπ : Type.{u1}} {X : Type.{u2}} [_inst_1 : TopologicalSpace.{u2} X] {s : Set.{u2} X} (f : BumpCovering.{u1, u2} Œπ X _inst_1 s) (x : X), Eq.{1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (finsum.{0, succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Œπ Real.instAddCommMonoidReal (fun (i : Œπ) => FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (PartitionOfUnity.toFun.{u1, u2} Œπ X _inst_1 s (BumpCovering.toPartitionOfUnity.{u1, u2} Œπ X _inst_1 s f) i) x)) (HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instSubReal) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal)) (finprod.{0, succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Œπ Real.instCommMonoidReal (fun (i : Œπ) => HSub.hSub.{0, 0, 0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) (instHSub.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instSubReal) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) x) Real.instOneReal)) (FunLike.coe.{succ u2, succ u2, 1} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X (fun (_x : X) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : X) => Real) _x) (ContinuousMapClass.toFunLike.{u2, u2, 0} (ContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, 0} X Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) (BumpCovering.toFun.{u1, u2} Œπ X _inst_1 s f i) x))))
Case conversion may be inaccurate. Consider using '#align bump_covering.sum_to_partition_of_unity_eq BumpCovering.sum_toPartitionOfUnity_eq‚Çì'. -/
theorem sum_toPartitionOfUnity_eq (x : X) :
    (‚àë·∂† i, f.toPartitionOfUnity i x) = 1 - ‚àè·∂† i, 1 - f i x :=
  f.sum_toPouFun_eq x
#align bump_covering.sum_to_partition_of_unity_eq BumpCovering.sum_toPartitionOfUnity_eq

#print BumpCovering.IsSubordinate.toPartitionOfUnity /-
theorem IsSubordinate.toPartitionOfUnity {f : BumpCovering Œπ X s} {U : Œπ ‚Üí Set X}
    (h : f.IsSubordinate U) : f.toPartitionOfUnity.IsSubordinate U := fun i =>
  Subset.trans (closure_mono <| f.support_toPartitionOfUnity_subset i) (h i)
#align bump_covering.is_subordinate.to_partition_of_unity BumpCovering.IsSubordinate.toPartitionOfUnity
-/

end BumpCovering

namespace PartitionOfUnity

variable {s : Set X}

instance [Inhabited Œπ] : Inhabited (PartitionOfUnity Œπ X s) :=
  ‚ü®BumpCovering.toPartitionOfUnity default‚ü©

#print PartitionOfUnity.exists_isSubordinate_of_locallyFinite /-
/-- If `X` is a normal topological space and `U` is a locally finite open covering of a closed set
`s`, then there exists a `partition_of_unity Œπ X s` that is subordinate to `U`. If `X` is a
paracompact space, then the assumption `hf : locally_finite U` can be omitted, see
`bump_covering.exists_is_subordinate`. -/
theorem exists_isSubordinate_of_locallyFinite [NormalSpace X] (hs : IsClosed s) (U : Œπ ‚Üí Set X)
    (ho : ‚àÄ i, IsOpen (U i)) (hf : LocallyFinite U) (hU : s ‚äÜ ‚ãÉ i, U i) :
    ‚àÉ f : PartitionOfUnity Œπ X s, f.IsSubordinate U :=
  let ‚ü®f, hf‚ü© := BumpCovering.exists_isSubordinate_of_locallyFinite hs U ho hf hU
  ‚ü®f.toPartitionOfUnity, hf.toPartitionOfUnity‚ü©
#align partition_of_unity.exists_is_subordinate_of_locally_finite PartitionOfUnity.exists_isSubordinate_of_locallyFinite
-/

#print PartitionOfUnity.exists_isSubordinate /-
/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set
`s`, then there exists a `partition_of_unity Œπ X s` that is subordinate to `U`. -/
theorem exists_isSubordinate [NormalSpace X] [ParacompactSpace X] (hs : IsClosed s) (U : Œπ ‚Üí Set X)
    (ho : ‚àÄ i, IsOpen (U i)) (hU : s ‚äÜ ‚ãÉ i, U i) :
    ‚àÉ f : PartitionOfUnity Œπ X s, f.IsSubordinate U :=
  let ‚ü®f, hf‚ü© := BumpCovering.exists_isSubordinate hs U ho hU
  ‚ü®f.toPartitionOfUnity, hf.toPartitionOfUnity‚ü©
#align partition_of_unity.exists_is_subordinate PartitionOfUnity.exists_isSubordinate
-/

end PartitionOfUnity

