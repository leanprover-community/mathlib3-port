import Mathbin.Topology.UniformSpace.AbstractCompletion

/-!
# Hausdorff completions of uniform spaces

The goal is to construct a left-adjoint to the inclusion of complete Hausdorff uniform spaces
into all uniform spaces. Any uniform space `Œ±` gets a completion `completion Œ±` and a morphism
(ie. uniformly continuous map) `coe : Œ± ‚Üí completion Œ±` which solves the universal
mapping problem of factorizing morphisms from `Œ±` to any complete Hausdorff uniform space `Œ≤`.
It means any uniformly continuous `f : Œ± ‚Üí Œ≤` gives rise to a unique morphism
`completion.extension f : completion Œ± ‚Üí Œ≤` such that `f = completion.extension f ‚àò coe`.
Actually `completion.extension f` is defined for all maps from `Œ±` to `Œ≤` but it has the desired
properties only if `f` is uniformly continuous.

Beware that `coe` is not injective if `Œ±` is not Hausdorff. But its image is always
dense. The adjoint functor acting on morphisms is then constructed by the usual abstract nonsense.
For every uniform spaces `Œ±` and `Œ≤`, it turns `f : Œ± ‚Üí Œ≤` into a morphism
  `completion.map f : completion Œ± ‚Üí completion Œ≤`
such that
  `coe ‚àò f = (completion.map f) ‚àò coe`
provided `f` is uniformly continuous. This construction is compatible with composition.

In this file we introduce the following concepts:

* `Cauchy Œ±` the uniform completion of the uniform space `Œ±` (using Cauchy filters). These are not
  minimal filters.

* `completion Œ± := quotient (separation_setoid (Cauchy Œ±))` the Hausdorff completion.

## References

This formalization is mostly based on
  N. Bourbaki: General Topology
  I. M. James: Topologies and Uniformities
From a slightly different perspective in order to reuse material in topology.uniform_space.basic.
-/


noncomputable theory

open Filter Set

universe u v w x

open_locale uniformity Classical TopologicalSpace Filter

/-- Space of Cauchy filters

This is essentially the completion of a uniform space. The embeddings are the neighbourhood filters.
This space is not minimal, the separated uniform space (i.e. quotiented on the intersection of all
entourages) is necessary for this.
-/
def Cauchy‚Çì (Œ± : Type u) [UniformSpace Œ±] : Type u :=
  { f : Filter Œ± // Cauchy f }

namespace Cauchy‚Çì

section 

parameter {Œ± : Type u}[UniformSpace Œ±]

variable{Œ≤ : Type v}{Œ≥ : Type w}

variable[UniformSpace Œ≤][UniformSpace Œ≥]

def gen (s : Set (Œ± √ó Œ±)) : Set (Cauchy‚Çì Œ± √ó Cauchy‚Çì Œ±) :=
  { p | s ‚àà p.1.val √ó·∂† p.2.val }

theorem monotone_gen : Monotone gen :=
  monotone_set_of$ fun p => @monotone_mem (Œ± √ó Œ±) (p.1.val √ó·∂† p.2.val)

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
private theorem symm_gen : ¬´expr ‚â§ ¬ª(map prod.swap ((exprùì§() Œ±).lift' gen), (exprùì§() Œ±).lift' gen) :=
calc
  ¬´expr = ¬ª(map prod.swap ((exprùì§() Œ±).lift' gen), (exprùì§() Œ±).lift' (Œª
    s : set ¬´expr √ó ¬ª(Œ±, Œ±), {p | ¬´expr ‚àà ¬ª(s, ¬´expr √ó·∂† ¬ª(p.2.val, p.1.val))})) : begin
    delta [ident gen] [],
    simp [] [] [] ["[", expr map_lift'_eq, ",", expr monotone_set_of, ",", expr monotone_mem, ",", expr function.comp, ",", expr image_swap_eq_preimage_swap, ",", "-", ident subtype.val_eq_coe, "]"] [] []
  end
  ¬´expr ‚â§ ¬ª(..., (exprùì§() Œ±).lift' gen) : uniformity_lift_le_swap (monotone_principal.comp ¬´expr $ ¬ª(monotone_set_of, assume
    p, @monotone_mem ¬´expr √ó ¬ª(Œ±, Œ±) ¬´expr √ó·∂† ¬ª(p.2.val, p.1.val))) (begin
     have [ident h] [] [":=", expr Œª p : ¬´expr √ó ¬ª(Cauchy Œ±, Cauchy Œ±), @filter.prod_comm _ _ p.2.val p.1.val],
     simp [] [] [] ["[", expr function.comp, ",", expr h, ",", "-", ident subtype.val_eq_coe, ",", expr mem_map', "]"] [] [],
     exact [expr le_refl _]
   end)

private theorem comp_rel_gen_gen_subset_gen_comp_rel {s t : Set (Œ± √ó Œ±)} :
  CompRel (gen s) (gen t) ‚äÜ (gen (CompRel s t) : Set (Cauchy‚Çì Œ± √ó Cauchy‚Çì Œ±)) :=
  fun ‚ü®f, g‚ü© ‚ü®h, h‚ÇÅ, h‚ÇÇ‚ü© =>
    let ‚ü®t‚ÇÅ, (ht‚ÇÅ : t‚ÇÅ ‚àà f.val), t‚ÇÇ, (ht‚ÇÇ : t‚ÇÇ ‚àà h.val), (h‚ÇÅ : Set.Prod t‚ÇÅ t‚ÇÇ ‚äÜ s)‚ü© := mem_prod_iff.mp h‚ÇÅ 
    let ‚ü®t‚ÇÉ, (ht‚ÇÉ : t‚ÇÉ ‚àà h.val), t‚ÇÑ, (ht‚ÇÑ : t‚ÇÑ ‚àà g.val), (h‚ÇÇ : Set.Prod t‚ÇÉ t‚ÇÑ ‚äÜ t)‚ü© := mem_prod_iff.mp h‚ÇÇ 
    have  : t‚ÇÇ ‚à© t‚ÇÉ ‚àà h.val := inter_mem ht‚ÇÇ ht‚ÇÉ 
    let ‚ü®x, xt‚ÇÇ, xt‚ÇÉ‚ü© := h.property.left.nonempty_of_mem this
    (f.val √ó·∂† g.val).sets_of_superset (prod_mem_prod ht‚ÇÅ ht‚ÇÑ)
      fun ‚ü®a, b‚ü© ‚ü®(ha : a ‚àà t‚ÇÅ), (hb : b ‚àà t‚ÇÑ)‚ü© =>
        ‚ü®x, h‚ÇÅ (show (a, x) ‚àà Set.Prod t‚ÇÅ t‚ÇÇ from ‚ü®ha, xt‚ÇÇ‚ü©), h‚ÇÇ (show (x, b) ‚àà Set.Prod t‚ÇÉ t‚ÇÑ from ‚ü®xt‚ÇÉ, hb‚ü©)‚ü©

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
private theorem comp_gen : ¬´expr ‚â§ ¬ª(((exprùì§() Œ±).lift' gen).lift' (Œª s, comp_rel s s), (exprùì§() Œ±).lift' gen) :=
calc
  ¬´expr = ¬ª(((exprùì§() Œ±).lift' gen).lift' (Œª
    s, comp_rel s s), (exprùì§() Œ±).lift' (Œª s, comp_rel (gen s) (gen s))) : begin
    rw ["[", expr lift'_lift'_assoc, "]"] [],
    exact [expr monotone_gen],
    exact [expr monotone_comp_rel monotone_id monotone_id]
  end
  ¬´expr ‚â§ ¬ª(..., (exprùì§() Œ±).lift' (Œª
    s, ¬´expr $ ¬ª(gen, comp_rel s s))) : ¬´expr $ ¬ª(lift'_mono', assume s hs, comp_rel_gen_gen_subset_gen_comp_rel)
  ¬´expr = ¬ª(..., ¬´expr $ ¬ª((exprùì§() Œ±).lift', Œª s : set ¬´expr √ó ¬ª(Œ±, Œ±), comp_rel s s).lift' gen) : begin
    rw ["[", expr lift'_lift'_assoc, "]"] [],
    exact [expr monotone_comp_rel monotone_id monotone_id],
    exact [expr monotone_gen]
  end
  ¬´expr ‚â§ ¬ª(..., (exprùì§() Œ±).lift' gen) : lift'_mono comp_le_uniformity (le_refl _)

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
instance : uniform_space (Cauchy Œ±) :=
uniform_space.of_core { uniformity := (exprùì§() Œ±).lift' gen,
  refl := ¬´expr $ ¬ª(principal_le_lift', assume
   (s hs)
   ‚ü®a, b‚ü©
   (a_eq_b : ¬´expr = ¬ª(a, b)), ¬´expr ‚ñ∏ ¬ª(a_eq_b, a.property.right hs)),
  symm := symm_gen,
  comp := comp_gen }

theorem mem_uniformity {s : Set (Cauchy‚Çì Œ± √ó Cauchy‚Çì Œ±)} : s ‚àà ùì§ (Cauchy‚Çì Œ±) ‚Üî ‚àÉ (t : _)(_ : t ‚àà ùì§ Œ±), gen t ‚äÜ s :=
  mem_lift'_sets monotone_gen

theorem mem_uniformity' {s : Set (Cauchy‚Çì Œ± √ó Cauchy‚Çì Œ±)} :
  s ‚àà ùì§ (Cauchy‚Çì Œ±) ‚Üî ‚àÉ (t : _)(_ : t ‚àà ùì§ Œ±), ‚àÄ (f g : Cauchy‚Çì Œ±), t ‚àà f.1 √ó·∂† g.1 ‚Üí (f, g) ‚àà s :=
  mem_uniformity.trans$ bex_congr$ fun t h => Prod.forall

/-- Embedding of `Œ±` into its completion `Cauchy Œ±` -/
def pure_cauchy (a : Œ±) : Cauchy‚Çì Œ± :=
  ‚ü®pure a, cauchy_pure‚ü©

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem uniform_inducing_pure_cauchy : uniform_inducing (pure_cauchy : Œ± ‚Üí Cauchy Œ±) :=
‚ü®have ¬´expr = ¬ª(¬´expr ‚àò ¬ª(preimage (Œª
    x : ¬´expr √ó ¬ª(Œ±, Œ±), (pure_cauchy x.fst, pure_cauchy x.snd)), gen), id), from ¬´expr $ ¬ª(funext, assume
  s, ¬´expr $ ¬ª(set.ext, assume
   ‚ü®a‚ÇÅ, a‚ÇÇ‚ü©, by simp [] [] [] ["[", expr preimage, ",", expr gen, ",", expr pure_cauchy, ",", expr prod_principal_principal, "]"] [] [])),
 calc
   ¬´expr = ¬ª(comap (Œª
     x : ¬´expr √ó ¬ª(Œ±, Œ±), (pure_cauchy x.fst, pure_cauchy x.snd)) ((exprùì§() Œ±).lift' gen), (exprùì§() Œ±).lift' ¬´expr ‚àò ¬ª(preimage (Œª
      x : ¬´expr √ó ¬ª(Œ±, Œ±), (pure_cauchy x.fst, pure_cauchy x.snd)), gen)) : comap_lift'_eq monotone_gen
   ¬´expr = ¬ª(..., exprùì§() Œ±) : by simp [] [] [] ["[", expr this, "]"] [] []‚ü©

theorem uniform_embedding_pure_cauchy : UniformEmbedding (pure_cauchy : Œ± ‚Üí Cauchy‚Çì Œ±) :=
  { uniform_inducing_pure_cauchy with inj := fun a‚ÇÅ a‚ÇÇ h => pure_injective$ Subtype.ext_iff_val.1 h }

theorem dense_range_pure_cauchy : DenseRange pure_cauchy :=
  fun f =>
    have h_ex : ‚àÄ s (_ : s ‚àà ùì§ (Cauchy‚Çì Œ±)), ‚àÉ y : Œ±, (f, pure_cauchy y) ‚àà s :=
      fun s hs =>
        let ‚ü®t'', ht''‚ÇÅ, (ht''‚ÇÇ : gen t'' ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs 
        let ‚ü®t', ht'‚ÇÅ, ht'‚ÇÇ‚ü© := comp_mem_uniformity_sets ht''‚ÇÅ 
        have  : t' ‚àà f.val √ó·∂† f.val := f.property.right ht'‚ÇÅ 
        let ‚ü®t, ht, (h : Set.Prod t t ‚äÜ t')‚ü© := mem_prod_same_iff.mp this 
        let ‚ü®x, (hx : x ‚àà t)‚ü© := f.property.left.nonempty_of_mem ht 
        have  : t'' ‚àà f.val √ó·∂† pure x :=
          mem_prod_iff.mpr
            ‚ü®t, ht, { y:Œ± | (x, y) ‚àà t' }, h$ mk_mem_prod hx hx,
              fun ‚ü®a, b‚ü© ‚ü®(h‚ÇÅ : a ‚àà t), (h‚ÇÇ : (x, b) ‚àà t')‚ü© => ht'‚ÇÇ$ prod_mk_mem_comp_rel (@h (a, x) ‚ü®h‚ÇÅ, hx‚ü©) h‚ÇÇ‚ü©
        ‚ü®x,
          ht''‚ÇÇ$
            by 
              dsimp [gen] <;> exact this‚ü©
    by 
      simp only [closure_eq_cluster_pts, ClusterPt, nhds_eq_uniformity, lift'_inf_principal_eq,
        Set.inter_comm _ (range pure_cauchy), mem_set_of_eq]
      exact
        (lift'_ne_bot_iff$ monotone_inter monotone_const monotone_preimage).mpr
          fun s hs =>
            let ‚ü®y, hy‚ü© := h_ex s hs 
            have  : pure_cauchy y ‚àà range pure_cauchy ‚à© { y:Cauchy‚Çì Œ± | (f, y) ‚àà s } := ‚ü®mem_range_self y, hy‚ü©
            ‚ü®_, this‚ü©

theorem dense_inducing_pure_cauchy : DenseInducing pure_cauchy :=
  uniform_inducing_pure_cauchy.dense_inducing dense_range_pure_cauchy

theorem dense_embedding_pure_cauchy : DenseEmbedding pure_cauchy :=
  uniform_embedding_pure_cauchy.dense_embedding dense_range_pure_cauchy

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem nonempty_Cauchy_iff : ¬´expr ‚Üî ¬ª(nonempty (Cauchy Œ±), nonempty Œ±) :=
begin
  split; rintro ["‚ü®", ident c, "‚ü©"],
  { have [] [] [":=", expr eq_univ_iff_forall.1 dense_embedding_pure_cauchy.to_dense_inducing.closure_range c],
    obtain ["‚ü®", "_", ",", "‚ü®", "_", ",", ident a, ",", "_", "‚ü©", "‚ü©", ":=", expr mem_closure_iff.1 this _ is_open_univ trivial],
    exact [expr ‚ü®a‚ü©] },
  { exact [expr ‚ü®pure_cauchy c‚ü©] }
end

section 

set_option eqn_compiler.zeta true

instance  : CompleteSpace (Cauchy‚Çì Œ±) :=
  complete_space_extension uniform_inducing_pure_cauchy dense_range_pure_cauchy$
    fun f hf =>
      let f' : Cauchy‚Çì Œ± := ‚ü®f, hf‚ü©
      have  : map pure_cauchy f ‚â§ (ùì§$ Cauchy‚Çì Œ±).lift' (preimage (Prod.mk f')) :=
        le_lift'$
          fun s hs =>
            let ‚ü®t, ht‚ÇÅ, (ht‚ÇÇ : gen t ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs 
            let ‚ü®t', ht', (h : Set.Prod t' t' ‚äÜ t)‚ü© := mem_prod_same_iff.mp (hf.right ht‚ÇÅ)
            have  : t' ‚äÜ { y:Œ± | (f', pure_cauchy y) ‚àà gen t } :=
              fun x hx => (f √ó·∂† pure x).sets_of_superset (prod_mem_prod ht' hx) h 
            f.sets_of_superset ht'$ subset.trans this (preimage_mono ht‚ÇÇ)
      ‚ü®f',
        by 
          simp [nhds_eq_uniformity] <;> assumption‚ü©

end 

instance  [Inhabited Œ±] : Inhabited (Cauchy‚Çì Œ±) :=
  ‚ü®pure_cauchy$ default Œ±‚ü©

instance  [h : Nonempty Œ±] : Nonempty (Cauchy‚Çì Œ±) :=
  h.rec_on$ fun a => Nonempty.intro$ Cauchy‚Çì.pureCauchy a

section Extend

def extend (f : Œ± ‚Üí Œ≤) : Cauchy‚Çì Œ± ‚Üí Œ≤ :=
  if UniformContinuous f then dense_inducing_pure_cauchy.extend f else
    fun x => f (Classical.inhabitedOfNonempty$ nonempty_Cauchy_iff.1 ‚ü®x‚ü©).default

variable[SeparatedSpace Œ≤]

theorem extend_pure_cauchy {f : Œ± ‚Üí Œ≤} (hf : UniformContinuous f) (a : Œ±) : extend f (pure_cauchy a) = f a :=
  by 
    rw [extend, if_pos hf]
    exact uniformly_extend_of_ind uniform_inducing_pure_cauchy dense_range_pure_cauchy hf _

variable[_root_.complete_space Œ≤]

theorem uniform_continuous_extend {f : Œ± ‚Üí Œ≤} : UniformContinuous (extend f) :=
  by 
    byCases' hf : UniformContinuous f
    ¬∑
      rw [extend, if_pos hf]
      exact uniform_continuous_uniformly_extend uniform_inducing_pure_cauchy dense_range_pure_cauchy hf
    ¬∑
      rw [extend, if_neg hf]
      exact
        uniform_continuous_of_const
          fun a b =>
            by 
              congr

end Extend

end 

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem Cauchy_eq
{Œ± : Type*}
[inhabited Œ±]
[uniform_space Œ±]
[complete_space Œ±]
[separated_space Œ±]
{f g : Cauchy Œ±} : ¬´expr ‚Üî ¬ª(¬´expr = ¬ª(Lim f.1, Lim g.1), ¬´expr ‚àà ¬ª((f, g), separation_rel (Cauchy Œ±))) :=
begin
  split,
  { intros [ident e, ident s, ident hs],
    rcases [expr Cauchy.mem_uniformity'.1 hs, "with", "‚ü®", ident t, ",", ident tu, ",", ident ts, "‚ü©"],
    apply [expr ts],
    rcases [expr comp_mem_uniformity_sets tu, "with", "‚ü®", ident d, ",", ident du, ",", ident dt, "‚ü©"],
    refine [expr mem_prod_iff.2 ‚ü®_, f.2.le_nhds_Lim (mem_nhds_right (Lim f.1) du), _, g.2.le_nhds_Lim (mem_nhds_left (Lim g.1) du), Œª
      x h, _‚ü©],
    cases [expr x] ["with", ident a, ident b],
    cases [expr h] ["with", ident h‚ÇÅ, ident h‚ÇÇ],
    rw ["<-", expr e] ["at", ident h‚ÇÇ],
    exact [expr dt ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü©] },
  { intros [ident H],
    refine [expr separated_def.1 (by apply_instance) _ _ (Œª t tu, _)],
    rcases [expr mem_uniformity_is_closed tu, "with", "‚ü®", ident d, ",", ident du, ",", ident dc, ",", ident dt, "‚ü©"],
    refine [expr H {p | ¬´expr ‚àà ¬ª((Lim p.1.1, Lim p.2.1), t)} (Cauchy.mem_uniformity'.2 ‚ü®d, du, Œª f g h, _‚ü©)],
    rcases [expr mem_prod_iff.1 h, "with", "‚ü®", ident x, ",", ident xf, ",", ident y, ",", ident yg, ",", ident h, "‚ü©"],
    have [ident limc] [":", expr ‚àÄ (f : Cauchy Œ±) (x ¬´expr ‚àà ¬ª f.1), ¬´expr ‚àà ¬ª(Lim f.1, closure x)] [],
    { intros [ident f, ident x, ident xf],
      rw [expr closure_eq_cluster_pts] [],
      exact [expr f.2.1.mono (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf))] },
    have [] [] [":=", expr dc.closure_subset_iff.2 h],
    rw [expr closure_prod_eq] ["at", ident this],
    refine [expr dt (this ‚ü®_, _‚ü©)]; dsimp [] [] [] []; apply [expr limc]; assumption }
end

section 

attribute [local instance] UniformSpace.separationSetoid

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem separated_pure_cauchy_injective
{Œ± : Type*}
[uniform_space Œ±]
[s : separated_space Œ±] : function.injective (Œª a : Œ±, ¬´expr‚ü¶ ‚üß¬ª(pure_cauchy a))
| a, b, h := ¬´expr $ ¬ª(separated_def.1 s _ _, assume
 s
 hs, let ‚ü®t, ht, hts‚ü© := by rw ["[", "<-", expr (@uniform_embedding_pure_cauchy Œ± _).comap_uniformity, ",", expr filter.mem_comap, "]"] ["at", ident hs]; exact [expr hs] in
 have ¬´expr ‚àà ¬ª((pure_cauchy a, pure_cauchy b), t), from quotient.exact h t ht,
 @hts (a, b) this)

end 

end Cauchy‚Çì

attribute [local instance] UniformSpace.separationSetoid

open Cauchy‚Çì Set

namespace UniformSpace

variable(Œ± : Type _)[UniformSpace Œ±]

variable{Œ≤ : Type _}[UniformSpace Œ≤]

variable{Œ≥ : Type _}[UniformSpace Œ≥]

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
instance complete_space_separation [h : complete_space Œ±] : complete_space (quotient (separation_setoid Œ±)) :=
‚ü®assume
 f, assume
 hf : cauchy f, have cauchy (f.comap (Œª
   x, ¬´expr‚ü¶ ‚üß¬ª(x))), from ¬´expr $ ¬ª(hf.comap' comap_quotient_le_uniformity, hf.left.comap_of_surj (surjective_quotient_mk _)),
 let ‚ü®x, (hx : ¬´expr ‚â§ ¬ª(f.comap (Œª x, ¬´expr‚ü¶ ‚üß¬ª(x)), exprùìù() x))‚ü© := complete_space.complete this in
 ‚ü®¬´expr‚ü¶ ‚üß¬ª(x), ¬´expr $ ¬ª(comap_le_comap_iff, by simp [] [] [] [] [] []).1 ¬´expr $ ¬ª(hx.trans, map_le_iff_le_comap.1 continuous_quotient_mk.continuous_at)‚ü©‚ü©

/-- Hausdorff completion of `Œ±` -/
def completion :=
  Quotient‚Çì (separation_setoid$ Cauchy‚Çì Œ±)

namespace Completion

instance  [Inhabited Œ±] : Inhabited (completion Œ±) :=
  by 
    unfold completion <;> infer_instance

instance (priority := 50) : UniformSpace (completion Œ±) :=
  by 
    dunfold completion <;> infer_instance

instance  : CompleteSpace (completion Œ±) :=
  by 
    dunfold completion <;> infer_instance

instance  : SeparatedSpace (completion Œ±) :=
  by 
    dunfold completion <;> infer_instance

instance  : RegularSpace (completion Œ±) :=
  separated_regular

/-- Automatic coercion from `Œ±` to its completion. Not always injective. -/
instance  : CoeT‚Çì Œ± (completion Œ±) :=
  ‚ü®Quotient‚Çì.mk ‚àò pure_cauchy‚ü©

protected theorem coe_eq : (coe‚Çì : Œ± ‚Üí completion Œ±) = (Quotient‚Çì.mk ‚àò pure_cauchy) :=
  rfl

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem comap_coe_eq_uniformity : ¬´expr = ¬ª((exprùì§() _).comap (Œª
  p : ¬´expr √ó ¬ª(Œ±, Œ±), ((p.1 : completion Œ±), (p.2 : completion Œ±))), exprùì§() Œ±) :=
begin
  have [] [":", expr ¬´expr = ¬ª(Œª
    x : ¬´expr √ó ¬ª(Œ±, Œ±), ((x.1 : completion Œ±), (x.2 : completion Œ±)), ¬´expr ‚àò ¬ª(Œª
     x : ¬´expr √ó ¬ª(Cauchy Œ±, Cauchy Œ±), (¬´expr‚ü¶ ‚üß¬ª(x.1), ¬´expr‚ü¶ ‚üß¬ª(x.2)), Œª
     x : ¬´expr √ó ¬ª(Œ±, Œ±), (pure_cauchy x.1, pure_cauchy x.2)))] [],
  { ext [] ["‚ü®", ident a, ",", ident b, "‚ü©"] []; simp [] [] [] [] [] []; refl },
  rw ["[", expr this, ",", "<-", expr filter.comap_comap, "]"] [],
  change [expr ¬´expr = ¬ª(filter.comap _ (filter.comap _ ¬´expr $ ¬ª(exprùì§(), ¬´expr $ ¬ª(quotient, ¬´expr $ ¬ª(separation_setoid, Cauchy Œ±)))), exprùì§() Œ±)] [] [],
  rw ["[", expr comap_quotient_eq_uniformity, ",", expr uniform_embedding_pure_cauchy.comap_uniformity, "]"] []
end

theorem uniform_inducing_coe : UniformInducing (coe‚Çì : Œ± ‚Üí completion Œ±) :=
  ‚ü®comap_coe_eq_uniformity Œ±‚ü©

variable{Œ±}

theorem dense_range_coe : DenseRange (coe‚Çì : Œ± ‚Üí completion Œ±) :=
  dense_range_pure_cauchy.Quotient

variable(Œ±)

def cpkg {Œ± : Type _} [UniformSpace Œ±] : AbstractCompletion Œ± :=
  { Space := completion Œ±, coe := coe‚Çì,
    uniformStruct :=
      by 
        infer_instance,
    complete :=
      by 
        infer_instance,
    separation :=
      by 
        infer_instance,
    UniformInducing := completion.uniform_inducing_coe Œ±, dense := completion.dense_range_coe }

instance abstract_completion.inhabited : Inhabited (AbstractCompletion Œ±) :=
  ‚ü®cpkg‚ü©

attribute [local instance] AbstractCompletion.uniformStruct AbstractCompletion.complete AbstractCompletion.separation

theorem nonempty_completion_iff : Nonempty (completion Œ±) ‚Üî Nonempty Œ± :=
  cpkg.dense.nonempty_iff.symm

theorem uniform_continuous_coe : UniformContinuous (coe‚Çì : Œ± ‚Üí completion Œ±) :=
  cpkg.uniform_continuous_coe

theorem continuous_coe : Continuous (coe‚Çì : Œ± ‚Üí completion Œ±) :=
  cpkg.continuous_coe

theorem uniform_embedding_coe [SeparatedSpace Œ±] : UniformEmbedding (coe‚Çì : Œ± ‚Üí completion Œ±) :=
  { comap_uniformity := comap_coe_eq_uniformity Œ±, inj := separated_pure_cauchy_injective }

variable{Œ±}

theorem dense_inducing_coe : DenseInducing (coe‚Çì : Œ± ‚Üí completion Œ±) :=
  { (uniform_inducing_coe Œ±).Inducing with dense := dense_range_coe }

open TopologicalSpace

instance separable_space_completion [separable_space Œ±] : separable_space (completion Œ±) :=
  completion.dense_inducing_coe.SeparableSpace

theorem dense_embedding_coe [SeparatedSpace Œ±] : DenseEmbedding (coe‚Çì : Œ± ‚Üí completion Œ±) :=
  { dense_inducing_coe with inj := separated_pure_cauchy_injective }

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem dense_range_coe‚ÇÇ : dense_range (Œª x : ¬´expr √ó ¬ª(Œ±, Œ≤), ((x.1 : completion Œ±), (x.2 : completion Œ≤))) :=
dense_range_coe.prod_map dense_range_coe

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem dense_range_coe‚ÇÉ : dense_range (Œª
 x : ¬´expr √ó ¬ª(Œ±, ¬´expr √ó ¬ª(Œ≤, Œ≥)), ((x.1 : completion Œ±), ((x.2.1 : completion Œ≤), (x.2.2 : completion Œ≥)))) :=
dense_range_coe.prod_map dense_range_coe‚ÇÇ

@[elab_as_eliminator]
theorem induction_on {p : completion Œ± ‚Üí Prop} (a : completion Œ±) (hp : IsClosed { a | p a }) (ih : ‚àÄ (a : Œ±), p a) :
  p a :=
  is_closed_property dense_range_coe hp ih a

@[elab_as_eliminator]
theorem induction_on‚ÇÇ {p : completion Œ± ‚Üí completion Œ≤ ‚Üí Prop} (a : completion Œ±) (b : completion Œ≤)
  (hp : IsClosed { x:completion Œ± √ó completion Œ≤ | p x.1 x.2 }) (ih : ‚àÄ (a : Œ±) (b : Œ≤), p a b) : p a b :=
  have  : ‚àÄ (x : completion Œ± √ó completion Œ≤), p x.1 x.2 :=
    is_closed_property dense_range_coe‚ÇÇ hp$ fun ‚ü®a, b‚ü© => ih a b 
  this (a, b)

@[elab_as_eliminator]
theorem induction_on‚ÇÉ {p : completion Œ± ‚Üí completion Œ≤ ‚Üí completion Œ≥ ‚Üí Prop} (a : completion Œ±) (b : completion Œ≤)
  (c : completion Œ≥) (hp : IsClosed { x:completion Œ± √ó completion Œ≤ √ó completion Œ≥ | p x.1 x.2.1 x.2.2 })
  (ih : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), p a b c) : p a b c :=
  have  : ‚àÄ (x : completion Œ± √ó completion Œ≤ √ó completion Œ≥), p x.1 x.2.1 x.2.2 :=
    is_closed_property dense_range_coe‚ÇÉ hp$ fun ‚ü®a, b, c‚ü© => ih a b c 
  this (a, b, c)

theorem ext [T2Space Œ≤] {f g : completion Œ± ‚Üí Œ≤} (hf : Continuous f) (hg : Continuous g) (h : ‚àÄ (a : Œ±), f a = g a) :
  f = g :=
  cpkg.funext hf hg h

section Extension

variable{f : Œ± ‚Üí Œ≤}

/-- "Extension" to the completion. It is defined for any map `f` but
returns an arbitrary constant value if `f` is not uniformly continuous -/
protected def extension (f : Œ± ‚Üí Œ≤) : completion Œ± ‚Üí Œ≤ :=
  cpkg.extend f

variable[SeparatedSpace Œ≤]

@[simp]
theorem extension_coe (hf : UniformContinuous f) (a : Œ±) : (completion.extension f) a = f a :=
  cpkg.extend_coe hf a

variable[CompleteSpace Œ≤]

theorem uniform_continuous_extension : UniformContinuous (completion.extension f) :=
  cpkg.uniform_continuous_extend

theorem continuous_extension : Continuous (completion.extension f) :=
  cpkg.continuous_extend

theorem extension_unique (hf : UniformContinuous f) {g : completion Œ± ‚Üí Œ≤} (hg : UniformContinuous g)
  (h : ‚àÄ (a : Œ±), f a = g (a : completion Œ±)) : completion.extension f = g :=
  cpkg.extend_unique hf hg h

@[simp]
theorem extension_comp_coe {f : completion Œ± ‚Üí Œ≤} (hf : UniformContinuous f) : completion.extension (f ‚àò coe‚Çì) = f :=
  cpkg.extend_comp_coe hf

end Extension

section Map

variable{f : Œ± ‚Üí Œ≤}

/-- Completion functor acting on morphisms -/
protected def map (f : Œ± ‚Üí Œ≤) : completion Œ± ‚Üí completion Œ≤ :=
  cpkg.map cpkg f

theorem uniform_continuous_map : UniformContinuous (completion.map f) :=
  cpkg.uniform_continuous_map cpkg f

theorem continuous_map : Continuous (completion.map f) :=
  cpkg.continuous_map cpkg f

@[simp]
theorem map_coe (hf : UniformContinuous f) (a : Œ±) : (completion.map f) a = f a :=
  cpkg.map_coe cpkg hf a

theorem map_unique {f : Œ± ‚Üí Œ≤} {g : completion Œ± ‚Üí completion Œ≤} (hg : UniformContinuous g)
  (h : ‚àÄ (a : Œ±), ¬´expr‚Üë ¬ª (f a) = g a) : completion.map f = g :=
  cpkg.map_unique cpkg hg h

@[simp]
theorem map_id : completion.map (@id Œ±) = id :=
  cpkg.map_id

theorem extension_map [CompleteSpace Œ≥] [SeparatedSpace Œ≥] {f : Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ≤} (hf : UniformContinuous f)
  (hg : UniformContinuous g) : (completion.extension f ‚àò completion.map g) = completion.extension (f ‚àò g) :=
  completion.ext (continuous_extension.comp continuous_map) continuous_extension$
    by 
      intro a <;> simp only [hg, hf, hf.comp hg, ¬∑ ‚àò ¬∑, map_coe, extension_coe]

theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : UniformContinuous g) (hf : UniformContinuous f) :
  (completion.map g ‚àò completion.map f) = completion.map (g ‚àò f) :=
  extension_map ((uniform_continuous_coe _).comp hg) hf

end Map

section SeparationQuotientCompletion

def completion_separation_quotient_equiv (Œ± : Type u) [UniformSpace Œ±] :
  completion (separation_quotient Œ±) ‚âÉ completion Œ± :=
  by 
    refine'
      ‚ü®completion.extension (separation_quotient.lift (coe‚Çì : Œ± ‚Üí completion Œ±)), completion.map Quotient‚Çì.mk, _, _‚ü©
    ¬∑
      intro a 
      refine' induction_on a (is_closed_eq (continuous_map.comp continuous_extension) continuous_id) _ 
      rintro ‚ü®a‚ü©
      show
        completion.map Quotient‚Çì.mk (completion.extension (separation_quotient.lift coe‚Çì) (¬´expr‚Üë ¬ª (¬´expr‚ü¶ ‚üß¬ª a))) =
          ¬´expr‚Üë ¬ª (¬´expr‚ü¶ ‚üß¬ª a)
      rw [extension_coe (separation_quotient.uniform_continuous_lift _),
          separation_quotient.lift_mk (uniform_continuous_coe Œ±), completion.map_coe uniform_continuous_quotient_mk] <;>
        infer_instance
    ¬∑
      intro a 
      refine'
        completion.induction_on a (is_closed_eq (continuous_extension.comp continuous_map) continuous_id) fun a => _ 
      rw [map_coe uniform_continuous_quotient_mk, extension_coe (separation_quotient.uniform_continuous_lift _),
          separation_quotient.lift_mk (uniform_continuous_coe Œ±) _] <;>
        infer_instance

theorem uniform_continuous_completion_separation_quotient_equiv :
  UniformContinuous (¬´expr‚áë ¬ª (completion_separation_quotient_equiv Œ±)) :=
  uniform_continuous_extension

theorem uniform_continuous_completion_separation_quotient_equiv_symm :
  UniformContinuous (¬´expr‚áë ¬ª (completion_separation_quotient_equiv Œ±).symm) :=
  uniform_continuous_map

end SeparationQuotientCompletion

section Extension‚ÇÇ

variable(f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)

open Function

protected def extension‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : completion Œ± ‚Üí completion Œ≤ ‚Üí Œ≥ :=
  cpkg.extend‚ÇÇ cpkg f

variable[SeparatedSpace Œ≥]{f}

@[simp]
theorem extension‚ÇÇ_coe_coe (hf : UniformContinuous‚ÇÇ f) (a : Œ±) (b : Œ≤) : completion.extension‚ÇÇ f a b = f a b :=
  cpkg.extension‚ÇÇ_coe_coe cpkg hf a b

variable[CompleteSpace Œ≥](f)

theorem uniform_continuous_extension‚ÇÇ : UniformContinuous‚ÇÇ (completion.extension‚ÇÇ f) :=
  cpkg.uniform_continuous_extension‚ÇÇ cpkg f

end Extension‚ÇÇ

section Map‚ÇÇ

open Function

protected def map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : completion Œ± ‚Üí completion Œ≤ ‚Üí completion Œ≥ :=
  cpkg.map‚ÇÇ cpkg cpkg f

theorem uniform_continuous_map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : UniformContinuous‚ÇÇ (completion.map‚ÇÇ f) :=
  cpkg.uniform_continuous_map‚ÇÇ cpkg cpkg f

-- error in Topology.UniformSpace.Completion: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_map‚ÇÇ
{Œ¥}
[topological_space Œ¥]
{f : Œ± ‚Üí Œ≤ ‚Üí Œ≥}
{a : Œ¥ ‚Üí completion Œ±}
{b : Œ¥ ‚Üí completion Œ≤}
(ha : continuous a)
(hb : continuous b) : continuous (Œª d : Œ¥, completion.map‚ÇÇ f (a d) (b d)) :=
cpkg.continuous_map‚ÇÇ cpkg cpkg ha hb

theorem map‚ÇÇ_coe_coe (a : Œ±) (b : Œ≤) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hf : UniformContinuous‚ÇÇ f) :
  completion.map‚ÇÇ f (a : completion Œ±) (b : completion Œ≤) = f a b :=
  cpkg.map‚ÇÇ_coe_coe cpkg cpkg a b f hf

end Map‚ÇÇ

end Completion

end UniformSpace

