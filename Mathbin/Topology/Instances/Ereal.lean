import Mathbin.Topology.Instances.Ennreal 
import Mathbin.Topology.Algebra.Ordered.MonotoneContinuity 
import Mathbin.Data.Real.Ereal

/-!
# Topological structure on `ereal`

We endow `ereal` with the order topology, and prove basic properties of this topology.

## Main results

* `coe : ‚Ñù ‚Üí ereal` is an open embedding
* `coe : ‚Ñù‚â•0‚àû ‚Üí ereal` is an embedding
* The addition on `ereal` is continuous except at `(‚ä•, ‚ä§)` and at `(‚ä§, ‚ä•)`.
* Negation is a homeomorphism on `ereal`.

## Implementation

Most proofs are adapted from the corresponding proofs on `‚Ñù‚â•0‚àû`.
-/


noncomputable theory

open Classical Set Filter Metric TopologicalSpace

open_locale Classical TopologicalSpace Ennreal Nnreal BigOperators Filter

variable{Œ± : Type _}[TopologicalSpace Œ±]

namespace Ereal

instance  : TopologicalSpace Ereal :=
  Preorder‚Çì.topology Ereal

instance  : OrderTopology Ereal :=
  ‚ü®rfl‚ü©

instance  : T2Space Ereal :=
  by 
    infer_instance

-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
instance : second_countable_topology ereal :=
‚ü®begin
   refine [expr ‚ü®¬´expr‚ãÉ , ¬ª((q : expr‚Ñö()), {{a : ereal | ¬´expr < ¬ª(a, (q : expr‚Ñù()))}, {a : ereal | ¬´expr < ¬ª(((q : expr‚Ñù()) : ereal), a)}}), countable_Union (Œª
      a, (countable_singleton _).insert _), _‚ü©],
   refine [expr le_antisymm ¬´expr $ ¬ª(le_generate_from, by simp [] [] [] ["[", expr or_imp_distrib, ",", expr is_open_lt', ",", expr is_open_gt', "]"] [] [] { contextual := tt }) _],
   apply [expr le_generate_from (Œª s h, _)],
   rcases [expr h, "with", "‚ü®", ident a, ",", ident hs, "|", ident hs, "‚ü©"]; [rw [expr show ¬´expr = ¬ª(s, ¬´expr‚ãÉ , ¬ª((q ¬´expr ‚àà ¬ª {q : expr‚Ñö() | ¬´expr < ¬ª(a, (q : expr‚Ñù()))}), {b | ¬´expr < ¬ª(((q : expr‚Ñù()) : ereal), b)})), by { ext [] [ident x] [],
       simpa [] [] ["only"] ["[", expr hs, ",", expr exists_prop, ",", expr mem_Union, "]"] [] ["using", expr lt_iff_exists_rat_btwn] }] [], rw [expr show ¬´expr = ¬ª(s, ¬´expr‚ãÉ , ¬ª((q ¬´expr ‚àà ¬ª {q : expr‚Ñö() | ¬´expr < ¬ª(((q : expr‚Ñù()) : ereal), a)}), {b | ¬´expr < ¬ª(b, ((q : expr‚Ñù()) : ereal))})), by { ext [] [ident x] [],
       simpa [] [] ["only"] ["[", expr hs, ",", expr and_comm, ",", expr exists_prop, ",", expr mem_Union, "]"] [] ["using", expr lt_iff_exists_rat_btwn] }] []]; { apply [expr is_open_Union],
     intro [ident q],
     apply [expr is_open_Union],
     intro [ident hq],
     apply [expr generate_open.basic],
     exact [expr mem_Union.2 ‚ü®q, by simp [] [] [] [] [] []‚ü©] }
 end‚ü©

/-! ### Real coercion -/


theorem embedding_coe : Embedding (coe‚Çì : ‚Ñù ‚Üí Ereal) :=
  ‚ü®‚ü®by 
        refine' le_antisymm‚Çì _ _
        ¬∑
          rw [@OrderTopology.topology_eq_generate_intervals Ereal _, ‚Üêcoinduced_le_iff_le_induced]
          refine' le_generate_from fun s ha => _ 
          rcases ha with ‚ü®a, rfl | rfl‚ü©
          show IsOpen { b:‚Ñù | a < ¬´expr‚Üë ¬ª b }
          ¬∑
            induction a using Ereal.rec
            ¬∑
              simp only [is_open_univ, bot_lt_coe, set_of_true]
            ¬∑
              simp only [Ereal.coe_lt_coe_iff]
              exact is_open_Ioi
            ¬∑
              simp only [set_of_false, is_open_empty, not_top_lt]
          show IsOpen { b:‚Ñù | ¬´expr‚Üë ¬ª b < a }
          ¬∑
            induction a using Ereal.rec
            ¬∑
              simp only [not_lt_bot, set_of_false, is_open_empty]
            ¬∑
              simp only [Ereal.coe_lt_coe_iff]
              exact is_open_Iio
            ¬∑
              simp only [is_open_univ, coe_lt_top, set_of_true]
        ¬∑
          rw [@OrderTopology.topology_eq_generate_intervals ‚Ñù _]
          refine' le_generate_from fun s ha => _ 
          rcases ha with ‚ü®a, rfl | rfl‚ü©
          exact
            ‚ü®Ioi a, is_open_Ioi,
              by 
                simp [Ioi]‚ü©
          exact
            ‚ü®Iio a, is_open_Iio,
              by 
                simp [Iio]‚ü©‚ü©,
    fun a b =>
      by 
        simp only [imp_self, Ereal.coe_eq_coe_iff]‚ü©

theorem open_embedding_coe : OpenEmbedding (coe‚Çì : ‚Ñù ‚Üí Ereal) :=
  ‚ü®embedding_coe,
    by 
      convert @is_open_Ioo Ereal _ _ _ ‚ä• ‚ä§
      ext x 
      induction x using Ereal.rec
      ¬∑
        simp only [left_mem_Ioo, mem_range, coe_ne_bot, exists_false, not_false_iff]
      ¬∑
        simp only [mem_range_self, mem_Ioo, bot_lt_coe, coe_lt_top, and_self‚Çì]
      ¬∑
        simp only [mem_range, right_mem_Ioo, exists_false, coe_ne_top]‚ü©

@[normCast]
theorem tendsto_coe {Œ± : Type _} {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù} {a : ‚Ñù} :
  tendsto (fun a => (m a : Ereal)) f (ùìù (¬´expr‚Üë ¬ª a)) ‚Üî tendsto m f (ùìù a) :=
  embedding_coe.tendsto_nhds_iff.symm

theorem _root_.continuous_coe_real_ereal : Continuous (coe‚Çì : ‚Ñù ‚Üí Ereal) :=
  embedding_coe.Continuous

theorem continuous_coe_iff {f : Œ± ‚Üí ‚Ñù} : (Continuous fun a => (f a : Ereal)) ‚Üî Continuous f :=
  embedding_coe.continuous_iff.symm

theorem nhds_coe {r : ‚Ñù} : ùìù (r : Ereal) = (ùìù r).map coe‚Çì :=
  (open_embedding_coe.map_nhds_eq r).symm

-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem nhds_coe_coe
{r
 p : expr‚Ñù()} : ¬´expr = ¬ª(exprùìù() ((r : ereal), (p : ereal)), (exprùìù() (r, p)).map (Œª
  p : ¬´expr √ó ¬ª(expr‚Ñù(), expr‚Ñù()), (p.1, p.2))) :=
((open_embedding_coe.prod open_embedding_coe).map_nhds_eq (r, p)).symm

theorem tendsto_to_real {a : Ereal} (ha : a ‚â† ‚ä§) (h'a : a ‚â† ‚ä•) : tendsto Ereal.toReal (ùìù a) (ùìù a.to_real) :=
  by 
    lift a to ‚Ñù using And.intro ha h'a 
    rw [nhds_coe, tendsto_map'_iff]
    exact tendsto_id

theorem continuous_on_to_real : ContinuousOn Ereal.toReal ({‚ä•, ‚ä§} : Set Ereal).Compl :=
  fun a ha =>
    ContinuousAt.continuous_within_at
      (tendsto_to_real
        (by 
          simp [not_or_distrib] at ha 
          exact ha.2)
        (by 
          simp [not_or_distrib] at ha 
          exact ha.1))

/-- The set of finite `ereal` numbers is homeomorphic to `‚Ñù`. -/
def ne_bot_top_homeomorph_real : ({‚ä•, ‚ä§} : Set Ereal).Compl ‚âÉ‚Çú ‚Ñù :=
  { ne_top_bot_equiv_real with continuous_to_fun := continuous_on_iff_continuous_restrict.1 continuous_on_to_real,
    continuous_inv_fun := continuous_subtype_mk _ continuous_coe_real_ereal }

/-! ### ennreal coercion -/


-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem embedding_coe_ennreal : embedding (coe : ¬´expr‚Ñù‚â•0‚àû¬ª() ‚Üí ereal) :=
‚ü®‚ü®begin
    refine [expr le_antisymm _ _],
    { rw ["[", expr @order_topology.topology_eq_generate_intervals ereal _, ",", "<-", expr coinduced_le_iff_le_induced, "]"] [],
      refine [expr le_generate_from (assume s ha, _)],
      rcases [expr ha, "with", "‚ü®", ident a, ",", ident rfl, "|", ident rfl, "‚ü©"],
      show [expr is_open {b : ¬´expr‚Ñù‚â•0‚àû¬ª() | ¬´expr < ¬ª(a, ¬´expr‚Üë ¬ª(b))}],
      { induction [expr a] ["using", ident ereal.rec] ["with", ident x] [],
        { simp [] [] ["only"] ["[", expr is_open_univ, ",", expr bot_lt_coe_ennreal, ",", expr set_of_true, "]"] [] [] },
        { rcases [expr le_or_lt 0 x, "with", ident h, "|", ident h],
          { have [] [":", expr ¬´expr = ¬ª((x : ereal), ((id ‚ü®x, h‚ü© : ¬´expr‚Ñù‚â•0¬ª()) : ¬´expr‚Ñù‚â•0‚àû¬ª()))] [":=", expr rfl],
            rw [expr this] [],
            simp [] [] ["only"] ["[", expr id.def, ",", expr coe_ennreal_lt_coe_ennreal_iff, "]"] [] [],
            exact [expr is_open_Ioi] },
          { have [] [":", expr ‚àÄ
             y : ¬´expr‚Ñù‚â•0‚àû¬ª(), ¬´expr < ¬ª((x : ereal), y)] [":=", expr Œª
             y, (ereal.coe_lt_coe_iff.2 h).trans_le (coe_ennreal_nonneg _)],
            simp [] [] ["only"] ["[", expr this, ",", expr is_open_univ, ",", expr set_of_true, "]"] [] [] } },
        { simp [] [] ["only"] ["[", expr set_of_false, ",", expr is_open_empty, ",", expr not_top_lt, "]"] [] [] } },
      show [expr is_open {b : ¬´expr‚Ñù‚â•0‚àû¬ª() | ¬´expr < ¬ª(¬´expr‚Üë ¬ª(b), a)}],
      { induction [expr a] ["using", ident ereal.rec] ["with", ident x] [],
        { simp [] [] ["only"] ["[", expr not_lt_bot, ",", expr set_of_false, ",", expr is_open_empty, "]"] [] [] },
        { rcases [expr le_or_lt 0 x, "with", ident h, "|", ident h],
          { have [] [":", expr ¬´expr = ¬ª((x : ereal), ((id ‚ü®x, h‚ü© : ¬´expr‚Ñù‚â•0¬ª()) : ¬´expr‚Ñù‚â•0‚àû¬ª()))] [":=", expr rfl],
            rw [expr this] [],
            simp [] [] ["only"] ["[", expr id.def, ",", expr coe_ennreal_lt_coe_ennreal_iff, "]"] [] [],
            exact [expr is_open_Iio] },
          { convert [] [expr is_open_empty] [],
            apply [expr eq_empty_iff_forall_not_mem.2 (Œª y hy, lt_irrefl (x : ereal) _)],
            exact [expr ((ereal.coe_lt_coe_iff.2 h).trans_le (coe_ennreal_nonneg y)).trans hy] } },
        { simp [] [] ["only"] ["[", "<-", expr coe_ennreal_top, ",", expr coe_ennreal_lt_coe_ennreal_iff, "]"] [] [],
          exact [expr is_open_Iio] } } },
    { rw ["[", expr @order_topology.topology_eq_generate_intervals ¬´expr‚Ñù‚â•0‚àû¬ª() _, "]"] [],
      refine [expr le_generate_from (assume s ha, _)],
      rcases [expr ha, "with", "‚ü®", ident a, ",", ident rfl, "|", ident rfl, "‚ü©"],
      exact [expr ‚ü®Ioi a, is_open_Ioi, by simp [] [] [] ["[", expr Ioi, "]"] [] []‚ü©],
      exact [expr ‚ü®Iio a, is_open_Iio, by simp [] [] [] ["[", expr Iio, "]"] [] []‚ü©] }
  end‚ü©, assume a b, by simp [] [] ["only"] ["[", expr imp_self, ",", expr coe_ennreal_eq_coe_ennreal_iff, "]"] [] []‚ü©

@[normCast]
theorem tendsto_coe_ennreal {Œ± : Type _} {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} :
  tendsto (fun a => (m a : Ereal)) f (ùìù (¬´expr‚Üë ¬ª a)) ‚Üî tendsto m f (ùìù a) :=
  embedding_coe_ennreal.tendsto_nhds_iff.symm

theorem _root_.continuous_coe_ennreal_ereal : Continuous (coe‚Çì : ‚Ñù‚â•0‚àû ‚Üí Ereal) :=
  embedding_coe_ennreal.Continuous

theorem continuous_coe_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} : (Continuous fun a => (f a : Ereal)) ‚Üî Continuous f :=
  embedding_coe_ennreal.continuous_iff.symm

/-! ### Neighborhoods of infinity -/


theorem nhds_top : ùìù (‚ä§ : Ereal) = ‚®Ö(a : _)(_ : a ‚â† ‚ä§), ùìü (Ioi a) :=
  nhds_top_order.trans$
    by 
      simp [lt_top_iff_ne_top, Ioi]

theorem nhds_top' : ùìù (‚ä§ : Ereal) = ‚®Öa : ‚Ñù, ùìü (Ioi a) :=
  by 
    rw [nhds_top]
    apply le_antisymm‚Çì
    ¬∑
      exact
        infi_le_infi2
          fun x =>
            ‚ü®x,
              by 
                simp ‚ü©
    ¬∑
      refine' le_infi fun r => le_infi fun hr => _ 
      induction r using Ereal.rec
      ¬∑
        exact
          (infi_le _ 0).trans
            (by 
              simp )
      ¬∑
        exact infi_le _ _
      ¬∑
        simpa using hr

theorem mem_nhds_top_iff {s : Set Ereal} : s ‚àà ùìù (‚ä§ : Ereal) ‚Üî ‚àÉ y : ‚Ñù, Ioi (y : Ereal) ‚äÜ s :=
  by 
    rw [nhds_top', mem_infi_of_directed]
    ¬∑
      rfl 
    exact
      fun x y =>
        ‚ü®max x y,
          by 
            simp [le_refl‚Çì],
          by 
            simp [le_refl‚Çì]‚ü©

theorem tendsto_nhds_top_iff_real {Œ± : Type _} {m : Œ± ‚Üí Ereal} {f : Filter Œ±} :
  tendsto m f (ùìù ‚ä§) ‚Üî ‚àÄ (x : ‚Ñù), ‚àÄ·∂†a in f, ¬´expr‚Üë ¬ª x < m a :=
  by 
    simp only [nhds_top', mem_Ioi, tendsto_infi, tendsto_principal]

theorem nhds_bot : ùìù (‚ä• : Ereal) = ‚®Ö(a : _)(_ : a ‚â† ‚ä•), ùìü (Iio a) :=
  nhds_bot_order.trans$
    by 
      simp [bot_lt_iff_ne_bot]

theorem nhds_bot' : ùìù (‚ä• : Ereal) = ‚®Öa : ‚Ñù, ùìü (Iio a) :=
  by 
    rw [nhds_bot]
    apply le_antisymm‚Çì
    ¬∑
      exact
        infi_le_infi2
          fun x =>
            ‚ü®x,
              by 
                simp ‚ü©
    ¬∑
      refine' le_infi fun r => le_infi fun hr => _ 
      induction r using Ereal.rec
      ¬∑
        simpa using hr
      ¬∑
        exact infi_le _ _
      ¬∑
        exact
          (infi_le _ 0).trans
            (by 
              simp )

theorem mem_nhds_bot_iff {s : Set Ereal} : s ‚àà ùìù (‚ä• : Ereal) ‚Üî ‚àÉ y : ‚Ñù, Iio (y : Ereal) ‚äÜ s :=
  by 
    rw [nhds_bot', mem_infi_of_directed]
    ¬∑
      rfl 
    exact
      fun x y =>
        ‚ü®min x y,
          by 
            simp [le_refl‚Çì],
          by 
            simp [le_refl‚Çì]‚ü©

theorem tendsto_nhds_bot_iff_real {Œ± : Type _} {m : Œ± ‚Üí Ereal} {f : Filter Œ±} :
  tendsto m f (ùìù ‚ä•) ‚Üî ‚àÄ (x : ‚Ñù), ‚àÄ·∂†a in f, m a < x :=
  by 
    simp only [nhds_bot', mem_Iio, tendsto_infi, tendsto_principal]

/-! ### Continuity of addition -/


-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_at_add_coe_coe
(a b : expr‚Ñù()) : continuous_at (Œª p : ¬´expr √ó ¬ª(ereal, ereal), ¬´expr + ¬ª(p.1, p.2)) (a, b) :=
by simp [] [] ["only"] ["[", expr continuous_at, ",", expr nhds_coe_coe, ",", "<-", expr coe_add, ",", expr tendsto_map'_iff, ",", expr (¬´expr ‚àò ¬ª), ",", expr tendsto_coe, ",", expr tendsto_add, "]"] [] []

-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_at_add_top_coe
(a : expr‚Ñù()) : continuous_at (Œª p : ¬´expr √ó ¬ª(ereal, ereal), ¬´expr + ¬ª(p.1, p.2)) (¬´expr‚ä§¬ª(), a) :=
begin
  simp [] [] ["only"] ["[", expr continuous_at, ",", expr tendsto_nhds_top_iff_real, ",", expr top_add, ",", expr nhds_prod_eq, "]"] [] [],
  assume [binders (r)],
  rw [expr eventually_prod_iff] [],
  refine [expr ‚ü®Œª
    z, ¬´expr < ¬ª(((¬´expr - ¬ª(r, ¬´expr - ¬ª(a, 1)) : expr‚Ñù()) : ereal), z), Ioi_mem_nhds (coe_lt_top _), Œª
    z, ¬´expr < ¬ª(((¬´expr - ¬ª(a, 1) : expr‚Ñù()) : ereal), z), Ioi_mem_nhds (by simp [] [] [] ["[", expr zero_lt_one, "]"] [] []), Œª
    x hx y hy, _‚ü©],
  dsimp [] [] [] [],
  convert [] [expr add_lt_add hx hy] [],
  simp [] [] [] [] [] []
end

-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_at_add_coe_top
(a : expr‚Ñù()) : continuous_at (Œª p : ¬´expr √ó ¬ª(ereal, ereal), ¬´expr + ¬ª(p.1, p.2)) (a, ¬´expr‚ä§¬ª()) :=
begin
  change [expr continuous_at ¬´expr ‚àò ¬ª(Œª
    p : ¬´expr √ó ¬ª(ereal, ereal), ¬´expr + ¬ª(p.2, p.1), prod.swap) (a, ¬´expr‚ä§¬ª())] [] [],
  apply [expr continuous_at.comp _ continuous_swap.continuous_at],
  simp_rw [expr add_comm] [],
  exact [expr continuous_at_add_top_coe a]
end

-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_at_add_top_top : continuous_at (Œª
 p : ¬´expr √ó ¬ª(ereal, ereal), ¬´expr + ¬ª(p.1, p.2)) (¬´expr‚ä§¬ª(), ¬´expr‚ä§¬ª()) :=
begin
  simp [] [] ["only"] ["[", expr continuous_at, ",", expr tendsto_nhds_top_iff_real, ",", expr top_add, ",", expr nhds_prod_eq, "]"] [] [],
  assume [binders (r)],
  rw [expr eventually_prod_iff] [],
  refine [expr ‚ü®Œª
    z, ¬´expr < ¬ª((r : ereal), z), Ioi_mem_nhds (coe_lt_top _), Œª
    z, ¬´expr < ¬ª(((0 : expr‚Ñù()) : ereal), z), Ioi_mem_nhds (by simp [] [] [] ["[", expr zero_lt_one, "]"] [] []), Œª
    x hx y hy, _‚ü©],
  dsimp [] [] [] [],
  convert [] [expr add_lt_add hx hy] [],
  simp [] [] [] [] [] []
end

-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_at_add_bot_coe
(a : expr‚Ñù()) : continuous_at (Œª p : ¬´expr √ó ¬ª(ereal, ereal), ¬´expr + ¬ª(p.1, p.2)) (¬´expr‚ä•¬ª(), a) :=
begin
  simp [] [] ["only"] ["[", expr continuous_at, ",", expr tendsto_nhds_bot_iff_real, ",", expr nhds_prod_eq, ",", expr bot_add_coe, "]"] [] [],
  assume [binders (r)],
  rw [expr eventually_prod_iff] [],
  refine [expr ‚ü®Œª
    z, ¬´expr < ¬ª(z, ((¬´expr - ¬ª(r, ¬´expr + ¬ª(a, 1)) : expr‚Ñù()) : ereal)), Iio_mem_nhds (bot_lt_coe _), Œª
    z, ¬´expr < ¬ª(z, ((¬´expr + ¬ª(a, 1) : expr‚Ñù()) : ereal)), Iio_mem_nhds (by simp [] [] [] ["[", "-", ident coe_add, ",", expr zero_lt_one, "]"] [] []), Œª
    x hx y hy, _‚ü©],
  dsimp [] [] [] [],
  convert [] [expr add_lt_add hx hy] [],
  dsimp [] [] [] [],
  ring []
end

-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_at_add_coe_bot
(a : expr‚Ñù()) : continuous_at (Œª p : ¬´expr √ó ¬ª(ereal, ereal), ¬´expr + ¬ª(p.1, p.2)) (a, ¬´expr‚ä•¬ª()) :=
begin
  change [expr continuous_at ¬´expr ‚àò ¬ª(Œª
    p : ¬´expr √ó ¬ª(ereal, ereal), ¬´expr + ¬ª(p.2, p.1), prod.swap) (a, ¬´expr‚ä•¬ª())] [] [],
  apply [expr continuous_at.comp _ continuous_swap.continuous_at],
  simp_rw [expr add_comm] [],
  exact [expr continuous_at_add_bot_coe a]
end

-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_at_add_bot_bot : continuous_at (Œª
 p : ¬´expr √ó ¬ª(ereal, ereal), ¬´expr + ¬ª(p.1, p.2)) (¬´expr‚ä•¬ª(), ¬´expr‚ä•¬ª()) :=
begin
  simp [] [] ["only"] ["[", expr continuous_at, ",", expr tendsto_nhds_bot_iff_real, ",", expr nhds_prod_eq, ",", expr bot_add_bot, "]"] [] [],
  assume [binders (r)],
  rw [expr eventually_prod_iff] [],
  refine [expr ‚ü®Œª
    z, ¬´expr < ¬ª(z, r), Iio_mem_nhds (bot_lt_coe _), Œª
    z, ¬´expr < ¬ª(z, 0), Iio_mem_nhds (bot_lt_coe _), Œª x hx y hy, _‚ü©],
  dsimp [] [] [] [],
  convert [] [expr add_lt_add hx hy] [],
  simp [] [] [] [] [] []
end

-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- The addition on `ereal` is continuous except where it doesn't make sense (i.e., at `(‚ä•, ‚ä§)`
and at `(‚ä§, ‚ä•)`). -/
theorem continuous_at_add
{p : ¬´expr √ó ¬ª(ereal, ereal)}
(h : ¬´expr ‚à® ¬ª(¬´expr ‚â† ¬ª(p.1, ¬´expr‚ä§¬ª()), ¬´expr ‚â† ¬ª(p.2, ¬´expr‚ä•¬ª())))
(h' : ¬´expr ‚à® ¬ª(¬´expr ‚â† ¬ª(p.1, ¬´expr‚ä•¬ª()), ¬´expr ‚â† ¬ª(p.2, ¬´expr‚ä§¬ª()))) : continuous_at (Œª
 p : ¬´expr √ó ¬ª(ereal, ereal), ¬´expr + ¬ª(p.1, p.2)) p :=
begin
  rcases [expr p, "with", "‚ü®", ident x, ",", ident y, "‚ü©"],
  induction [expr x] ["using", ident ereal.rec] [] []; induction [expr y] ["using", ident ereal.rec] [] [],
  { exact [expr continuous_at_add_bot_bot] },
  { exact [expr continuous_at_add_bot_coe _] },
  { simpa [] [] [] [] [] ["using", expr h'] },
  { exact [expr continuous_at_add_coe_bot _] },
  { exact [expr continuous_at_add_coe_coe _ _] },
  { exact [expr continuous_at_add_coe_top _] },
  { simpa [] [] [] [] [] ["using", expr h] },
  { exact [expr continuous_at_add_top_coe _] },
  { exact [expr continuous_at_add_top_top] }
end

/-! ### Negation-/


/-- Negation on `ereal` as a homeomorphism -/
def neg_homeo : Ereal ‚âÉ‚Çú Ereal :=
  neg_order_iso.toHomeomorph

-- error in Topology.Instances.Ereal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem continuous_neg : continuous (Œª x : ereal, ¬´expr- ¬ª(x)) := neg_homeo.continuous

end Ereal

