/-
Copyright (c) 2018 Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robert Y. Lewis, S√©bastien Gou√´zel

! This file was ported from Lean 3 source module topology.metric_space.cau_seq_filter
! leanprover-community/mathlib commit 10bf4f825ad729c5653adc039dafa3622e7f93c9
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Analysis.Normed.Field.Basic

/-!
# Completeness in terms of `cauchy` filters vs `is_cau_seq` sequences

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we apply `metric.complete_of_cauchy_seq_tendsto` to prove that a `normed_ring`
is complete in terms of `cauchy` filter if and only if it is complete in terms
of `cau_seq` Cauchy sequences.
-/


universe u v

open Set Filter

open Topology Classical

variable {Œ≤ : Type v}

/- warning: cau_seq.tendsto_limit -> CauSeq.tendsto_limit is a dubious translation:
lean 3 declaration is
  forall {Œ≤ : Type.{u1}} [_inst_1 : NormedRing.{u1} Œ≤] [hn : IsAbsoluteValue.{0, u1} Real Real.orderedSemiring Œ≤ (Ring.toSemiring.{u1} Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1)) (Norm.norm.{u1} Œ≤ (NormedRing.toHasNorm.{u1} Œ≤ _inst_1))] (f : CauSeq.{0, u1} Real Real.linearOrderedField Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1) (Norm.norm.{u1} Œ≤ (NormedRing.toHasNorm.{u1} Œ≤ _inst_1))) [_inst_2 : CauSeq.IsComplete.{0, u1} Real Real.linearOrderedField Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1) (Norm.norm.{u1} Œ≤ (NormedRing.toHasNorm.{u1} Œ≤ _inst_1)) hn], Filter.Tendsto.{0, u1} Nat Œ≤ (coeFn.{succ u1, succ u1} (CauSeq.{0, u1} Real Real.linearOrderedField Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1) (Norm.norm.{u1} Œ≤ (NormedRing.toHasNorm.{u1} Œ≤ _inst_1))) (fun (_x : CauSeq.{0, u1} Real Real.linearOrderedField Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1) (Norm.norm.{u1} Œ≤ (NormedRing.toHasNorm.{u1} Œ≤ _inst_1))) => Nat -> Œ≤) (CauSeq.hasCoeToFun.{0, u1} Real Œ≤ Real.linearOrderedField (NormedRing.toRing.{u1} Œ≤ _inst_1) (Norm.norm.{u1} Œ≤ (NormedRing.toHasNorm.{u1} Œ≤ _inst_1))) f) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring)))) (nhds.{u1} Œ≤ (UniformSpace.toTopologicalSpace.{u1} Œ≤ (PseudoMetricSpace.toUniformSpace.{u1} Œ≤ (SeminormedRing.toPseudoMetricSpace.{u1} Œ≤ (NormedRing.toSeminormedRing.{u1} Œ≤ _inst_1)))) (CauSeq.lim.{0, u1} Real Real.linearOrderedField Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1) (Norm.norm.{u1} Œ≤ (NormedRing.toHasNorm.{u1} Œ≤ _inst_1)) hn _inst_2 f))
but is expected to have type
  forall {Œ≤ : Type.{u1}} [_inst_1 : NormedRing.{u1} Œ≤] [hn : IsAbsoluteValue.{0, u1} Real Real.orderedSemiring Œ≤ (Ring.toSemiring.{u1} Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1)) (Norm.norm.{u1} Œ≤ (NormedRing.toNorm.{u1} Œ≤ _inst_1))] (f : CauSeq.{0, u1} Real Real.instLinearOrderedFieldReal Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1) (Norm.norm.{u1} Œ≤ (NormedRing.toNorm.{u1} Œ≤ _inst_1))) [_inst_2 : CauSeq.IsComplete.{0, u1} Real Real.instLinearOrderedFieldReal Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1) (Norm.norm.{u1} Œ≤ (NormedRing.toNorm.{u1} Œ≤ _inst_1)) hn], Filter.Tendsto.{0, u1} Nat Œ≤ (Subtype.val.{succ u1} (Nat -> Œ≤) (fun (f : Nat -> Œ≤) => IsCauSeq.{0, u1} Real Real.instLinearOrderedFieldReal Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1) (Norm.norm.{u1} Œ≤ (NormedRing.toNorm.{u1} Œ≤ _inst_1)) f) f) (Filter.atTop.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring))) (nhds.{u1} Œ≤ (UniformSpace.toTopologicalSpace.{u1} Œ≤ (PseudoMetricSpace.toUniformSpace.{u1} Œ≤ (SeminormedRing.toPseudoMetricSpace.{u1} Œ≤ (NormedRing.toSeminormedRing.{u1} Œ≤ _inst_1)))) (CauSeq.lim.{0, u1} Real Real.instLinearOrderedFieldReal Œ≤ (NormedRing.toRing.{u1} Œ≤ _inst_1) (Norm.norm.{u1} Œ≤ (NormedRing.toNorm.{u1} Œ≤ _inst_1)) hn _inst_2 f))
Case conversion may be inaccurate. Consider using '#align cau_seq.tendsto_limit CauSeq.tendsto_limit‚Çì'. -/
theorem CauSeq.tendsto_limit [NormedRing Œ≤] [hn : IsAbsoluteValue (norm : Œ≤ ‚Üí ‚Ñù)]
    (f : CauSeq Œ≤ norm) [CauSeq.IsComplete Œ≤ norm] : Tendsto f atTop (ùìù f.lim) :=
  tendsto_nhds.mpr
    (by
      intro s os lfs
      suffices ‚àÉ a : ‚Ñï, ‚àÄ b : ‚Ñï, b ‚â• a ‚Üí f b ‚àà s by simpa using this
      rcases Metric.isOpen_iff.1 os _ lfs with ‚ü®Œµ, ‚ü®hŒµ, hŒµs‚ü©‚ü©
      cases' Setoid.symm (CauSeq.equiv_lim f) _ hŒµ with N hN
      exists N
      intro b hb
      apply hŒµs
      dsimp [Metric.ball]
      rw [dist_comm, dist_eq_norm]
      solve_by_elim)
#align cau_seq.tendsto_limit CauSeq.tendsto_limit

variable [NormedField Œ≤]

/-
 This section shows that if we have a uniform space generated by an absolute value, topological
 completeness and Cauchy sequence completeness coincide. The problem is that there isn't
 a good notion of "uniform space generated by an absolute value", so right now this is
 specific to norm. Furthermore, norm only instantiates is_absolute_value on normed_division_ring.
 This needs to be fixed, since it prevents showing that ‚Ñ§_[hp] is complete
-/
open Metric

/- warning: cauchy_seq.is_cau_seq -> CauchySeq.isCauSeq is a dubious translation:
lean 3 declaration is
  forall {Œ≤ : Type.{u1}} [_inst_1 : NormedField.{u1} Œ≤] {f : Nat -> Œ≤}, (CauchySeq.{u1, 0} Œ≤ Nat (PseudoMetricSpace.toUniformSpace.{u1} Œ≤ (SeminormedRing.toPseudoMetricSpace.{u1} Œ≤ (SeminormedCommRing.toSemiNormedRing.{u1} Œ≤ (NormedCommRing.toSeminormedCommRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))))) (CanonicallyLinearOrderedAddMonoid.semilatticeSup.{0} Nat Nat.canonicallyLinearOrderedAddMonoid) f) -> (IsCauSeq.{0, u1} Real Real.linearOrderedField Œ≤ (NormedRing.toRing.{u1} Œ≤ (NormedCommRing.toNormedRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))) (Norm.norm.{u1} Œ≤ (NormedField.toHasNorm.{u1} Œ≤ _inst_1)) f)
but is expected to have type
  forall {Œ≤ : Type.{u1}} [_inst_1 : NormedField.{u1} Œ≤] {f : Nat -> Œ≤}, (CauchySeq.{u1, 0} Œ≤ Nat (PseudoMetricSpace.toUniformSpace.{u1} Œ≤ (SeminormedRing.toPseudoMetricSpace.{u1} Œ≤ (SeminormedCommRing.toSeminormedRing.{u1} Œ≤ (NormedCommRing.toSeminormedCommRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))))) (Lattice.toSemilatticeSup.{0} Nat Nat.instLatticeNat) f) -> (IsCauSeq.{0, u1} Real Real.instLinearOrderedFieldReal Œ≤ (NormedRing.toRing.{u1} Œ≤ (NormedCommRing.toNormedRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))) (Norm.norm.{u1} Œ≤ (NormedField.toNorm.{u1} Œ≤ _inst_1)) f)
Case conversion may be inaccurate. Consider using '#align cauchy_seq.is_cau_seq CauchySeq.isCauSeq‚Çì'. -/
theorem CauchySeq.isCauSeq {f : ‚Ñï ‚Üí Œ≤} (hf : CauchySeq f) : IsCauSeq norm f :=
  by
  cases' cauchy_iff.1 hf with hf1 hf2
  intro Œµ hŒµ
  rcases hf2 { x | dist x.1 x.2 < Œµ } (dist_mem_uniformity hŒµ) with ‚ü®t, ‚ü®ht, htsub‚ü©‚ü©
  simp at ht; cases' ht with N hN
  exists N
  intro j hj
  rw [‚Üê dist_eq_norm]
  apply @htsub (f j, f N)
  apply Set.mk_mem_prod <;> solve_by_elim [le_refl]
#align cauchy_seq.is_cau_seq CauchySeq.isCauSeq

/- warning: cau_seq.cauchy_seq -> CauSeq.cauchySeq is a dubious translation:
lean 3 declaration is
  forall {Œ≤ : Type.{u1}} [_inst_1 : NormedField.{u1} Œ≤] (f : CauSeq.{0, u1} Real Real.linearOrderedField Œ≤ (NormedRing.toRing.{u1} Œ≤ (NormedCommRing.toNormedRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))) (Norm.norm.{u1} Œ≤ (NormedField.toHasNorm.{u1} Œ≤ _inst_1))), CauchySeq.{u1, 0} Œ≤ Nat (PseudoMetricSpace.toUniformSpace.{u1} Œ≤ (SeminormedRing.toPseudoMetricSpace.{u1} Œ≤ (SeminormedCommRing.toSemiNormedRing.{u1} Œ≤ (NormedCommRing.toSeminormedCommRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))))) (CanonicallyLinearOrderedAddMonoid.semilatticeSup.{0} Nat Nat.canonicallyLinearOrderedAddMonoid) (coeFn.{succ u1, succ u1} (CauSeq.{0, u1} Real Real.linearOrderedField Œ≤ (NormedRing.toRing.{u1} Œ≤ (NormedCommRing.toNormedRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))) (Norm.norm.{u1} Œ≤ (NormedField.toHasNorm.{u1} Œ≤ _inst_1))) (fun (_x : CauSeq.{0, u1} Real Real.linearOrderedField Œ≤ (NormedRing.toRing.{u1} Œ≤ (NormedCommRing.toNormedRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))) (Norm.norm.{u1} Œ≤ (NormedField.toHasNorm.{u1} Œ≤ _inst_1))) => Nat -> Œ≤) (CauSeq.hasCoeToFun.{0, u1} Real Œ≤ Real.linearOrderedField (NormedRing.toRing.{u1} Œ≤ (NormedCommRing.toNormedRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))) (Norm.norm.{u1} Œ≤ (NormedField.toHasNorm.{u1} Œ≤ _inst_1))) f)
but is expected to have type
  forall {Œ≤ : Type.{u1}} [_inst_1 : NormedField.{u1} Œ≤] (f : CauSeq.{0, u1} Real Real.instLinearOrderedFieldReal Œ≤ (NormedRing.toRing.{u1} Œ≤ (NormedCommRing.toNormedRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))) (Norm.norm.{u1} Œ≤ (NormedField.toNorm.{u1} Œ≤ _inst_1))), CauchySeq.{u1, 0} Œ≤ Nat (PseudoMetricSpace.toUniformSpace.{u1} Œ≤ (SeminormedRing.toPseudoMetricSpace.{u1} Œ≤ (SeminormedCommRing.toSeminormedRing.{u1} Œ≤ (NormedCommRing.toSeminormedCommRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))))) (Lattice.toSemilatticeSup.{0} Nat Nat.instLatticeNat) (Subtype.val.{succ u1} (Nat -> Œ≤) (fun (f : Nat -> Œ≤) => IsCauSeq.{0, u1} Real Real.instLinearOrderedFieldReal Œ≤ (NormedRing.toRing.{u1} Œ≤ (NormedCommRing.toNormedRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))) (Norm.norm.{u1} Œ≤ (NormedField.toNorm.{u1} Œ≤ _inst_1)) f) f)
Case conversion may be inaccurate. Consider using '#align cau_seq.cauchy_seq CauSeq.cauchySeq‚Çì'. -/
theorem CauSeq.cauchySeq (f : CauSeq Œ≤ norm) : CauchySeq f :=
  by
  refine' cauchy_iff.2 ‚ü®by infer_instance, fun s hs => _‚ü©
  rcases mem_uniformity_dist.1 hs with ‚ü®Œµ, ‚ü®hŒµ, hŒµs‚ü©‚ü©
  cases' CauSeq.cauchy‚ÇÇ f hŒµ with N hN
  exists { n | n ‚â• N }.image f
  simp only [exists_prop, mem_at_top_sets, mem_map, mem_image, ge_iff_le, mem_set_of_eq]
  constructor
  ¬∑ exists N
    intro b hb
    exists b
    simp [hb]
  ¬∑ rintro ‚ü®a, b‚ü© ‚ü®‚ü®a', ‚ü®ha'1, ha'2‚ü©‚ü©, ‚ü®b', ‚ü®hb'1, hb'2‚ü©‚ü©‚ü©
    dsimp at ha'1 ha'2 hb'1 hb'2
    rw [‚Üê ha'2, ‚Üê hb'2]
    apply hŒµs
    rw [dist_eq_norm]
    apply hN <;> assumption
#align cau_seq.cauchy_seq CauSeq.cauchySeq

/- warning: cau_seq_iff_cauchy_seq -> isCauSeq_iff_cauchySeq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} [_inst_2 : NormedField.{u1} Œ±] {u : Nat -> Œ±}, Iff (IsCauSeq.{0, u1} Real Real.linearOrderedField Œ± (NormedRing.toRing.{u1} Œ± (NormedCommRing.toNormedRing.{u1} Œ± (NormedField.toNormedCommRing.{u1} Œ± _inst_2))) (Norm.norm.{u1} Œ± (NormedField.toHasNorm.{u1} Œ± _inst_2)) u) (CauchySeq.{u1, 0} Œ± Nat (PseudoMetricSpace.toUniformSpace.{u1} Œ± (SeminormedRing.toPseudoMetricSpace.{u1} Œ± (SeminormedCommRing.toSemiNormedRing.{u1} Œ± (NormedCommRing.toSeminormedCommRing.{u1} Œ± (NormedField.toNormedCommRing.{u1} Œ± _inst_2))))) (CanonicallyLinearOrderedAddMonoid.semilatticeSup.{0} Nat Nat.canonicallyLinearOrderedAddMonoid) u)
but is expected to have type
  forall {Œ± : Type.{u1}} [_inst_2 : NormedField.{u1} Œ±] {u : Nat -> Œ±}, Iff (IsCauSeq.{0, u1} Real Real.instLinearOrderedFieldReal Œ± (NormedRing.toRing.{u1} Œ± (NormedCommRing.toNormedRing.{u1} Œ± (NormedField.toNormedCommRing.{u1} Œ± _inst_2))) (Norm.norm.{u1} Œ± (NormedField.toNorm.{u1} Œ± _inst_2)) u) (CauchySeq.{u1, 0} Œ± Nat (PseudoMetricSpace.toUniformSpace.{u1} Œ± (SeminormedRing.toPseudoMetricSpace.{u1} Œ± (SeminormedCommRing.toSeminormedRing.{u1} Œ± (NormedCommRing.toSeminormedCommRing.{u1} Œ± (NormedField.toNormedCommRing.{u1} Œ± _inst_2))))) (Lattice.toSemilatticeSup.{0} Nat Nat.instLatticeNat) u)
Case conversion may be inaccurate. Consider using '#align cau_seq_iff_cauchy_seq isCauSeq_iff_cauchySeq‚Çì'. -/
/-- In a normed field, `cau_seq` coincides with the usual notion of Cauchy sequences. -/
theorem isCauSeq_iff_cauchySeq {Œ± : Type u} [NormedField Œ±] {u : ‚Ñï ‚Üí Œ±} :
    IsCauSeq norm u ‚Üî CauchySeq u :=
  ‚ü®fun h => CauSeq.cauchySeq ‚ü®u, h‚ü©, fun h => h.IsCauSeq‚ü©
#align cau_seq_iff_cauchy_seq isCauSeq_iff_cauchySeq

/- warning: complete_space_of_cau_seq_complete -> completeSpace_of_cauSeq_isComplete is a dubious translation:
lean 3 declaration is
  forall {Œ≤ : Type.{u1}} [_inst_1 : NormedField.{u1} Œ≤] [_inst_2 : CauSeq.IsComplete.{0, u1} Real Real.linearOrderedField Œ≤ (NormedRing.toRing.{u1} Œ≤ (NormedCommRing.toNormedRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))) (Norm.norm.{u1} Œ≤ (NormedField.toHasNorm.{u1} Œ≤ _inst_1)) (isAbsoluteValue_norm.{u1} Œ≤ (NormedField.toNormedDivisionRing.{u1} Œ≤ _inst_1))], CompleteSpace.{u1} Œ≤ (PseudoMetricSpace.toUniformSpace.{u1} Œ≤ (SeminormedRing.toPseudoMetricSpace.{u1} Œ≤ (SeminormedCommRing.toSemiNormedRing.{u1} Œ≤ (NormedCommRing.toSeminormedCommRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1)))))
but is expected to have type
  forall {Œ≤ : Type.{u1}} [_inst_1 : NormedField.{u1} Œ≤] [_inst_2 : CauSeq.IsComplete.{0, u1} Real Real.instLinearOrderedFieldReal Œ≤ (NormedRing.toRing.{u1} Œ≤ (NormedCommRing.toNormedRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1))) (Norm.norm.{u1} Œ≤ (NormedField.toNorm.{u1} Œ≤ _inst_1)) (isAbsoluteValue_norm.{u1} Œ≤ (NormedField.toNormedDivisionRing.{u1} Œ≤ _inst_1))], CompleteSpace.{u1} Œ≤ (PseudoMetricSpace.toUniformSpace.{u1} Œ≤ (SeminormedRing.toPseudoMetricSpace.{u1} Œ≤ (SeminormedCommRing.toSeminormedRing.{u1} Œ≤ (NormedCommRing.toSeminormedCommRing.{u1} Œ≤ (NormedField.toNormedCommRing.{u1} Œ≤ _inst_1)))))
Case conversion may be inaccurate. Consider using '#align complete_space_of_cau_seq_complete completeSpace_of_cauSeq_isComplete‚Çì'. -/
-- see Note [lower instance priority]
/-- A complete normed field is complete as a metric space, as Cauchy sequences converge by
assumption and this suffices to characterize completeness. -/
instance (priority := 100) completeSpace_of_cauSeq_isComplete [CauSeq.IsComplete Œ≤ norm] :
    CompleteSpace Œ≤ := by
  apply complete_of_cauchy_seq_tendsto
  intro u hu
  have C : IsCauSeq norm u := isCauSeq_iff_cauchySeq.2 hu
  exists CauSeq.lim ‚ü®u, C‚ü©
  rw [Metric.tendsto_atTop]
  intro Œµ Œµpos
  cases' (CauSeq.equiv_lim ‚ü®u, C‚ü©) _ Œµpos with N hN
  exists N
  simpa [dist_eq_norm] using hN
#align complete_space_of_cau_seq_complete completeSpace_of_cauSeq_isComplete

