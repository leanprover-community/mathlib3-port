import Mathbin.Topology.MetricSpace.Antilipschitz

/-!
# Isometries

We define isometries, i.e., maps between emetric spaces that preserve
the edistance (on metric spaces, these are exactly the maps that preserve distances),
and prove their basic properties. We also introduce isometric bijections.

Since a lot of elementary properties don't require `eq_of_dist_eq_zero` we start setting up the
theory for `pseudo_metric_space` and we specialize to `metric_space` when needed.
-/


noncomputable theory

universe u v w

variable{Œ± : Type u}{Œ≤ : Type v}{Œ≥ : Type w}

open Function Set

open_locale TopologicalSpace

/-- An isometry (also known as isometric embedding) is a map preserving the edistance
between pseudoemetric spaces, or equivalently the distance between pseudometric space.  -/
def Isometry [PseudoEmetricSpace Œ±] [PseudoEmetricSpace Œ≤] (f : Œ± ‚Üí Œ≤) : Prop :=
  ‚àÄ (x1 x2 : Œ±), edist (f x1) (f x2) = edist x1 x2

/-- On pseudometric spaces, a map is an isometry if and only if it preserves distances. -/
theorem isometry_emetric_iff_metric [PseudoMetricSpace Œ±] [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} :
  Isometry f ‚Üî ‚àÄ x y, dist (f x) (f y) = dist x y :=
  ‚ü®fun H x y =>
      by 
        simp [dist_edist, H x y],
    fun H x y =>
      by 
        simp [edist_dist, H x y]‚ü©

/-- An isometry preserves edistances. -/
theorem Isometry.edist_eq [PseudoEmetricSpace Œ±] [PseudoEmetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Isometry f) (x y : Œ±) :
  edist (f x) (f y) = edist x y :=
  hf x y

/-- An isometry preserves distances. -/
theorem Isometry.dist_eq [PseudoMetricSpace Œ±] [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Isometry f) (x y : Œ±) :
  dist (f x) (f y) = dist x y :=
  by 
    rw [dist_edist, dist_edist, hf]

section PseudoEmetricIsometry

variable[PseudoEmetricSpace Œ±][PseudoEmetricSpace Œ≤][PseudoEmetricSpace Œ≥]

variable{f : Œ± ‚Üí Œ≤}{x y z : Œ±}{s : Set Œ±}

theorem Isometry.lipschitz (h : Isometry f) : LipschitzWith 1 f :=
  LipschitzWith.of_edist_le$ fun x y => le_of_eq‚Çì (h x y)

theorem Isometry.antilipschitz (h : Isometry f) : AntilipschitzWith 1 f :=
  fun x y =>
    by 
      simp only [h x y, Ennreal.coe_one, one_mul‚Çì, le_refl‚Çì]

/-- An isometry from an emetric space is injective -/
theorem Isometry.injective {Œ± : Type u} [EmetricSpace Œ±] {f : Œ± ‚Üí Œ≤} (h : Isometry f) : injective f :=
  h.antilipschitz.injective

/-- Any map on a subsingleton is an isometry -/
theorem isometry_subsingleton [Subsingleton Œ±] : Isometry f :=
  fun x y =>
    by 
      rw [Subsingleton.elim‚Çì x y] <;> simp 

/-- The identity is an isometry -/
theorem isometry_id : Isometry (id : Œ± ‚Üí Œ±) :=
  fun x y => rfl

/-- The composition of isometries is an isometry -/
theorem Isometry.comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : Isometry g) (hf : Isometry f) : Isometry (g ‚àò f) :=
  fun x y =>
    calc edist ((g ‚àò f) x) ((g ‚àò f) y) = edist (f x) (f y) := hg _ _ 
      _ = edist x y := hf _ _
      

/-- An isometry from a metric space is a uniform inducing map -/
theorem Isometry.uniform_inducing (hf : Isometry f) : UniformInducing f :=
  hf.antilipschitz.uniform_inducing hf.lipschitz.uniform_continuous

/-- An isometry is continuous. -/
theorem Isometry.continuous (hf : Isometry f) : Continuous f :=
  hf.lipschitz.continuous

/-- The right inverse of an isometry is an isometry. -/
theorem Isometry.right_inv {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±} (h : Isometry f) (hg : RightInverse g f) : Isometry g :=
  fun x y =>
    by 
      rw [‚Üêh, hg _, hg _]

/-- Isometries preserve the diameter in pseudoemetric spaces. -/
theorem Isometry.ediam_image (hf : Isometry f) (s : Set Œ±) : Emetric.diam (f '' s) = Emetric.diam s :=
  eq_of_forall_ge_iff$
    fun d =>
      by 
        simp only [Emetric.diam_le_iff, ball_image_iff, hf.edist_eq]

theorem Isometry.ediam_range (hf : Isometry f) : Emetric.diam (range f) = Emetric.diam (univ : Set Œ±) :=
  by 
    rw [‚Üêimage_univ]
    exact hf.ediam_image univ

/-- The injection from a subtype is an isometry -/
theorem isometry_subtype_coe {s : Set Œ±} : Isometry (coe‚Çì : s ‚Üí Œ±) :=
  fun x y => rfl

theorem Isometry.comp_continuous_on_iff {Œ≥} [TopologicalSpace Œ≥] (hf : Isometry f) {g : Œ≥ ‚Üí Œ±} {s : Set Œ≥} :
  ContinuousOn (f ‚àò g) s ‚Üî ContinuousOn g s :=
  hf.uniform_inducing.inducing.continuous_on_iff.symm

theorem Isometry.comp_continuous_iff {Œ≥} [TopologicalSpace Œ≥] (hf : Isometry f) {g : Œ≥ ‚Üí Œ±} :
  Continuous (f ‚àò g) ‚Üî Continuous g :=
  hf.uniform_inducing.inducing.continuous_iff.symm

end PseudoEmetricIsometry

section EmetricIsometry

variable[EmetricSpace Œ±]

/-- An isometry from a metric space is a uniform embedding -/
theorem Isometry.uniform_embedding [PseudoEmetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Isometry f) : UniformEmbedding f :=
  hf.antilipschitz.uniform_embedding hf.lipschitz.uniform_continuous

/-- An isometry from a complete emetric space is a closed embedding -/
theorem Isometry.closed_embedding [CompleteSpace Œ±] [EmetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Isometry f) :
  ClosedEmbedding f :=
  hf.antilipschitz.closed_embedding hf.lipschitz.uniform_continuous

theorem Isometry.tendsto_nhds_iff [CompleteSpace Œ±] [EmetricSpace Œ≤] {Œπ : Type _} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±} {a : Filter Œπ}
  {b : Œ±} (hf : Isometry f) : Filter.Tendsto g a (ùìù b) ‚Üî Filter.Tendsto (f ‚àò g) a (ùìù (f b)) :=
  hf.closed_embedding.tendsto_nhds_iff

end EmetricIsometry

/-- An isometry preserves the diameter in pseudometric spaces. -/
theorem Isometry.diam_image [PseudoMetricSpace Œ±] [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Isometry f) (s : Set Œ±) :
  Metric.diam (f '' s) = Metric.diam s :=
  by 
    rw [Metric.diam, Metric.diam, hf.ediam_image]

theorem Isometry.diam_range [PseudoMetricSpace Œ±] [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Isometry f) :
  Metric.diam (range f) = Metric.diam (univ : Set Œ±) :=
  by 
    rw [‚Üêimage_univ]
    exact hf.diam_image univ

/-- `Œ±` and `Œ≤` are isometric if there is an isometric bijection between them. -/
@[nolint has_inhabited_instance]
structure Isometric(Œ± : Type _)(Œ≤ : Type _)[PseudoEmetricSpace Œ±][PseudoEmetricSpace Œ≤] extends Œ± ‚âÉ Œ≤ where 
  isometry_to_fun : Isometry to_fun

infixl:25 " ‚âÉ·µ¢ " => Isometric

namespace Isometric

section PseudoEmetricSpace

variable[PseudoEmetricSpace Œ±][PseudoEmetricSpace Œ≤][PseudoEmetricSpace Œ≥]

instance  : CoeFun (Œ± ‚âÉ·µ¢ Œ≤) fun _ => Œ± ‚Üí Œ≤ :=
  ‚ü®fun e => e.to_equiv‚ü©

theorem coe_eq_to_equiv (h : Œ± ‚âÉ·µ¢ Œ≤) (a : Œ±) : h a = h.to_equiv a :=
  rfl

@[simp]
theorem coe_to_equiv (h : Œ± ‚âÉ·µ¢ Œ≤) : ¬´expr‚áë ¬ª h.to_equiv = h :=
  rfl

protected theorem Isometry (h : Œ± ‚âÉ·µ¢ Œ≤) : Isometry h :=
  h.isometry_to_fun

protected theorem bijective (h : Œ± ‚âÉ·µ¢ Œ≤) : bijective h :=
  h.to_equiv.bijective

protected theorem injective (h : Œ± ‚âÉ·µ¢ Œ≤) : injective h :=
  h.to_equiv.injective

protected theorem surjective (h : Œ± ‚âÉ·µ¢ Œ≤) : surjective h :=
  h.to_equiv.surjective

protected theorem edist_eq (h : Œ± ‚âÉ·µ¢ Œ≤) (x y : Œ±) : edist (h x) (h y) = edist x y :=
  h.isometry.edist_eq x y

protected theorem dist_eq {Œ± Œ≤ : Type _} [PseudoMetricSpace Œ±] [PseudoMetricSpace Œ≤] (h : Œ± ‚âÉ·µ¢ Œ≤) (x y : Œ±) :
  dist (h x) (h y) = dist x y :=
  h.isometry.dist_eq x y

protected theorem Continuous (h : Œ± ‚âÉ·µ¢ Œ≤) : Continuous h :=
  h.isometry.continuous

@[simp]
theorem ediam_image (h : Œ± ‚âÉ·µ¢ Œ≤) (s : Set Œ±) : Emetric.diam (h '' s) = Emetric.diam s :=
  h.isometry.ediam_image s

theorem to_equiv_inj : ‚àÄ ‚¶Éh‚ÇÅ h‚ÇÇ : Œ± ‚âÉ·µ¢ Œ≤‚¶Ñ, h‚ÇÅ.to_equiv = h‚ÇÇ.to_equiv ‚Üí h‚ÇÅ = h‚ÇÇ
| ‚ü®e‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®e‚ÇÇ, h‚ÇÇ‚ü©, H =>
  by 
    dsimp  at H 
    subst e‚ÇÅ

@[ext]
theorem ext ‚¶Éh‚ÇÅ h‚ÇÇ : Œ± ‚âÉ·µ¢ Œ≤‚¶Ñ (H : ‚àÄ x, h‚ÇÅ x = h‚ÇÇ x) : h‚ÇÅ = h‚ÇÇ :=
  to_equiv_inj$ Equiv.ext H

/-- Alternative constructor for isometric bijections,
taking as input an isometry, and a right inverse. -/
def mk' {Œ± : Type u} [EmetricSpace Œ±] (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) (hfg : ‚àÄ x, f (g x) = x) (hf : Isometry f) : Œ± ‚âÉ·µ¢ Œ≤ :=
  { toFun := f, invFun := g, left_inv := fun x => hf.injective$ hfg _, right_inv := hfg, isometry_to_fun := hf }

/-- The identity isometry of a space. -/
protected def refl (Œ± : Type _) [PseudoEmetricSpace Œ±] : Œ± ‚âÉ·µ¢ Œ± :=
  { Equiv.refl Œ± with isometry_to_fun := isometry_id }

/-- The composition of two isometric isomorphisms, as an isometric isomorphism. -/
protected def trans (h‚ÇÅ : Œ± ‚âÉ·µ¢ Œ≤) (h‚ÇÇ : Œ≤ ‚âÉ·µ¢ Œ≥) : Œ± ‚âÉ·µ¢ Œ≥ :=
  { Equiv.trans h‚ÇÅ.to_equiv h‚ÇÇ.to_equiv with isometry_to_fun := h‚ÇÇ.isometry_to_fun.comp h‚ÇÅ.isometry_to_fun }

@[simp]
theorem trans_apply (h‚ÇÅ : Œ± ‚âÉ·µ¢ Œ≤) (h‚ÇÇ : Œ≤ ‚âÉ·µ¢ Œ≥) (x : Œ±) : h‚ÇÅ.trans h‚ÇÇ x = h‚ÇÇ (h‚ÇÅ x) :=
  rfl

/-- The inverse of an isometric isomorphism, as an isometric isomorphism. -/
protected def symm (h : Œ± ‚âÉ·µ¢ Œ≤) : Œ≤ ‚âÉ·µ¢ Œ± :=
  { isometry_to_fun := h.isometry.right_inv h.right_inv, toEquiv := h.to_equiv.symm }

/-- See Note [custom simps projection]. We need to specify this projection explicitly in this case,
  because it is a composition of multiple projections. -/
def simps.apply (h : Œ± ‚âÉ·µ¢ Œ≤) : Œ± ‚Üí Œ≤ :=
  h

/-- See Note [custom simps projection] -/
def simps.symm_apply (h : Œ± ‚âÉ·µ¢ Œ≤) : Œ≤ ‚Üí Œ± :=
  h.symm

initialize_simps_projections Isometric (to_equiv_to_fun ‚Üí apply, to_equiv_inv_fun ‚Üí symmApply)

@[simp]
theorem symm_symm (h : Œ± ‚âÉ·µ¢ Œ≤) : h.symm.symm = h :=
  to_equiv_inj h.to_equiv.symm_symm

@[simp]
theorem apply_symm_apply (h : Œ± ‚âÉ·µ¢ Œ≤) (y : Œ≤) : h (h.symm y) = y :=
  h.to_equiv.apply_symm_apply y

@[simp]
theorem symm_apply_apply (h : Œ± ‚âÉ·µ¢ Œ≤) (x : Œ±) : h.symm (h x) = x :=
  h.to_equiv.symm_apply_apply x

theorem symm_apply_eq (h : Œ± ‚âÉ·µ¢ Œ≤) {x : Œ±} {y : Œ≤} : h.symm y = x ‚Üî y = h x :=
  h.to_equiv.symm_apply_eq

theorem eq_symm_apply (h : Œ± ‚âÉ·µ¢ Œ≤) {x : Œ±} {y : Œ≤} : x = h.symm y ‚Üî h x = y :=
  h.to_equiv.eq_symm_apply

theorem symm_comp_self (h : Œ± ‚âÉ·µ¢ Œ≤) : (¬´expr‚áë ¬ª h.symm ‚àò ¬´expr‚áë ¬ª h) = id :=
  funext$ fun a => h.to_equiv.left_inv a

theorem self_comp_symm (h : Œ± ‚âÉ·µ¢ Œ≤) : (¬´expr‚áë ¬ª h ‚àò ¬´expr‚áë ¬ª h.symm) = id :=
  funext$ fun a => h.to_equiv.right_inv a

@[simp]
theorem range_eq_univ (h : Œ± ‚âÉ·µ¢ Œ≤) : range h = univ :=
  h.to_equiv.range_eq_univ

theorem image_symm (h : Œ± ‚âÉ·µ¢ Œ≤) : image h.symm = preimage h :=
  image_eq_preimage_of_inverse h.symm.to_equiv.left_inv h.symm.to_equiv.right_inv

theorem preimage_symm (h : Œ± ‚âÉ·µ¢ Œ≤) : preimage h.symm = image h :=
  (image_eq_preimage_of_inverse h.to_equiv.left_inv h.to_equiv.right_inv).symm

@[simp]
theorem symm_trans_apply (h‚ÇÅ : Œ± ‚âÉ·µ¢ Œ≤) (h‚ÇÇ : Œ≤ ‚âÉ·µ¢ Œ≥) (x : Œ≥) : (h‚ÇÅ.trans h‚ÇÇ).symm x = h‚ÇÅ.symm (h‚ÇÇ.symm x) :=
  rfl

theorem ediam_univ (h : Œ± ‚âÉ·µ¢ Œ≤) : Emetric.diam (univ : Set Œ±) = Emetric.diam (univ : Set Œ≤) :=
  by 
    rw [‚Üêh.range_eq_univ, h.isometry.ediam_range]

@[simp]
theorem ediam_preimage (h : Œ± ‚âÉ·µ¢ Œ≤) (s : Set Œ≤) : Emetric.diam (h ‚Åª¬π' s) = Emetric.diam s :=
  by 
    rw [‚Üêimage_symm, ediam_image]

/-- The (bundled) homeomorphism associated to an isometric isomorphism. -/
@[simps toEquiv]
protected def to_homeomorph (h : Œ± ‚âÉ·µ¢ Œ≤) : Œ± ‚âÉ‚Çú Œ≤ :=
  { continuous_to_fun := h.continuous, continuous_inv_fun := h.symm.continuous, toEquiv := h.to_equiv }

@[simp]
theorem coe_to_homeomorph (h : Œ± ‚âÉ·µ¢ Œ≤) : ¬´expr‚áë ¬ª h.to_homeomorph = h :=
  rfl

@[simp]
theorem coe_to_homeomorph_symm (h : Œ± ‚âÉ·µ¢ Œ≤) : ¬´expr‚áë ¬ª h.to_homeomorph.symm = h.symm :=
  rfl

@[simp]
theorem comp_continuous_on_iff {Œ≥} [TopologicalSpace Œ≥] (h : Œ± ‚âÉ·µ¢ Œ≤) {f : Œ≥ ‚Üí Œ±} {s : Set Œ≥} :
  ContinuousOn (h ‚àò f) s ‚Üî ContinuousOn f s :=
  h.to_homeomorph.comp_continuous_on_iff _ _

@[simp]
theorem comp_continuous_iff {Œ≥} [TopologicalSpace Œ≥] (h : Œ± ‚âÉ·µ¢ Œ≤) {f : Œ≥ ‚Üí Œ±} : Continuous (h ‚àò f) ‚Üî Continuous f :=
  h.to_homeomorph.comp_continuous_iff

@[simp]
theorem comp_continuous_iff' {Œ≥} [TopologicalSpace Œ≥] (h : Œ± ‚âÉ·µ¢ Œ≤) {f : Œ≤ ‚Üí Œ≥} : Continuous (f ‚àò h) ‚Üî Continuous f :=
  h.to_homeomorph.comp_continuous_iff'

/-- The group of isometries. -/
instance  : Group‚Çì (Œ± ‚âÉ·µ¢ Œ±) :=
  { one := Isometric.refl _, mul := fun e‚ÇÅ e‚ÇÇ => e‚ÇÇ.trans e‚ÇÅ, inv := Isometric.symm, mul_assoc := fun e‚ÇÅ e‚ÇÇ e‚ÇÉ => rfl,
    one_mul := fun e => ext$ fun _ => rfl, mul_one := fun e => ext$ fun _ => rfl,
    mul_left_inv := fun e => ext e.symm_apply_apply }

@[simp]
theorem coe_one : ¬´expr‚áë ¬ª (1 : Œ± ‚âÉ·µ¢ Œ±) = id :=
  rfl

@[simp]
theorem coe_mul (e‚ÇÅ e‚ÇÇ : Œ± ‚âÉ·µ¢ Œ±) : ¬´expr‚áë ¬ª (e‚ÇÅ*e‚ÇÇ) = (e‚ÇÅ ‚àò e‚ÇÇ) :=
  rfl

theorem mul_apply (e‚ÇÅ e‚ÇÇ : Œ± ‚âÉ·µ¢ Œ±) (x : Œ±) : (e‚ÇÅ*e‚ÇÇ) x = e‚ÇÅ (e‚ÇÇ x) :=
  rfl

@[simp]
theorem inv_apply_self (e : Œ± ‚âÉ·µ¢ Œ±) (x : Œ±) : (e‚Åª¬π) (e x) = x :=
  e.symm_apply_apply x

@[simp]
theorem apply_inv_self (e : Œ± ‚âÉ·µ¢ Œ±) (x : Œ±) : e ((e‚Åª¬π) x) = x :=
  e.apply_symm_apply x

protected theorem CompleteSpace [CompleteSpace Œ≤] (e : Œ± ‚âÉ·µ¢ Œ≤) : CompleteSpace Œ± :=
  complete_space_of_is_complete_univ$
    is_complete_of_complete_image e.isometry.uniform_inducing$
      by 
        rwa [Set.image_univ, Isometric.range_eq_univ, ‚Üêcomplete_space_iff_is_complete_univ]

theorem complete_space_iff (e : Œ± ‚âÉ·µ¢ Œ≤) : CompleteSpace Œ± ‚Üî CompleteSpace Œ≤ :=
  by 
    split  <;> intro H 
    exacts[e.symm.complete_space, e.complete_space]

end PseudoEmetricSpace

section PseudoMetricSpace

variable[PseudoMetricSpace Œ±][PseudoMetricSpace Œ≤](h : Œ± ‚âÉ·µ¢ Œ≤)

@[simp]
theorem diam_image (s : Set Œ±) : Metric.diam (h '' s) = Metric.diam s :=
  h.isometry.diam_image s

@[simp]
theorem diam_preimage (s : Set Œ≤) : Metric.diam (h ‚Åª¬π' s) = Metric.diam s :=
  by 
    rw [‚Üêimage_symm, diam_image]

theorem diam_univ : Metric.diam (univ : Set Œ±) = Metric.diam (univ : Set Œ≤) :=
  congr_arg‚Çì Ennreal.toReal h.ediam_univ

end PseudoMetricSpace

end Isometric

/-- An isometry induces an isometric isomorphism between the source space and the
range of the isometry. -/
@[simps (config := { simpRhs := tt }) toEquiv apply]
def Isometry.isometricOnRange [EmetricSpace Œ±] [PseudoEmetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} (h : Isometry f) : Œ± ‚âÉ·µ¢ range f :=
  { isometry_to_fun :=
      fun x y =>
        by 
          simpa [Subtype.edist_eq] using h x y,
    toEquiv := Equiv.ofInjective f h.injective }

