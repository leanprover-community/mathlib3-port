import Mathbin.Topology.MetricSpace.Isometry 
import Mathbin.Topology.Instances.Ennreal 
import Mathbin.Analysis.SpecificLimits

/-!
# Hausdorff distance

The Hausdorff distance on subsets of a metric (or emetric) space.

Given two subsets `s` and `t` of a metric space, their Hausdorff distance is the smallest `d`
such that any point `s` is within `d` of a point in `t`, and conversely. This quantity
is often infinite (think of `s` bounded and `t` unbounded), and therefore better
expressed in the setting of emetric spaces.

## Main definitions

This files introduces:
* `inf_edist x s`, the infimum edistance of a point `x` to a set `s` in an emetric space
* `Hausdorff_edist s t`, the Hausdorff edistance of two sets in an emetric space
* Versions of these notions on metric spaces, called respectively `inf_dist` and `Hausdorff_dist`
* `thickening Œ¥ s`, the open thickening by radius `Œ¥` of a set `s` in a pseudo emetric space.
-/


noncomputable theory

open_locale Classical Nnreal Ennreal TopologicalSpace

universe u v w

open Classical Set Function TopologicalSpace Filter

namespace Emetric

section InfEdist

variable{Œ± : Type u}{Œ≤ : Type v}[PseudoEmetricSpace Œ±][PseudoEmetricSpace Œ≤]{x y : Œ±}{s t : Set Œ±}{Œ¶ : Œ± ‚Üí Œ≤}

/-! ### Distance of a point to a set as a function into `‚Ñù‚â•0‚àû`. -/


/-- The minimal edistance of a point to a set -/
def inf_edist (x : Œ±) (s : Set Œ±) : ‚Ñù‚â•0‚àû :=
  ‚®Ö(y : _)(_ : y ‚àà s), edist x y

@[simp]
theorem inf_edist_empty : inf_edist x ‚àÖ = ‚àû :=
  infi_emptyset

theorem le_inf_edist {d} : d ‚â§ inf_edist x s ‚Üî ‚àÄ y (_ : y ‚àà s), d ‚â§ edist x y :=
  by 
    simp only [inf_edist, le_infi_iff]

/-- The edist to a union is the minimum of the edists -/
@[simp]
theorem inf_edist_union : inf_edist x (s ‚à™ t) = inf_edist x s‚äìinf_edist x t :=
  infi_union

/-- The edist to a singleton is the edistance to the single point of this singleton -/
@[simp]
theorem inf_edist_singleton : inf_edist x {y} = edist x y :=
  infi_singleton

/-- The edist to a set is bounded above by the edist to any of its points -/
theorem inf_edist_le_edist_of_mem (h : y ‚àà s) : inf_edist x s ‚â§ edist x y :=
  binfi_le _ h

/-- If a point `x` belongs to `s`, then its edist to `s` vanishes -/
theorem inf_edist_zero_of_mem (h : x ‚àà s) : inf_edist x s = 0 :=
  nonpos_iff_eq_zero.1$ @edist_self _ _ x ‚ñ∏ inf_edist_le_edist_of_mem h

/-- The edist is monotonous with respect to inclusion -/
theorem inf_edist_le_inf_edist_of_subset (h : s ‚äÜ t) : inf_edist x t ‚â§ inf_edist x s :=
  infi_le_infi_of_subset h

/-- If the edist to a set is `< r`, there exists a point in the set at edistance `< r` -/
theorem exists_edist_lt_of_inf_edist_lt {r : ‚Ñù‚â•0‚àû} (h : inf_edist x s < r) : ‚àÉ (y : _)(_ : y ‚àà s), edist x y < r :=
  by 
    simpa only [inf_edist, infi_lt_iff] using h

/-- The edist of `x` to `s` is bounded by the sum of the edist of `y` to `s` and
the edist from `x` to `y` -/
theorem inf_edist_le_inf_edist_add_edist : inf_edist x s ‚â§ inf_edist y s+edist x y :=
  calc (‚®Ö(z : _)(_ : z ‚àà s), edist x z) ‚â§ ‚®Ö(z : _)(_ : z ‚àà s), edist y z+edist x y :=
    binfi_le_binfi$ fun z hz => (edist_triangle _ _ _).trans_eq (add_comm‚Çì _ _)
    _ = (‚®Ö(z : _)(_ : z ‚àà s), edist y z)+edist x y :=
    by 
      simp only [Ennreal.infi_add]
    

/-- The edist to a set depends continuously on the point -/
@[continuity]
theorem continuous_inf_edist : Continuous fun x => inf_edist x s :=
  continuous_of_le_add_edist 1
      (by 
        simp )$
    by 
      simp only [one_mul‚Çì, inf_edist_le_inf_edist_add_edist, forall_2_true_iff]

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The edist to a set and to its closure coincide -/
theorem inf_edist_closure : ¬´expr = ¬ª(inf_edist x (closure s), inf_edist x s) :=
begin
  refine [expr le_antisymm (inf_edist_le_inf_edist_of_subset subset_closure) _],
  refine [expr ennreal.le_of_forall_pos_le_add (Œª Œµ Œµpos h, _)],
  have [ident Œµ0] [":", expr ¬´expr < ¬ª(0, (¬´expr / ¬ª(Œµ, 2) : ¬´expr‚Ñù‚â•0‚àû¬ª()))] [":=", expr by simpa [] [] [] ["[", expr pos_iff_ne_zero, "]"] [] ["using", expr Œµpos]],
  have [] [":", expr ¬´expr < ¬ª(inf_edist x (closure s), ¬´expr + ¬ª(inf_edist x (closure s), ¬´expr / ¬ª(Œµ, 2)))] [],
  from [expr ennreal.lt_add_right h.ne Œµ0.ne'],
  rcases [expr exists_edist_lt_of_inf_edist_lt this, "with", "‚ü®", ident y, ",", ident ycs, ",", ident hy, "‚ü©"],
  rcases [expr emetric.mem_closure_iff.1 ycs ¬´expr / ¬ª(Œµ, 2) Œµ0, "with", "‚ü®", ident z, ",", ident zs, ",", ident dyz, "‚ü©"],
  calc
    ¬´expr ‚â§ ¬ª(inf_edist x s, edist x z) : inf_edist_le_edist_of_mem zs
    ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(edist x y, edist y z)) : edist_triangle _ _ _
    ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(¬´expr + ¬ª(inf_edist x (closure s), ¬´expr / ¬ª(Œµ, 2)), ¬´expr / ¬ª(Œµ, 2))) : add_le_add (le_of_lt hy) (le_of_lt dyz)
    ¬´expr = ¬ª(..., ¬´expr + ¬ª(inf_edist x (closure s), ¬´expr‚Üë ¬ª(Œµ))) : by rw ["[", expr add_assoc, ",", expr ennreal.add_halves, "]"] []
end

/-- A point belongs to the closure of `s` iff its infimum edistance to this set vanishes -/
theorem mem_closure_iff_inf_edist_zero : x ‚àà Closure s ‚Üî inf_edist x s = 0 :=
  ‚ü®fun h =>
      by 
        rw [‚Üêinf_edist_closure] <;> exact inf_edist_zero_of_mem h,
    fun h =>
      Emetric.mem_closure_iff.2$
        fun Œµ Œµpos =>
          exists_edist_lt_of_inf_edist_lt
            (by 
              rwa [h])‚ü©

/-- Given a closed set `s`, a point belongs to `s` iff its infimum edistance to this set vanishes -/
theorem mem_iff_inf_edist_zero_of_closed (h : IsClosed s) : x ‚àà s ‚Üî inf_edist x s = 0 :=
  by 
    convert ‚Üê mem_closure_iff_inf_edist_zero 
    exact h.closure_eq

theorem disjoint_closed_ball_of_lt_inf_edist {r : ‚Ñù‚â•0‚àû} (h : r < inf_edist x s) : Disjoint (closed_ball x r) s :=
  by 
    rw [disjoint_left]
    intro y hy h'y 
    apply lt_irrefl‚Çì (inf_edist x s)
    calc inf_edist x s ‚â§ edist x y := inf_edist_le_edist_of_mem h'y _ ‚â§ r :=
      by 
        rwa [mem_closed_ball, edist_comm] at hy _ < inf_edist x s :=
      h

/-- The infimum edistance is invariant under isometries -/
theorem inf_edist_image (hŒ¶ : Isometry Œ¶) : inf_edist (Œ¶ x) (Œ¶ '' t) = inf_edist x t :=
  by 
    simp only [inf_edist, infi_image, hŒ¶.edist_eq]

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem _root_.is_open.exists_Union_is_closed
{U : set Œ±}
(hU : is_open U) : ¬´expr‚àÉ , ¬ª((F : expr‚Ñï() ‚Üí set Œ±), ¬´expr ‚àß ¬ª(‚àÄ
  n, is_closed (F n), ¬´expr ‚àß ¬ª(‚àÄ n, ¬´expr ‚äÜ ¬ª(F n, U), ¬´expr ‚àß ¬ª(¬´expr = ¬ª(¬´expr‚ãÉ , ¬ª((n), F n), U), monotone F)))) :=
begin
  obtain ["‚ü®", ident a, ",", ident a_pos, ",", ident a_lt_one, "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((a : ¬´expr‚Ñù‚â•0‚àû¬ª()), ¬´expr ‚àß ¬ª(¬´expr < ¬ª(0, a), ¬´expr < ¬ª(a, 1))), ":=", expr exists_between ennreal.zero_lt_one],
  let [ident F] [] [":=", expr Œª n : expr‚Ñï(), ¬´expr ‚Åª¬π' ¬ª(Œª x, inf_edist x ¬´expr ·∂ú¬ª(U), Ici ¬´expr ^ ¬ª(a, n))],
  have [ident F_subset] [":", expr ‚àÄ n, ¬´expr ‚äÜ ¬ª(F n, U)] [],
  { assume [binders (n x hx)],
    by_contra [ident h],
    rw ["[", "<-", expr mem_compl_iff, ",", expr mem_iff_inf_edist_zero_of_closed (is_open.is_closed_compl hU), "]"] ["at", ident h],
    have [] [":", expr ¬´expr < ¬ª(0, inf_edist x ¬´expr ·∂ú¬ª(U))] [":=", expr lt_of_lt_of_le (ennreal.pow_pos a_pos _) hx],
    rw [expr h] ["at", ident this],
    exact [expr lt_irrefl _ this] },
  refine [expr ‚ü®F, Œª n, is_closed.preimage continuous_inf_edist is_closed_Ici, F_subset, _, _‚ü©],
  show [expr monotone F],
  { assume [binders (m n hmn x hx)],
    simp [] [] ["only"] ["[", expr mem_Ici, ",", expr mem_preimage, "]"] [] ["at", ident hx, "‚ä¢"],
    apply [expr le_trans (ennreal.pow_le_pow_of_le_one a_lt_one.le hmn) hx] },
  show [expr ¬´expr = ¬ª(¬´expr‚ãÉ , ¬ª((n), F n), U)],
  { refine [expr subset.antisymm (by simp [] [] ["only"] ["[", expr Union_subset_iff, ",", expr F_subset, ",", expr forall_const, "]"] [] []) (Œª
      x hx, _)],
    have [] [":", expr ¬´expr¬¨ ¬ª(¬´expr ‚àà ¬ª(x, ¬´expr ·∂ú¬ª(U)))] [],
    by simpa [] [] [] [] [] ["using", expr hx],
    rw [expr mem_iff_inf_edist_zero_of_closed (is_open.is_closed_compl hU)] ["at", ident this],
    have [ident B] [":", expr ¬´expr < ¬ª(0, inf_edist x ¬´expr ·∂ú¬ª(U))] [],
    by simpa [] [] [] ["[", expr pos_iff_ne_zero, "]"] [] ["using", expr this],
    have [] [":", expr filter.tendsto (Œª
      n, ¬´expr ^ ¬ª(a, n)) at_top (exprùìù() 0)] [":=", expr ennreal.tendsto_pow_at_top_nhds_0_of_lt_1 a_lt_one],
    rcases [expr ((tendsto_order.1 this).2 _ B).exists, "with", "‚ü®", ident n, ",", ident hn, "‚ü©"],
    simp [] [] ["only"] ["[", expr mem_Union, ",", expr mem_Ici, ",", expr mem_preimage, "]"] [] [],
    exact [expr ‚ü®n, hn.le‚ü©] }
end

end InfEdist

/-! ### The Hausdorff distance as a function into `‚Ñù‚â•0‚àû`. -/


/-- The Hausdorff edistance between two sets is the smallest `r` such that each set
is contained in the `r`-neighborhood of the other one -/
@[irreducible]
def Hausdorff_edist {Œ± : Type u} [PseudoEmetricSpace Œ±] (s t : Set Œ±) : ‚Ñù‚â•0‚àû :=
  (‚®Ü(x : _)(_ : x ‚àà s), inf_edist x t)‚äî‚®Ü(y : _)(_ : y ‚àà t), inf_edist y s

theorem Hausdorff_edist_def {Œ± : Type u} [PseudoEmetricSpace Œ±] (s t : Set Œ±) :
  Hausdorff_edist s t = (‚®Ü(x : _)(_ : x ‚àà s), inf_edist x t)‚äî‚®Ü(y : _)(_ : y ‚àà t), inf_edist y s :=
  by 
    rw [Hausdorff_edist]

section HausdorffEdist

variable{Œ± : Type u}{Œ≤ : Type v}[PseudoEmetricSpace Œ±][PseudoEmetricSpace Œ≤]{x y : Œ±}{s t u : Set Œ±}{Œ¶ : Œ± ‚Üí Œ≤}

/-- The Hausdorff edistance of a set to itself vanishes -/
@[simp]
theorem Hausdorff_edist_self : Hausdorff_edist s s = 0 :=
  by 
    simp only [Hausdorff_edist_def, sup_idem, Ennreal.supr_eq_zero]
    exact fun x hx => inf_edist_zero_of_mem hx

/-- The Haudorff edistances of `s` to `t` and of `t` to `s` coincide -/
theorem Hausdorff_edist_comm : Hausdorff_edist s t = Hausdorff_edist t s :=
  by 
    unfold Hausdorff_edist <;> apply sup_comm

/-- Bounding the Hausdorff edistance by bounding the edistance of any point
in each set to the other set -/
theorem Hausdorff_edist_le_of_inf_edist {r : ‚Ñù‚â•0‚àû} (H1 : ‚àÄ x (_ : x ‚àà s), inf_edist x t ‚â§ r)
  (H2 : ‚àÄ x (_ : x ‚àà t), inf_edist x s ‚â§ r) : Hausdorff_edist s t ‚â§ r :=
  by 
    simp only [Hausdorff_edist, sup_le_iff, supr_le_iff]
    exact ‚ü®H1, H2‚ü©

/-- Bounding the Hausdorff edistance by exhibiting, for any point in each set,
another point in the other set at controlled distance -/
theorem Hausdorff_edist_le_of_mem_edist {r : ‚Ñù‚â•0‚àû} (H1 : ‚àÄ x (_ : x ‚àà s), ‚àÉ (y : _)(_ : y ‚àà t), edist x y ‚â§ r)
  (H2 : ‚àÄ x (_ : x ‚àà t), ‚àÉ (y : _)(_ : y ‚àà s), edist x y ‚â§ r) : Hausdorff_edist s t ‚â§ r :=
  by 
    refine' Hausdorff_edist_le_of_inf_edist _ _
    ¬∑
      intro x xs 
      rcases H1 x xs with ‚ü®y, yt, hy‚ü©
      exact le_trans‚Çì (inf_edist_le_edist_of_mem yt) hy
    ¬∑
      intro x xt 
      rcases H2 x xt with ‚ü®y, ys, hy‚ü©
      exact le_trans‚Çì (inf_edist_le_edist_of_mem ys) hy

/-- The distance to a set is controlled by the Hausdorff distance -/
theorem inf_edist_le_Hausdorff_edist_of_mem (h : x ‚àà s) : inf_edist x t ‚â§ Hausdorff_edist s t :=
  by 
    rw [Hausdorff_edist_def]
    refine' le_trans‚Çì _ le_sup_left 
    exact le_bsupr x h

/-- If the Hausdorff distance is `<r`, then any point in one of the sets has
a corresponding point at distance `<r` in the other set -/
theorem exists_edist_lt_of_Hausdorff_edist_lt {r : ‚Ñù‚â•0‚àû} (h : x ‚àà s) (H : Hausdorff_edist s t < r) :
  ‚àÉ (y : _)(_ : y ‚àà t), edist x y < r :=
  exists_edist_lt_of_inf_edist_lt$
    calc inf_edist x t ‚â§ Hausdorff_edist s t := inf_edist_le_Hausdorff_edist_of_mem h 
      _ < r := H
      

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The distance from `x` to `s` or `t` is controlled in terms of the Hausdorff distance
between `s` and `t` -/
theorem inf_edist_le_inf_edist_add_Hausdorff_edist : ¬´expr ‚â§ ¬ª(inf_edist x t, ¬´expr + ¬ª(inf_edist x s, Hausdorff_edist s t)) :=
¬´expr $ ¬ª(ennreal.le_of_forall_pos_le_add, Œª Œµ Œµpos h, begin
   have [ident Œµ0] [":", expr ¬´expr ‚â† ¬ª((¬´expr / ¬ª(Œµ, 2) : ¬´expr‚Ñù‚â•0‚àû¬ª()), 0)] [":=", expr by simpa [] [] [] ["[", expr pos_iff_ne_zero, "]"] [] ["using", expr Œµpos]],
   have [] [":", expr ¬´expr < ¬ª(inf_edist x s, ¬´expr + ¬ª(inf_edist x s, ¬´expr / ¬ª(Œµ, 2)))] [":=", expr ennreal.lt_add_right (ennreal.add_lt_top.1 h).1.ne Œµ0],
   rcases [expr exists_edist_lt_of_inf_edist_lt this, "with", "‚ü®", ident y, ",", ident ys, ",", ident dxy, "‚ü©"],
   have [] [":", expr ¬´expr < ¬ª(Hausdorff_edist s t, ¬´expr + ¬ª(Hausdorff_edist s t, ¬´expr / ¬ª(Œµ, 2)))] [":=", expr ennreal.lt_add_right (ennreal.add_lt_top.1 h).2.ne Œµ0],
   rcases [expr exists_edist_lt_of_Hausdorff_edist_lt ys this, "with", "‚ü®", ident z, ",", ident zt, ",", ident dyz, "‚ü©"],
   calc
     ¬´expr ‚â§ ¬ª(inf_edist x t, edist x z) : inf_edist_le_edist_of_mem zt
     ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(edist x y, edist y z)) : edist_triangle _ _ _
     ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(¬´expr + ¬ª(inf_edist x s, ¬´expr / ¬ª(Œµ, 2)), ¬´expr + ¬ª(Hausdorff_edist s t, ¬´expr / ¬ª(Œµ, 2)))) : add_le_add dxy.le dyz.le
     ¬´expr = ¬ª(..., ¬´expr + ¬ª(¬´expr + ¬ª(inf_edist x s, Hausdorff_edist s t), Œµ)) : by simp [] [] [] ["[", expr ennreal.add_halves, ",", expr add_comm, ",", expr add_left_comm, "]"] [] []
 end)

/-- The Hausdorff edistance is invariant under eisometries -/
theorem Hausdorff_edist_image (h : Isometry Œ¶) : Hausdorff_edist (Œ¶ '' s) (Œ¶ '' t) = Hausdorff_edist s t :=
  by 
    simp only [Hausdorff_edist_def, supr_image, inf_edist_image h]

/-- The Hausdorff distance is controlled by the diameter of the union -/
theorem Hausdorff_edist_le_ediam (hs : s.nonempty) (ht : t.nonempty) : Hausdorff_edist s t ‚â§ diam (s ‚à™ t) :=
  by 
    rcases hs with ‚ü®x, xs‚ü©
    rcases ht with ‚ü®y, yt‚ü©
    refine' Hausdorff_edist_le_of_mem_edist _ _
    ¬∑
      intro z hz 
      exact ‚ü®y, yt, edist_le_diam_of_mem (subset_union_left _ _ hz) (subset_union_right _ _ yt)‚ü©
    ¬∑
      intro z hz 
      exact ‚ü®x, xs, edist_le_diam_of_mem (subset_union_right _ _ hz) (subset_union_left _ _ xs)‚ü©

/-- The Hausdorff distance satisfies the triangular inequality -/
theorem Hausdorff_edist_triangle : Hausdorff_edist s u ‚â§ Hausdorff_edist s t+Hausdorff_edist t u :=
  by 
    rw [Hausdorff_edist_def]
    simp only [sup_le_iff, supr_le_iff]
    split 
    show ‚àÄ x (_ : x ‚àà s), inf_edist x u ‚â§ Hausdorff_edist s t+Hausdorff_edist t u 
    exact
      fun x xs =>
        calc inf_edist x u ‚â§ inf_edist x t+Hausdorff_edist t u := inf_edist_le_inf_edist_add_Hausdorff_edist 
          _ ‚â§ Hausdorff_edist s t+Hausdorff_edist t u := add_le_add_right (inf_edist_le_Hausdorff_edist_of_mem xs) _ 
          
    show ‚àÄ x (_ : x ‚àà u), inf_edist x s ‚â§ Hausdorff_edist s t+Hausdorff_edist t u 
    exact
      fun x xu =>
        calc inf_edist x s ‚â§ inf_edist x t+Hausdorff_edist t s := inf_edist_le_inf_edist_add_Hausdorff_edist 
          _ ‚â§ Hausdorff_edist u t+Hausdorff_edist t s := add_le_add_right (inf_edist_le_Hausdorff_edist_of_mem xu) _ 
          _ = Hausdorff_edist s t+Hausdorff_edist t u :=
          by 
            simp [Hausdorff_edist_comm, add_comm‚Çì]
          

/-- Two sets are at zero Hausdorff edistance if and only if they have the same closure -/
theorem Hausdorff_edist_zero_iff_closure_eq_closure : Hausdorff_edist s t = 0 ‚Üî Closure s = Closure t :=
  calc Hausdorff_edist s t = 0 ‚Üî s ‚äÜ Closure t ‚àß t ‚äÜ Closure s :=
    by 
      simp only [Hausdorff_edist_def, Ennreal.sup_eq_zero, Ennreal.supr_eq_zero, ‚Üêmem_closure_iff_inf_edist_zero,
        subset_def]
    _ ‚Üî Closure s = Closure t :=
    ‚ü®fun h => subset.antisymm (closure_minimal h.1 is_closed_closure) (closure_minimal h.2 is_closed_closure),
      fun h => ‚ü®h ‚ñ∏ subset_closure, h.symm ‚ñ∏ subset_closure‚ü©‚ü©
    

/-- The Hausdorff edistance between a set and its closure vanishes -/
@[simp]
theorem Hausdorff_edist_self_closure : Hausdorff_edist s (Closure s) = 0 :=
  by 
    rw [Hausdorff_edist_zero_iff_closure_eq_closure, closure_closure]

/-- Replacing a set by its closure does not change the Hausdorff edistance. -/
@[simp]
theorem Hausdorff_edist_closure‚ÇÅ : Hausdorff_edist (Closure s) t = Hausdorff_edist s t :=
  by 
    refine' le_antisymm‚Çì _ _
    ¬∑
      calc _ ‚â§ Hausdorff_edist (Closure s) s+Hausdorff_edist s t := Hausdorff_edist_triangle _ = Hausdorff_edist s t :=
        by 
          simp [Hausdorff_edist_comm]
    ¬∑
      calc _ ‚â§ Hausdorff_edist s (Closure s)+Hausdorff_edist (Closure s) t :=
        Hausdorff_edist_triangle _ = Hausdorff_edist (Closure s) t :=
        by 
          simp 

/-- Replacing a set by its closure does not change the Hausdorff edistance. -/
@[simp]
theorem Hausdorff_edist_closure‚ÇÇ : Hausdorff_edist s (Closure t) = Hausdorff_edist s t :=
  by 
    simp [@Hausdorff_edist_comm _ _ s _]

/-- The Hausdorff edistance between sets or their closures is the same -/
@[simp]
theorem Hausdorff_edist_closure : Hausdorff_edist (Closure s) (Closure t) = Hausdorff_edist s t :=
  by 
    simp 

/-- Two closed sets are at zero Hausdorff edistance if and only if they coincide -/
theorem Hausdorff_edist_zero_iff_eq_of_closed (hs : IsClosed s) (ht : IsClosed t) : Hausdorff_edist s t = 0 ‚Üî s = t :=
  by 
    rw [Hausdorff_edist_zero_iff_closure_eq_closure, hs.closure_eq, ht.closure_eq]

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The Haudorff edistance to the empty set is infinite -/
theorem Hausdorff_edist_empty (ne : s.nonempty) : ¬´expr = ¬ª(Hausdorff_edist s ¬´expr‚àÖ¬ª(), ¬´expr‚àû¬ª()) :=
begin
  rcases [expr ne, "with", "‚ü®", ident x, ",", ident xs, "‚ü©"],
  have [] [":", expr ¬´expr ‚â§ ¬ª(inf_edist x ¬´expr‚àÖ¬ª(), Hausdorff_edist s ¬´expr‚àÖ¬ª())] [":=", expr inf_edist_le_Hausdorff_edist_of_mem xs],
  simpa [] [] [] [] [] ["using", expr this]
end

/-- If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty -/
theorem nonempty_of_Hausdorff_edist_ne_top (hs : s.nonempty) (fin : Hausdorff_edist s t ‚â† ‚ä§) : t.nonempty :=
  t.eq_empty_or_nonempty.elim (fun ht => (Fin‚Çì$ ht.symm ‚ñ∏ Hausdorff_edist_empty hs).elim) id

theorem empty_or_nonempty_of_Hausdorff_edist_ne_top (fin : Hausdorff_edist s t ‚â† ‚ä§) :
  s = ‚àÖ ‚àß t = ‚àÖ ‚à® s.nonempty ‚àß t.nonempty :=
  by 
    cases' s.eq_empty_or_nonempty with hs hs
    ¬∑
      cases' t.eq_empty_or_nonempty with ht ht
      ¬∑
        exact Or.inl ‚ü®hs, ht‚ü©
      ¬∑
        rw [Hausdorff_edist_comm] at fin 
        exact Or.inr ‚ü®nonempty_of_Hausdorff_edist_ne_top ht Fin‚Çì, ht‚ü©
    ¬∑
      exact Or.inr ‚ü®hs, nonempty_of_Hausdorff_edist_ne_top hs Fin‚Çì‚ü©

end HausdorffEdist

end Emetric

/-! Now, we turn to the same notions in metric spaces. To avoid the difficulties related to
`Inf` and `Sup` on `‚Ñù` (which is only conditionally complete), we use the notions in `‚Ñù‚â•0‚àû`
formulated in terms of the edistance, and coerce them to `‚Ñù`.
Then their properties follow readily from the corresponding properties in `‚Ñù‚â•0‚àû`,
modulo some tedious rewriting of inequalities from one to the other. -/


namespace Metric

section 

variable{Œ± : Type u}{Œ≤ : Type v}[PseudoMetricSpace Œ±][PseudoMetricSpace Œ≤]{s t u : Set Œ±}{x y : Œ±}{Œ¶ : Œ± ‚Üí Œ≤}

open Emetric

/-! ### Distance of a point to a set as a function into `‚Ñù`. -/


/-- The minimal distance of a point to a set -/
def inf_dist (x : Œ±) (s : Set Œ±) : ‚Ñù :=
  Ennreal.toReal (inf_edist x s)

/-- the minimal distance is always nonnegative -/
theorem inf_dist_nonneg : 0 ‚â§ inf_dist x s :=
  by 
    simp [inf_dist]

/-- the minimal distance to the empty set is 0 (if you want to have the more reasonable
value ‚àû instead, use `inf_edist`, which takes values in ‚Ñù‚â•0‚àû) -/
@[simp]
theorem inf_dist_empty : inf_dist x ‚àÖ = 0 :=
  by 
    simp [inf_dist]

/-- In a metric space, the minimal edistance to a nonempty set is finite -/
theorem inf_edist_ne_top (h : s.nonempty) : inf_edist x s ‚â† ‚ä§ :=
  by 
    rcases h with ‚ü®y, hy‚ü©
    apply lt_top_iff_ne_top.1
    calc inf_edist x s ‚â§ edist x y := inf_edist_le_edist_of_mem hy _ < ‚ä§ := lt_top_iff_ne_top.2 (edist_ne_top _ _)

/-- The minimal distance of a point to a set containing it vanishes -/
theorem inf_dist_zero_of_mem (h : x ‚àà s) : inf_dist x s = 0 :=
  by 
    simp [inf_edist_zero_of_mem h, inf_dist]

/-- The minimal distance to a singleton is the distance to the unique point in this singleton -/
@[simp]
theorem inf_dist_singleton : inf_dist x {y} = dist x y :=
  by 
    simp [inf_dist, inf_edist, dist_edist]

/-- The minimal distance to a set is bounded by the distance to any point in this set -/
theorem inf_dist_le_dist_of_mem (h : y ‚àà s) : inf_dist x s ‚â§ dist x y :=
  by 
    rw [dist_edist, inf_dist, Ennreal.to_real_le_to_real (inf_edist_ne_top ‚ü®_, h‚ü©) (edist_ne_top _ _)]
    exact inf_edist_le_edist_of_mem h

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The minimal distance is monotonous with respect to inclusion -/
theorem inf_dist_le_inf_dist_of_subset
(h : ¬´expr ‚äÜ ¬ª(s, t))
(hs : s.nonempty) : ¬´expr ‚â§ ¬ª(inf_dist x t, inf_dist x s) :=
begin
  have [ident ht] [":", expr t.nonempty] [":=", expr hs.mono h],
  rw ["[", expr inf_dist, ",", expr inf_dist, ",", expr ennreal.to_real_le_to_real (inf_edist_ne_top ht) (inf_edist_ne_top hs), "]"] [],
  exact [expr inf_edist_le_inf_edist_of_subset h]
end

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If the minimal distance to a set is `<r`, there exists a point in this set at distance `<r` -/
theorem exists_dist_lt_of_inf_dist_lt
{r : real}
(h : ¬´expr < ¬ª(inf_dist x s, r))
(hs : s.nonempty) : ¬´expr‚àÉ , ¬ª((y ¬´expr ‚àà ¬ª s), ¬´expr < ¬ª(dist x y, r)) :=
begin
  have [ident rpos] [":", expr ¬´expr < ¬ª(0, r)] [":=", expr lt_of_le_of_lt inf_dist_nonneg h],
  have [] [":", expr ¬´expr < ¬ª(inf_edist x s, ennreal.of_real r)] [],
  { rwa ["[", expr inf_dist, ",", "<-", expr ennreal.to_real_of_real (le_of_lt rpos), ",", expr ennreal.to_real_lt_to_real (inf_edist_ne_top hs), "]"] ["at", ident h],
    simp [] [] [] [] [] [] },
  rcases [expr exists_edist_lt_of_inf_edist_lt this, "with", "‚ü®", ident y, ",", ident ys, ",", ident hy, "‚ü©"],
  rw ["[", expr edist_dist, ",", expr ennreal.of_real_lt_of_real_iff rpos, "]"] ["at", ident hy],
  exact [expr ‚ü®y, ys, hy‚ü©]
end

/-- The minimal distance from `x` to `s` is bounded by the distance from `y` to `s`, modulo
the distance between `x` and `y` -/
theorem inf_dist_le_inf_dist_add_dist : inf_dist x s ‚â§ inf_dist y s+dist x y :=
  by 
    cases' s.eq_empty_or_nonempty with hs hs
    ¬∑
      ¬∑
        simp [hs, dist_nonneg]
    ¬∑
      rw [inf_dist, inf_dist, dist_edist, ‚ÜêEnnreal.to_real_add (inf_edist_ne_top hs) (edist_ne_top _ _),
        Ennreal.to_real_le_to_real (inf_edist_ne_top hs)]
      ¬∑
        apply inf_edist_le_inf_edist_add_edist
      ¬∑
        simp [Ennreal.add_eq_top, inf_edist_ne_top hs, edist_ne_top]

theorem disjoint_closed_ball_of_lt_inf_dist {r : ‚Ñù} (h : r < inf_dist x s) : Disjoint (closed_ball x r) s :=
  by 
    rw [disjoint_left]
    intro y hy h'y 
    apply lt_irrefl‚Çì (inf_dist x s)
    calc inf_dist x s ‚â§ dist x y := inf_dist_le_dist_of_mem h'y _ ‚â§ r :=
      by 
        rwa [mem_closed_ball, dist_comm] at hy _ < inf_dist x s :=
      h

variable(s)

/-- The minimal distance to a set is Lipschitz in point with constant 1 -/
theorem lipschitz_inf_dist_pt : LipschitzWith 1 fun x => inf_dist x s :=
  LipschitzWith.of_le_add$ fun x y => inf_dist_le_inf_dist_add_dist

/-- The minimal distance to a set is uniformly continuous in point -/
theorem uniform_continuous_inf_dist_pt : UniformContinuous fun x => inf_dist x s :=
  (lipschitz_inf_dist_pt s).UniformContinuous

/-- The minimal distance to a set is continuous in point -/
@[continuity]
theorem continuous_inf_dist_pt : Continuous fun x => inf_dist x s :=
  (uniform_continuous_inf_dist_pt s).Continuous

variable{s}

/-- The minimal distance to a set and its closure coincide -/
theorem inf_dist_eq_closure : inf_dist x (Closure s) = inf_dist x s :=
  by 
    simp [inf_dist, inf_edist_closure]

/-- A point belongs to the closure of `s` iff its infimum distance to this set vanishes -/
theorem mem_closure_iff_inf_dist_zero (h : s.nonempty) : x ‚àà Closure s ‚Üî inf_dist x s = 0 :=
  by 
    simp [mem_closure_iff_inf_edist_zero, inf_dist, Ennreal.to_real_eq_zero_iff, inf_edist_ne_top h]

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes -/
theorem _root_.is_closed.mem_iff_inf_dist_zero
(h : is_closed s)
(hs : s.nonempty) : ¬´expr ‚Üî ¬ª(¬´expr ‚àà ¬ª(x, s), ¬´expr = ¬ª(inf_dist x s, 0)) :=
begin
  have [] [] [":=", expr @mem_closure_iff_inf_dist_zero _ _ s x hs],
  rwa [expr h.closure_eq] ["at", ident this]
end

/-- Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes -/
theorem _root_.is_closed.not_mem_iff_inf_dist_pos (h : IsClosed s) (hs : s.nonempty) : x ‚àâ s ‚Üî 0 < inf_dist x s :=
  by 
    rw [‚Üênot_iff_not]
    pushNeg 
    simp [h.mem_iff_inf_dist_zero hs, le_antisymm_iff‚Çì, inf_dist_nonneg]

/-- The infimum distance is invariant under isometries -/
theorem inf_dist_image (hŒ¶ : Isometry Œ¶) : inf_dist (Œ¶ x) (Œ¶ '' t) = inf_dist x t :=
  by 
    simp [inf_dist, inf_edist_image hŒ¶]

/-! ### Distance of a point to a set as a function into `‚Ñù‚â•0`. -/


/-- The minimal distance of a point to a set as a `‚Ñù‚â•0` -/
def inf_nndist (x : Œ±) (s : Set Œ±) :  ‚Ñù‚â•0  :=
  Ennreal.toNnreal (inf_edist x s)

@[simp]
theorem coe_inf_nndist : (inf_nndist x s : ‚Ñù) = inf_dist x s :=
  rfl

/-- The minimal distance to a set (as `‚Ñù‚â•0`) is Lipschitz in point with constant 1 -/
theorem lipschitz_inf_nndist_pt (s : Set Œ±) : LipschitzWith 1 fun x => inf_nndist x s :=
  LipschitzWith.of_le_add$ fun x y => inf_dist_le_inf_dist_add_dist

/-- The minimal distance to a set (as `‚Ñù‚â•0`) is uniformly continuous in point -/
theorem uniform_continuous_inf_nndist_pt (s : Set Œ±) : UniformContinuous fun x => inf_nndist x s :=
  (lipschitz_inf_nndist_pt s).UniformContinuous

/-- The minimal distance to a set (as `‚Ñù‚â•0`) is continuous in point -/
theorem continuous_inf_nndist_pt (s : Set Œ±) : Continuous fun x => inf_nndist x s :=
  (uniform_continuous_inf_nndist_pt s).Continuous

/-! ### The Hausdorff distance as a function into `‚Ñù`. -/


/-- The Hausdorff distance between two sets is the smallest nonnegative `r` such that each set is
included in the `r`-neighborhood of the other. If there is no such `r`, it is defined to
be `0`, arbitrarily -/
def Hausdorff_dist (s t : Set Œ±) : ‚Ñù :=
  Ennreal.toReal (Hausdorff_edist s t)

/-- The Hausdorff distance is nonnegative -/
theorem Hausdorff_dist_nonneg : 0 ‚â§ Hausdorff_dist s t :=
  by 
    simp [Hausdorff_dist]

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff
edistance. -/
theorem Hausdorff_edist_ne_top_of_nonempty_of_bounded
(hs : s.nonempty)
(ht : t.nonempty)
(bs : bounded s)
(bt : bounded t) : ¬´expr ‚â† ¬ª(Hausdorff_edist s t, ¬´expr‚ä§¬ª()) :=
begin
  rcases [expr hs, "with", "‚ü®", ident cs, ",", ident hcs, "‚ü©"],
  rcases [expr ht, "with", "‚ü®", ident ct, ",", ident hct, "‚ü©"],
  rcases [expr (bounded_iff_subset_ball ct).1 bs, "with", "‚ü®", ident rs, ",", ident hrs, "‚ü©"],
  rcases [expr (bounded_iff_subset_ball cs).1 bt, "with", "‚ü®", ident rt, ",", ident hrt, "‚ü©"],
  have [] [":", expr ¬´expr ‚â§ ¬ª(Hausdorff_edist s t, ennreal.of_real (max rs rt))] [],
  { apply [expr Hausdorff_edist_le_of_mem_edist],
    { assume [binders (x xs)],
      existsi ["[", expr ct, ",", expr hct, "]"],
      have [] [":", expr ¬´expr ‚â§ ¬ª(dist x ct, max rs rt)] [":=", expr le_trans (hrs xs) (le_max_left _ _)],
      rwa ["[", expr edist_dist, ",", expr ennreal.of_real_le_of_real_iff, "]"] [],
      exact [expr le_trans dist_nonneg this] },
    { assume [binders (x xt)],
      existsi ["[", expr cs, ",", expr hcs, "]"],
      have [] [":", expr ¬´expr ‚â§ ¬ª(dist x cs, max rs rt)] [":=", expr le_trans (hrt xt) (le_max_right _ _)],
      rwa ["[", expr edist_dist, ",", expr ennreal.of_real_le_of_real_iff, "]"] [],
      exact [expr le_trans dist_nonneg this] } },
  exact [expr ne_top_of_le_ne_top ennreal.of_real_ne_top this]
end

/-- The Hausdorff distance between a set and itself is zero -/
@[simp]
theorem Hausdorff_dist_self_zero : Hausdorff_dist s s = 0 :=
  by 
    simp [Hausdorff_dist]

/-- The Hausdorff distance from `s` to `t` and from `t` to `s` coincide -/
theorem Hausdorff_dist_comm : Hausdorff_dist s t = Hausdorff_dist t s :=
  by 
    simp [Hausdorff_dist, Hausdorff_edist_comm]

/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable
value ‚àû instead, use `Hausdorff_edist`, which takes values in ‚Ñù‚â•0‚àû) -/
@[simp]
theorem Hausdorff_dist_empty : Hausdorff_dist s ‚àÖ = 0 :=
  by 
    cases' s.eq_empty_or_nonempty with h h
    ¬∑
      simp [h]
    ¬∑
      simp [Hausdorff_dist, Hausdorff_edist_empty h]

/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable
value ‚àû instead, use `Hausdorff_edist`, which takes values in ‚Ñù‚â•0‚àû) -/
@[simp]
theorem Hausdorff_dist_empty' : Hausdorff_dist ‚àÖ s = 0 :=
  by 
    simp [Hausdorff_dist_comm]

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Bounding the Hausdorff distance by bounding the distance of any point
in each set to the other set -/
theorem Hausdorff_dist_le_of_inf_dist
{r : expr‚Ñù()}
(hr : ¬´expr ‚â§ ¬ª(0, r))
(H1 : ‚àÄ x ¬´expr ‚àà ¬ª s, ¬´expr ‚â§ ¬ª(inf_dist x t, r))
(H2 : ‚àÄ x ¬´expr ‚àà ¬ª t, ¬´expr ‚â§ ¬ª(inf_dist x s, r)) : ¬´expr ‚â§ ¬ª(Hausdorff_dist s t, r) :=
begin
  by_cases [expr h1, ":", expr ¬´expr = ¬ª(Hausdorff_edist s t, ¬´expr‚ä§¬ª())],
  by rwa ["[", expr Hausdorff_dist, ",", expr h1, ",", expr ennreal.top_to_real, "]"] [],
  cases [expr s.eq_empty_or_nonempty] ["with", ident hs, ident hs],
  by rwa ["[", expr hs, ",", expr Hausdorff_dist_empty', "]"] [],
  cases [expr t.eq_empty_or_nonempty] ["with", ident ht, ident ht],
  by rwa ["[", expr ht, ",", expr Hausdorff_dist_empty, "]"] [],
  have [] [":", expr ¬´expr ‚â§ ¬ª(Hausdorff_edist s t, ennreal.of_real r)] [],
  { apply [expr Hausdorff_edist_le_of_inf_edist _ _],
    { assume [binders (x hx)],
      have [ident I] [] [":=", expr H1 x hx],
      rwa ["[", expr inf_dist, ",", "<-", expr ennreal.to_real_of_real hr, ",", expr ennreal.to_real_le_to_real (inf_edist_ne_top ht) ennreal.of_real_ne_top, "]"] ["at", ident I] },
    { assume [binders (x hx)],
      have [ident I] [] [":=", expr H2 x hx],
      rwa ["[", expr inf_dist, ",", "<-", expr ennreal.to_real_of_real hr, ",", expr ennreal.to_real_le_to_real (inf_edist_ne_top hs) ennreal.of_real_ne_top, "]"] ["at", ident I] } },
  rwa ["[", expr Hausdorff_dist, ",", "<-", expr ennreal.to_real_of_real hr, ",", expr ennreal.to_real_le_to_real h1 ennreal.of_real_ne_top, "]"] []
end

/-- Bounding the Hausdorff distance by exhibiting, for any point in each set,
another point in the other set at controlled distance -/
theorem Hausdorff_dist_le_of_mem_dist {r : ‚Ñù} (hr : 0 ‚â§ r) (H1 : ‚àÄ x (_ : x ‚àà s), ‚àÉ (y : _)(_ : y ‚àà t), dist x y ‚â§ r)
  (H2 : ‚àÄ x (_ : x ‚àà t), ‚àÉ (y : _)(_ : y ‚àà s), dist x y ‚â§ r) : Hausdorff_dist s t ‚â§ r :=
  by 
    apply Hausdorff_dist_le_of_inf_dist hr
    ¬∑
      intro x xs 
      rcases H1 x xs with ‚ü®y, yt, hy‚ü©
      exact le_trans‚Çì (inf_dist_le_dist_of_mem yt) hy
    ¬∑
      intro x xt 
      rcases H2 x xt with ‚ü®y, ys, hy‚ü©
      exact le_trans‚Çì (inf_dist_le_dist_of_mem ys) hy

/-- The Hausdorff distance is controlled by the diameter of the union -/
theorem Hausdorff_dist_le_diam (hs : s.nonempty) (bs : Bounded s) (ht : t.nonempty) (bt : Bounded t) :
  Hausdorff_dist s t ‚â§ diam (s ‚à™ t) :=
  by 
    rcases hs with ‚ü®x, xs‚ü©
    rcases ht with ‚ü®y, yt‚ü©
    refine' Hausdorff_dist_le_of_mem_dist diam_nonneg _ _
    ¬∑
      exact
        fun z hz =>
          ‚ü®y, yt, dist_le_diam_of_mem (bounded_union.2 ‚ü®bs, bt‚ü©) (subset_union_left _ _ hz) (subset_union_right _ _ yt)‚ü©
    ¬∑
      exact
        fun z hz =>
          ‚ü®x, xs, dist_le_diam_of_mem (bounded_union.2 ‚ü®bs, bt‚ü©) (subset_union_right _ _ hz) (subset_union_left _ _ xs)‚ü©

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The distance to a set is controlled by the Hausdorff distance -/
theorem inf_dist_le_Hausdorff_dist_of_mem
(hx : ¬´expr ‚àà ¬ª(x, s))
(fin : ¬´expr ‚â† ¬ª(Hausdorff_edist s t, ¬´expr‚ä§¬ª())) : ¬´expr ‚â§ ¬ª(inf_dist x t, Hausdorff_dist s t) :=
begin
  have [ident ht] [":", expr t.nonempty] [":=", expr nonempty_of_Hausdorff_edist_ne_top ‚ü®x, hx‚ü© fin],
  rw ["[", expr Hausdorff_dist, ",", expr inf_dist, ",", expr ennreal.to_real_le_to_real (inf_edist_ne_top ht) fin, "]"] [],
  exact [expr inf_edist_le_Hausdorff_edist_of_mem hx]
end

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If the Hausdorff distance is `<r`, then any point in one of the sets is at distance
`<r` of a point in the other set -/
theorem exists_dist_lt_of_Hausdorff_dist_lt
{r : expr‚Ñù()}
(h : ¬´expr ‚àà ¬ª(x, s))
(H : ¬´expr < ¬ª(Hausdorff_dist s t, r))
(fin : ¬´expr ‚â† ¬ª(Hausdorff_edist s t, ¬´expr‚ä§¬ª())) : ¬´expr‚àÉ , ¬ª((y ¬´expr ‚àà ¬ª t), ¬´expr < ¬ª(dist x y, r)) :=
begin
  have [ident r0] [":", expr ¬´expr < ¬ª(0, r)] [":=", expr lt_of_le_of_lt Hausdorff_dist_nonneg H],
  have [] [":", expr ¬´expr < ¬ª(Hausdorff_edist s t, ennreal.of_real r)] [],
  by rwa ["[", expr Hausdorff_dist, ",", "<-", expr ennreal.to_real_of_real (le_of_lt r0), ",", expr ennreal.to_real_lt_to_real fin ennreal.of_real_ne_top, "]"] ["at", ident H],
  rcases [expr exists_edist_lt_of_Hausdorff_edist_lt h this, "with", "‚ü®", ident y, ",", ident hy, ",", ident yr, "‚ü©"],
  rw ["[", expr edist_dist, ",", expr ennreal.of_real_lt_of_real_iff r0, "]"] ["at", ident yr],
  exact [expr ‚ü®y, hy, yr‚ü©]
end

/-- If the Hausdorff distance is `<r`, then any point in one of the sets is at distance
`<r` of a point in the other set -/
theorem exists_dist_lt_of_Hausdorff_dist_lt' {r : ‚Ñù} (h : y ‚àà t) (H : Hausdorff_dist s t < r)
  (fin : Hausdorff_edist s t ‚â† ‚ä§) : ‚àÉ (x : _)(_ : x ‚àà s), dist x y < r :=
  by 
    rw [Hausdorff_dist_comm] at H 
    rw [Hausdorff_edist_comm] at fin 
    simpa [dist_comm] using exists_dist_lt_of_Hausdorff_dist_lt h H Fin‚Çì

/-- The infimum distance to `s` and `t` are the same, up to the Hausdorff distance
between `s` and `t` -/
theorem inf_dist_le_inf_dist_add_Hausdorff_dist (fin : Hausdorff_edist s t ‚â† ‚ä§) :
  inf_dist x t ‚â§ inf_dist x s+Hausdorff_dist s t :=
  by 
    rcases empty_or_nonempty_of_Hausdorff_edist_ne_top Fin‚Çì with (‚ü®hs, ht‚ü© | ‚ü®hs, ht‚ü©)
    ¬∑
      simp only [hs, ht, Hausdorff_dist_empty, inf_dist_empty, zero_add‚Çì]
    rw [inf_dist, inf_dist, Hausdorff_dist, ‚ÜêEnnreal.to_real_add (inf_edist_ne_top hs) Fin‚Çì,
      Ennreal.to_real_le_to_real (inf_edist_ne_top ht)]
    ¬∑
      exact inf_edist_le_inf_edist_add_Hausdorff_edist
    ¬∑
      exact Ennreal.add_ne_top.2 ‚ü®inf_edist_ne_top hs, Fin‚Çì‚ü©

/-- The Hausdorff distance is invariant under isometries -/
theorem Hausdorff_dist_image (h : Isometry Œ¶) : Hausdorff_dist (Œ¶ '' s) (Œ¶ '' t) = Hausdorff_dist s t :=
  by 
    simp [Hausdorff_dist, Hausdorff_edist_image h]

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The Hausdorff distance satisfies the triangular inequality -/
theorem Hausdorff_dist_triangle
(fin : ¬´expr ‚â† ¬ª(Hausdorff_edist s t, ¬´expr‚ä§¬ª())) : ¬´expr ‚â§ ¬ª(Hausdorff_dist s u, ¬´expr + ¬ª(Hausdorff_dist s t, Hausdorff_dist t u)) :=
begin
  by_cases [expr ¬´expr = ¬ª(Hausdorff_edist s u, ¬´expr‚ä§¬ª())],
  { calc
      ¬´expr = ¬ª(Hausdorff_dist s u, ¬´expr + ¬ª(0, 0)) : by simp [] [] [] ["[", expr Hausdorff_dist, ",", expr h, "]"] [] []
      ¬´expr ‚â§ ¬ª(..., ¬´expr + ¬ª(Hausdorff_dist s t, Hausdorff_dist t u)) : add_le_add Hausdorff_dist_nonneg Hausdorff_dist_nonneg },
  { have [ident Dtu] [":", expr ¬´expr < ¬ª(Hausdorff_edist t u, ¬´expr‚ä§¬ª())] [":=", expr calc
       ¬´expr ‚â§ ¬ª(Hausdorff_edist t u, ¬´expr + ¬ª(Hausdorff_edist t s, Hausdorff_edist s u)) : Hausdorff_edist_triangle
       ¬´expr = ¬ª(..., ¬´expr + ¬ª(Hausdorff_edist s t, Hausdorff_edist s u)) : by simp [] [] [] ["[", expr Hausdorff_edist_comm, "]"] [] []
       ¬´expr < ¬ª(..., ¬´expr‚ä§¬ª()) : by simp [] [] [] ["[", expr lt_top_iff_ne_top, ",", "*", "]"] [] []],
    rw ["[", expr Hausdorff_dist, ",", expr Hausdorff_dist, ",", expr Hausdorff_dist, ",", "<-", expr ennreal.to_real_add fin Dtu.ne, ",", expr ennreal.to_real_le_to_real h, "]"] [],
    { exact [expr Hausdorff_edist_triangle] },
    { simp [] [] [] ["[", expr ennreal.add_eq_top, ",", expr lt_top_iff_ne_top.1 Dtu, ",", expr fin, "]"] [] [] } }
end

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The Hausdorff distance satisfies the triangular inequality -/
theorem Hausdorff_dist_triangle'
(fin : ¬´expr ‚â† ¬ª(Hausdorff_edist t u, ¬´expr‚ä§¬ª())) : ¬´expr ‚â§ ¬ª(Hausdorff_dist s u, ¬´expr + ¬ª(Hausdorff_dist s t, Hausdorff_dist t u)) :=
begin
  rw [expr Hausdorff_edist_comm] ["at", ident fin],
  have [ident I] [":", expr ¬´expr ‚â§ ¬ª(Hausdorff_dist u s, ¬´expr + ¬ª(Hausdorff_dist u t, Hausdorff_dist t s))] [":=", expr Hausdorff_dist_triangle fin],
  simpa [] [] [] ["[", expr add_comm, ",", expr Hausdorff_dist_comm, "]"] [] ["using", expr I]
end

/-- The Hausdorff distance between a set and its closure vanish -/
@[simp]
theorem Hausdorff_dist_self_closure : Hausdorff_dist s (Closure s) = 0 :=
  by 
    simp [Hausdorff_dist]

/-- Replacing a set by its closure does not change the Hausdorff distance. -/
@[simp]
theorem Hausdorff_dist_closure‚ÇÅ : Hausdorff_dist (Closure s) t = Hausdorff_dist s t :=
  by 
    simp [Hausdorff_dist]

/-- Replacing a set by its closure does not change the Hausdorff distance. -/
@[simp]
theorem Hausdorff_dist_closure‚ÇÇ : Hausdorff_dist s (Closure t) = Hausdorff_dist s t :=
  by 
    simp [Hausdorff_dist]

/-- The Hausdorff distance between two sets and their closures coincide -/
@[simp]
theorem Hausdorff_dist_closure : Hausdorff_dist (Closure s) (Closure t) = Hausdorff_dist s t :=
  by 
    simp [Hausdorff_dist]

/-- Two sets are at zero Hausdorff distance if and only if they have the same closures -/
theorem Hausdorff_dist_zero_iff_closure_eq_closure (fin : Hausdorff_edist s t ‚â† ‚ä§) :
  Hausdorff_dist s t = 0 ‚Üî Closure s = Closure t :=
  by 
    simp [Hausdorff_edist_zero_iff_closure_eq_closure.symm, Hausdorff_dist, Ennreal.to_real_eq_zero_iff, Fin‚Çì]

/-- Two closed sets are at zero Hausdorff distance if and only if they coincide -/
theorem _root_.is_closed.Hausdorff_dist_zero_iff_eq (hs : IsClosed s) (ht : IsClosed t)
  (fin : Hausdorff_edist s t ‚â† ‚ä§) : Hausdorff_dist s t = 0 ‚Üî s = t :=
  by 
    simp [(Hausdorff_edist_zero_iff_eq_of_closed hs ht).symm, Hausdorff_dist, Ennreal.to_real_eq_zero_iff, Fin‚Çì]

end 

section Thickening

variable{Œ± : Type u}[PseudoEmetricSpace Œ±]

open Emetric

/-- The (open) `Œ¥`-thickening `thickening Œ¥ E` of a subset `E` in a pseudo emetric space consists
of those points that are at distance less than `Œ¥` from some point of `E`. -/
def thickening (Œ¥ : ‚Ñù) (E : Set Œ±) : Set Œ± :=
  { x:Œ± | inf_edist x E < Ennreal.ofReal Œ¥ }

/-- The (open) thickening equals the preimage of an open interval under `inf_edist`. -/
theorem thickening_eq_preimage_inf_edist (Œ¥ : ‚Ñù) (E : Set Œ±) :
  thickening Œ¥ E = (fun x => inf_edist x E) ‚Åª¬π' Iio (Ennreal.ofReal Œ¥) :=
  rfl

/-- The (open) thickening is an open set. -/
theorem is_open_thickening {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=
  Continuous.is_open_preimage continuous_inf_edist _ is_open_Iio

/-- The (open) thickening of the empty set is empty. -/
@[simp]
theorem thickening_empty (Œ¥ : ‚Ñù) : thickening Œ¥ (‚àÖ : Set Œ±) = ‚àÖ :=
  by 
    simp only [thickening, set_of_false, inf_edist_empty, not_top_lt]

/-- The (open) thickening `thickening Œ¥ E` of a fixed subset `E` is an increasing function of the
thickening radius `Œ¥`. -/
theorem thickening_mono {Œ¥‚ÇÅ Œ¥‚ÇÇ : ‚Ñù} (hle : Œ¥‚ÇÅ ‚â§ Œ¥‚ÇÇ) (E : Set Œ±) : thickening Œ¥‚ÇÅ E ‚äÜ thickening Œ¥‚ÇÇ E :=
  preimage_mono (Iio_subset_Iio (Ennreal.of_real_le_of_real hle))

/-- The (open) thickening `thickening Œ¥ E` with a fixed thickening radius `Œ¥` is
an increasing function of the subset `E`. -/
theorem thickening_subset_of_subset (Œ¥ : ‚Ñù) {E‚ÇÅ E‚ÇÇ : Set Œ±} (h : E‚ÇÅ ‚äÜ E‚ÇÇ) : thickening Œ¥ E‚ÇÅ ‚äÜ thickening Œ¥ E‚ÇÇ :=
  fun _ hx => lt_of_le_of_lt‚Çì (inf_edist_le_inf_edist_of_subset h) hx

variable{X : Type u}[MetricSpace X]

-- error in Topology.MetricSpace.HausdorffDistance: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A point in a metric space belongs to the (open) `Œ¥`-thickening of a subset `E` if and only if
it is at distance less than `Œ¥` from some point of `E`. -/
theorem mem_thickening_iff
{Œ¥ : expr‚Ñù()}
(E : set X)
(x : X) : ¬´expr ‚Üî ¬ª(¬´expr ‚àà ¬ª(x, thickening Œ¥ E), ¬´expr‚àÉ , ¬ª((z ¬´expr ‚àà ¬ª E), ¬´expr < ¬ª(dist x z, Œ¥))) :=
begin
  unfold [ident thickening] [],
  simp [] [] ["only"] ["[", expr exists_prop, ",", expr mem_set_of_eq, "]"] [] [],
  split,
  { intros [ident h],
    rcases [expr exists_edist_lt_of_inf_edist_lt h, "with", "‚ü®", ident z, ",", "‚ü®", ident hzE, ",", ident hxz, "‚ü©", "‚ü©"],
    refine [expr ‚ü®z, hzE, _‚ü©],
    rw [expr dist_edist] [],
    apply [expr (@ennreal.of_real_lt_of_real_iff_of_nonneg (edist x z).to_real Œ¥ ennreal.to_real_nonneg).mp],
    rwa [expr ennreal.of_real_to_real (edist_lt_top x z).ne] [] },
  { intros [ident h],
    rcases [expr h, "with", "‚ü®", ident z, ",", "‚ü®", ident hzE, ",", ident hxz, "‚ü©", "‚ü©"],
    rw [expr dist_edist] ["at", ident hxz],
    apply [expr lt_of_le_of_lt (@inf_edist_le_edist_of_mem _ _ x _ _ hzE) _],
    have [ident key] [] [":=", expr (@ennreal.of_real_lt_of_real_iff_of_nonneg (edist x z).to_real Œ¥ ennreal.to_real_nonneg).mpr hxz],
    rwa [expr ennreal.of_real_to_real (edist_lt_top x z).ne] ["at", ident key] }
end

/-- The (open) `Œ¥`-thickening `thickening Œ¥ E` of a subset `E` in a metric space equals the
union of balls of radius `Œ¥` centered at points of `E`. -/
theorem thickening_eq_bUnion_ball {Œ¥ : ‚Ñù} {E : Set X} : thickening Œ¥ E = ‚ãÉ(x : _)(_ : x ‚àà E), ball x Œ¥ :=
  by 
    ext x 
    rw [mem_bUnion_iff]
    exact mem_thickening_iff E x

end Thickening

end Metric

