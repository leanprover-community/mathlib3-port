/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Patrick Massot

! This file was ported from Lean 3 source module topology.maps
! leanprover-community/mathlib commit 369525b73f229ccd76a6ec0e0e0bf2be57599768
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Order
import Mathbin.Topology.NhdsSet

/-!
# Specific classes of maps between topological spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file introduces the following properties of a map `f : X ‚Üí Y` between topological spaces:

* `is_open_map f` means the image of an open set under `f` is open.
* `is_closed_map f` means the image of a closed set under `f` is closed.

(Open and closed maps need not be continuous.)

* `inducing f` means the topology on `X` is the one induced via `f` from the topology on `Y`.
  These behave like embeddings except they need not be injective. Instead, points of `X` which
  are identified by `f` are also inseparable in the topology on `X`.
* `embedding f` means `f` is inducing and also injective. Equivalently, `f` identifies `X` with
  a subspace of `Y`.
* `open_embedding f` means `f` is an embedding with open image, so it identifies `X` with an
  open subspace of `Y`. Equivalently, `f` is an embedding and an open map.
* `closed_embedding f` similarly means `f` is an embedding with closed image, so it identifies
  `X` with a closed subspace of `Y`. Equivalently, `f` is an embedding and a closed map.

* `quotient_map f` is the dual condition to `embedding f`: `f` is surjective and the topology
  on `Y` is the one coinduced via `f` from the topology on `X`. Equivalently, `f` identifies
  `Y` with a quotient of `X`. Quotient maps are also sometimes known as identification maps.

## References

* <https://en.wikipedia.org/wiki/Open_and_closed_maps>
* <https://en.wikipedia.org/wiki/Embedding#General_topology>
* <https://en.wikipedia.org/wiki/Quotient_space_(topology)#Quotient_map>

## Tags

open map, closed map, embedding, quotient map, identification map

-/


open Set Filter Function

open Topology Filter

variable {Œ± : Type _} {Œ≤ : Type _} {Œ≥ : Type _} {Œ¥ : Type _}

section Inducing

#print Inducing /-
/-- A function `f : Œ± ‚Üí Œ≤` between topological spaces is inducing if the topology on `Œ±` is induced
by the topology on `Œ≤` through `f`, meaning that a set `s : set Œ±` is open iff it is the preimage
under `f` of some open set `t : set Œ≤`. -/
@[mk_iff]
structure Inducing [tŒ± : TopologicalSpace Œ±] [tŒ≤ : TopologicalSpace Œ≤] (f : Œ± ‚Üí Œ≤) : Prop where
  induced : tŒ± = tŒ≤.induced f
#align inducing Inducing
-/

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥] [TopologicalSpace Œ¥]

#print inducing_id /-
theorem inducing_id : Inducing (@id Œ±) :=
  ‚ü®induced_id.symm‚ü©
#align inducing_id inducing_id
-/

/- warning: inducing.comp -> Inducing.comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (Inducing.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Inducing.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (Inducing.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Inducing.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) -> (Inducing.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f))
Case conversion may be inaccurate. Consider using '#align inducing.comp Inducing.comp‚Çì'. -/
protected theorem Inducing.comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : Inducing g) (hf : Inducing f) :
    Inducing (g ‚àò f) :=
  ‚ü®by rw [hf.induced, hg.induced, induced_compose]‚ü©
#align inducing.comp Inducing.comp

/- warning: inducing_of_inducing_compose -> inducing_of_inducing_compose is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Inducing.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)) -> (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u3}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Continuous.{u3, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Inducing.{u3, u1} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u3, succ u2, succ u1} Œ± Œ≤ Œ≥ g f)) -> (Inducing.{u3, u2} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align inducing_of_inducing_compose inducing_of_inducing_compose‚Çì'. -/
theorem inducing_of_inducing_compose {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hf : Continuous f) (hg : Continuous g)
    (hgf : Inducing (g ‚àò f)) : Inducing f :=
  ‚ü®le_antisymm (by rwa [‚Üê continuous_iff_le_induced])
      (by
        rw [hgf.induced, ‚Üê continuous_iff_le_induced]
        apply hg.comp continuous_induced_dom)‚ü©
#align inducing_of_inducing_compose inducing_of_inducing_compose

/- warning: inducing_iff_nhds -> inducing_iff_nhds is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, Iff (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (forall (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 a) (Filter.comap.{u1, u2} Œ± Œ≤ f (nhds.{u2} Œ≤ _inst_2 (f a))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, Iff (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) (forall (a : Œ±), Eq.{succ u2} (Filter.{u2} Œ±) (nhds.{u2} Œ± _inst_1 a) (Filter.comap.{u2, u1} Œ± Œ≤ f (nhds.{u1} Œ≤ _inst_2 (f a))))
Case conversion may be inaccurate. Consider using '#align inducing_iff_nhds inducing_iff_nhds‚Çì'. -/
theorem inducing_iff_nhds {f : Œ± ‚Üí Œ≤} : Inducing f ‚Üî ‚àÄ a, ùìù a = comap f (ùìù (f a)) :=
  (inducing_iff _).trans (induced_iff_nhds_eq f)
#align inducing_iff_nhds inducing_iff_nhds

/- warning: inducing.nhds_eq_comap -> Inducing.nhds_eq_comap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhds.{u1} Œ± _inst_1 a) (Filter.comap.{u1, u2} Œ± Œ≤ f (nhds.{u2} Œ≤ _inst_2 (f a))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u2} (Filter.{u2} Œ±) (nhds.{u2} Œ± _inst_1 a) (Filter.comap.{u2, u1} Œ± Œ≤ f (nhds.{u1} Œ≤ _inst_2 (f a))))
Case conversion may be inaccurate. Consider using '#align inducing.nhds_eq_comap Inducing.nhds_eq_comap‚Çì'. -/
theorem Inducing.nhds_eq_comap {f : Œ± ‚Üí Œ≤} (hf : Inducing f) : ‚àÄ a : Œ±, ùìù a = comap f (ùìù <| f a) :=
  inducing_iff_nhds.1 hf
#align inducing.nhds_eq_comap Inducing.nhds_eq_comap

/- warning: inducing.nhds_set_eq_comap -> Inducing.nhdsSet_eq_comap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u1} Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (nhdsSet.{u1} Œ± _inst_1 s) (Filter.comap.{u1, u2} Œ± Œ≤ f (nhdsSet.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u2} Œ±), Eq.{succ u2} (Filter.{u2} Œ±) (nhdsSet.{u2} Œ± _inst_1 s) (Filter.comap.{u2, u1} Œ± Œ≤ f (nhdsSet.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align inducing.nhds_set_eq_comap Inducing.nhdsSet_eq_comap‚Çì'. -/
theorem Inducing.nhdsSet_eq_comap {f : Œ± ‚Üí Œ≤} (hf : Inducing f) (s : Set Œ±) :
    ùìùÀ¢ s = comap f (ùìùÀ¢ (f '' s)) := by
  simp only [nhdsSet, sup‚Çõ_image, comap_supr, hf.nhds_eq_comap, sup·µ¢_image]
#align inducing.nhds_set_eq_comap Inducing.nhdsSet_eq_comap

/- warning: inducing.map_nhds_eq -> Inducing.map_nhds_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u2} (Filter.{u2} Œ≤) (Filter.map.{u1, u2} Œ± Œ≤ f (nhds.{u1} Œ± _inst_1 a)) (nhdsWithin.{u2} Œ≤ _inst_2 (f a) (Set.range.{u2, succ u1} Œ≤ Œ± f)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ≤) (Filter.map.{u2, u1} Œ± Œ≤ f (nhds.{u2} Œ± _inst_1 a)) (nhdsWithin.{u1} Œ≤ _inst_2 (f a) (Set.range.{u1, succ u2} Œ≤ Œ± f)))
Case conversion may be inaccurate. Consider using '#align inducing.map_nhds_eq Inducing.map_nhds_eq‚Çì'. -/
theorem Inducing.map_nhds_eq {f : Œ± ‚Üí Œ≤} (hf : Inducing f) (a : Œ±) : (ùìù a).map f = ùìù[range f] f a :=
  hf.induced.symm ‚ñ∏ map_nhds_induced_eq a
#align inducing.map_nhds_eq Inducing.map_nhds_eq

/- warning: inducing.map_nhds_of_mem -> Inducing.map_nhds_of_mem is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) (Set.range.{u2, succ u1} Œ≤ Œ± f) (nhds.{u2} Œ≤ _inst_2 (f a))) -> (Eq.{succ u2} (Filter.{u2} Œ≤) (Filter.map.{u1, u2} Œ± Œ≤ f (nhds.{u1} Œ± _inst_1 a)) (nhds.{u2} Œ≤ _inst_2 (f a))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) (Set.range.{u1, succ u2} Œ≤ Œ± f) (nhds.{u1} Œ≤ _inst_2 (f a))) -> (Eq.{succ u1} (Filter.{u1} Œ≤) (Filter.map.{u2, u1} Œ± Œ≤ f (nhds.{u2} Œ± _inst_1 a)) (nhds.{u1} Œ≤ _inst_2 (f a))))
Case conversion may be inaccurate. Consider using '#align inducing.map_nhds_of_mem Inducing.map_nhds_of_mem‚Çì'. -/
theorem Inducing.map_nhds_of_mem {f : Œ± ‚Üí Œ≤} (hf : Inducing f) (a : Œ±) (h : range f ‚àà ùìù (f a)) :
    (ùìù a).map f = ùìù (f a) :=
  hf.induced.symm ‚ñ∏ map_nhds_induced_of_mem h
#align inducing.map_nhds_of_mem Inducing.map_nhds_of_mem

/- warning: inducing.image_mem_nhds_within -> Inducing.image_mem_nhdsWithin is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {a : Œ±} {s : Set.{u1} Œ±}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhds.{u1} Œ± _inst_1 a)) -> (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) (Set.image.{u1, u2} Œ± Œ≤ f s) (nhdsWithin.{u2} Œ≤ _inst_2 (f a) (Set.range.{u2, succ u1} Œ≤ Œ± f))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {a : Œ±} {s : Set.{u2} Œ±}, (Membership.mem.{u2, u2} (Set.{u2} Œ±) (Filter.{u2} Œ±) (instMembershipSetFilter.{u2} Œ±) s (nhds.{u2} Œ± _inst_1 a)) -> (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) (Set.image.{u2, u1} Œ± Œ≤ f s) (nhdsWithin.{u1} Œ≤ _inst_2 (f a) (Set.range.{u1, succ u2} Œ≤ Œ± f))))
Case conversion may be inaccurate. Consider using '#align inducing.image_mem_nhds_within Inducing.image_mem_nhdsWithin‚Çì'. -/
theorem Inducing.image_mem_nhdsWithin {f : Œ± ‚Üí Œ≤} (hf : Inducing f) {a : Œ±} {s : Set Œ±}
    (hs : s ‚àà ùìù a) : f '' s ‚àà ùìù[range f] f a :=
  hf.map_nhds_eq a ‚ñ∏ image_mem_map hs
#align inducing.image_mem_nhds_within Inducing.image_mem_nhdsWithin

/- warning: inducing.tendsto_nhds_iff -> Inducing.tendsto_nhds_iff is a dubious translation:
lean 3 declaration is
  forall {Œ≤ : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_2 : TopologicalSpace.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {Œπ : Type.{u3}} {f : Œπ -> Œ≤} {g : Œ≤ -> Œ≥} {a : Filter.{u3} Œπ} {b : Œ≤}, (Inducing.{u1, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Filter.Tendsto.{u3, u1} Œπ Œ≤ f a (nhds.{u1} Œ≤ _inst_2 b)) (Filter.Tendsto.{u3, u2} Œπ Œ≥ (Function.comp.{succ u3, succ u1, succ u2} Œπ Œ≤ Œ≥ g f) a (nhds.{u2} Œ≥ _inst_3 (g b))))
but is expected to have type
  forall {Œ≤ : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≥] {Œπ : Type.{u3}} {f : Œπ -> Œ≤} {g : Œ≤ -> Œ≥} {a : Filter.{u3} Œπ} {b : Œ≤}, (Inducing.{u2, u1} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Filter.Tendsto.{u3, u2} Œπ Œ≤ f a (nhds.{u2} Œ≤ _inst_2 b)) (Filter.Tendsto.{u3, u1} Œπ Œ≥ (Function.comp.{succ u3, succ u2, succ u1} Œπ Œ≤ Œ≥ g f) a (nhds.{u1} Œ≥ _inst_3 (g b))))
Case conversion may be inaccurate. Consider using '#align inducing.tendsto_nhds_iff Inducing.tendsto_nhds_iff‚Çì'. -/
theorem Inducing.tendsto_nhds_iff {Œπ : Type _} {f : Œπ ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} {a : Filter Œπ} {b : Œ≤}
    (hg : Inducing g) : Tendsto f a (ùìù b) ‚Üî Tendsto (g ‚àò f) a (ùìù (g b)) := by
  rw [hg.nhds_eq_comap, tendsto_comap_iff]
#align inducing.tendsto_nhds_iff Inducing.tendsto_nhds_iff

/- warning: inducing.continuous_at_iff -> Inducing.continuousAt_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Inducing.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (forall {x : Œ±}, Iff (ContinuousAt.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f x) (ContinuousAt.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f) x))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Inducing.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (forall {x : Œ±}, Iff (ContinuousAt.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f x) (ContinuousAt.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f) x))
Case conversion may be inaccurate. Consider using '#align inducing.continuous_at_iff Inducing.continuousAt_iff‚Çì'. -/
theorem Inducing.continuousAt_iff {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hg : Inducing g) {x : Œ±} :
    ContinuousAt f x ‚Üî ContinuousAt (g ‚àò f) x := by
  simp_rw [ContinuousAt, Inducing.tendsto_nhds_iff hg]
#align inducing.continuous_at_iff Inducing.continuousAt_iff

/- warning: inducing.continuous_iff -> Inducing.continuous_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Inducing.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (Continuous.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Inducing.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Continuous.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) (Continuous.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f)))
Case conversion may be inaccurate. Consider using '#align inducing.continuous_iff Inducing.continuous_iff‚Çì'. -/
theorem Inducing.continuous_iff {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hg : Inducing g) :
    Continuous f ‚Üî Continuous (g ‚àò f) := by
  simp_rw [continuous_iff_continuousAt, hg.continuous_at_iff]
#align inducing.continuous_iff Inducing.continuous_iff

/- warning: inducing.continuous_at_iff' -> Inducing.continuousAt_iff' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {x : Œ±}, (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) (Set.range.{u2, succ u1} Œ≤ Œ± f) (nhds.{u2} Œ≤ _inst_2 (f x))) -> (Iff (ContinuousAt.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f) x) (ContinuousAt.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g (f x))))
but is expected to have type
  forall {Œ± : Type.{u3}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Inducing.{u3, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {x : Œ±}, (Membership.mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (instMembershipSetFilter.{u2} Œ≤) (Set.range.{u2, succ u3} Œ≤ Œ± f) (nhds.{u2} Œ≤ _inst_2 (f x))) -> (Iff (ContinuousAt.{u3, u1} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u3, succ u2, succ u1} Œ± Œ≤ Œ≥ g f) x) (ContinuousAt.{u2, u1} Œ≤ Œ≥ _inst_2 _inst_3 g (f x))))
Case conversion may be inaccurate. Consider using '#align inducing.continuous_at_iff' Inducing.continuousAt_iff'‚Çì'. -/
theorem Inducing.continuousAt_iff' {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hf : Inducing f) {x : Œ±}
    (h : range f ‚àà ùìù (f x)) : ContinuousAt (g ‚àò f) x ‚Üî ContinuousAt g (f x) := by
  simp_rw [ContinuousAt, Filter.Tendsto, ‚Üê hf.map_nhds_of_mem _ h, Filter.map_map]
#align inducing.continuous_at_iff' Inducing.continuousAt_iff'

/- warning: inducing.continuous -> Inducing.continuous is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align inducing.continuous Inducing.continuous‚Çì'. -/
protected theorem Inducing.continuous {f : Œ± ‚Üí Œ≤} (hf : Inducing f) : Continuous f :=
  hf.continuous_iff.mp continuous_id
#align inducing.continuous Inducing.continuous

/- warning: inducing.inducing_iff -> Inducing.inducing_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Inducing.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (Inducing.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Inducing.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Inducing.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) (Inducing.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f)))
Case conversion may be inaccurate. Consider using '#align inducing.inducing_iff Inducing.inducing_iff‚Çì'. -/
protected theorem Inducing.inducing_iff {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hg : Inducing g) :
    Inducing f ‚Üî Inducing (g ‚àò f) :=
  by
  refine' ‚ü®fun h => hg.comp h, fun hgf => inducing_of_inducing_compose _ hg.continuous hgf‚ü©
  rw [hg.continuous_iff]
  exact hgf.continuous
#align inducing.inducing_iff Inducing.inducing_iff

/- warning: inducing.closure_eq_preimage_closure_image -> Inducing.closure_eq_preimage_closure_image is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u1} Œ±), Eq.{succ u1} (Set.{u1} Œ±) (closure.{u1} Œ± _inst_1 s) (Set.preimage.{u1, u2} Œ± Œ≤ f (closure.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u2} Œ±), Eq.{succ u2} (Set.{u2} Œ±) (closure.{u2} Œ± _inst_1 s) (Set.preimage.{u2, u1} Œ± Œ≤ f (closure.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align inducing.closure_eq_preimage_closure_image Inducing.closure_eq_preimage_closure_image‚Çì'. -/
theorem Inducing.closure_eq_preimage_closure_image {f : Œ± ‚Üí Œ≤} (hf : Inducing f) (s : Set Œ±) :
    closure s = f ‚Åª¬π' closure (f '' s) := by
  ext x
  rw [Set.mem_preimage, ‚Üê closure_induced, hf.induced]
#align inducing.closure_eq_preimage_closure_image Inducing.closure_eq_preimage_closure_image

/- warning: inducing.is_closed_iff -> Inducing.isClosed_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ±}, Iff (IsClosed.{u1} Œ± _inst_1 s) (Exists.{succ u2} (Set.{u2} Œ≤) (fun (t : Set.{u2} Œ≤) => And (IsClosed.{u2} Œ≤ _inst_2 t) (Eq.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, u2} Œ± Œ≤ f t) s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ±}, Iff (IsClosed.{u2} Œ± _inst_1 s) (Exists.{succ u1} (Set.{u1} Œ≤) (fun (t : Set.{u1} Œ≤) => And (IsClosed.{u1} Œ≤ _inst_2 t) (Eq.{succ u2} (Set.{u2} Œ±) (Set.preimage.{u2, u1} Œ± Œ≤ f t) s))))
Case conversion may be inaccurate. Consider using '#align inducing.is_closed_iff Inducing.isClosed_iff‚Çì'. -/
theorem Inducing.isClosed_iff {f : Œ± ‚Üí Œ≤} (hf : Inducing f) {s : Set Œ±} :
    IsClosed s ‚Üî ‚àÉ t, IsClosed t ‚àß f ‚Åª¬π' t = s := by rw [hf.induced, isClosed_induced_iff]
#align inducing.is_closed_iff Inducing.isClosed_iff

/- warning: inducing.is_closed_iff' -> Inducing.isClosed_iff' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ±}, Iff (IsClosed.{u1} Œ± _inst_1 s) (forall (x : Œ±), (Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) (f x) (closure.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s))) -> (Membership.Mem.{u1, u1} Œ± (Set.{u1} Œ±) (Set.hasMem.{u1} Œ±) x s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ±}, Iff (IsClosed.{u2} Œ± _inst_1 s) (forall (x : Œ±), (Membership.mem.{u1, u1} Œ≤ (Set.{u1} Œ≤) (Set.instMembershipSet.{u1} Œ≤) (f x) (closure.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s))) -> (Membership.mem.{u2, u2} Œ± (Set.{u2} Œ±) (Set.instMembershipSet.{u2} Œ±) x s)))
Case conversion may be inaccurate. Consider using '#align inducing.is_closed_iff' Inducing.isClosed_iff'‚Çì'. -/
theorem Inducing.isClosed_iff' {f : Œ± ‚Üí Œ≤} (hf : Inducing f) {s : Set Œ±} :
    IsClosed s ‚Üî ‚àÄ x, f x ‚àà closure (f '' s) ‚Üí x ‚àà s := by rw [hf.induced, isClosed_induced_iff']
#align inducing.is_closed_iff' Inducing.isClosed_iff'

/- warning: inducing.is_closed_preimage -> Inducing.isClosed_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u2} Œ≤), (IsClosed.{u2} Œ≤ _inst_2 s) -> (IsClosed.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u1} Œ≤), (IsClosed.{u1} Œ≤ _inst_2 s) -> (IsClosed.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align inducing.is_closed_preimage Inducing.isClosed_preimage‚Çì'. -/
theorem Inducing.isClosed_preimage {f : Œ± ‚Üí Œ≤} (h : Inducing f) (s : Set Œ≤) (hs : IsClosed s) :
    IsClosed (f ‚Åª¬π' s) :=
  (Inducing.isClosed_iff h).mpr ‚ü®s, hs, rfl‚ü©
#align inducing.is_closed_preimage Inducing.isClosed_preimage

/- warning: inducing.is_open_iff -> Inducing.isOpen_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ±}, Iff (IsOpen.{u1} Œ± _inst_1 s) (Exists.{succ u2} (Set.{u2} Œ≤) (fun (t : Set.{u2} Œ≤) => And (IsOpen.{u2} Œ≤ _inst_2 t) (Eq.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, u2} Œ± Œ≤ f t) s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ±}, Iff (IsOpen.{u2} Œ± _inst_1 s) (Exists.{succ u1} (Set.{u1} Œ≤) (fun (t : Set.{u1} Œ≤) => And (IsOpen.{u1} Œ≤ _inst_2 t) (Eq.{succ u2} (Set.{u2} Œ±) (Set.preimage.{u2, u1} Œ± Œ≤ f t) s))))
Case conversion may be inaccurate. Consider using '#align inducing.is_open_iff Inducing.isOpen_iff‚Çì'. -/
theorem Inducing.isOpen_iff {f : Œ± ‚Üí Œ≤} (hf : Inducing f) {s : Set Œ±} :
    IsOpen s ‚Üî ‚àÉ t, IsOpen t ‚àß f ‚Åª¬π' t = s := by rw [hf.induced, isOpen_induced_iff]
#align inducing.is_open_iff Inducing.isOpen_iff

/- warning: inducing.dense_iff -> Inducing.dense_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ±}, Iff (Dense.{u1} Œ± _inst_1 s) (forall (x : Œ±), Membership.Mem.{u2, u2} Œ≤ (Set.{u2} Œ≤) (Set.hasMem.{u2} Œ≤) (f x) (closure.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ±}, Iff (Dense.{u2} Œ± _inst_1 s) (forall (x : Œ±), Membership.mem.{u1, u1} Œ≤ (Set.{u1} Œ≤) (Set.instMembershipSet.{u1} Œ≤) (f x) (closure.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align inducing.dense_iff Inducing.dense_iff‚Çì'. -/
theorem Inducing.dense_iff {f : Œ± ‚Üí Œ≤} (hf : Inducing f) {s : Set Œ±} :
    Dense s ‚Üî ‚àÄ x, f x ‚àà closure (f '' s) := by
  simp only [Dense, hf.closure_eq_preimage_closure_image, mem_preimage]
#align inducing.dense_iff Inducing.dense_iff

end Inducing

section Embedding

#print Embedding /-
/-- A function between topological spaces is an embedding if it is injective,
  and for all `s : set Œ±`, `s` is open iff it is the preimage of an open set. -/
@[mk_iff]
structure Embedding [tŒ± : TopologicalSpace Œ±] [tŒ≤ : TopologicalSpace Œ≤] (f : Œ± ‚Üí Œ≤) extends
  Inducing f : Prop where
  inj : Injective f
#align embedding Embedding
-/

#print Function.Injective.embedding_induced /-
theorem Function.Injective.embedding_induced [t : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Injective f) : @Embedding Œ± Œ≤ (t.induced f) t f :=
  { induced := rfl
    inj := hf }
#align function.injective.embedding_induced Function.Injective.embedding_induced
-/

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥]

/- warning: embedding.mk' -> Embedding.mk' is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] (f : Œ± -> Œ≤), (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (forall (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ±) (Filter.comap.{u1, u2} Œ± Œ≤ f (nhds.{u2} Œ≤ _inst_2 (f a))) (nhds.{u1} Œ± _inst_1 a)) -> (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] (f : Œ± -> Œ≤), (Function.Injective.{succ u2, succ u1} Œ± Œ≤ f) -> (forall (a : Œ±), Eq.{succ u2} (Filter.{u2} Œ±) (Filter.comap.{u2, u1} Œ± Œ≤ f (nhds.{u1} Œ≤ _inst_2 (f a))) (nhds.{u2} Œ± _inst_1 a)) -> (Embedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align embedding.mk' Embedding.mk'‚Çì'. -/
theorem Embedding.mk' (f : Œ± ‚Üí Œ≤) (inj : Injective f) (induced : ‚àÄ a, comap f (ùìù (f a)) = ùìù a) :
    Embedding f :=
  ‚ü®inducing_iff_nhds.2 fun a => (induced a).symm, inj‚ü©
#align embedding.mk' Embedding.mk'

#print embedding_id /-
theorem embedding_id : Embedding (@id Œ±) :=
  ‚ü®inducing_id, fun a‚ÇÅ a‚ÇÇ h => h‚ü©
#align embedding_id embedding_id
-/

/- warning: embedding.comp -> Embedding.comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (Embedding.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Embedding.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (Embedding.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Embedding.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) -> (Embedding.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f))
Case conversion may be inaccurate. Consider using '#align embedding.comp Embedding.comp‚Çì'. -/
theorem Embedding.comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : Embedding g) (hf : Embedding f) :
    Embedding (g ‚àò f) :=
  { hg.to_inducing.comp hf.to_inducing with inj := fun a‚ÇÅ a‚ÇÇ h => hf.inj <| hg.inj h }
#align embedding.comp Embedding.comp

/- warning: embedding_of_embedding_compose -> embedding_of_embedding_compose is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Embedding.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)) -> (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u3}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Continuous.{u3, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Embedding.{u3, u1} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u3, succ u2, succ u1} Œ± Œ≤ Œ≥ g f)) -> (Embedding.{u3, u2} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align embedding_of_embedding_compose embedding_of_embedding_compose‚Çì'. -/
theorem embedding_of_embedding_compose {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hf : Continuous f)
    (hg : Continuous g) (hgf : Embedding (g ‚àò f)) : Embedding f :=
  { induced := (inducing_of_inducing_compose hf hg hgf.to_inducing).induced
    inj := fun a‚ÇÅ a‚ÇÇ h => hgf.inj <| by simp [h, (¬∑ ‚àò ¬∑)] }
#align embedding_of_embedding_compose embedding_of_embedding_compose

#print Function.LeftInverse.embedding /-
protected theorem Function.LeftInverse.embedding {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±} (h : LeftInverse f g)
    (hf : Continuous f) (hg : Continuous g) : Embedding g :=
  embedding_of_embedding_compose hg hf <| h.comp_eq_id.symm ‚ñ∏ embedding_id
#align function.left_inverse.embedding Function.LeftInverse.embedding
-/

/- warning: embedding.map_nhds_eq -> Embedding.map_nhds_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u2} (Filter.{u2} Œ≤) (Filter.map.{u1, u2} Œ± Œ≤ f (nhds.{u1} Œ± _inst_1 a)) (nhdsWithin.{u2} Œ≤ _inst_2 (f a) (Set.range.{u2, succ u1} Œ≤ Œ± f)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Embedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ≤) (Filter.map.{u2, u1} Œ± Œ≤ f (nhds.{u2} Œ± _inst_1 a)) (nhdsWithin.{u1} Œ≤ _inst_2 (f a) (Set.range.{u1, succ u2} Œ≤ Œ± f)))
Case conversion may be inaccurate. Consider using '#align embedding.map_nhds_eq Embedding.map_nhds_eq‚Çì'. -/
theorem Embedding.map_nhds_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (a : Œ±) :
    (ùìù a).map f = ùìù[range f] f a :=
  hf.1.map_nhds_eq a
#align embedding.map_nhds_eq Embedding.map_nhds_eq

/- warning: embedding.map_nhds_of_mem -> Embedding.map_nhds_of_mem is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) (Set.range.{u2, succ u1} Œ≤ Œ± f) (nhds.{u2} Œ≤ _inst_2 (f a))) -> (Eq.{succ u2} (Filter.{u2} Œ≤) (Filter.map.{u1, u2} Œ± Œ≤ f (nhds.{u1} Œ± _inst_1 a)) (nhds.{u2} Œ≤ _inst_2 (f a))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Embedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) (Set.range.{u1, succ u2} Œ≤ Œ± f) (nhds.{u1} Œ≤ _inst_2 (f a))) -> (Eq.{succ u1} (Filter.{u1} Œ≤) (Filter.map.{u2, u1} Œ± Œ≤ f (nhds.{u2} Œ± _inst_1 a)) (nhds.{u1} Œ≤ _inst_2 (f a))))
Case conversion may be inaccurate. Consider using '#align embedding.map_nhds_of_mem Embedding.map_nhds_of_mem‚Çì'. -/
theorem Embedding.map_nhds_of_mem {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (a : Œ±) (h : range f ‚àà ùìù (f a)) :
    (ùìù a).map f = ùìù (f a) :=
  hf.1.map_nhds_of_mem a h
#align embedding.map_nhds_of_mem Embedding.map_nhds_of_mem

/- warning: embedding.tendsto_nhds_iff -> Embedding.tendsto_nhds_iff is a dubious translation:
lean 3 declaration is
  forall {Œ≤ : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_2 : TopologicalSpace.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {Œπ : Type.{u3}} {f : Œπ -> Œ≤} {g : Œ≤ -> Œ≥} {a : Filter.{u3} Œπ} {b : Œ≤}, (Embedding.{u1, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Filter.Tendsto.{u3, u1} Œπ Œ≤ f a (nhds.{u1} Œ≤ _inst_2 b)) (Filter.Tendsto.{u3, u2} Œπ Œ≥ (Function.comp.{succ u3, succ u1, succ u2} Œπ Œ≤ Œ≥ g f) a (nhds.{u2} Œ≥ _inst_3 (g b))))
but is expected to have type
  forall {Œ≤ : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≥] {Œπ : Type.{u3}} {f : Œπ -> Œ≤} {g : Œ≤ -> Œ≥} {a : Filter.{u3} Œπ} {b : Œ≤}, (Embedding.{u2, u1} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Filter.Tendsto.{u3, u2} Œπ Œ≤ f a (nhds.{u2} Œ≤ _inst_2 b)) (Filter.Tendsto.{u3, u1} Œπ Œ≥ (Function.comp.{succ u3, succ u2, succ u1} Œπ Œ≤ Œ≥ g f) a (nhds.{u1} Œ≥ _inst_3 (g b))))
Case conversion may be inaccurate. Consider using '#align embedding.tendsto_nhds_iff Embedding.tendsto_nhds_iff‚Çì'. -/
theorem Embedding.tendsto_nhds_iff {Œπ : Type _} {f : Œπ ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} {a : Filter Œπ} {b : Œ≤}
    (hg : Embedding g) : Tendsto f a (ùìù b) ‚Üî Tendsto (g ‚àò f) a (ùìù (g b)) :=
  hg.to_inducing.tendsto_nhds_iff
#align embedding.tendsto_nhds_iff Embedding.tendsto_nhds_iff

/- warning: embedding.continuous_iff -> Embedding.continuous_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Embedding.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (Continuous.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ≥}, (Embedding.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Continuous.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) (Continuous.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f)))
Case conversion may be inaccurate. Consider using '#align embedding.continuous_iff Embedding.continuous_iff‚Çì'. -/
theorem Embedding.continuous_iff {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hg : Embedding g) :
    Continuous f ‚Üî Continuous (g ‚àò f) :=
  Inducing.continuous_iff hg.1
#align embedding.continuous_iff Embedding.continuous_iff

/- warning: embedding.continuous -> Embedding.continuous is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Embedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align embedding.continuous Embedding.continuous‚Çì'. -/
theorem Embedding.continuous {f : Œ± ‚Üí Œ≤} (hf : Embedding f) : Continuous f :=
  Inducing.continuous hf.1
#align embedding.continuous Embedding.continuous

/- warning: embedding.closure_eq_preimage_closure_image -> Embedding.closure_eq_preimage_closure_image is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {e : Œ± -> Œ≤}, (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 e) -> (forall (s : Set.{u1} Œ±), Eq.{succ u1} (Set.{u1} Œ±) (closure.{u1} Œ± _inst_1 s) (Set.preimage.{u1, u2} Œ± Œ≤ e (closure.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ e s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {e : Œ± -> Œ≤}, (Embedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 e) -> (forall (s : Set.{u2} Œ±), Eq.{succ u2} (Set.{u2} Œ±) (closure.{u2} Œ± _inst_1 s) (Set.preimage.{u2, u1} Œ± Œ≤ e (closure.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ e s))))
Case conversion may be inaccurate. Consider using '#align embedding.closure_eq_preimage_closure_image Embedding.closure_eq_preimage_closure_image‚Çì'. -/
theorem Embedding.closure_eq_preimage_closure_image {e : Œ± ‚Üí Œ≤} (he : Embedding e) (s : Set Œ±) :
    closure s = e ‚Åª¬π' closure (e '' s) :=
  he.1.closure_eq_preimage_closure_image s
#align embedding.closure_eq_preimage_closure_image Embedding.closure_eq_preimage_closure_image

/- warning: embedding.discrete_topology -> Embedding.discreteTopology is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} [_inst_4 : TopologicalSpace.{u1} X] [tY : TopologicalSpace.{u2} Y] [_inst_5 : DiscreteTopology.{u2} Y tY] {f : X -> Y}, (Embedding.{u1, u2} X Y _inst_4 tY f) -> (DiscreteTopology.{u1} X _inst_4)
but is expected to have type
  forall {X : Type.{u2}} {Y : Type.{u1}} [_inst_4 : TopologicalSpace.{u2} X] [tY : TopologicalSpace.{u1} Y] [_inst_5 : DiscreteTopology.{u1} Y tY] {f : X -> Y}, (Embedding.{u2, u1} X Y _inst_4 tY f) -> (DiscreteTopology.{u2} X _inst_4)
Case conversion may be inaccurate. Consider using '#align embedding.discrete_topology Embedding.discreteTopology‚Çì'. -/
/-- The topology induced under an inclusion `f : X ‚Üí Y` from the discrete topological space `Y`
is the discrete topology on `X`. -/
theorem Embedding.discreteTopology {X Y : Type _} [TopologicalSpace X] [tY : TopologicalSpace Y]
    [DiscreteTopology Y] {f : X ‚Üí Y} (hf : Embedding f) : DiscreteTopology X :=
  discreteTopology_iff_nhds.2 fun x => by
    rw [hf.nhds_eq_comap, nhds_discrete, comap_pure, ‚Üê image_singleton, hf.inj.preimage_image,
      principal_singleton]
#align embedding.discrete_topology Embedding.discreteTopology

end Embedding

#print QuotientMap /-
/-- A function between topological spaces is a quotient map if it is surjective,
  and for all `s : set Œ≤`, `s` is open iff its preimage is an open set. -/
def QuotientMap {Œ± : Type _} {Œ≤ : Type _} [tŒ± : TopologicalSpace Œ±] [tŒ≤ : TopologicalSpace Œ≤]
    (f : Œ± ‚Üí Œ≤) : Prop :=
  Surjective f ‚àß tŒ≤ = tŒ±.coinduced f
#align quotient_map QuotientMap
-/

/- warning: quotient_map_iff -> quotientMap_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, Iff (QuotientMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (And (Function.Surjective.{succ u1, succ u2} Œ± Œ≤ f) (forall (s : Set.{u2} Œ≤), Iff (IsOpen.{u2} Œ≤ _inst_2 s) (IsOpen.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, Iff (QuotientMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) (And (Function.Surjective.{succ u2, succ u1} Œ± Œ≤ f) (forall (s : Set.{u1} Œ≤), Iff (IsOpen.{u1} Œ≤ _inst_2 s) (IsOpen.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align quotient_map_iff quotientMap_iff‚Çì'. -/
theorem quotientMap_iff {Œ± Œ≤ : Type _} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} :
    QuotientMap f ‚Üî Surjective f ‚àß ‚àÄ s : Set Œ≤, IsOpen s ‚Üî IsOpen (f ‚Åª¬π' s) :=
  and_congr Iff.rfl topologicalSpace_eq_iff
#align quotient_map_iff quotientMap_iff

namespace QuotientMap

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥] [TopologicalSpace Œ¥]
  {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤}

#print QuotientMap.id /-
protected theorem id : QuotientMap (@id Œ±) :=
  ‚ü®fun a => ‚ü®a, rfl‚ü©, coinduced_id.symm‚ü©
#align quotient_map.id QuotientMap.id
-/

/- warning: quotient_map.comp -> QuotientMap.comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (QuotientMap.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (QuotientMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (QuotientMap.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (QuotientMap.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (QuotientMap.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) -> (QuotientMap.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f))
Case conversion may be inaccurate. Consider using '#align quotient_map.comp QuotientMap.comp‚Çì'. -/
protected theorem comp (hg : QuotientMap g) (hf : QuotientMap f) : QuotientMap (g ‚àò f) :=
  ‚ü®hg.left.comp hf.left, by rw [hg.right, hf.right, coinduced_compose]‚ü©
#align quotient_map.comp QuotientMap.comp

/- warning: quotient_map.of_quotient_map_compose -> QuotientMap.of_quotientMap_compose is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (QuotientMap.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)) -> (QuotientMap.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g)
but is expected to have type
  forall {Œ± : Type.{u3}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (Continuous.{u3, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (QuotientMap.{u3, u1} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u3, succ u2, succ u1} Œ± Œ≤ Œ≥ g f)) -> (QuotientMap.{u2, u1} Œ≤ Œ≥ _inst_2 _inst_3 g)
Case conversion may be inaccurate. Consider using '#align quotient_map.of_quotient_map_compose QuotientMap.of_quotientMap_compose‚Çì'. -/
protected theorem of_quotientMap_compose (hf : Continuous f) (hg : Continuous g)
    (hgf : QuotientMap (g ‚àò f)) : QuotientMap g :=
  ‚ü®hgf.1.of_comp,
    le_antisymm
      (by
        rw [hgf.right, ‚Üê continuous_iff_coinduced_le]
        apply continuous_coinduced_rng.comp hf)
      (by rwa [‚Üê continuous_iff_coinduced_le])‚ü©
#align quotient_map.of_quotient_map_compose QuotientMap.of_quotientMap_compose

/- warning: quotient_map.of_inverse -> QuotientMap.of_inverse is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ±}, (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ≤ Œ± _inst_2 _inst_1 g) -> (Function.LeftInverse.{succ u1, succ u2} Œ± Œ≤ g f) -> (QuotientMap.{u2, u1} Œ≤ Œ± _inst_2 _inst_1 g)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤} {g : Œ≤ -> Œ±}, (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u1, u2} Œ≤ Œ± _inst_2 _inst_1 g) -> (Function.LeftInverse.{succ u2, succ u1} Œ± Œ≤ g f) -> (QuotientMap.{u1, u2} Œ≤ Œ± _inst_2 _inst_1 g)
Case conversion may be inaccurate. Consider using '#align quotient_map.of_inverse QuotientMap.of_inverse‚Çì'. -/
theorem of_inverse {g : Œ≤ ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) (h : LeftInverse g f) :
    QuotientMap g :=
  QuotientMap.of_quotientMap_compose hf hg <| h.comp_eq_id.symm ‚ñ∏ QuotientMap.id
#align quotient_map.of_inverse QuotientMap.of_inverse

/- warning: quotient_map.continuous_iff -> QuotientMap.continuous_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (QuotientMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Iff (Continuous.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) (Continuous.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)))
but is expected to have type
  forall {Œ± : Type.{u3}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_1 : TopologicalSpace.{u3} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (QuotientMap.{u3, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Iff (Continuous.{u2, u1} Œ≤ Œ≥ _inst_2 _inst_3 g) (Continuous.{u3, u1} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u3, succ u2, succ u1} Œ± Œ≤ Œ≥ g f)))
Case conversion may be inaccurate. Consider using '#align quotient_map.continuous_iff QuotientMap.continuous_iff‚Çì'. -/
protected theorem continuous_iff (hf : QuotientMap f) : Continuous g ‚Üî Continuous (g ‚àò f) := by
  rw [continuous_iff_coinduced_le, continuous_iff_coinduced_le, hf.right, coinduced_compose]
#align quotient_map.continuous_iff QuotientMap.continuous_iff

/- warning: quotient_map.continuous -> QuotientMap.continuous is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (QuotientMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (QuotientMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align quotient_map.continuous QuotientMap.continuous‚Çì'. -/
protected theorem continuous (hf : QuotientMap f) : Continuous f :=
  hf.continuous_iff.mp continuous_id
#align quotient_map.continuous QuotientMap.continuous

/- warning: quotient_map.surjective -> QuotientMap.surjective is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (QuotientMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Function.Surjective.{succ u1, succ u2} Œ± Œ≤ f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (QuotientMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Function.Surjective.{succ u2, succ u1} Œ± Œ≤ f)
Case conversion may be inaccurate. Consider using '#align quotient_map.surjective QuotientMap.surjective‚Çì'. -/
protected theorem surjective (hf : QuotientMap f) : Surjective f :=
  hf.1
#align quotient_map.surjective QuotientMap.surjective

/- warning: quotient_map.is_open_preimage -> QuotientMap.isOpen_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (QuotientMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ≤}, Iff (IsOpen.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s)) (IsOpen.{u2} Œ≤ _inst_2 s))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (QuotientMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ≤}, Iff (IsOpen.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s)) (IsOpen.{u1} Œ≤ _inst_2 s))
Case conversion may be inaccurate. Consider using '#align quotient_map.is_open_preimage QuotientMap.isOpen_preimage‚Çì'. -/
protected theorem isOpen_preimage (hf : QuotientMap f) {s : Set Œ≤} : IsOpen (f ‚Åª¬π' s) ‚Üî IsOpen s :=
  ((quotientMap_iff.1 hf).2 s).symm
#align quotient_map.is_open_preimage QuotientMap.isOpen_preimage

/- warning: quotient_map.is_closed_preimage -> QuotientMap.isClosed_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (QuotientMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ≤}, Iff (IsClosed.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s)) (IsClosed.{u2} Œ≤ _inst_2 s))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (QuotientMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ≤}, Iff (IsClosed.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s)) (IsClosed.{u1} Œ≤ _inst_2 s))
Case conversion may be inaccurate. Consider using '#align quotient_map.is_closed_preimage QuotientMap.isClosed_preimage‚Çì'. -/
protected theorem isClosed_preimage (hf : QuotientMap f) {s : Set Œ≤} :
    IsClosed (f ‚Åª¬π' s) ‚Üî IsClosed s := by
  simp only [‚Üê isOpen_compl_iff, ‚Üê preimage_compl, hf.is_open_preimage]
#align quotient_map.is_closed_preimage QuotientMap.isClosed_preimage

end QuotientMap

#print IsOpenMap /-
/-- A map `f : Œ± ‚Üí Œ≤` is said to be an *open map*, if the image of any open `U : set Œ±`
is open in `Œ≤`. -/
def IsOpenMap [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (f : Œ± ‚Üí Œ≤) :=
  ‚àÄ U : Set Œ±, IsOpen U ‚Üí IsOpen (f '' U)
#align is_open_map IsOpenMap
-/

namespace IsOpenMap

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥] {f : Œ± ‚Üí Œ≤}

#print IsOpenMap.id /-
protected theorem id : IsOpenMap (@id Œ±) := fun s hs => by rwa [image_id]
#align is_open_map.id IsOpenMap.id
-/

/- warning: is_open_map.comp -> IsOpenMap.comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsOpenMap.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (IsOpenMap.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (IsOpenMap.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsOpenMap.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f))
Case conversion may be inaccurate. Consider using '#align is_open_map.comp IsOpenMap.comp‚Çì'. -/
protected theorem comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : IsOpenMap g) (hf : IsOpenMap f) :
    IsOpenMap (g ‚àò f) := by intro s hs <;> rw [image_comp] <;> exact hg _ (hf _ hs)
#align is_open_map.comp IsOpenMap.comp

/- warning: is_open_map.is_open_range -> IsOpenMap.isOpen_range is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsOpen.{u2} Œ≤ _inst_2 (Set.range.{u2, succ u1} Œ≤ Œ± f))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsOpen.{u1} Œ≤ _inst_2 (Set.range.{u1, succ u2} Œ≤ Œ± f))
Case conversion may be inaccurate. Consider using '#align is_open_map.is_open_range IsOpenMap.isOpen_range‚Çì'. -/
theorem isOpen_range (hf : IsOpenMap f) : IsOpen (range f) :=
  by
  rw [‚Üê image_univ]
  exact hf _ isOpen_univ
#align is_open_map.is_open_range IsOpenMap.isOpen_range

/- warning: is_open_map.image_mem_nhds -> IsOpenMap.image_mem_nhds is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {x : Œ±} {s : Set.{u1} Œ±}, (Membership.Mem.{u1, u1} (Set.{u1} Œ±) (Filter.{u1} Œ±) (Filter.hasMem.{u1} Œ±) s (nhds.{u1} Œ± _inst_1 x)) -> (Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) (Set.image.{u1, u2} Œ± Œ≤ f s) (nhds.{u2} Œ≤ _inst_2 (f x))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {x : Œ±} {s : Set.{u2} Œ±}, (Membership.mem.{u2, u2} (Set.{u2} Œ±) (Filter.{u2} Œ±) (instMembershipSetFilter.{u2} Œ±) s (nhds.{u2} Œ± _inst_1 x)) -> (Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) (Set.image.{u2, u1} Œ± Œ≤ f s) (nhds.{u1} Œ≤ _inst_2 (f x))))
Case conversion may be inaccurate. Consider using '#align is_open_map.image_mem_nhds IsOpenMap.image_mem_nhds‚Çì'. -/
theorem image_mem_nhds (hf : IsOpenMap f) {x : Œ±} {s : Set Œ±} (hx : s ‚àà ùìù x) : f '' s ‚àà ùìù (f x) :=
  let ‚ü®t, hts, ht, hxt‚ü© := mem_nhds_iff.1 hx
  mem_of_superset (IsOpen.mem_nhds (hf t ht) (mem_image_of_mem _ hxt)) (image_subset _ hts)
#align is_open_map.image_mem_nhds IsOpenMap.image_mem_nhds

/- warning: is_open_map.range_mem_nhds -> IsOpenMap.range_mem_nhds is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (x : Œ±), Membership.Mem.{u2, u2} (Set.{u2} Œ≤) (Filter.{u2} Œ≤) (Filter.hasMem.{u2} Œ≤) (Set.range.{u2, succ u1} Œ≤ Œ± f) (nhds.{u2} Œ≤ _inst_2 (f x)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (x : Œ±), Membership.mem.{u1, u1} (Set.{u1} Œ≤) (Filter.{u1} Œ≤) (instMembershipSetFilter.{u1} Œ≤) (Set.range.{u1, succ u2} Œ≤ Œ± f) (nhds.{u1} Œ≤ _inst_2 (f x)))
Case conversion may be inaccurate. Consider using '#align is_open_map.range_mem_nhds IsOpenMap.range_mem_nhds‚Çì'. -/
theorem range_mem_nhds (hf : IsOpenMap f) (x : Œ±) : range f ‚àà ùìù (f x) :=
  hf.isOpen_range.mem_nhds <| mem_range_self _
#align is_open_map.range_mem_nhds IsOpenMap.range_mem_nhds

/- warning: is_open_map.maps_to_interior -> IsOpenMap.mapsTo_interior is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ±} {t : Set.{u2} Œ≤}, (Set.MapsTo.{u1, u2} Œ± Œ≤ f s t) -> (Set.MapsTo.{u1, u2} Œ± Œ≤ f (interior.{u1} Œ± _inst_1 s) (interior.{u2} Œ≤ _inst_2 t)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ±} {t : Set.{u1} Œ≤}, (Set.MapsTo.{u2, u1} Œ± Œ≤ f s t) -> (Set.MapsTo.{u2, u1} Œ± Œ≤ f (interior.{u2} Œ± _inst_1 s) (interior.{u1} Œ≤ _inst_2 t)))
Case conversion may be inaccurate. Consider using '#align is_open_map.maps_to_interior IsOpenMap.mapsTo_interior‚Çì'. -/
theorem mapsTo_interior (hf : IsOpenMap f) {s : Set Œ±} {t : Set Œ≤} (h : MapsTo f s t) :
    MapsTo f (interior s) (interior t) :=
  mapsTo'.2 <|
    interior_maximal (h.mono interior_subset Subset.rfl).image_subset (hf _ isOpen_interior)
#align is_open_map.maps_to_interior IsOpenMap.mapsTo_interior

/- warning: is_open_map.image_interior_subset -> IsOpenMap.image_interior_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u1} Œ±), HasSubset.Subset.{u2} (Set.{u2} Œ≤) (Set.hasSubset.{u2} Œ≤) (Set.image.{u1, u2} Œ± Œ≤ f (interior.{u1} Œ± _inst_1 s)) (interior.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u2} Œ±), HasSubset.Subset.{u1} (Set.{u1} Œ≤) (Set.instHasSubsetSet.{u1} Œ≤) (Set.image.{u2, u1} Œ± Œ≤ f (interior.{u2} Œ± _inst_1 s)) (interior.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align is_open_map.image_interior_subset IsOpenMap.image_interior_subset‚Çì'. -/
theorem image_interior_subset (hf : IsOpenMap f) (s : Set Œ±) :
    f '' interior s ‚äÜ interior (f '' s) :=
  (hf.mapsTo_interior (mapsTo_image f s)).image_subset
#align is_open_map.image_interior_subset IsOpenMap.image_interior_subset

/- warning: is_open_map.nhds_le -> IsOpenMap.nhds_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (nhds.{u2} Œ≤ _inst_2 (f a)) (Filter.map.{u1, u2} Œ± Œ≤ f (nhds.{u1} Œ± _inst_1 a)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), LE.le.{u1} (Filter.{u1} Œ≤) (Preorder.toLE.{u1} (Filter.{u1} Œ≤) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ≤) (Filter.instPartialOrderFilter.{u1} Œ≤))) (nhds.{u1} Œ≤ _inst_2 (f a)) (Filter.map.{u2, u1} Œ± Œ≤ f (nhds.{u2} Œ± _inst_1 a)))
Case conversion may be inaccurate. Consider using '#align is_open_map.nhds_le IsOpenMap.nhds_le‚Çì'. -/
theorem nhds_le (hf : IsOpenMap f) (a : Œ±) : ùìù (f a) ‚â§ (ùìù a).map f :=
  le_map fun s => hf.image_mem_nhds
#align is_open_map.nhds_le IsOpenMap.nhds_le

/- warning: is_open_map.of_nhds_le -> IsOpenMap.of_nhds_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (forall (a : Œ±), LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (nhds.{u2} Œ≤ _inst_2 (f a)) (Filter.map.{u1, u2} Œ± Œ≤ f (nhds.{u1} Œ± _inst_1 a))) -> (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (forall (a : Œ±), LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.instPartialOrderFilter.{u2} Œ≤))) (nhds.{u2} Œ≤ _inst_2 (f a)) (Filter.map.{u1, u2} Œ± Œ≤ f (nhds.{u1} Œ± _inst_1 a))) -> (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align is_open_map.of_nhds_le IsOpenMap.of_nhds_le‚Çì'. -/
theorem of_nhds_le (hf : ‚àÄ a, ùìù (f a) ‚â§ map f (ùìù a)) : IsOpenMap f := fun s hs =>
  isOpen_iff_mem_nhds.2 fun b ‚ü®a, has, hab‚ü© => hab ‚ñ∏ hf _ (image_mem_map <| IsOpen.mem_nhds hs has)
#align is_open_map.of_nhds_le IsOpenMap.of_nhds_le

/- warning: is_open_map.of_sections -> IsOpenMap.of_sections is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (forall (x : Œ±), Exists.{max (succ u2) (succ u1)} (Œ≤ -> Œ±) (fun (g : Œ≤ -> Œ±) => And (ContinuousAt.{u2, u1} Œ≤ Œ± _inst_2 _inst_1 g (f x)) (And (Eq.{succ u1} Œ± (g (f x)) x) (Function.RightInverse.{succ u1, succ u2} Œ± Œ≤ g f)))) -> (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (forall (x : Œ±), Exists.{max (succ u2) (succ u1)} (Œ≤ -> Œ±) (fun (g : Œ≤ -> Œ±) => And (ContinuousAt.{u1, u2} Œ≤ Œ± _inst_2 _inst_1 g (f x)) (And (Eq.{succ u2} Œ± (g (f x)) x) (Function.RightInverse.{succ u2, succ u1} Œ± Œ≤ g f)))) -> (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align is_open_map.of_sections IsOpenMap.of_sections‚Çì'. -/
theorem of_sections {f : Œ± ‚Üí Œ≤}
    (h : ‚àÄ x, ‚àÉ g : Œ≤ ‚Üí Œ±, ContinuousAt g (f x) ‚àß g (f x) = x ‚àß RightInverse g f) : IsOpenMap f :=
  of_nhds_le fun x =>
    let ‚ü®g, hgc, hgx, hgf‚ü© := h x
    calc
      ùìù (f x) = map f (map g (ùìù (f x))) := by rw [map_map, hgf.comp_eq_id, map_id]
      _ ‚â§ map f (ùìù (g (f x))) := map_mono hgc
      _ = map f (ùìù x) := by rw [hgx]
      
#align is_open_map.of_sections IsOpenMap.of_sections

#print IsOpenMap.of_inverse /-
theorem of_inverse {f : Œ± ‚Üí Œ≤} {f' : Œ≤ ‚Üí Œ±} (h : Continuous f') (l_inv : LeftInverse f f')
    (r_inv : RightInverse f f') : IsOpenMap f :=
  of_sections fun x => ‚ü®f', h.ContinuousAt, r_inv _, l_inv‚ü©
#align is_open_map.of_inverse IsOpenMap.of_inverse
-/

/- warning: is_open_map.to_quotient_map -> IsOpenMap.to_quotientMap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Function.Surjective.{succ u1, succ u2} Œ± Œ≤ f) -> (QuotientMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Function.Surjective.{succ u2, succ u1} Œ± Œ≤ f) -> (QuotientMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align is_open_map.to_quotient_map IsOpenMap.to_quotientMap‚Çì'. -/
/-- A continuous surjective open map is a quotient map. -/
theorem to_quotientMap {f : Œ± ‚Üí Œ≤} (open_map : IsOpenMap f) (cont : Continuous f)
    (surj : Surjective f) : QuotientMap f :=
  quotientMap_iff.2
    ‚ü®surj, fun s => ‚ü®fun h => h.Preimage cont, fun h => surj.image_preimage s ‚ñ∏ open_map _ h‚ü©‚ü©
#align is_open_map.to_quotient_map IsOpenMap.to_quotientMap

/- warning: is_open_map.interior_preimage_subset_preimage_interior -> IsOpenMap.interior_preimage_subset_preimage_interior is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ≤}, HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (interior.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s)) (Set.preimage.{u1, u2} Œ± Œ≤ f (interior.{u2} Œ≤ _inst_2 s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ≤}, HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (interior.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s)) (Set.preimage.{u2, u1} Œ± Œ≤ f (interior.{u1} Œ≤ _inst_2 s)))
Case conversion may be inaccurate. Consider using '#align is_open_map.interior_preimage_subset_preimage_interior IsOpenMap.interior_preimage_subset_preimage_interior‚Çì'. -/
theorem interior_preimage_subset_preimage_interior (hf : IsOpenMap f) {s : Set Œ≤} :
    interior (f ‚Åª¬π' s) ‚äÜ f ‚Åª¬π' interior s :=
  hf.mapsTo_interior (mapsTo_preimage _ _)
#align is_open_map.interior_preimage_subset_preimage_interior IsOpenMap.interior_preimage_subset_preimage_interior

/- warning: is_open_map.preimage_interior_eq_interior_preimage -> IsOpenMap.preimage_interior_eq_interior_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u2} Œ≤), Eq.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, u2} Œ± Œ≤ f (interior.{u2} Œ≤ _inst_2 s)) (interior.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u1} Œ≤), Eq.{succ u2} (Set.{u2} Œ±) (Set.preimage.{u2, u1} Œ± Œ≤ f (interior.{u1} Œ≤ _inst_2 s)) (interior.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align is_open_map.preimage_interior_eq_interior_preimage IsOpenMap.preimage_interior_eq_interior_preimage‚Çì'. -/
theorem preimage_interior_eq_interior_preimage (hf‚ÇÅ : IsOpenMap f) (hf‚ÇÇ : Continuous f)
    (s : Set Œ≤) : f ‚Åª¬π' interior s = interior (f ‚Åª¬π' s) :=
  Subset.antisymm (preimage_interior_subset_interior_preimage hf‚ÇÇ)
    (interior_preimage_subset_preimage_interior hf‚ÇÅ)
#align is_open_map.preimage_interior_eq_interior_preimage IsOpenMap.preimage_interior_eq_interior_preimage

/- warning: is_open_map.preimage_closure_subset_closure_preimage -> IsOpenMap.preimage_closure_subset_closure_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ≤}, HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.preimage.{u1, u2} Œ± Œ≤ f (closure.{u2} Œ≤ _inst_2 s)) (closure.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ≤}, HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (Set.preimage.{u2, u1} Œ± Œ≤ f (closure.{u1} Œ≤ _inst_2 s)) (closure.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align is_open_map.preimage_closure_subset_closure_preimage IsOpenMap.preimage_closure_subset_closure_preimage‚Çì'. -/
theorem preimage_closure_subset_closure_preimage (hf : IsOpenMap f) {s : Set Œ≤} :
    f ‚Åª¬π' closure s ‚äÜ closure (f ‚Åª¬π' s) :=
  by
  rw [‚Üê compl_subset_compl]
  simp only [‚Üê interior_compl, ‚Üê preimage_compl, hf.interior_preimage_subset_preimage_interior]
#align is_open_map.preimage_closure_subset_closure_preimage IsOpenMap.preimage_closure_subset_closure_preimage

/- warning: is_open_map.preimage_closure_eq_closure_preimage -> IsOpenMap.preimage_closure_eq_closure_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u2} Œ≤), Eq.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, u2} Œ± Œ≤ f (closure.{u2} Œ≤ _inst_2 s)) (closure.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u1} Œ≤), Eq.{succ u2} (Set.{u2} Œ±) (Set.preimage.{u2, u1} Œ± Œ≤ f (closure.{u1} Œ≤ _inst_2 s)) (closure.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align is_open_map.preimage_closure_eq_closure_preimage IsOpenMap.preimage_closure_eq_closure_preimage‚Çì'. -/
theorem preimage_closure_eq_closure_preimage (hf : IsOpenMap f) (hfc : Continuous f) (s : Set Œ≤) :
    f ‚Åª¬π' closure s = closure (f ‚Åª¬π' s) :=
  hf.preimage_closure_subset_closure_preimage.antisymm (hfc.closure_preimage_subset s)
#align is_open_map.preimage_closure_eq_closure_preimage IsOpenMap.preimage_closure_eq_closure_preimage

/- warning: is_open_map.preimage_frontier_subset_frontier_preimage -> IsOpenMap.preimage_frontier_subset_frontier_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ≤}, HasSubset.Subset.{u1} (Set.{u1} Œ±) (Set.hasSubset.{u1} Œ±) (Set.preimage.{u1, u2} Œ± Œ≤ f (frontier.{u2} Œ≤ _inst_2 s)) (frontier.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ≤}, HasSubset.Subset.{u2} (Set.{u2} Œ±) (Set.instHasSubsetSet.{u2} Œ±) (Set.preimage.{u2, u1} Œ± Œ≤ f (frontier.{u1} Œ≤ _inst_2 s)) (frontier.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align is_open_map.preimage_frontier_subset_frontier_preimage IsOpenMap.preimage_frontier_subset_frontier_preimage‚Çì'. -/
theorem preimage_frontier_subset_frontier_preimage (hf : IsOpenMap f) {s : Set Œ≤} :
    f ‚Åª¬π' frontier s ‚äÜ frontier (f ‚Åª¬π' s) := by
  simpa only [frontier_eq_closure_inter_closure, preimage_inter] using
    inter_subset_inter hf.preimage_closure_subset_closure_preimage
      hf.preimage_closure_subset_closure_preimage
#align is_open_map.preimage_frontier_subset_frontier_preimage IsOpenMap.preimage_frontier_subset_frontier_preimage

/- warning: is_open_map.preimage_frontier_eq_frontier_preimage -> IsOpenMap.preimage_frontier_eq_frontier_preimage is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u2} Œ≤), Eq.{succ u1} (Set.{u1} Œ±) (Set.preimage.{u1, u2} Œ± Œ≤ f (frontier.{u2} Œ≤ _inst_2 s)) (frontier.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u1} Œ≤), Eq.{succ u2} (Set.{u2} Œ±) (Set.preimage.{u2, u1} Œ± Œ≤ f (frontier.{u1} Œ≤ _inst_2 s)) (frontier.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align is_open_map.preimage_frontier_eq_frontier_preimage IsOpenMap.preimage_frontier_eq_frontier_preimage‚Çì'. -/
theorem preimage_frontier_eq_frontier_preimage (hf : IsOpenMap f) (hfc : Continuous f) (s : Set Œ≤) :
    f ‚Åª¬π' frontier s = frontier (f ‚Åª¬π' s) := by
  simp only [frontier_eq_closure_inter_closure, preimage_inter, preimage_compl,
    hf.preimage_closure_eq_closure_preimage hfc]
#align is_open_map.preimage_frontier_eq_frontier_preimage IsOpenMap.preimage_frontier_eq_frontier_preimage

end IsOpenMap

/- warning: is_open_map_iff_nhds_le -> isOpenMap_iff_nhds_le is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, Iff (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (forall (a : Œ±), LE.le.{u2} (Filter.{u2} Œ≤) (Preorder.toLE.{u2} (Filter.{u2} Œ≤) (PartialOrder.toPreorder.{u2} (Filter.{u2} Œ≤) (Filter.partialOrder.{u2} Œ≤))) (nhds.{u2} Œ≤ _inst_2 (f a)) (Filter.map.{u1, u2} Œ± Œ≤ f (nhds.{u1} Œ± _inst_1 a)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, Iff (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) (forall (a : Œ±), LE.le.{u1} (Filter.{u1} Œ≤) (Preorder.toLE.{u1} (Filter.{u1} Œ≤) (PartialOrder.toPreorder.{u1} (Filter.{u1} Œ≤) (Filter.instPartialOrderFilter.{u1} Œ≤))) (nhds.{u1} Œ≤ _inst_2 (f a)) (Filter.map.{u2, u1} Œ± Œ≤ f (nhds.{u2} Œ± _inst_1 a)))
Case conversion may be inaccurate. Consider using '#align is_open_map_iff_nhds_le isOpenMap_iff_nhds_le‚Çì'. -/
theorem isOpenMap_iff_nhds_le [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} :
    IsOpenMap f ‚Üî ‚àÄ a : Œ±, ùìù (f a) ‚â§ (ùìù a).map f :=
  ‚ü®fun hf => hf.nhds_le, IsOpenMap.of_nhds_le‚ü©
#align is_open_map_iff_nhds_le isOpenMap_iff_nhds_le

/- warning: is_open_map_iff_interior -> isOpenMap_iff_interior is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, Iff (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (forall (s : Set.{u1} Œ±), HasSubset.Subset.{u2} (Set.{u2} Œ≤) (Set.hasSubset.{u2} Œ≤) (Set.image.{u1, u2} Œ± Œ≤ f (interior.{u1} Œ± _inst_1 s)) (interior.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, Iff (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) (forall (s : Set.{u2} Œ±), HasSubset.Subset.{u1} (Set.{u1} Œ≤) (Set.instHasSubsetSet.{u1} Œ≤) (Set.image.{u2, u1} Œ± Œ≤ f (interior.{u2} Œ± _inst_1 s)) (interior.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align is_open_map_iff_interior isOpenMap_iff_interior‚Çì'. -/
theorem isOpenMap_iff_interior [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} :
    IsOpenMap f ‚Üî ‚àÄ s, f '' interior s ‚äÜ interior (f '' s) :=
  ‚ü®IsOpenMap.image_interior_subset, fun hs u hu =>
    subset_interior_iff_isOpen.mp <|
      calc
        f '' u = f '' interior u := by rw [hu.interior_eq]
        _ ‚äÜ interior (f '' u) := hs u
        ‚ü©
#align is_open_map_iff_interior isOpenMap_iff_interior

/- warning: inducing.is_open_map -> Inducing.isOpenMap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsOpen.{u2} Œ≤ _inst_2 (Set.range.{u2, succ u1} Œ≤ Œ± f)) -> (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsOpen.{u1} Œ≤ _inst_2 (Set.range.{u1, succ u2} Œ≤ Œ± f)) -> (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align inducing.is_open_map Inducing.isOpenMap‚Çì'. -/
/-- An inducing map with an open range is an open map. -/
protected theorem Inducing.isOpenMap [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤}
    (hi : Inducing f) (ho : IsOpen (range f)) : IsOpenMap f :=
  IsOpenMap.of_nhds_le fun x => (hi.map_nhds_of_mem _ <| IsOpen.mem_nhds ho <| mem_range_self _).ge
#align inducing.is_open_map Inducing.isOpenMap

section IsClosedMap

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤]

#print IsClosedMap /-
/-- A map `f : Œ± ‚Üí Œ≤` is said to be a *closed map*, if the image of any closed `U : set Œ±`
is closed in `Œ≤`. -/
def IsClosedMap (f : Œ± ‚Üí Œ≤) :=
  ‚àÄ U : Set Œ±, IsClosed U ‚Üí IsClosed (f '' U)
#align is_closed_map IsClosedMap
-/

end IsClosedMap

namespace IsClosedMap

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥]

open Function

#print IsClosedMap.id /-
protected theorem id : IsClosedMap (@id Œ±) := fun s hs => by rwa [image_id]
#align is_closed_map.id IsClosedMap.id
-/

/- warning: is_closed_map.comp -> IsClosedMap.comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (IsClosedMap.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (IsClosedMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsClosedMap.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (IsClosedMap.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (IsClosedMap.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsClosedMap.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f))
Case conversion may be inaccurate. Consider using '#align is_closed_map.comp IsClosedMap.comp‚Çì'. -/
protected theorem comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : IsClosedMap g) (hf : IsClosedMap f) :
    IsClosedMap (g ‚àò f) := by
  intro s hs
  rw [image_comp]
  exact hg _ (hf _ hs)
#align is_closed_map.comp IsClosedMap.comp

/- warning: is_closed_map.closure_image_subset -> IsClosedMap.closure_image_subset is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsClosedMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u1} Œ±), HasSubset.Subset.{u2} (Set.{u2} Œ≤) (Set.hasSubset.{u2} Œ≤) (closure.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s)) (Set.image.{u1, u2} Œ± Œ≤ f (closure.{u1} Œ± _inst_1 s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsClosedMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u2} Œ±), HasSubset.Subset.{u1} (Set.{u1} Œ≤) (Set.instHasSubsetSet.{u1} Œ≤) (closure.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s)) (Set.image.{u2, u1} Œ± Œ≤ f (closure.{u2} Œ± _inst_1 s)))
Case conversion may be inaccurate. Consider using '#align is_closed_map.closure_image_subset IsClosedMap.closure_image_subset‚Çì'. -/
theorem closure_image_subset {f : Œ± ‚Üí Œ≤} (hf : IsClosedMap f) (s : Set Œ±) :
    closure (f '' s) ‚äÜ f '' closure s :=
  closure_minimal (image_subset _ subset_closure) (hf _ isClosed_closure)
#align is_closed_map.closure_image_subset IsClosedMap.closure_image_subset

#print IsClosedMap.of_inverse /-
theorem of_inverse {f : Œ± ‚Üí Œ≤} {f' : Œ≤ ‚Üí Œ±} (h : Continuous f') (l_inv : LeftInverse f f')
    (r_inv : RightInverse f f') : IsClosedMap f := fun s hs =>
  have : f' ‚Åª¬π' s = f '' s := by ext x <;> simp [mem_image_iff_of_inverse r_inv l_inv]
  this ‚ñ∏ hs.Preimage h
#align is_closed_map.of_inverse IsClosedMap.of_inverse
-/

/- warning: is_closed_map.of_nonempty -> IsClosedMap.of_nonempty is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (forall (s : Set.{u1} Œ±), (IsClosed.{u1} Œ± _inst_1 s) -> (Set.Nonempty.{u1} Œ± s) -> (IsClosed.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s))) -> (IsClosedMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (forall (s : Set.{u2} Œ±), (IsClosed.{u2} Œ± _inst_1 s) -> (Set.Nonempty.{u2} Œ± s) -> (IsClosed.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s))) -> (IsClosedMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align is_closed_map.of_nonempty IsClosedMap.of_nonempty‚Çì'. -/
theorem of_nonempty {f : Œ± ‚Üí Œ≤} (h : ‚àÄ s, IsClosed s ‚Üí s.Nonempty ‚Üí IsClosed (f '' s)) :
    IsClosedMap f := by
  intro s hs; cases' eq_empty_or_nonempty s with h2s h2s
  ¬∑ simp_rw [h2s, image_empty, isClosed_empty]
  ¬∑ exact h s hs h2s
#align is_closed_map.of_nonempty IsClosedMap.of_nonempty

/- warning: is_closed_map.closed_range -> IsClosedMap.closed_range is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (IsClosedMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsClosed.{u2} Œ≤ _inst_2 (Set.range.{u2, succ u1} Œ≤ Œ± f))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (IsClosedMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsClosed.{u1} Œ≤ _inst_2 (Set.range.{u1, succ u2} Œ≤ Œ± f))
Case conversion may be inaccurate. Consider using '#align is_closed_map.closed_range IsClosedMap.closed_range‚Çì'. -/
theorem closed_range {f : Œ± ‚Üí Œ≤} (hf : IsClosedMap f) : IsClosed (range f) :=
  @image_univ _ _ f ‚ñ∏ hf _ isClosed_univ
#align is_closed_map.closed_range IsClosedMap.closed_range

end IsClosedMap

/- warning: inducing.is_closed_map -> Inducing.isClosedMap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsClosed.{u2} Œ≤ _inst_2 (Set.range.{u2, succ u1} Œ≤ Œ± f)) -> (IsClosedMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Inducing.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsClosed.{u1} Œ≤ _inst_2 (Set.range.{u1, succ u2} Œ≤ Œ± f)) -> (IsClosedMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align inducing.is_closed_map Inducing.isClosedMap‚Çì'. -/
theorem Inducing.isClosedMap [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Inducing f)
    (h : IsClosed (range f)) : IsClosedMap f :=
  by
  intro s hs
  rcases hf.is_closed_iff.1 hs with ‚ü®t, ht, rfl‚ü©
  rw [image_preimage_eq_inter_range]
  exact ht.inter h
#align inducing.is_closed_map Inducing.isClosedMap

/- warning: is_closed_map_iff_closure_image -> isClosedMap_iff_closure_image is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, Iff (IsClosedMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (forall (s : Set.{u1} Œ±), HasSubset.Subset.{u2} (Set.{u2} Œ≤) (Set.hasSubset.{u2} Œ≤) (closure.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s)) (Set.image.{u1, u2} Œ± Œ≤ f (closure.{u1} Œ± _inst_1 s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, Iff (IsClosedMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) (forall (s : Set.{u2} Œ±), HasSubset.Subset.{u1} (Set.{u1} Œ≤) (Set.instHasSubsetSet.{u1} Œ≤) (closure.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s)) (Set.image.{u2, u1} Œ± Œ≤ f (closure.{u2} Œ± _inst_1 s)))
Case conversion may be inaccurate. Consider using '#align is_closed_map_iff_closure_image isClosedMap_iff_closure_image‚Çì'. -/
theorem isClosedMap_iff_closure_image [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
        _ = f '' c := by rw [hc.closure_eq]
        ‚ü©
#align is_closed_map_iff_closure_image isClosedMap_iff_closure_image

section OpenEmbedding

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥]

#print OpenEmbedding /-
/-- An open embedding is an embedding with open image. -/
@[mk_iff]
structure OpenEmbedding (f : Œ± ‚Üí Œ≤) extends Embedding f : Prop where
  open_range : IsOpen <| range f
#align open_embedding OpenEmbedding
-/

/- warning: open_embedding.is_open_map -> OpenEmbedding.isOpenMap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (OpenEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align open_embedding.is_open_map OpenEmbedding.isOpenMap‚Çì'. -/
theorem OpenEmbedding.isOpenMap {f : Œ± ‚Üí Œ≤} (hf : OpenEmbedding f) : IsOpenMap f :=
  hf.toEmbedding.to_inducing.IsOpenMap hf.open_range
#align open_embedding.is_open_map OpenEmbedding.isOpenMap

/- warning: open_embedding.map_nhds_eq -> OpenEmbedding.map_nhds_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u2} (Filter.{u2} Œ≤) (Filter.map.{u1, u2} Œ± Œ≤ f (nhds.{u1} Œ± _inst_1 a)) (nhds.{u2} Œ≤ _inst_2 (f a)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (OpenEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (a : Œ±), Eq.{succ u1} (Filter.{u1} Œ≤) (Filter.map.{u2, u1} Œ± Œ≤ f (nhds.{u2} Œ± _inst_1 a)) (nhds.{u1} Œ≤ _inst_2 (f a)))
Case conversion may be inaccurate. Consider using '#align open_embedding.map_nhds_eq OpenEmbedding.map_nhds_eq‚Çì'. -/
theorem OpenEmbedding.map_nhds_eq {f : Œ± ‚Üí Œ≤} (hf : OpenEmbedding f) (a : Œ±) :
    map f (ùìù a) = ùìù (f a) :=
  hf.toEmbedding.map_nhds_of_mem _ <| hf.open_range.mem_nhds <| mem_range_self _
#align open_embedding.map_nhds_eq OpenEmbedding.map_nhds_eq

/- warning: open_embedding.open_iff_image_open -> OpenEmbedding.open_iff_image_open is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ±}, Iff (IsOpen.{u1} Œ± _inst_1 s) (IsOpen.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (OpenEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ±}, Iff (IsOpen.{u2} Œ± _inst_1 s) (IsOpen.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align open_embedding.open_iff_image_open OpenEmbedding.open_iff_image_open‚Çì'. -/
theorem OpenEmbedding.open_iff_image_open {f : Œ± ‚Üí Œ≤} (hf : OpenEmbedding f) {s : Set Œ±} :
    IsOpen s ‚Üî IsOpen (f '' s) :=
  ‚ü®hf.IsOpenMap s, fun h =>
    by
    convert ‚Üê h.preimage hf.to_embedding.continuous
    apply preimage_image_eq _ hf.inj‚ü©
#align open_embedding.open_iff_image_open OpenEmbedding.open_iff_image_open

/- warning: open_embedding.tendsto_nhds_iff -> OpenEmbedding.tendsto_nhds_iff is a dubious translation:
lean 3 declaration is
  forall {Œ≤ : Type.{u1}} {Œ≥ : Type.{u2}} [_inst_2 : TopologicalSpace.{u1} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {Œπ : Type.{u3}} {f : Œπ -> Œ≤} {g : Œ≤ -> Œ≥} {a : Filter.{u3} Œπ} {b : Œ≤}, (OpenEmbedding.{u1, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Filter.Tendsto.{u3, u1} Œπ Œ≤ f a (nhds.{u1} Œ≤ _inst_2 b)) (Filter.Tendsto.{u3, u2} Œπ Œ≥ (Function.comp.{succ u3, succ u1, succ u2} Œπ Œ≤ Œ≥ g f) a (nhds.{u2} Œ≥ _inst_3 (g b))))
but is expected to have type
  forall {Œ≤ : Type.{u2}} {Œ≥ : Type.{u1}} [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u1} Œ≥] {Œπ : Type.{u3}} {f : Œπ -> Œ≤} {g : Œ≤ -> Œ≥} {a : Filter.{u3} Œπ} {b : Œ≤}, (OpenEmbedding.{u2, u1} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (Filter.Tendsto.{u3, u2} Œπ Œ≤ f a (nhds.{u2} Œ≤ _inst_2 b)) (Filter.Tendsto.{u3, u1} Œπ Œ≥ (Function.comp.{succ u3, succ u2, succ u1} Œπ Œ≤ Œ≥ g f) a (nhds.{u1} Œ≥ _inst_3 (g b))))
Case conversion may be inaccurate. Consider using '#align open_embedding.tendsto_nhds_iff OpenEmbedding.tendsto_nhds_iff‚Çì'. -/
theorem OpenEmbedding.tendsto_nhds_iff {Œπ : Type _} {f : Œπ ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} {a : Filter Œπ} {b : Œ≤}
    (hg : OpenEmbedding g) : Tendsto f a (ùìù b) ‚Üî Tendsto (g ‚àò f) a (ùìù (g b)) :=
  hg.toEmbedding.tendsto_nhds_iff
#align open_embedding.tendsto_nhds_iff OpenEmbedding.tendsto_nhds_iff

/- warning: open_embedding.continuous -> OpenEmbedding.continuous is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (OpenEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align open_embedding.continuous OpenEmbedding.continuous‚Çì'. -/
theorem OpenEmbedding.continuous {f : Œ± ‚Üí Œ≤} (hf : OpenEmbedding f) : Continuous f :=
  hf.toEmbedding.Continuous
#align open_embedding.continuous OpenEmbedding.continuous

/- warning: open_embedding.open_iff_preimage_open -> OpenEmbedding.open_iff_preimage_open is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ≤}, (HasSubset.Subset.{u2} (Set.{u2} Œ≤) (Set.hasSubset.{u2} Œ≤) s (Set.range.{u2, succ u1} Œ≤ Œ± f)) -> (Iff (IsOpen.{u2} Œ≤ _inst_2 s) (IsOpen.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (OpenEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ≤}, (HasSubset.Subset.{u1} (Set.{u1} Œ≤) (Set.instHasSubsetSet.{u1} Œ≤) s (Set.range.{u1, succ u2} Œ≤ Œ± f)) -> (Iff (IsOpen.{u1} Œ≤ _inst_2 s) (IsOpen.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align open_embedding.open_iff_preimage_open OpenEmbedding.open_iff_preimage_open‚Çì'. -/
theorem OpenEmbedding.open_iff_preimage_open {f : Œ± ‚Üí Œ≤} (hf : OpenEmbedding f) {s : Set Œ≤}
    (hs : s ‚äÜ range f) : IsOpen s ‚Üî IsOpen (f ‚Åª¬π' s) :=
  by
  convert ‚Üê hf.open_iff_image_open.symm
  rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]
#align open_embedding.open_iff_preimage_open OpenEmbedding.open_iff_preimage_open

/- warning: open_embedding_of_embedding_open -> openEmbedding_of_embedding_open is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Embedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (OpenEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align open_embedding_of_embedding_open openEmbedding_of_embedding_open‚Çì'. -/
theorem openEmbedding_of_embedding_open {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : Embedding f) (h‚ÇÇ : IsOpenMap f) :
    OpenEmbedding f :=
  ‚ü®h‚ÇÅ, h‚ÇÇ.isOpen_range‚ü©
#align open_embedding_of_embedding_open openEmbedding_of_embedding_open

/- warning: open_embedding_iff_embedding_open -> openEmbedding_iff_embedding_open is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, Iff (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (And (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, Iff (OpenEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) (And (Embedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align open_embedding_iff_embedding_open openEmbedding_iff_embedding_open‚Çì'. -/
theorem openEmbedding_iff_embedding_open {f : Œ± ‚Üí Œ≤} :
    OpenEmbedding f ‚Üî Embedding f ‚àß IsOpenMap f :=
  ‚ü®fun h => ‚ü®h.1, h.IsOpenMap‚ü©, fun h => openEmbedding_of_embedding_open h.1 h.2‚ü©
#align open_embedding_iff_embedding_open openEmbedding_iff_embedding_open

/- warning: open_embedding_of_continuous_injective_open -> openEmbedding_of_continuous_injective_open is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Function.Injective.{succ u2, succ u1} Œ± Œ≤ f) -> (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (OpenEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align open_embedding_of_continuous_injective_open openEmbedding_of_continuous_injective_open‚Çì'. -/
theorem openEmbedding_of_continuous_injective_open {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : Continuous f)
    (h‚ÇÇ : Injective f) (h‚ÇÉ : IsOpenMap f) : OpenEmbedding f :=
  by
  simp only [openEmbedding_iff_embedding_open, embedding_iff, inducing_iff_nhds, *, and_true_iff]
  exact fun a =>
    le_antisymm (h‚ÇÅ.tendsto _).le_comap (@comap_map _ _ (ùìù a) _ h‚ÇÇ ‚ñ∏ comap_mono (h‚ÇÉ.nhds_le _))
#align open_embedding_of_continuous_injective_open openEmbedding_of_continuous_injective_open

/- warning: open_embedding_iff_continuous_injective_open -> openEmbedding_iff_continuous_injective_open is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, Iff (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (And (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (And (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, Iff (OpenEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) (And (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) (And (Function.Injective.{succ u2, succ u1} Œ± Œ≤ f) (IsOpenMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)))
Case conversion may be inaccurate. Consider using '#align open_embedding_iff_continuous_injective_open openEmbedding_iff_continuous_injective_open‚Çì'. -/
theorem openEmbedding_iff_continuous_injective_open {f : Œ± ‚Üí Œ≤} :
    OpenEmbedding f ‚Üî Continuous f ‚àß Injective f ‚àß IsOpenMap f :=
  ‚ü®fun h => ‚ü®h.Continuous, h.inj, h.IsOpenMap‚ü©, fun h =>
    openEmbedding_of_continuous_injective_open h.1 h.2.1 h.2.2‚ü©
#align open_embedding_iff_continuous_injective_open openEmbedding_iff_continuous_injective_open

#print openEmbedding_id /-
theorem openEmbedding_id : OpenEmbedding (@id Œ±) :=
  ‚ü®embedding_id, IsOpenMap.id.isOpen_range‚ü©
#align open_embedding_id openEmbedding_id
-/

/- warning: open_embedding.comp -> OpenEmbedding.comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (OpenEmbedding.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (OpenEmbedding.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (OpenEmbedding.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (OpenEmbedding.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) -> (OpenEmbedding.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f))
Case conversion may be inaccurate. Consider using '#align open_embedding.comp OpenEmbedding.comp‚Çì'. -/
theorem OpenEmbedding.comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : OpenEmbedding g) (hf : OpenEmbedding f) :
    OpenEmbedding (g ‚àò f) :=
  ‚ü®hg.1.comp hf.1, (hg.IsOpenMap.comp hf.IsOpenMap).isOpen_range‚ü©
#align open_embedding.comp OpenEmbedding.comp

/- warning: open_embedding.is_open_map_iff -> OpenEmbedding.isOpenMap_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (OpenEmbedding.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (IsOpenMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) (IsOpenMap.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (OpenEmbedding.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (IsOpenMap.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) (IsOpenMap.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f)))
Case conversion may be inaccurate. Consider using '#align open_embedding.is_open_map_iff OpenEmbedding.isOpenMap_iff‚Çì'. -/
theorem OpenEmbedding.isOpenMap_iff {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : OpenEmbedding g) :
    IsOpenMap f ‚Üî IsOpenMap (g ‚àò f) := by
  simp only [isOpenMap_iff_nhds_le, ‚Üê @map_map _ _ _ _ f g, ‚Üê hg.map_nhds_eq, map_le_map_iff hg.inj]
#align open_embedding.is_open_map_iff OpenEmbedding.isOpenMap_iff

/- warning: open_embedding.of_comp_iff -> OpenEmbedding.of_comp_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] (f : Œ± -> Œ≤) {g : Œ≤ -> Œ≥}, (OpenEmbedding.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (OpenEmbedding.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)) (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] (f : Œ± -> Œ≤) {g : Œ≤ -> Œ≥}, (OpenEmbedding.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (Iff (OpenEmbedding.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f)) (OpenEmbedding.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f))
Case conversion may be inaccurate. Consider using '#align open_embedding.of_comp_iff OpenEmbedding.of_comp_iff‚Çì'. -/
theorem OpenEmbedding.of_comp_iff (f : Œ± ‚Üí Œ≤) {g : Œ≤ ‚Üí Œ≥} (hg : OpenEmbedding g) :
    OpenEmbedding (g ‚àò f) ‚Üî OpenEmbedding f := by
  simp only [openEmbedding_iff_continuous_injective_open, ‚Üê hg.is_open_map_iff, ‚Üê
    hg.1.continuous_iff, hg.inj.of_comp_iff]
#align open_embedding.of_comp_iff OpenEmbedding.of_comp_iff

/- warning: open_embedding.of_comp -> OpenEmbedding.of_comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] (f : Œ± -> Œ≤) {g : Œ≤ -> Œ≥}, (OpenEmbedding.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (OpenEmbedding.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f)) -> (OpenEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] (f : Œ± -> Œ≤) {g : Œ≤ -> Œ≥}, (OpenEmbedding.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (OpenEmbedding.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f)) -> (OpenEmbedding.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align open_embedding.of_comp OpenEmbedding.of_comp‚Çì'. -/
theorem OpenEmbedding.of_comp (f : Œ± ‚Üí Œ≤) {g : Œ≤ ‚Üí Œ≥} (hg : OpenEmbedding g)
    (h : OpenEmbedding (g ‚àò f)) : OpenEmbedding f :=
  (OpenEmbedding.of_comp_iff f hg).1 h
#align open_embedding.of_comp OpenEmbedding.of_comp

end OpenEmbedding

section ClosedEmbedding

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥]

#print ClosedEmbedding /-
/-- A closed embedding is an embedding with closed image. -/
@[mk_iff]
structure ClosedEmbedding (f : Œ± ‚Üí Œ≤) extends Embedding f : Prop where
  closed_range : IsClosed <| range f
#align closed_embedding ClosedEmbedding
-/

variable {f : Œ± ‚Üí Œ≤}

/- warning: closed_embedding.tendsto_nhds_iff -> ClosedEmbedding.tendsto_nhds_iff is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤} {Œπ : Type.{u3}} {g : Œπ -> Œ±} {a : Filter.{u3} Œπ} {b : Œ±}, (ClosedEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Iff (Filter.Tendsto.{u3, u1} Œπ Œ± g a (nhds.{u1} Œ± _inst_1 b)) (Filter.Tendsto.{u3, u2} Œπ Œ≤ (Function.comp.{succ u3, succ u1, succ u2} Œπ Œ± Œ≤ f g) a (nhds.{u2} Œ≤ _inst_2 (f b))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤} {Œπ : Type.{u3}} {g : Œπ -> Œ±} {a : Filter.{u3} Œπ} {b : Œ±}, (ClosedEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Iff (Filter.Tendsto.{u3, u2} Œπ Œ± g a (nhds.{u2} Œ± _inst_1 b)) (Filter.Tendsto.{u3, u1} Œπ Œ≤ (Function.comp.{succ u3, succ u2, succ u1} Œπ Œ± Œ≤ f g) a (nhds.{u1} Œ≤ _inst_2 (f b))))
Case conversion may be inaccurate. Consider using '#align closed_embedding.tendsto_nhds_iff ClosedEmbedding.tendsto_nhds_iff‚Çì'. -/
theorem ClosedEmbedding.tendsto_nhds_iff {Œπ : Type _} {g : Œπ ‚Üí Œ±} {a : Filter Œπ} {b : Œ±}
    (hf : ClosedEmbedding f) : Tendsto g a (ùìù b) ‚Üî Tendsto (f ‚àò g) a (ùìù (f b)) :=
  hf.toEmbedding.tendsto_nhds_iff
#align closed_embedding.tendsto_nhds_iff ClosedEmbedding.tendsto_nhds_iff

/- warning: closed_embedding.continuous -> ClosedEmbedding.continuous is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align closed_embedding.continuous ClosedEmbedding.continuous‚Çì'. -/
theorem ClosedEmbedding.continuous (hf : ClosedEmbedding f) : Continuous f :=
  hf.toEmbedding.Continuous
#align closed_embedding.continuous ClosedEmbedding.continuous

/- warning: closed_embedding.is_closed_map -> ClosedEmbedding.isClosedMap is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsClosedMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsClosedMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align closed_embedding.is_closed_map ClosedEmbedding.isClosedMap‚Çì'. -/
theorem ClosedEmbedding.isClosedMap (hf : ClosedEmbedding f) : IsClosedMap f :=
  hf.toEmbedding.to_inducing.IsClosedMap hf.closed_range
#align closed_embedding.is_closed_map ClosedEmbedding.isClosedMap

/- warning: closed_embedding.closed_iff_image_closed -> ClosedEmbedding.closed_iff_image_closed is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ±}, Iff (IsClosed.{u1} Œ± _inst_1 s) (IsClosed.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ±}, Iff (IsClosed.{u2} Œ± _inst_1 s) (IsClosed.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s)))
Case conversion may be inaccurate. Consider using '#align closed_embedding.closed_iff_image_closed ClosedEmbedding.closed_iff_image_closed‚Çì'. -/
theorem ClosedEmbedding.closed_iff_image_closed (hf : ClosedEmbedding f) {s : Set Œ±} :
    IsClosed s ‚Üî IsClosed (f '' s) :=
  ‚ü®hf.IsClosedMap s, fun h =>
    by
    convert ‚Üê continuous_iff_is_closed.mp hf.continuous _ h
    apply preimage_image_eq _ hf.inj‚ü©
#align closed_embedding.closed_iff_image_closed ClosedEmbedding.closed_iff_image_closed

/- warning: closed_embedding.closed_iff_preimage_closed -> ClosedEmbedding.closed_iff_preimage_closed is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u2} Œ≤}, (HasSubset.Subset.{u2} (Set.{u2} Œ≤) (Set.hasSubset.{u2} Œ≤) s (Set.range.{u2, succ u1} Œ≤ Œ± f)) -> (Iff (IsClosed.{u2} Œ≤ _inst_2 s) (IsClosed.{u1} Œ± _inst_1 (Set.preimage.{u1, u2} Œ± Œ≤ f s))))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall {s : Set.{u1} Œ≤}, (HasSubset.Subset.{u1} (Set.{u1} Œ≤) (Set.instHasSubsetSet.{u1} Œ≤) s (Set.range.{u1, succ u2} Œ≤ Œ± f)) -> (Iff (IsClosed.{u1} Œ≤ _inst_2 s) (IsClosed.{u2} Œ± _inst_1 (Set.preimage.{u2, u1} Œ± Œ≤ f s))))
Case conversion may be inaccurate. Consider using '#align closed_embedding.closed_iff_preimage_closed ClosedEmbedding.closed_iff_preimage_closed‚Çì'. -/
theorem ClosedEmbedding.closed_iff_preimage_closed (hf : ClosedEmbedding f) {s : Set Œ≤}
    (hs : s ‚äÜ range f) : IsClosed s ‚Üî IsClosed (f ‚Åª¬π' s) :=
  by
  convert ‚Üê hf.closed_iff_image_closed.symm
  rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]
#align closed_embedding.closed_iff_preimage_closed ClosedEmbedding.closed_iff_preimage_closed

/- warning: closed_embedding_of_embedding_closed -> closedEmbedding_of_embedding_closed is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Embedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsClosedMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (ClosedEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Embedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (IsClosedMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (ClosedEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align closed_embedding_of_embedding_closed closedEmbedding_of_embedding_closed‚Çì'. -/
theorem closedEmbedding_of_embedding_closed (h‚ÇÅ : Embedding f) (h‚ÇÇ : IsClosedMap f) :
    ClosedEmbedding f :=
  ‚ü®h‚ÇÅ, by convert h‚ÇÇ univ isClosed_univ <;> simp‚ü©
#align closed_embedding_of_embedding_closed closedEmbedding_of_embedding_closed

/- warning: closed_embedding_of_continuous_injective_closed -> closedEmbedding_of_continuous_injective_closed is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (Continuous.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (Function.Injective.{succ u1, succ u2} Œ± Œ≤ f) -> (IsClosedMap.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (ClosedEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f)
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (Continuous.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (Function.Injective.{succ u2, succ u1} Œ± Œ≤ f) -> (IsClosedMap.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (ClosedEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align closed_embedding_of_continuous_injective_closed closedEmbedding_of_continuous_injective_closed‚Çì'. -/
theorem closedEmbedding_of_continuous_injective_closed (h‚ÇÅ : Continuous f) (h‚ÇÇ : Injective f)
    (h‚ÇÉ : IsClosedMap f) : ClosedEmbedding f :=
  by
  refine' closedEmbedding_of_embedding_closed ‚ü®‚ü®_‚ü©, h‚ÇÇ‚ü© h‚ÇÉ
  apply le_antisymm (continuous_iff_le_induced.mp h‚ÇÅ) _
  intro s'
  change IsOpen _ ‚â§ IsOpen _
  rw [‚Üê isClosed_compl_iff, ‚Üê isClosed_compl_iff]
  generalize s'·∂ú = s
  rw [isClosed_induced_iff]
  refine' fun hs => ‚ü®f '' s, h‚ÇÉ s hs, _‚ü©
  rw [preimage_image_eq _ h‚ÇÇ]
#align closed_embedding_of_continuous_injective_closed closedEmbedding_of_continuous_injective_closed

#print closedEmbedding_id /-
theorem closedEmbedding_id : ClosedEmbedding (@id Œ±) :=
  ‚ü®embedding_id, by convert isClosed_univ <;> apply range_id‚ü©
#align closed_embedding_id closedEmbedding_id
-/

/- warning: closed_embedding.comp -> ClosedEmbedding.comp is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} {Œ≥ : Type.{u3}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] [_inst_3 : TopologicalSpace.{u3} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (ClosedEmbedding.{u2, u3} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (ClosedEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (ClosedEmbedding.{u1, u3} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u2, succ u3} Œ± Œ≤ Œ≥ g f))
but is expected to have type
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u3}} {Œ≥ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u3} Œ≤] [_inst_3 : TopologicalSpace.{u2} Œ≥] {g : Œ≤ -> Œ≥} {f : Œ± -> Œ≤}, (ClosedEmbedding.{u3, u2} Œ≤ Œ≥ _inst_2 _inst_3 g) -> (ClosedEmbedding.{u1, u3} Œ± Œ≤ _inst_1 _inst_2 f) -> (ClosedEmbedding.{u1, u2} Œ± Œ≥ _inst_1 _inst_3 (Function.comp.{succ u1, succ u3, succ u2} Œ± Œ≤ Œ≥ g f))
Case conversion may be inaccurate. Consider using '#align closed_embedding.comp ClosedEmbedding.comp‚Çì'. -/
theorem ClosedEmbedding.comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : ClosedEmbedding g)
    (hf : ClosedEmbedding f) : ClosedEmbedding (g ‚àò f) :=
  ‚ü®hg.toEmbedding.comp hf.toEmbedding,
    show IsClosed (range (g ‚àò f)) by
      rw [range_comp, ‚Üê hg.closed_iff_image_closed] <;> exact hf.closed_range‚ü©
#align closed_embedding.comp ClosedEmbedding.comp

/- warning: closed_embedding.closure_image_eq -> ClosedEmbedding.closure_image_eq is a dubious translation:
lean 3 declaration is
  forall {Œ± : Type.{u1}} {Œ≤ : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} Œ±] [_inst_2 : TopologicalSpace.{u2} Œ≤] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u1, u2} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u1} Œ±), Eq.{succ u2} (Set.{u2} Œ≤) (closure.{u2} Œ≤ _inst_2 (Set.image.{u1, u2} Œ± Œ≤ f s)) (Set.image.{u1, u2} Œ± Œ≤ f (closure.{u1} Œ± _inst_1 s)))
but is expected to have type
  forall {Œ± : Type.{u2}} {Œ≤ : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} Œ±] [_inst_2 : TopologicalSpace.{u1} Œ≤] {f : Œ± -> Œ≤}, (ClosedEmbedding.{u2, u1} Œ± Œ≤ _inst_1 _inst_2 f) -> (forall (s : Set.{u2} Œ±), Eq.{succ u1} (Set.{u1} Œ≤) (closure.{u1} Œ≤ _inst_2 (Set.image.{u2, u1} Œ± Œ≤ f s)) (Set.image.{u2, u1} Œ± Œ≤ f (closure.{u2} Œ± _inst_1 s)))
Case conversion may be inaccurate. Consider using '#align closed_embedding.closure_image_eq ClosedEmbedding.closure_image_eq‚Çì'. -/
theorem ClosedEmbedding.closure_image_eq {f : Œ± ‚Üí Œ≤} (hf : ClosedEmbedding f) (s : Set Œ±) :
    closure (f '' s) = f '' closure s :=
  (hf.IsClosedMap.closure_image_subset _).antisymm
    (image_closure_subset_closure_image hf.Continuous)
#align closed_embedding.closure_image_eq ClosedEmbedding.closure_image_eq

end ClosedEmbedding

