/-
Copyright (c) 2022 Jujian Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jujian Zhang

! This file was ported from Lean 3 source module topology.sheaves.punit
! leanprover-community/mathlib commit 38df578a6450a8c5142b3727e3ae894c2300cae0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Sheaves.SheafCondition.Sites

/-!
# Presheaves on punit

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Presheaves on punit satisfy sheaf condition iff its value at empty set is a terminal object.
-/


namespace TopCat.Presheaf

universe u v w

open CategoryTheory CategoryTheory.Limits TopCat Opposite

variable {C : Type u} [Category.{v} C]

/- warning: Top.presheaf.is_sheaf_of_is_terminal_of_indiscrete -> TopCat.Presheaf.isSheaf_of_isTerminal_of_indiscrete is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {X : TopCat.{u3}}, (Eq.{succ u3} (autoParamₓ.{succ u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 108 (OfNat.mk.{0} Nat 108 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 121 (OfNat.mk.{0} Nat 121 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 95 (OfNat.mk.{0} Nat 95 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 115 (OfNat.mk.{0} Nat 115 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 101 (OfNat.mk.{0} Nat 101 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) Name.anonymous))) (CategoryTheory.Bundled.str.{u3, u3} TopologicalSpace.{u3} X) (Top.top.{u3} (autoParamₓ.{succ u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 108 (OfNat.mk.{0} Nat 108 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 121 (OfNat.mk.{0} Nat 121 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 95 (OfNat.mk.{0} Nat 95 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 115 (OfNat.mk.{0} Nat 115 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 101 (OfNat.mk.{0} Nat 101 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) Name.anonymous))) (CompleteLattice.toHasTop.{u3} (autoParamₓ.{succ u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 108 (OfNat.mk.{0} Nat 108 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 121 (OfNat.mk.{0} Nat 121 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 95 (OfNat.mk.{0} Nat 95 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 115 (OfNat.mk.{0} Nat 115 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 101 (OfNat.mk.{0} Nat 101 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) Name.anonymous))) (TopologicalSpace.completeLattice.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X))))) -> (forall (F : TopCat.Presheaf.{u3, u2, u1} C _inst_1 X), (CategoryTheory.Limits.IsTerminal.{u2, u1} C _inst_1 (CategoryTheory.Functor.obj.{u3, u2, u3, u1} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X))) (CategoryTheory.Category.opposite.{u3, u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (Preorder.smallCategory.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (PartialOrder.toPreorder.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (SetLike.partialOrder.{u3, u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopologicalSpace.Opens.setLike.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)))))) C _inst_1 F (Opposite.op.{succ u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (Bot.bot.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (CompleteLattice.toHasBot.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (TopologicalSpace.Opens.completeLattice.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X))))))) -> (TopCat.Presheaf.IsSheaf.{u3, u2, u1} C _inst_1 X F))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {X : TopCat.{u3}}, (Eq.{succ u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (CategoryTheory.Bundled.str.{u3, u3} TopologicalSpace.{u3} X) (Top.top.{u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (CompleteLattice.toTop.{u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X))))) -> (forall (F : TopCat.Presheaf.{u3, u2, u1} C _inst_1 X), (CategoryTheory.Limits.IsTerminal.{u2, u1} C _inst_1 (Prefunctor.obj.{succ u3, succ u2, u3, u1} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))) (CategoryTheory.CategoryStruct.toQuiver.{u3, u3} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))) (CategoryTheory.Category.toCategoryStruct.{u3, u3} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))) (CategoryTheory.Category.opposite.{u3, u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (Preorder.smallCategory.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (PartialOrder.toPreorder.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (CompleteSemilatticeInf.toPartialOrder.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (CompleteLattice.toCompleteSemilatticeInf.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))))))))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u3, u1} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))) (CategoryTheory.Category.opposite.{u3, u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (Preorder.smallCategory.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (PartialOrder.toPreorder.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (CompleteSemilatticeInf.toPartialOrder.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (CompleteLattice.toCompleteSemilatticeInf.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))))))) C _inst_1 F) (Opposite.op.{succ u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (Bot.bot.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (CompleteLattice.toBot.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))))))) -> (TopCat.Presheaf.IsSheaf.{u3, u2, u1} C _inst_1 X F))
Case conversion may be inaccurate. Consider using '#align Top.presheaf.is_sheaf_of_is_terminal_of_indiscrete TopCat.Presheaf.isSheaf_of_isTerminal_of_indiscreteₓ'. -/
theorem isSheaf_of_isTerminal_of_indiscrete {X : TopCat.{w}} (hind : X.str = ⊤) (F : Presheaf C X)
    (it : IsTerminal <| F.obj <| op ⊥) : F.IsSheaf := fun c U s hs =>
  by
  obtain rfl | hne := eq_or_ne U ⊥
  · intro _ _
    rw [@exists_unique_iff_exists _ ⟨fun _ _ => _⟩]
    · refine' ⟨it.from _, fun U hU hs => is_terminal.hom_ext _ _ _⟩
      rwa [le_bot_iff.1 hU.le]
    · apply it.hom_ext
  · convert presieve.is_sheaf_for_top_sieve _
    rw [← sieve.id_mem_iff_eq_top]
    have := (U.eq_bot_or_top hind).resolve_left hne
    subst this
    obtain he | ⟨⟨x⟩⟩ := isEmpty_or_nonempty X
    · exact (hne <| SetLike.ext'_iff.2 <| Set.univ_eq_empty_iff.2 he).elim
    obtain ⟨U, f, hf, hm⟩ := hs x trivial
    obtain rfl | rfl := U.eq_bot_or_top hind
    · cases hm
    · convert hf
#align Top.presheaf.is_sheaf_of_is_terminal_of_indiscrete TopCat.Presheaf.isSheaf_of_isTerminal_of_indiscrete

/- warning: Top.presheaf.is_sheaf_iff_is_terminal_of_indiscrete -> TopCat.Presheaf.isSheaf_iff_isTerminal_of_indiscrete is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {X : TopCat.{u3}}, (Eq.{succ u3} (autoParamₓ.{succ u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 108 (OfNat.mk.{0} Nat 108 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 121 (OfNat.mk.{0} Nat 121 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 95 (OfNat.mk.{0} Nat 95 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 115 (OfNat.mk.{0} Nat 115 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 101 (OfNat.mk.{0} Nat 101 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) Name.anonymous))) (CategoryTheory.Bundled.str.{u3, u3} TopologicalSpace.{u3} X) (Top.top.{u3} (autoParamₓ.{succ u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 108 (OfNat.mk.{0} Nat 108 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 121 (OfNat.mk.{0} Nat 121 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 95 (OfNat.mk.{0} Nat 95 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 115 (OfNat.mk.{0} Nat 115 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 101 (OfNat.mk.{0} Nat 101 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) Name.anonymous))) (CompleteLattice.toHasTop.{u3} (autoParamₓ.{succ u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 112 (OfNat.mk.{0} Nat 112 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 108 (OfNat.mk.{0} Nat 108 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 121 (OfNat.mk.{0} Nat 121 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 95 (OfNat.mk.{0} Nat 95 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 115 (OfNat.mk.{0} Nat 115 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 110 (OfNat.mk.{0} Nat 110 (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 101 (OfNat.mk.{0} Nat 101 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Name.mk_string (String.str (String.str (String.str (String.str (String.str (String.str String.empty (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 97 (OfNat.mk.{0} Nat 97 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 116 (OfNat.mk.{0} Nat 116 (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 105 (OfNat.mk.{0} Nat 105 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) (Char.ofNat (OfNat.ofNat.{0} Nat 99 (OfNat.mk.{0} Nat 99 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit0.{0} Nat Nat.hasAdd (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))))))) Name.anonymous))) (TopologicalSpace.completeLattice.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X))))) -> (forall (F : TopCat.Presheaf.{u3, u2, u1} C _inst_1 X), Iff (TopCat.Presheaf.IsSheaf.{u3, u2, u1} C _inst_1 X F) (Nonempty.{max 1 (succ u1) (succ u2)} (CategoryTheory.Limits.IsTerminal.{u2, u1} C _inst_1 (CategoryTheory.Functor.obj.{u3, u2, u3, u1} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X))) (CategoryTheory.Category.opposite.{u3, u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (Preorder.smallCategory.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (PartialOrder.toPreorder.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (SetLike.partialOrder.{u3, u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopologicalSpace.Opens.setLike.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)))))) C _inst_1 F (Opposite.op.{succ u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (Bot.bot.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (CompleteLattice.toHasBot.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)) (TopologicalSpace.Opens.completeLattice.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} X) (TopCat.topologicalSpace.{u3} X)))))))))
but is expected to have type
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] {X : TopCat.{u3}}, (Eq.{succ u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (CategoryTheory.Bundled.str.{u3, u3} TopologicalSpace.{u3} X) (Top.top.{u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (CompleteLattice.toTop.{u3} (TopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X)) (TopologicalSpace.instCompleteLatticeTopologicalSpace.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X))))) -> (forall (F : TopCat.Presheaf.{u3, u2, u1} C _inst_1 X), Iff (TopCat.Presheaf.IsSheaf.{u3, u2, u1} C _inst_1 X F) (Nonempty.{max (succ u1) (succ u2)} (CategoryTheory.Limits.IsTerminal.{u2, u1} C _inst_1 (Prefunctor.obj.{succ u3, succ u2, u3, u1} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))) (CategoryTheory.CategoryStruct.toQuiver.{u3, u3} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))) (CategoryTheory.Category.toCategoryStruct.{u3, u3} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))) (CategoryTheory.Category.opposite.{u3, u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (Preorder.smallCategory.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (PartialOrder.toPreorder.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (CompleteSemilatticeInf.toPartialOrder.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (CompleteLattice.toCompleteSemilatticeInf.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))))))))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u1} C (CategoryTheory.Category.toCategoryStruct.{u2, u1} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u3, u1} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))) (CategoryTheory.Category.opposite.{u3, u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (Preorder.smallCategory.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (PartialOrder.toPreorder.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (CompleteSemilatticeInf.toPartialOrder.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (CompleteLattice.toCompleteSemilatticeInf.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X))))))) C _inst_1 F) (Opposite.op.{succ u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (Bot.bot.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (CompleteLattice.toBot.{u3} (TopologicalSpace.Opens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u3} (CategoryTheory.Bundled.α.{u3, u3} TopologicalSpace.{u3} X) (TopCat.topologicalSpace_coe.{u3} X)))))))))
Case conversion may be inaccurate. Consider using '#align Top.presheaf.is_sheaf_iff_is_terminal_of_indiscrete TopCat.Presheaf.isSheaf_iff_isTerminal_of_indiscreteₓ'. -/
theorem isSheaf_iff_isTerminal_of_indiscrete {X : TopCat.{w}} (hind : X.str = ⊤)
    (F : Presheaf C X) : F.IsSheaf ↔ Nonempty (IsTerminal <| F.obj <| op ⊥) :=
  ⟨fun h => ⟨Sheaf.isTerminalOfEmpty ⟨F, h⟩⟩, fun ⟨it⟩ =>
    isSheaf_of_isTerminal_of_indiscrete hind F it⟩
#align Top.presheaf.is_sheaf_iff_is_terminal_of_indiscrete TopCat.Presheaf.isSheaf_iff_isTerminal_of_indiscrete

/- warning: Top.presheaf.is_sheaf_on_punit_of_is_terminal -> TopCat.Presheaf.isSheaf_on_pUnit_of_isTerminal is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (F : TopCat.Presheaf.{u3, u2, u1} C _inst_1 (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})), (CategoryTheory.Limits.IsTerminal.{u2, u1} C _inst_1 (CategoryTheory.Functor.obj.{u3, u2, u3, u1} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})))) (CategoryTheory.Category.opposite.{u3, u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (Preorder.smallCategory.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (PartialOrder.toPreorder.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (SetLike.partialOrder.{u3, u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopologicalSpace.Opens.setLike.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))))))) C _inst_1 F (Opposite.op.{succ u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (Bot.bot.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (CompleteLattice.toHasBot.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (TopologicalSpace.Opens.completeLattice.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})))))))) -> (TopCat.Presheaf.IsSheaf.{u3, u2, u1} C _inst_1 (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}) F)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u2} C] (F : TopCat.Presheaf.{u1, u3, u2} C _inst_1 (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})), (CategoryTheory.Limits.IsTerminal.{u3, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u3, u1, u2} (Opposite.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (Opposite.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (Opposite.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))) (CategoryTheory.Category.opposite.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))))))))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} C (CategoryTheory.Category.toCategoryStruct.{u3, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u1, u2} (Opposite.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))) (CategoryTheory.Category.opposite.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))))))) C _inst_1 F) (Opposite.op.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (Bot.bot.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (CompleteLattice.toBot.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))))))) -> (TopCat.Presheaf.IsSheaf.{u1, u3, u2} C _inst_1 (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}) F)
Case conversion may be inaccurate. Consider using '#align Top.presheaf.is_sheaf_on_punit_of_is_terminal TopCat.Presheaf.isSheaf_on_pUnit_of_isTerminalₓ'. -/
theorem isSheaf_on_pUnit_of_isTerminal (F : Presheaf C (TopCat.of PUnit))
    (it : IsTerminal <| F.obj <| op ⊥) : F.IsSheaf :=
  isSheaf_of_isTerminal_of_indiscrete (@Subsingleton.elim (TopologicalSpace PUnit) _ _ _) F it
#align Top.presheaf.is_sheaf_on_punit_of_is_terminal TopCat.Presheaf.isSheaf_on_pUnit_of_isTerminal

/- warning: Top.presheaf.is_sheaf_on_punit_iff_is_terminal -> TopCat.Presheaf.isSheaf_on_pUnit_iff_isTerminal is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u2, u1} C] (F : TopCat.Presheaf.{u3, u2, u1} C _inst_1 (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})), Iff (TopCat.Presheaf.IsSheaf.{u3, u2, u1} C _inst_1 (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}) F) (Nonempty.{max 1 (succ u1) (succ u2)} (CategoryTheory.Limits.IsTerminal.{u2, u1} C _inst_1 (CategoryTheory.Functor.obj.{u3, u2, u3, u1} (Opposite.{succ u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})))) (CategoryTheory.Category.opposite.{u3, u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (Preorder.smallCategory.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (PartialOrder.toPreorder.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (SetLike.partialOrder.{u3, u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopologicalSpace.Opens.setLike.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))))))) C _inst_1 F (Opposite.op.{succ u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (Bot.bot.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (CompleteLattice.toHasBot.{u3} (TopologicalSpace.Opens.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3}))) (TopologicalSpace.Opens.completeLattice.{u3} (coeSort.{succ (succ u3), succ (succ u3)} TopCat.{u3} Type.{u3} TopCat.hasCoeToSort.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})) (TopCat.topologicalSpace.{u3} (TopCat.of.{u3} PUnit.{succ u3} PUnit.topologicalSpace.{u3})))))))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u3, u2} C] (F : TopCat.Presheaf.{u1, u3, u2} C _inst_1 (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})), Iff (TopCat.Presheaf.IsSheaf.{u1, u3, u2} C _inst_1 (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}) F) (Nonempty.{max (succ u2) (succ u3)} (CategoryTheory.Limits.IsTerminal.{u3, u2} C _inst_1 (Prefunctor.obj.{succ u1, succ u3, u1, u2} (Opposite.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (Opposite.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (Opposite.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))) (CategoryTheory.Category.opposite.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))))))))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u2} C (CategoryTheory.Category.toCategoryStruct.{u3, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u1, u2} (Opposite.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))) (CategoryTheory.Category.opposite.{u1, u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (Preorder.smallCategory.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (PartialOrder.toPreorder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (CompleteSemilatticeInf.toPartialOrder.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (CompleteLattice.toCompleteSemilatticeInf.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))))))) C _inst_1 F) (Opposite.op.{succ u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (Bot.bot.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (CompleteLattice.toBot.{u1} (TopologicalSpace.Opens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1}))) (TopologicalSpace.Opens.instCompleteLatticeOpens.{u1} (CategoryTheory.Bundled.α.{u1, u1} TopologicalSpace.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})) (TopCat.topologicalSpace_coe.{u1} (TopCat.of.{u1} PUnit.{succ u1} instTopologicalSpacePUnit.{u1})))))))))
Case conversion may be inaccurate. Consider using '#align Top.presheaf.is_sheaf_on_punit_iff_is_terminal TopCat.Presheaf.isSheaf_on_pUnit_iff_isTerminalₓ'. -/
theorem isSheaf_on_pUnit_iff_isTerminal (F : Presheaf C (TopCat.of PUnit)) :
    F.IsSheaf ↔ Nonempty (IsTerminal <| F.obj <| op ⊥) :=
  ⟨fun h => ⟨Sheaf.isTerminalOfEmpty ⟨F, h⟩⟩, fun ⟨it⟩ => isSheaf_on_pUnit_of_isTerminal F it⟩
#align Top.presheaf.is_sheaf_on_punit_iff_is_terminal TopCat.Presheaf.isSheaf_on_pUnit_iff_isTerminal

end TopCat.Presheaf

