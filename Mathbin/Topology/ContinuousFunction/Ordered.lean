/-
Copyright © 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Shing Tak Lam

! This file was ported from Lean 3 source module topology.continuous_function.ordered
! leanprover-community/mathlib commit 84dc0bd6619acaea625086d6f53cb35cdd554219
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.Algebra.Order.ProjIcc
import Mathbin.Topology.Algebra.Order.Group
import Mathbin.Topology.ContinuousFunction.Basic

/-!
# Bundled continuous maps into orders, with order-compatible topology

-/


variable {α : Type _} {β : Type _} {γ : Type _}

variable [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ]

namespace ContinuousMap

section

variable [LinearOrderedAddCommGroup β] [OrderTopology β]

#print ContinuousMap.abs /-
/-- The pointwise absolute value of a continuous function as a continuous function. -/
def abs (f : C(α, β)) : C(α, β) where toFun x := |f x|
#align continuous_map.abs ContinuousMap.abs
-/

-- see Note [lower instance priority]
instance (priority := 100) : Abs C(α, β) :=
  ⟨fun f => abs f⟩

/- warning: continuous_map.abs_apply -> ContinuousMap.abs_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : LinearOrderedAddCommGroup.{u2} β] [_inst_5 : OrderTopology.{u2} β _inst_2 (PartialOrder.toPreorder.{u2} β (OrderedAddCommGroup.toPartialOrder.{u2} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} β _inst_4)))] (f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (Abs.abs.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasAbs.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f) x) (Abs.abs.{u2} β (Neg.toHasAbs.{u2} β (SubNegMonoid.toHasNeg.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddCommGroup.toAddGroup.{u2} β (OrderedAddCommGroup.toAddCommGroup.{u2} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} β _inst_4))))) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β (LinearOrder.toLattice.{u2} β (LinearOrderedAddCommGroup.toLinearOrder.{u2} β _inst_4))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : TopologicalSpace.{u1} β] [_inst_4 : LinearOrderedAddCommGroup.{u1} β] [_inst_5 : OrderTopology.{u1} β _inst_2 (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_4)))] (f : ContinuousMap.{u2, u1} α β _inst_1 _inst_2) (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 _inst_2)) (Abs.abs.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 _inst_2) (ContinuousMap.instAbsContinuousMap.{u2, u1} α β _inst_1 _inst_2 _inst_4 _inst_5) f) x) (Abs.abs.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (Neg.toHasAbs.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (NegZeroClass.toNeg.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (OrderedAddCommGroup.toAddCommGroup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_4))))))) (SemilatticeSup.toHasSup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (Lattice.toSemilatticeSup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (DistribLattice.toLattice.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (instDistribLattice.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (LinearOrderedAddCommGroup.toLinearOrder.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_4)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 _inst_2)) f x))
Case conversion may be inaccurate. Consider using '#align continuous_map.abs_apply ContinuousMap.abs_applyₓ'. -/
@[simp]
theorem abs_apply (f : C(α, β)) (x : α) : (|f|) x = |f x| :=
  rfl
#align continuous_map.abs_apply ContinuousMap.abs_apply

end

/-!
We now set up the partial order and lattice structure (given by pointwise min and max)
on continuous functions.
-/


section Lattice

#print ContinuousMap.partialOrder /-
instance partialOrder [PartialOrder β] : PartialOrder C(α, β) :=
  PartialOrder.lift (fun f => f.toFun) (by tidy)
#align continuous_map.partial_order ContinuousMap.partialOrder
-/

/- warning: continuous_map.le_def -> ContinuousMap.le_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : PartialOrder.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2} {g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2}, Iff (LE.le.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (Preorder.toLE.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (PartialOrder.toPreorder.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.partialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_4))) f g) (forall (a : α), LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_4)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : PartialOrder.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2} {g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2}, Iff (LE.le.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (Preorder.toLE.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (PartialOrder.toPreorder.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.partialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_4))) f g) (forall (a : α), LE.le.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) _inst_4)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) f a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) g a))
Case conversion may be inaccurate. Consider using '#align continuous_map.le_def ContinuousMap.le_defₓ'. -/
theorem le_def [PartialOrder β] {f g : C(α, β)} : f ≤ g ↔ ∀ a, f a ≤ g a :=
  Pi.le_def
#align continuous_map.le_def ContinuousMap.le_def

/- warning: continuous_map.lt_def -> ContinuousMap.lt_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : PartialOrder.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2} {g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2}, Iff (LT.lt.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (Preorder.toLT.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (PartialOrder.toPreorder.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.partialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_4))) f g) (And (forall (a : α), LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_4)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a)) (Exists.{succ u1} α (fun (a : α) => LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_4)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : PartialOrder.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2} {g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2}, Iff (LT.lt.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (Preorder.toLT.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (PartialOrder.toPreorder.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.partialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_4))) f g) (And (forall (a : α), LE.le.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) _inst_4)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) f a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) g a)) (Exists.{succ u1} α (fun (a : α) => LT.lt.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) _inst_4)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) f a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) g a))))
Case conversion may be inaccurate. Consider using '#align continuous_map.lt_def ContinuousMap.lt_defₓ'. -/
theorem lt_def [PartialOrder β] {f g : C(α, β)} : f < g ↔ (∀ a, f a ≤ g a) ∧ ∃ a, f a < g a :=
  Pi.lt_def
#align continuous_map.lt_def ContinuousMap.lt_def

#print ContinuousMap.hasSup /-
instance hasSup [LinearOrder β] [OrderClosedTopology β] : HasSup C(α, β)
    where sup f g := { toFun := fun a => max (f a) (g a) }
#align continuous_map.has_sup ContinuousMap.hasSup
-/

/- warning: continuous_map.sup_coe -> ContinuousMap.sup_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : LinearOrder.{u2} β] [_inst_5 : OrderClosedTopology.{u2} β _inst_2 (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β (LinearOrder.toLattice.{u2} β _inst_4))))] (f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} ((fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (HasSup.sup.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f g)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (HasSup.sup.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f g)) (HasSup.sup.{max u1 u2} (α -> β) (Pi.hasSup.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β (LinearOrder.toLattice.{u2} β _inst_4)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : LinearOrder.{u2} β] [_inst_5 : OrderClosedTopology.{u2} β _inst_2 (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β (DistribLattice.toLattice.{u2} β (instDistribLattice.{u2} β _inst_4)))))] (f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) (HasSup.sup.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f g)) (HasSup.sup.{max u1 u2} (α -> β) (Pi.instHasSupForAll.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β (DistribLattice.toLattice.{u2} β (instDistribLattice.{u2} β _inst_4))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) f) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) g))
Case conversion may be inaccurate. Consider using '#align continuous_map.sup_coe ContinuousMap.sup_coeₓ'. -/
@[simp, norm_cast]
theorem sup_coe [LinearOrder β] [OrderClosedTopology β] (f g : C(α, β)) :
    ((f ⊔ g : C(α, β)) : α → β) = (f ⊔ g : α → β) :=
  rfl
#align continuous_map.sup_coe ContinuousMap.sup_coe

/- warning: continuous_map.sup_apply -> ContinuousMap.sup_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : LinearOrder.{u2} β] [_inst_5 : OrderClosedTopology.{u2} β _inst_2 (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β (LinearOrder.toLattice.{u2} β _inst_4))))] (f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (HasSup.sup.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f g) a) (LinearOrder.max.{u2} β _inst_4 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : LinearOrder.{u2} β] [_inst_5 : OrderClosedTopology.{u2} β _inst_2 (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β (DistribLattice.toLattice.{u2} β (instDistribLattice.{u2} β _inst_4)))))] (f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) (HasSup.sup.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f g) a) (Max.max.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (LinearOrder.toMax.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) f a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) g a))
Case conversion may be inaccurate. Consider using '#align continuous_map.sup_apply ContinuousMap.sup_applyₓ'. -/
@[simp]
theorem sup_apply [LinearOrder β] [OrderClosedTopology β] (f g : C(α, β)) (a : α) :
    (f ⊔ g) a = max (f a) (g a) :=
  rfl
#align continuous_map.sup_apply ContinuousMap.sup_apply

instance [LinearOrder β] [OrderClosedTopology β] : SemilatticeSup C(α, β) :=
  { ContinuousMap.partialOrder,
    ContinuousMap.hasSup with
    le_sup_left := fun f g => le_def.mpr (by simp [le_refl])
    le_sup_right := fun f g => le_def.mpr (by simp [le_refl])
    sup_le := fun f₁ f₂ g w₁ w₂ => le_def.mpr fun a => by simp [le_def.mp w₁ a, le_def.mp w₂ a] }

#print ContinuousMap.hasInf /-
instance hasInf [LinearOrder β] [OrderClosedTopology β] : HasInf C(α, β)
    where inf f g := { toFun := fun a => min (f a) (g a) }
#align continuous_map.has_inf ContinuousMap.hasInf
-/

/- warning: continuous_map.inf_coe -> ContinuousMap.inf_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : LinearOrder.{u2} β] [_inst_5 : OrderClosedTopology.{u2} β _inst_2 (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β (LinearOrder.toLattice.{u2} β _inst_4))))] (f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} ((fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (HasInf.inf.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f g)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (HasInf.inf.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f g)) (HasInf.inf.{max u1 u2} (α -> β) (Pi.hasInf.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β (LinearOrder.toLattice.{u2} β _inst_4)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : LinearOrder.{u2} β] [_inst_5 : OrderClosedTopology.{u2} β _inst_2 (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β (DistribLattice.toLattice.{u2} β (instDistribLattice.{u2} β _inst_4)))))] (f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) (HasInf.inf.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f g)) (HasInf.inf.{max u1 u2} (α -> β) (Pi.instHasInfForAll.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => Lattice.toHasInf.{u2} β (DistribLattice.toLattice.{u2} β (instDistribLattice.{u2} β _inst_4)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) f) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) g))
Case conversion may be inaccurate. Consider using '#align continuous_map.inf_coe ContinuousMap.inf_coeₓ'. -/
@[simp, norm_cast]
theorem inf_coe [LinearOrder β] [OrderClosedTopology β] (f g : C(α, β)) :
    ((f ⊓ g : C(α, β)) : α → β) = (f ⊓ g : α → β) :=
  rfl
#align continuous_map.inf_coe ContinuousMap.inf_coe

/- warning: continuous_map.inf_apply -> ContinuousMap.inf_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : LinearOrder.{u2} β] [_inst_5 : OrderClosedTopology.{u2} β _inst_2 (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β (LinearOrder.toLattice.{u2} β _inst_4))))] (f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (HasInf.inf.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f g) a) (LinearOrder.min.{u2} β _inst_4 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : LinearOrder.{u2} β] [_inst_5 : OrderClosedTopology.{u2} β _inst_2 (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β (DistribLattice.toLattice.{u2} β (instDistribLattice.{u2} β _inst_4)))))] (f : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (g : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) (HasInf.inf.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) f g) a) (Min.min.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (LinearOrder.toMin.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) f a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 _inst_2)) g a))
Case conversion may be inaccurate. Consider using '#align continuous_map.inf_apply ContinuousMap.inf_applyₓ'. -/
@[simp]
theorem inf_apply [LinearOrder β] [OrderClosedTopology β] (f g : C(α, β)) (a : α) :
    (f ⊓ g) a = min (f a) (g a) :=
  rfl
#align continuous_map.inf_apply ContinuousMap.inf_apply

instance [LinearOrder β] [OrderClosedTopology β] : SemilatticeInf C(α, β) :=
  { ContinuousMap.partialOrder,
    ContinuousMap.hasInf with
    inf_le_left := fun f g => le_def.mpr (by simp [le_refl])
    inf_le_right := fun f g => le_def.mpr (by simp [le_refl])
    le_inf := fun f₁ f₂ g w₁ w₂ => le_def.mpr fun a => by simp [le_def.mp w₁ a, le_def.mp w₂ a] }

instance [LinearOrder β] [OrderClosedTopology β] : Lattice C(α, β) :=
  { ContinuousMap.semilatticeInf, ContinuousMap.semilatticeSup with }

-- TODO transfer this lattice structure to `bounded_continuous_function`
section Sup'

variable [LinearOrder γ] [OrderClosedTopology γ]

/- warning: continuous_map.sup'_apply -> ContinuousMap.sup'_apply is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u1}} {γ : Type.{u2}} [_inst_2 : TopologicalSpace.{u1} β] [_inst_3 : TopologicalSpace.{u2} γ] [_inst_4 : LinearOrder.{u2} γ] [_inst_5 : OrderClosedTopology.{u2} γ _inst_3 (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ (LinearOrder.toLattice.{u2} γ _inst_4))))] {ι : Type.{u3}} {s : Finset.{u3} ι} (H : Finset.Nonempty.{u3} ι s) (f : ι -> (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3)) (b : β), Eq.{succ u2} γ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) (fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (ContinuousMap.hasCoeToFun.{u1, u2} β γ _inst_2 _inst_3) (Finset.sup'.{max u1 u2, u3} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeSup.{u1, u2} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f) b) (Finset.sup'.{u2, u3} γ ι (Lattice.toSemilatticeSup.{u2} γ (LinearOrder.toLattice.{u2} γ _inst_4)) s H (fun (a : ι) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) (fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (ContinuousMap.hasCoeToFun.{u1, u2} β γ _inst_2 _inst_3) (f a) b))
but is expected to have type
  forall {β : Type.{u2}} {γ : Type.{u1}} [_inst_2 : TopologicalSpace.{u2} β] [_inst_3 : TopologicalSpace.{u1} γ] [_inst_4 : LinearOrder.{u1} γ] [_inst_5 : OrderClosedTopology.{u1} γ _inst_3 (PartialOrder.toPreorder.{u1} γ (SemilatticeInf.toPartialOrder.{u1} γ (Lattice.toSemilatticeInf.{u1} γ (DistribLattice.toLattice.{u1} γ (instDistribLattice.{u1} γ _inst_4)))))] {ι : Type.{u3}} {s : Finset.{u3} ι} (H : Finset.Nonempty.{u3} ι s) (f : ι -> (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3)) (b : β), Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) b) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} β γ _inst_2 _inst_3)) (Finset.sup'.{max u2 u1, u3} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeSup.{u2, u1} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f) b) (Finset.sup'.{u1, u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) b) ι (Lattice.toSemilatticeSup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) b) (DistribLattice.toLattice.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) b) (instDistribLattice.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) b) _inst_4))) s H (fun (a : ι) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} β γ _inst_2 _inst_3)) (f a) b))
Case conversion may be inaccurate. Consider using '#align continuous_map.sup'_apply ContinuousMap.sup'_applyₓ'. -/
theorem sup'_apply {ι : Type _} {s : Finset ι} (H : s.Nonempty) (f : ι → C(β, γ)) (b : β) :
    s.sup' H f b = s.sup' H fun a => f a b :=
  Finset.comp_sup'_eq_sup'_comp H (fun f : C(β, γ) => f b) fun i j => rfl
#align continuous_map.sup'_apply ContinuousMap.sup'_apply

/- warning: continuous_map.sup'_coe -> ContinuousMap.sup'_coe is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u1}} {γ : Type.{u2}} [_inst_2 : TopologicalSpace.{u1} β] [_inst_3 : TopologicalSpace.{u2} γ] [_inst_4 : LinearOrder.{u2} γ] [_inst_5 : OrderClosedTopology.{u2} γ _inst_3 (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ (LinearOrder.toLattice.{u2} γ _inst_4))))] {ι : Type.{u3}} {s : Finset.{u3} ι} (H : Finset.Nonempty.{u3} ι s) (f : ι -> (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3)), Eq.{max (succ u1) (succ u2)} ((fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (Finset.sup'.{max u1 u2, u3} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeSup.{u1, u2} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) (fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (ContinuousMap.hasCoeToFun.{u1, u2} β γ _inst_2 _inst_3) (Finset.sup'.{max u1 u2, u3} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeSup.{u1, u2} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f)) (Finset.sup'.{max u1 u2, u3} ((fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (Finset.sup'.{max u1 u2, u3} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeSup.{u1, u2} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f)) ι (Pi.semilatticeSup.{u1, u2} β (fun (ᾰ : β) => γ) (fun (i : β) => Lattice.toSemilatticeSup.{u2} γ (LinearOrder.toLattice.{u2} γ _inst_4))) s H (fun (a : ι) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) (fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (ContinuousMap.hasCoeToFun.{u1, u2} β γ _inst_2 _inst_3) (f a)))
but is expected to have type
  forall {β : Type.{u2}} {γ : Type.{u1}} [_inst_2 : TopologicalSpace.{u2} β] [_inst_3 : TopologicalSpace.{u1} γ] [_inst_4 : LinearOrder.{u1} γ] [_inst_5 : OrderClosedTopology.{u1} γ _inst_3 (PartialOrder.toPreorder.{u1} γ (SemilatticeInf.toPartialOrder.{u1} γ (Lattice.toSemilatticeInf.{u1} γ (DistribLattice.toLattice.{u1} γ (instDistribLattice.{u1} γ _inst_4)))))] {ι : Type.{u3}} {s : Finset.{u3} ι} (H : Finset.Nonempty.{u3} ι s) (f : ι -> (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3)), Eq.{max (succ u2) (succ u1)} (forall (a : β), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} β γ _inst_2 _inst_3)) (Finset.sup'.{max u2 u1, u3} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeSup.{u2, u1} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f)) (Finset.sup'.{max u2 u1, u3} (forall (a : β), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) a) ι (Pi.semilatticeSup.{u2, u1} β (fun (ᾰ : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) ᾰ) (fun (i : β) => Lattice.toSemilatticeSup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) i) (DistribLattice.toLattice.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) i) (instDistribLattice.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) i) _inst_4)))) s H (fun (a : ι) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} β γ _inst_2 _inst_3)) (f a)))
Case conversion may be inaccurate. Consider using '#align continuous_map.sup'_coe ContinuousMap.sup'_coeₓ'. -/
@[simp, norm_cast]
theorem sup'_coe {ι : Type _} {s : Finset ι} (H : s.Nonempty) (f : ι → C(β, γ)) :
    ((s.sup' H f : C(β, γ)) : ι → β) = s.sup' H fun a => (f a : β → γ) :=
  by
  ext
  simp [sup'_apply]
#align continuous_map.sup'_coe ContinuousMap.sup'_coe

end Sup'

section Inf'

variable [LinearOrder γ] [OrderClosedTopology γ]

/- warning: continuous_map.inf'_apply -> ContinuousMap.inf'_apply is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u1}} {γ : Type.{u2}} [_inst_2 : TopologicalSpace.{u1} β] [_inst_3 : TopologicalSpace.{u2} γ] [_inst_4 : LinearOrder.{u2} γ] [_inst_5 : OrderClosedTopology.{u2} γ _inst_3 (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ (LinearOrder.toLattice.{u2} γ _inst_4))))] {ι : Type.{u3}} {s : Finset.{u3} ι} (H : Finset.Nonempty.{u3} ι s) (f : ι -> (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3)) (b : β), Eq.{succ u2} γ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) (fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (ContinuousMap.hasCoeToFun.{u1, u2} β γ _inst_2 _inst_3) (Finset.inf'.{max u1 u2, u3} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeInf.{u1, u2} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f) b) (Finset.inf'.{u2, u3} γ ι (Lattice.toSemilatticeInf.{u2} γ (LinearOrder.toLattice.{u2} γ _inst_4)) s H (fun (a : ι) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) (fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (ContinuousMap.hasCoeToFun.{u1, u2} β γ _inst_2 _inst_3) (f a) b))
but is expected to have type
  forall {β : Type.{u2}} {γ : Type.{u1}} [_inst_2 : TopologicalSpace.{u2} β] [_inst_3 : TopologicalSpace.{u1} γ] [_inst_4 : LinearOrder.{u1} γ] [_inst_5 : OrderClosedTopology.{u1} γ _inst_3 (PartialOrder.toPreorder.{u1} γ (SemilatticeInf.toPartialOrder.{u1} γ (Lattice.toSemilatticeInf.{u1} γ (DistribLattice.toLattice.{u1} γ (instDistribLattice.{u1} γ _inst_4)))))] {ι : Type.{u3}} {s : Finset.{u3} ι} (H : Finset.Nonempty.{u3} ι s) (f : ι -> (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3)) (b : β), Eq.{succ u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) b) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} β γ _inst_2 _inst_3)) (Finset.inf'.{max u2 u1, u3} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeInf.{u2, u1} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f) b) (Finset.inf'.{u1, u3} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) b) ι (Lattice.toSemilatticeInf.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) b) (DistribLattice.toLattice.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) b) (instDistribLattice.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) b) _inst_4))) s H (fun (a : ι) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} β γ _inst_2 _inst_3)) (f a) b))
Case conversion may be inaccurate. Consider using '#align continuous_map.inf'_apply ContinuousMap.inf'_applyₓ'. -/
theorem inf'_apply {ι : Type _} {s : Finset ι} (H : s.Nonempty) (f : ι → C(β, γ)) (b : β) :
    s.inf' H f b = s.inf' H fun a => f a b :=
  @sup'_apply _ γᵒᵈ _ _ _ _ _ _ H f b
#align continuous_map.inf'_apply ContinuousMap.inf'_apply

/- warning: continuous_map.inf'_coe -> ContinuousMap.inf'_coe is a dubious translation:
lean 3 declaration is
  forall {β : Type.{u1}} {γ : Type.{u2}} [_inst_2 : TopologicalSpace.{u1} β] [_inst_3 : TopologicalSpace.{u2} γ] [_inst_4 : LinearOrder.{u2} γ] [_inst_5 : OrderClosedTopology.{u2} γ _inst_3 (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ (LinearOrder.toLattice.{u2} γ _inst_4))))] {ι : Type.{u3}} {s : Finset.{u3} ι} (H : Finset.Nonempty.{u3} ι s) (f : ι -> (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3)), Eq.{max (succ u1) (succ u2)} ((fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (Finset.inf'.{max u1 u2, u3} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeInf.{u1, u2} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) (fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (ContinuousMap.hasCoeToFun.{u1, u2} β γ _inst_2 _inst_3) (Finset.inf'.{max u1 u2, u3} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeInf.{u1, u2} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f)) (Finset.inf'.{max u1 u2, u3} ((fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (Finset.inf'.{max u1 u2, u3} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeInf.{u1, u2} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f)) ι (Pi.semilatticeInf.{u1, u2} β (fun (ᾰ : β) => γ) (fun (i : β) => Lattice.toSemilatticeInf.{u2} γ (LinearOrder.toLattice.{u2} γ _inst_4))) s H (fun (a : ι) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) (fun (_x : ContinuousMap.{u1, u2} β γ _inst_2 _inst_3) => β -> γ) (ContinuousMap.hasCoeToFun.{u1, u2} β γ _inst_2 _inst_3) (f a)))
but is expected to have type
  forall {β : Type.{u2}} {γ : Type.{u1}} [_inst_2 : TopologicalSpace.{u2} β] [_inst_3 : TopologicalSpace.{u1} γ] [_inst_4 : LinearOrder.{u1} γ] [_inst_5 : OrderClosedTopology.{u1} γ _inst_3 (PartialOrder.toPreorder.{u1} γ (SemilatticeInf.toPartialOrder.{u1} γ (Lattice.toSemilatticeInf.{u1} γ (DistribLattice.toLattice.{u1} γ (instDistribLattice.{u1} γ _inst_4)))))] {ι : Type.{u3}} {s : Finset.{u3} ι} (H : Finset.Nonempty.{u3} ι s) (f : ι -> (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3)), Eq.{max (succ u2) (succ u1)} (forall (a : β), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} β γ _inst_2 _inst_3)) (Finset.inf'.{max u2 u1, u3} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) ι (ContinuousMap.semilatticeInf.{u2, u1} β γ _inst_2 _inst_3 _inst_4 _inst_5) s H f)) (Finset.inf'.{max u2 u1, u3} (forall (a : β), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) a) ι (Pi.semilatticeInf.{u2, u1} β (fun (ᾰ : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) ᾰ) (fun (i : β) => Lattice.toSemilatticeInf.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) i) (DistribLattice.toLattice.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) i) (instDistribLattice.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) i) _inst_4)))) s H (fun (a : ι) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : β) => γ) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} β γ _inst_2 _inst_3)) (f a)))
Case conversion may be inaccurate. Consider using '#align continuous_map.inf'_coe ContinuousMap.inf'_coeₓ'. -/
@[simp, norm_cast]
theorem inf'_coe {ι : Type _} {s : Finset ι} (H : s.Nonempty) (f : ι → C(β, γ)) :
    ((s.inf' H f : C(β, γ)) : ι → β) = s.inf' H fun a => (f a : β → γ) :=
  @sup'_coe _ γᵒᵈ _ _ _ _ _ _ H f
#align continuous_map.inf'_coe ContinuousMap.inf'_coe

end Inf'

end Lattice

section Extend

variable [LinearOrder α] [OrderTopology α] {a b : α} (h : a ≤ b)

#print ContinuousMap.IccExtend /-
/-- Extend a continuous function `f : C(set.Icc a b, β)` to a function `f : C(α, β)`.
-/
def IccExtend (f : C(Set.Icc a b, β)) : C(α, β) :=
  ⟨Set.IccExtend h f⟩
#align continuous_map.Icc_extend ContinuousMap.IccExtend
-/

/- warning: continuous_map.coe_Icc_extend -> ContinuousMap.coe_IccExtend is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : TopologicalSpace.{u2} β] [_inst_4 : LinearOrder.{u1} α] [_inst_5 : OrderTopology.{u1} α _inst_1 (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4))))] {a : α} {b : α} (h : LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4))))) a b) (f : ContinuousMap.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) (Set.Icc.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4)))) a b)) β (Subtype.topologicalSpace.{u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x (Set.Icc.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4)))) a b)) _inst_1) _inst_2), Eq.{max (succ u1) (succ u2)} ((fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.IccExtend.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5 a b h f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 _inst_2) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 _inst_2) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (ContinuousMap.IccExtend.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5 a b h f)) (Set.IccExtend.{u1, u2} α β _inst_4 a b h (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) (Set.Icc.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4)))) a b)) β (Subtype.topologicalSpace.{u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x (Set.Icc.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4)))) a b)) _inst_1) _inst_2) (fun (_x : ContinuousMap.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) (Set.Icc.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4)))) a b)) β (Subtype.topologicalSpace.{u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x (Set.Icc.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4)))) a b)) _inst_1) _inst_2) => (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) (Set.Icc.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4)))) a b)) -> β) (ContinuousMap.hasCoeToFun.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) (Set.Icc.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4)))) a b)) β (Subtype.topologicalSpace.{u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x (Set.Icc.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_4)))) a b)) _inst_1) _inst_2) f))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : TopologicalSpace.{u1} β] [_inst_4 : LinearOrder.{u2} α] [_inst_5 : OrderTopology.{u2} α _inst_1 (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4)))))] {a : α} {b : α} (h : LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4)))))) a b) (f : ContinuousMap.{u2, u1} (Set.Elem.{u2} α (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) β (instTopologicalSpaceSubtype.{u2} α (fun (x : α) => Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) x (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) _inst_1) _inst_2), Eq.{max (succ u2) (succ u1)} (forall (a : α), (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 _inst_2)) (ContinuousMap.IccExtend.{u2, u1} α β _inst_1 _inst_2 _inst_4 _inst_5 a b h f)) (Set.IccExtend.{u2, u1} α β _inst_4 a b h (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} (Set.Elem.{u2} α (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) β (instTopologicalSpaceSubtype.{u2} α (fun (x : α) => Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) x (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) _inst_1) _inst_2) (Set.Elem.{u2} α (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) (fun (_x : Set.Elem.{u2} α (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : Set.Elem.{u2} α (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} (Set.Elem.{u2} α (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) β (instTopologicalSpaceSubtype.{u2} α (fun (x : α) => Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) x (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) _inst_1) _inst_2) (Set.Elem.{u2} α (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) β (instTopologicalSpaceSubtype.{u2} α (fun (x : α) => Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) x (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) _inst_1) _inst_2 (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} (Set.Elem.{u2} α (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) β (instTopologicalSpaceSubtype.{u2} α (fun (x : α) => Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) x (Set.Icc.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_4))))) a b)) _inst_1) _inst_2)) f))
Case conversion may be inaccurate. Consider using '#align continuous_map.coe_Icc_extend ContinuousMap.coe_IccExtendₓ'. -/
@[simp]
theorem coe_IccExtend (f : C(Set.Icc a b, β)) :
    ((IccExtend h f : C(α, β)) : α → β) = Set.IccExtend h f :=
  rfl
#align continuous_map.coe_Icc_extend ContinuousMap.coe_IccExtend

end Extend

end ContinuousMap

