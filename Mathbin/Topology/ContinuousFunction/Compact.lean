/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module topology.continuous_function.compact
! leanprover-community/mathlib commit 0b7c740e25651db0ba63648fbae9f9d6f941e31b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Topology.ContinuousFunction.Bounded
import Mathbin.Topology.UniformSpace.Compact
import Mathbin.Topology.CompactOpen
import Mathbin.Topology.Sets.Compacts

/-!
# Continuous functions on a compact space

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Continuous functions `C(α, β)` from a compact space `α` to a metric space `β`
are automatically bounded, and so acquire various structures inherited from `α →ᵇ β`.

This file transfers these structures, and restates some lemmas
characterising these structures.

If you need a lemma which is proved about `α →ᵇ β` but not for `C(α, β)` when `α` is compact,
you should restate it here. You can also use
`bounded_continuous_function.equiv_continuous_map_of_compact` to move functions back and forth.

-/


noncomputable section

open Topology Classical NNReal BoundedContinuousFunction BigOperators

open Set Filter Metric

open BoundedContinuousFunction

namespace ContinuousMap

variable {α β E : Type _} [TopologicalSpace α] [CompactSpace α] [MetricSpace β]
  [NormedAddCommGroup E]

section

variable (α β)

#print ContinuousMap.equivBoundedOfCompact /-
/-- When `α` is compact, the bounded continuous maps `α →ᵇ β` are
equivalent to `C(α, β)`.
-/
@[simps (config := { fullyApplied := false })]
def equivBoundedOfCompact : C(α, β) ≃ (α →ᵇ β) :=
  ⟨mkOfCompact, BoundedContinuousFunction.toContinuousMap, fun f => by ext; rfl, fun f => by ext;
    rfl⟩
#align continuous_map.equiv_bounded_of_compact ContinuousMap.equivBoundedOfCompact
-/

/- warning: continuous_map.uniform_inducing_equiv_bounded_of_compact -> ContinuousMap.uniformInducing_equivBoundedOfCompact is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β], UniformInducing.{max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (ContinuousMap.compactConvergenceUniformSpace.{u1, u2} α β _inst_1 (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) => (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) -> (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (ContinuousMap.equivBoundedOfCompact.{u1, u2} α β _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall (α : Type.{u2}) (β : Type.{u1}) [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β], UniformInducing.{max u2 u1, max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) (ContinuousMap.compactConvergenceUniformSpace.{u2, u1} α β _inst_1 (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (PseudoMetricSpace.toUniformSpace.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (fun (_x : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) => BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.equivBoundedOfCompact.{u2, u1} α β _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align continuous_map.uniform_inducing_equiv_bounded_of_compact ContinuousMap.uniformInducing_equivBoundedOfCompactₓ'. -/
theorem uniformInducing_equivBoundedOfCompact : UniformInducing (equivBoundedOfCompact α β) :=
  UniformInducing.mk'
    (by
      simp only [has_basis_compact_convergence_uniformity.mem_iff, uniformity_basis_dist_le.mem_iff]
      exact fun s =>
        ⟨fun ⟨⟨a, b⟩, ⟨ha, ⟨ε, hε, hb⟩⟩, hs⟩ =>
          ⟨{ p | ∀ x, (p.1 x, p.2 x) ∈ b }, ⟨ε, hε, fun _ h x => hb ((dist_le hε.le).mp h x)⟩,
            fun f g h => hs fun x hx => h x⟩,
          fun ⟨t, ⟨ε, hε, ht⟩, hs⟩ =>
          ⟨⟨Set.univ, { p | dist p.1 p.2 ≤ ε }⟩, ⟨isCompact_univ, ⟨ε, hε, fun _ h => h⟩⟩,
            fun ⟨f, g⟩ h => hs _ _ (ht ((dist_le hε.le).mpr fun x => h x (mem_univ x)))⟩⟩)
#align continuous_map.uniform_inducing_equiv_bounded_of_compact ContinuousMap.uniformInducing_equivBoundedOfCompact

/- warning: continuous_map.uniform_embedding_equiv_bounded_of_compact -> ContinuousMap.uniformEmbedding_equivBoundedOfCompact is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β], UniformEmbedding.{max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (ContinuousMap.compactConvergenceUniformSpace.{u1, u2} α β _inst_1 (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (PseudoMetricSpace.toUniformSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ (max u1 u2))) (succ (max u1 u2)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ (max u1 u2))} (Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (fun (_x : Equiv.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) => (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) -> (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), succ (max u1 u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (ContinuousMap.equivBoundedOfCompact.{u1, u2} α β _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall (α : Type.{u2}) (β : Type.{u1}) [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β], UniformEmbedding.{max u2 u1, max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) (ContinuousMap.compactConvergenceUniformSpace.{u2, u1} α β _inst_1 (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (PseudoMetricSpace.toUniformSpace.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) (BoundedContinuousFunction.instPseudoMetricSpaceBoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (fun (_x : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) => BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.equivBoundedOfCompact.{u2, u1} α β _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align continuous_map.uniform_embedding_equiv_bounded_of_compact ContinuousMap.uniformEmbedding_equivBoundedOfCompactₓ'. -/
theorem uniformEmbedding_equivBoundedOfCompact : UniformEmbedding (equivBoundedOfCompact α β) :=
  { uniformInducing_equivBoundedOfCompact α β with inj := (equivBoundedOfCompact α β).Injective }
#align continuous_map.uniform_embedding_equiv_bounded_of_compact ContinuousMap.uniformEmbedding_equivBoundedOfCompact

/- warning: continuous_map.add_equiv_bounded_of_compact -> ContinuousMap.addEquivBoundedOfCompact is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] [_inst_5 : AddMonoid.{u2} β] [_inst_6 : LipschitzAdd.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3) _inst_5], AddEquiv.{max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (ContinuousMap.instAdd.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β _inst_5)) (ContinuousMap.addEquivBoundedOfCompact._proof_1.{u2} β _inst_3 _inst_5 _inst_6)) (BoundedContinuousFunction.hasAdd.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3) _inst_5 _inst_6)
but is expected to have type
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] [_inst_5 : AddMonoid.{u2} β] [_inst_6 : LipschitzAdd.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3) _inst_5], AddEquiv.{max u2 u1, max u2 u1} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (ContinuousMap.instAdd.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β _inst_5)) (LipschitzAdd.continuousAdd.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3) _inst_5 _inst_6)) (BoundedContinuousFunction.instAddBoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3) _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align continuous_map.add_equiv_bounded_of_compact ContinuousMap.addEquivBoundedOfCompactₓ'. -/
/-- When `α` is compact, the bounded continuous maps `α →ᵇ 𝕜` are
additively equivalent to `C(α, 𝕜)`.
-/
@[simps (config := { fullyApplied := false }) apply symm_apply]
def addEquivBoundedOfCompact [AddMonoid β] [LipschitzAdd β] : C(α, β) ≃+ (α →ᵇ β) :=
  ({ toContinuousMapAddHom α β, (equivBoundedOfCompact α β).symm with } : (α →ᵇ β) ≃+ C(α, β)).symm
#align continuous_map.add_equiv_bounded_of_compact ContinuousMap.addEquivBoundedOfCompact

instance : MetricSpace C(α, β) :=
  (uniformEmbedding_equivBoundedOfCompact α β).comapMetricSpace _

/- warning: continuous_map.isometry_equiv_bounded_of_compact -> ContinuousMap.isometryEquivBoundedOfCompact is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β], IsometryEquiv.{max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) (PseudoMetricSpace.toPseudoEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (BoundedContinuousFunction.pseudoMetricSpace.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))
but is expected to have type
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β], IsometryEquiv.{max u2 u1, max u2 u1} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (EMetricSpace.toPseudoEMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toEMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) (EMetricSpace.toPseudoEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (MetricSpace.toEMetricSpace.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (BoundedContinuousFunction.instMetricSpaceBoundedContinuousFunctionToPseudoMetricSpace.{u1, u2} α β _inst_1 _inst_3)))
Case conversion may be inaccurate. Consider using '#align continuous_map.isometry_equiv_bounded_of_compact ContinuousMap.isometryEquivBoundedOfCompactₓ'. -/
/-- When `α` is compact, and `β` is a metric space, the bounded continuous maps `α →ᵇ β` are
isometric to `C(α, β)`.
-/
@[simps (config := { fullyApplied := false }) toEquiv apply symm_apply]
def isometryEquivBoundedOfCompact : C(α, β) ≃ᵢ (α →ᵇ β)
    where
  isometry_toFun x y := rfl
  toEquiv := equivBoundedOfCompact α β
#align continuous_map.isometry_equiv_bounded_of_compact ContinuousMap.isometryEquivBoundedOfCompact

end

/- warning: bounded_continuous_function.dist_mk_of_compact -> BoundedContinuousFunction.dist_mkOfCompact is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))), Eq.{1} Real (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3) _inst_2 f) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3) _inst_2 g)) (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β] (f : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (g : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))), Eq.{1} Real (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) (BoundedContinuousFunction.mkOfCompact.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3) _inst_2 f) (BoundedContinuousFunction.mkOfCompact.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3) _inst_2 g)) (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} α β _inst_1 _inst_2 _inst_3))) f g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_mk_of_compact BoundedContinuousFunction.dist_mkOfCompactₓ'. -/
@[simp]
theorem BoundedContinuousFunction.dist_mkOfCompact (f g : C(α, β)) :
    dist (mkOfCompact f) (mkOfCompact g) = dist f g :=
  rfl
#align bounded_continuous_function.dist_mk_of_compact BoundedContinuousFunction.dist_mkOfCompact

/- warning: bounded_continuous_function.dist_to_continuous_map -> BoundedContinuousFunction.dist_toContinuousMap is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] (f : BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (g : BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)), Eq.{1} Real (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) (BoundedContinuousFunction.toContinuousMap.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3) f) (BoundedContinuousFunction.toContinuousMap.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3) g)) (Dist.dist.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (BoundedContinuousFunction.hasDist.{u1, u2} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β] (f : BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) (g : BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)), Eq.{1} Real (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} α β _inst_1 _inst_2 _inst_3))) (BoundedContinuousFunction.toContinuousMap.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3) f) (BoundedContinuousFunction.toContinuousMap.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3) g)) (Dist.dist.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) (BoundedContinuousFunction.instDistBoundedContinuousFunction.{u2, u1} α β _inst_1 (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)) f g)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.dist_to_continuous_map BoundedContinuousFunction.dist_toContinuousMapₓ'. -/
@[simp]
theorem BoundedContinuousFunction.dist_toContinuousMap (f g : α →ᵇ β) :
    dist f.toContinuousMap g.toContinuousMap = dist f g :=
  rfl
#align bounded_continuous_function.dist_to_continuous_map BoundedContinuousFunction.dist_toContinuousMap

open BoundedContinuousFunction

section

variable {α β} {f g : C(α, β)} {C : ℝ}

/- warning: continuous_map.dist_apply_le_dist -> ContinuousMap.dist_apply_le_dist is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} (x : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) g x)) (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) f g)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} (x : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (PseudoMetricSpace.toDist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (MetricSpace.toPseudoMetricSpace.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_3)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))))) g x)) (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (PseudoMetricSpace.toDist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) f g)
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_apply_le_dist ContinuousMap.dist_apply_le_distₓ'. -/
/-- The pointwise distance is controlled by the distance between functions, by definition. -/
theorem dist_apply_le_dist (x : α) : dist (f x) (g x) ≤ dist f g := by
  simp only [← dist_mk_of_compact, dist_coe_le_dist, ← mk_of_compact_apply]
#align continuous_map.dist_apply_le_dist ContinuousMap.dist_apply_le_dist

/- warning: continuous_map.dist_le -> ContinuousMap.dist_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {C : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (Iff (LE.le.{0} Real Real.hasLe (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) g x)) C))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β] {f : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))} {g : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))} {C : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (Iff (LE.le.{0} Real Real.instLEReal (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} α β _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) g x)) C))
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_le ContinuousMap.dist_leₓ'. -/
/-- The distance between two functions is controlled by the supremum of the pointwise distances -/
theorem dist_le (C0 : (0 : ℝ) ≤ C) : dist f g ≤ C ↔ ∀ x : α, dist (f x) (g x) ≤ C := by
  simp only [← dist_mk_of_compact, dist_le C0, mk_of_compact_apply]
#align continuous_map.dist_le ContinuousMap.dist_le

/- warning: continuous_map.dist_le_iff_of_nonempty -> ContinuousMap.dist_le_iff_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u1} α], Iff (LE.le.{0} Real Real.hasLe (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) g x)) C)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β] {f : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))} {g : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u2} α], Iff (LE.le.{0} Real Real.instLEReal (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} α β _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) g x)) C)
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_le_iff_of_nonempty ContinuousMap.dist_le_iff_of_nonemptyₓ'. -/
theorem dist_le_iff_of_nonempty [Nonempty α] : dist f g ≤ C ↔ ∀ x, dist (f x) (g x) ≤ C := by
  simp only [← dist_mk_of_compact, dist_le_iff_of_nonempty, mk_of_compact_apply]
#align continuous_map.dist_le_iff_of_nonempty ContinuousMap.dist_le_iff_of_nonempty

/- warning: continuous_map.dist_lt_iff_of_nonempty -> ContinuousMap.dist_lt_iff_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u1} α], Iff (LT.lt.{0} Real Real.hasLt (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : α), LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) g x)) C)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β] {f : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))} {g : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u2} α], Iff (LT.lt.{0} Real Real.instLTReal (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} α β _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : α), LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) g x)) C)
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_lt_iff_of_nonempty ContinuousMap.dist_lt_iff_of_nonemptyₓ'. -/
theorem dist_lt_iff_of_nonempty [Nonempty α] : dist f g < C ↔ ∀ x : α, dist (f x) (g x) < C := by
  simp only [← dist_mk_of_compact, dist_lt_iff_of_nonempty_compact, mk_of_compact_apply]
#align continuous_map.dist_lt_iff_of_nonempty ContinuousMap.dist_lt_iff_of_nonempty

/- warning: continuous_map.dist_lt_of_nonempty -> ContinuousMap.dist_lt_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u1} α], (forall (x : α), LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) g x)) C) -> (LT.lt.{0} Real Real.hasLt (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) f g) C)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β] {f : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))} {g : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))} {C : Real} [_inst_5 : Nonempty.{succ u2} α], (forall (x : α), LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) g x)) C) -> (LT.lt.{0} Real Real.instLTReal (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} α β _inst_1 _inst_2 _inst_3))) f g) C)
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_lt_of_nonempty ContinuousMap.dist_lt_of_nonemptyₓ'. -/
theorem dist_lt_of_nonempty [Nonempty α] (w : ∀ x : α, dist (f x) (g x) < C) : dist f g < C :=
  dist_lt_iff_of_nonempty.2 w
#align continuous_map.dist_lt_of_nonempty ContinuousMap.dist_lt_of_nonempty

/- warning: continuous_map.dist_lt_iff -> ContinuousMap.dist_lt_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] {f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {g : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))} {C : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (Iff (LT.lt.{0} Real Real.hasLt (Dist.dist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (PseudoMetricSpace.toHasDist.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ContinuousMap.metricSpace.{u1, u2} α β _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : α), LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) g x)) C))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β] {f : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))} {g : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))} {C : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (Iff (LT.lt.{0} Real Real.instLTReal (Dist.dist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (PseudoMetricSpace.toDist.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (MetricSpace.toPseudoMetricSpace.{max u2 u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (ContinuousMap.metricSpace.{u2, u1} α β _inst_1 _inst_2 _inst_3))) f g) C) (forall (x : α), LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) g x)) C))
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_lt_iff ContinuousMap.dist_lt_iffₓ'. -/
theorem dist_lt_iff (C0 : (0 : ℝ) < C) : dist f g < C ↔ ∀ x : α, dist (f x) (g x) < C := by
  simp only [← dist_mk_of_compact, dist_lt_iff_of_compact C0, mk_of_compact_apply]
#align continuous_map.dist_lt_iff ContinuousMap.dist_lt_iff

end

instance [CompleteSpace β] : CompleteSpace C(α, β) :=
  (isometryEquivBoundedOfCompact α β).CompleteSpace

/- warning: continuous_map.continuous_eval -> ContinuousMap.continuous_eval is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β], Continuous.{max u1 u2, u2} (Prod.{max u1 u2, u1} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α) β (Prod.topologicalSpace.{max u1 u2, u1} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α (ContinuousMap.compactOpen.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) _inst_1) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (fun (p : Prod.{max u1 u2, u1} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (Prod.fst.{max u1 u2, u1} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α p) (Prod.snd.{max u1 u2, u1} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α p))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β], Continuous.{max u2 u1, u1} (Prod.{max u1 u2, u2} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α) β (instTopologicalSpaceProd.{max u2 u1, u2} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (ContinuousMap.compactOpen.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) _inst_1) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (fun (p : Prod.{max u1 u2, u2} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) (Prod.fst.{max u2 u1, u2} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α p) (Prod.snd.{max u2 u1, u2} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α p))
Case conversion may be inaccurate. Consider using '#align continuous_map.continuous_eval ContinuousMap.continuous_evalₓ'. -/
/-- See also `continuous_map.continuous_eval'` -/
@[continuity]
theorem continuous_eval : Continuous fun p : C(α, β) × α => p.1 p.2 :=
  continuous_eval.comp ((isometryEquivBoundedOfCompact α β).Continuous.Prod_map continuous_id)
#align continuous_map.continuous_eval ContinuousMap.continuous_eval

/- warning: continuous_map.continuous_eval_const -> ContinuousMap.continuous_eval_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β] (x : α), Continuous.{max u1 u2, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) β (ContinuousMap.compactOpen.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (fun (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) f x)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_3 : MetricSpace.{u1} β] (x : α), Continuous.{max u2 u1, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (ContinuousMap.compactOpen.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (UniformSpace.toTopologicalSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (PseudoMetricSpace.toUniformSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) x) _inst_3))) (fun (f : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) f x)
Case conversion may be inaccurate. Consider using '#align continuous_map.continuous_eval_const ContinuousMap.continuous_eval_constₓ'. -/
/-- See also `continuous_map.continuous_eval_const` -/
@[continuity]
theorem continuous_eval_const (x : α) : Continuous fun f : C(α, β) => f x :=
  continuous_eval.comp (continuous_id.prod_mk continuous_const)
#align continuous_map.continuous_eval_const ContinuousMap.continuous_eval_const

/- warning: continuous_map.continuous_coe -> ContinuousMap.continuous_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β], Continuous.{max u1 u2, max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (α -> β) (ContinuousMap.compactOpen.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (Pi.topologicalSpace.{u1, u2} α (fun (ᾰ : α) => β) (fun (a : α) => UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (ᾰ : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_3 : MetricSpace.{u2} β], Continuous.{max u2 u1, max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (α -> β) (ContinuousMap.compactOpen.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (Pi.topologicalSpace.{u1, u2} α (fun (ᾰ : α) => β) (fun (a : α) => UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α (fun (ᾰ : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) ᾰ) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3))))))
Case conversion may be inaccurate. Consider using '#align continuous_map.continuous_coe ContinuousMap.continuous_coeₓ'. -/
/-- See also `continuous_map.continuous_coe'` -/
theorem continuous_coe : @Continuous C(α, β) (α → β) _ _ coeFn :=
  continuous_pi continuous_eval_const
#align continuous_map.continuous_coe ContinuousMap.continuous_coe

-- TODO at some point we will need lemmas characterising this norm!
-- At the moment the only way to reason about it is to transfer `f : C(α,E)` back to `α →ᵇ E`.
instance : Norm C(α, E) where norm x := dist x 0

/- warning: bounded_continuous_function.norm_mk_of_compact -> BoundedContinuousFunction.norm_mkOfCompact is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))) (BoundedContinuousFunction.hasNorm.{u1, u2} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)) _inst_2 f)) (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} α E _inst_1 _inst_2 _inst_4) f)
but is expected to have type
  forall {α : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))), Eq.{1} Real (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u2, u1} α E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u2, u1} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)) (BoundedContinuousFunction.mkOfCompact.{u2, u1} α E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)) _inst_2 f)) (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} α E _inst_1 _inst_2 _inst_4) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_mk_of_compact BoundedContinuousFunction.norm_mkOfCompactₓ'. -/
@[simp]
theorem BoundedContinuousFunction.norm_mkOfCompact (f : C(α, E)) : ‖mkOfCompact f‖ = ‖f‖ :=
  rfl
#align bounded_continuous_function.norm_mk_of_compact BoundedContinuousFunction.norm_mkOfCompact

/- warning: bounded_continuous_function.norm_to_continuous_map_eq -> BoundedContinuousFunction.norm_toContinuousMap_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : BoundedContinuousFunction.{u1, u2} α E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))), Eq.{1} Real (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} α E _inst_1 _inst_2 _inst_4) (BoundedContinuousFunction.toContinuousMap.{u1, u2} α E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)) f)) (Norm.norm.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))) (BoundedContinuousFunction.hasNorm.{u1, u2} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)) f)
but is expected to have type
  forall {α : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : BoundedContinuousFunction.{u2, u1} α E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))), Eq.{1} Real (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} α E _inst_1 _inst_2 _inst_4) (BoundedContinuousFunction.toContinuousMap.{u2, u1} α E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)) f)) (Norm.norm.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α E _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))) (BoundedContinuousFunction.instNormBoundedContinuousFunctionToPseudoMetricSpace.{u2, u1} α E _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)) f)
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.norm_to_continuous_map_eq BoundedContinuousFunction.norm_toContinuousMap_eqₓ'. -/
@[simp]
theorem BoundedContinuousFunction.norm_toContinuousMap_eq (f : α →ᵇ E) :
    ‖f.toContinuousMap‖ = ‖f‖ :=
  rfl
#align bounded_continuous_function.norm_to_continuous_map_eq BoundedContinuousFunction.norm_toContinuousMap_eq

open BoundedContinuousFunction

instance : NormedAddCommGroup C(α, E) :=
  { ContinuousMap.metricSpace _ _,
    ContinuousMap.addCommGroup with
    dist_eq := fun x y => by
      rw [← norm_mk_of_compact, ← dist_mk_of_compact, dist_eq_norm, mk_of_compact_sub]
    dist := dist
    norm := norm }

instance [Nonempty α] [One E] [NormOneClass E] : NormOneClass C(α, E)
    where norm_one := by simp only [← norm_mk_of_compact, mk_of_compact_one, norm_one]

section

variable (f : C(α, E))

/- warning: continuous_map.norm_coe_le_norm -> ContinuousMap.norm_coe_le_norm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => α -> E) (ContinuousMap.hasCoeToFun.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} α E _inst_1 _inst_2 _inst_4) f)
but is expected to have type
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (NormedAddCommGroup.toNorm.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) _inst_4) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))))) f x)) (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u1, u2} α E _inst_1 _inst_2 _inst_4) f)
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_coe_le_norm ContinuousMap.norm_coe_le_normₓ'. -/
-- The corresponding lemmas for `bounded_continuous_function` are stated with `{f}`,
-- and so can not be used in dot notation.
theorem norm_coe_le_norm (x : α) : ‖f x‖ ≤ ‖f‖ :=
  (mkOfCompact f).norm_coe_le_norm x
#align continuous_map.norm_coe_le_norm ContinuousMap.norm_coe_le_norm

/- warning: continuous_map.dist_le_two_norm -> ContinuousMap.dist_le_two_norm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (x : α) (y : α), LE.le.{0} Real Real.hasLe (Dist.dist.{u2} E (PseudoMetricSpace.toHasDist.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => α -> E) (ContinuousMap.hasCoeToFun.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => α -> E) (ContinuousMap.hasCoeToFun.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.hasMul) (OfNat.ofNat.{0} Real 2 (OfNat.mk.{0} Real 2 (bit0.{0} Real Real.hasAdd (One.one.{0} Real Real.hasOne)))) (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} α E _inst_1 _inst_2 _inst_4) f))
but is expected to have type
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (x : α) (y : α), LE.le.{0} Real Real.instLEReal (Dist.dist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (PseudoMetricSpace.toDist.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) _inst_4))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) _x) (ContinuousMapClass.toFunLike.{max u1 u2, u1, u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4)))))) f y)) (HMul.hMul.{0, 0, 0} Real Real Real (instHMul.{0} Real Real.instMulReal) (OfNat.ofNat.{0} Real 2 (instOfNat.{0} Real 2 Real.natCast (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u1, u2} α E _inst_1 _inst_2 _inst_4) f))
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_le_two_norm ContinuousMap.dist_le_two_normₓ'. -/
/-- Distance between the images of any two points is at most twice the norm of the function. -/
theorem dist_le_two_norm (x y : α) : dist (f x) (f y) ≤ 2 * ‖f‖ :=
  (mkOfCompact f).dist_le_two_norm x y
#align continuous_map.dist_le_two_norm ContinuousMap.dist_le_two_norm

/- warning: continuous_map.norm_le -> ContinuousMap.norm_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) {C : Real}, (LE.le.{0} Real Real.hasLe (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) C) -> (Iff (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} α E _inst_1 _inst_2 _inst_4) f) C) (forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => α -> E) (ContinuousMap.hasCoeToFun.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) C))
but is expected to have type
  forall {α : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) {C : Real}, (LE.le.{0} Real Real.instLEReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) C) -> (Iff (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} α E _inst_1 _inst_2 _inst_4) f) C) (forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (NormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) C))
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_le ContinuousMap.norm_leₓ'. -/
/-- The norm of a function is controlled by the supremum of the pointwise norms -/
theorem norm_le {C : ℝ} (C0 : (0 : ℝ) ≤ C) : ‖f‖ ≤ C ↔ ∀ x : α, ‖f x‖ ≤ C :=
  @BoundedContinuousFunction.norm_le _ _ _ _ (mkOfCompact f) _ C0
#align continuous_map.norm_le ContinuousMap.norm_le

/- warning: continuous_map.norm_le_of_nonempty -> ContinuousMap.norm_le_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) [_inst_5 : Nonempty.{succ u1} α] {M : Real}, Iff (LE.le.{0} Real Real.hasLe (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} α E _inst_1 _inst_2 _inst_4) f) M) (forall (x : α), LE.le.{0} Real Real.hasLe (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => α -> E) (ContinuousMap.hasCoeToFun.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) M)
but is expected to have type
  forall {α : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) [_inst_5 : Nonempty.{succ u2} α] {M : Real}, Iff (LE.le.{0} Real Real.instLEReal (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} α E _inst_1 _inst_2 _inst_4) f) M) (forall (x : α), LE.le.{0} Real Real.instLEReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (NormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) M)
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_le_of_nonempty ContinuousMap.norm_le_of_nonemptyₓ'. -/
theorem norm_le_of_nonempty [Nonempty α] {M : ℝ} : ‖f‖ ≤ M ↔ ∀ x, ‖f x‖ ≤ M :=
  @BoundedContinuousFunction.norm_le_of_nonempty _ _ _ _ _ (mkOfCompact f) _
#align continuous_map.norm_le_of_nonempty ContinuousMap.norm_le_of_nonempty

/- warning: continuous_map.norm_lt_iff -> ContinuousMap.norm_lt_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) {M : Real}, (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) M) -> (Iff (LT.lt.{0} Real Real.hasLt (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} α E _inst_1 _inst_2 _inst_4) f) M) (forall (x : α), LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => α -> E) (ContinuousMap.hasCoeToFun.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) M))
but is expected to have type
  forall {α : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) {M : Real}, (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) M) -> (Iff (LT.lt.{0} Real Real.instLTReal (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} α E _inst_1 _inst_2 _inst_4) f) M) (forall (x : α), LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (NormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) M))
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_lt_iff ContinuousMap.norm_lt_iffₓ'. -/
theorem norm_lt_iff {M : ℝ} (M0 : 0 < M) : ‖f‖ < M ↔ ∀ x, ‖f x‖ < M :=
  @BoundedContinuousFunction.norm_lt_iff_of_compact _ _ _ _ _ (mkOfCompact f) _ M0
#align continuous_map.norm_lt_iff ContinuousMap.norm_lt_iff

/- warning: continuous_map.nnnorm_lt_iff -> ContinuousMap.nnnorm_lt_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) {M : NNReal}, (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (OfNat.ofNat.{0} NNReal 0 (OfNat.mk.{0} NNReal 0 (Zero.zero.{0} NNReal (MulZeroClass.toHasZero.{0} NNReal (NonUnitalNonAssocSemiring.toMulZeroClass.{0} NNReal (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} NNReal (Semiring.toNonAssocSemiring.{0} NNReal NNReal.semiring))))))) M) -> (Iff (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (SeminormedAddGroup.toNNNorm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (NormedAddCommGroup.toSeminormedAddCommGroup.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.normedAddCommGroup.{u1, u2} α E _inst_1 _inst_2 _inst_4)))) f) M) (forall (x : α), LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{u2} E (SeminormedAddGroup.toNNNorm.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => α -> E) (ContinuousMap.hasCoeToFun.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) M))
but is expected to have type
  forall {α : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) {M : NNReal}, (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (OfNat.ofNat.{0} NNReal 0 (Zero.toOfNat0.{0} NNReal instNNRealZero)) M) -> (Iff (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (SeminormedAddGroup.toNNNorm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (NormedAddCommGroup.toSeminormedAddCommGroup.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormedAddCommGroupContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} α E _inst_1 _inst_2 _inst_4)))) f) M) (forall (x : α), LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (SeminormedAddGroup.toNNNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) _inst_4))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) M))
Case conversion may be inaccurate. Consider using '#align continuous_map.nnnorm_lt_iff ContinuousMap.nnnorm_lt_iffₓ'. -/
theorem nnnorm_lt_iff {M : ℝ≥0} (M0 : 0 < M) : ‖f‖₊ < M ↔ ∀ x : α, ‖f x‖₊ < M :=
  f.norm_lt_iff M0
#align continuous_map.nnnorm_lt_iff ContinuousMap.nnnorm_lt_iff

/- warning: continuous_map.norm_lt_iff_of_nonempty -> ContinuousMap.norm_lt_iff_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) [_inst_5 : Nonempty.{succ u1} α] {M : Real}, Iff (LT.lt.{0} Real Real.hasLt (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} α E _inst_1 _inst_2 _inst_4) f) M) (forall (x : α), LT.lt.{0} Real Real.hasLt (Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => α -> E) (ContinuousMap.hasCoeToFun.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) M)
but is expected to have type
  forall {α : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) [_inst_5 : Nonempty.{succ u2} α] {M : Real}, Iff (LT.lt.{0} Real Real.instLTReal (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} α E _inst_1 _inst_2 _inst_4) f) M) (forall (x : α), LT.lt.{0} Real Real.instLTReal (Norm.norm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (NormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) M)
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_lt_iff_of_nonempty ContinuousMap.norm_lt_iff_of_nonemptyₓ'. -/
theorem norm_lt_iff_of_nonempty [Nonempty α] {M : ℝ} : ‖f‖ < M ↔ ∀ x, ‖f x‖ < M :=
  @BoundedContinuousFunction.norm_lt_iff_of_nonempty_compact _ _ _ _ _ _ (mkOfCompact f) _
#align continuous_map.norm_lt_iff_of_nonempty ContinuousMap.norm_lt_iff_of_nonempty

/- warning: continuous_map.nnnorm_lt_iff_of_nonempty -> ContinuousMap.nnnorm_lt_iff_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) [_inst_5 : Nonempty.{succ u1} α] {M : NNReal}, Iff (LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (SeminormedAddGroup.toNNNorm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (NormedAddCommGroup.toSeminormedAddCommGroup.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.normedAddCommGroup.{u1, u2} α E _inst_1 _inst_2 _inst_4)))) f) M) (forall (x : α), LT.lt.{0} NNReal (Preorder.toHasLt.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (OrderedCancelAddCommMonoid.toPartialOrder.{0} NNReal (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} NNReal NNReal.strictOrderedSemiring)))) (NNNorm.nnnorm.{u2} E (SeminormedAddGroup.toNNNorm.{u2} E (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => α -> E) (ContinuousMap.hasCoeToFun.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)) M)
but is expected to have type
  forall {α : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) [_inst_5 : Nonempty.{succ u2} α] {M : NNReal}, Iff (LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (SeminormedAddGroup.toNNNorm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (SeminormedAddCommGroup.toSeminormedAddGroup.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (NormedAddCommGroup.toSeminormedAddCommGroup.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormedAddCommGroupContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} α E _inst_1 _inst_2 _inst_4)))) f) M) (forall (x : α), LT.lt.{0} NNReal (Preorder.toLT.{0} NNReal (PartialOrder.toPreorder.{0} NNReal (StrictOrderedSemiring.toPartialOrder.{0} NNReal instNNRealStrictOrderedSemiring))) (NNNorm.nnnorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (SeminormedAddGroup.toNNNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (SeminormedAddCommGroup.toSeminormedAddGroup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) _inst_4))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)) M)
Case conversion may be inaccurate. Consider using '#align continuous_map.nnnorm_lt_iff_of_nonempty ContinuousMap.nnnorm_lt_iff_of_nonemptyₓ'. -/
theorem nnnorm_lt_iff_of_nonempty [Nonempty α] {M : ℝ≥0} : ‖f‖₊ < M ↔ ∀ x, ‖f x‖₊ < M :=
  f.norm_lt_iff_of_nonempty
#align continuous_map.nnnorm_lt_iff_of_nonempty ContinuousMap.nnnorm_lt_iff_of_nonempty

/- warning: continuous_map.apply_le_norm -> ContinuousMap.apply_le_norm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (x : α), LE.le.{0} Real Real.hasLe (coeFn.{succ u1, succ u1} (ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => α -> Real) (ContinuousMap.hasCoeToFun.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f x) (Norm.norm.{u1} (ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.hasNorm.{u1, 0} α Real _inst_1 _inst_2 Real.normedAddCommGroup) f)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (x : α), LE.le.{0} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => Real) x) Real.instLEReal (FunLike.coe.{succ u1, succ u1, 1} (ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f x) (Norm.norm.{u1} (ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u1, 0} α Real _inst_1 _inst_2 Real.normedAddCommGroup) f)
Case conversion may be inaccurate. Consider using '#align continuous_map.apply_le_norm ContinuousMap.apply_le_normₓ'. -/
theorem apply_le_norm (f : C(α, ℝ)) (x : α) : f x ≤ ‖f‖ :=
  le_trans (le_abs.mpr (Or.inl (le_refl (f x)))) (f.norm_coe_le_norm x)
#align continuous_map.apply_le_norm ContinuousMap.apply_le_norm

/- warning: continuous_map.neg_norm_le_apply -> ContinuousMap.neg_norm_le_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (x : α), LE.le.{0} Real Real.hasLe (Neg.neg.{0} Real Real.hasNeg (Norm.norm.{u1} (ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.hasNorm.{u1, 0} α Real _inst_1 _inst_2 Real.normedAddCommGroup) f)) (coeFn.{succ u1, succ u1} (ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (fun (_x : ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) => α -> Real) (ContinuousMap.hasCoeToFun.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) f x)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (x : α), LE.le.{0} Real Real.instLEReal (Neg.neg.{0} Real Real.instNegReal (Norm.norm.{u1} (ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u1, 0} α Real _inst_1 _inst_2 Real.normedAddCommGroup) f)) (FunLike.coe.{succ u1, succ u1, 1} (ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => Real) _x) (ContinuousMapClass.toFunLike.{u1, u1, 0} (ContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace))) α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)) (ContinuousMap.instContinuousMapClassContinuousMap.{u1, 0} α Real _inst_1 (UniformSpace.toTopologicalSpace.{0} Real (PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace)))) f x)
Case conversion may be inaccurate. Consider using '#align continuous_map.neg_norm_le_apply ContinuousMap.neg_norm_le_applyₓ'. -/
theorem neg_norm_le_apply (f : C(α, ℝ)) (x : α) : -‖f‖ ≤ f x :=
  le_trans (neg_le_neg (f.norm_coe_le_norm x)) (neg_le.mp (neg_le_abs_self (f x)))
#align continuous_map.neg_norm_le_apply ContinuousMap.neg_norm_le_apply

/- warning: continuous_map.norm_eq_supr_norm -> ContinuousMap.norm_eq_iSup_norm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {E : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α _inst_1] [_inst_4 : NormedAddCommGroup.{u2} E] (f : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))), Eq.{1} Real (Norm.norm.{max u1 u2} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (ContinuousMap.hasNorm.{u1, u2} α E _inst_1 _inst_2 _inst_4) f) (iSup.{0, succ u1} Real Real.hasSup α (fun (x : α) => Norm.norm.{u2} E (NormedAddCommGroup.toHasNorm.{u2} E _inst_4) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) (fun (_x : ContinuousMap.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) => α -> E) (ContinuousMap.hasCoeToFun.{u1, u2} α E _inst_1 (UniformSpace.toTopologicalSpace.{u2} E (PseudoMetricSpace.toUniformSpace.{u2} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} E _inst_4))))) f x)))
but is expected to have type
  forall {α : Type.{u2}} {E : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α _inst_1] [_inst_4 : NormedAddCommGroup.{u1} E] (f : ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))), Eq.{1} Real (Norm.norm.{max u2 u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) (ContinuousMap.instNormContinuousMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedAddCommGroup.{u2, u1} α E _inst_1 _inst_2 _inst_4) f) (iSup.{0, succ u2} Real Real.instSupSetReal α (fun (x : α) => Norm.norm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) (NormedAddCommGroup.toNorm.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) x) _inst_4) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => E) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4))))) α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α E _inst_1 (UniformSpace.toTopologicalSpace.{u1} E (PseudoMetricSpace.toUniformSpace.{u1} E (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} E (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} E _inst_4)))))) f x)))
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_eq_supr_norm ContinuousMap.norm_eq_iSup_normₓ'. -/
theorem norm_eq_iSup_norm : ‖f‖ = ⨆ x : α, ‖f x‖ :=
  (mkOfCompact f).norm_eq_iSup_norm
#align continuous_map.norm_eq_supr_norm ContinuousMap.norm_eq_iSup_norm

/- warning: continuous_map.norm_restrict_mono_set -> ContinuousMap.norm_restrict_mono_set is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.norm_restrict_mono_set ContinuousMap.norm_restrict_mono_setₓ'. -/
theorem norm_restrict_mono_set {X : Type _} [TopologicalSpace X] (f : C(X, E))
    {K L : TopologicalSpace.Compacts X} (hKL : K ≤ L) : ‖f.restrict K‖ ≤ ‖f.restrict L‖ :=
  (norm_le _ (norm_nonneg _)).mpr fun x => norm_coe_le_norm (f.restrict L) <| Set.inclusion hKL x
#align continuous_map.norm_restrict_mono_set ContinuousMap.norm_restrict_mono_set

end

section

variable {R : Type _} [NormedRing R]

instance : NormedRing C(α, R) :=
  { (inferInstance : NormedAddCommGroup C(α, R)), ContinuousMap.ring with
    norm_mul := fun f g => norm_mul_le (mkOfCompact f) (mkOfCompact g) }

end

section

variable {𝕜 : Type _} [NormedField 𝕜] [NormedSpace 𝕜 E]

instance : NormedSpace 𝕜 C(α, E) where norm_smul_le c f := (norm_smul_le c (mkOfCompact f) : _)

section

variable (α 𝕜 E)

/- warning: continuous_map.linear_isometry_bounded_of_compact -> ContinuousMap.linearIsometryBoundedOfCompact is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact ContinuousMap.linearIsometryBoundedOfCompactₓ'. -/
/-- When `α` is compact and `𝕜` is a normed field,
the `𝕜`-algebra of bounded continuous maps `α →ᵇ β` is
`𝕜`-linearly isometric to `C(α, β)`.
-/
def linearIsometryBoundedOfCompact : C(α, E) ≃ₗᵢ[𝕜] α →ᵇ E :=
  {
    addEquivBoundedOfCompact α
      E with
    map_smul' := fun c f => by ext; simp
    norm_map' := fun f => rfl }
#align continuous_map.linear_isometry_bounded_of_compact ContinuousMap.linearIsometryBoundedOfCompact

variable {α E}

/- warning: continuous_map.eval_clm -> ContinuousMap.evalClm is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.eval_clm ContinuousMap.evalClmₓ'. -/
-- to match bounded_continuous_function.eval_clm
/-- The evaluation at a point, as a continuous linear map from `C(α, 𝕜)` to `𝕜`. -/
def evalClm (x : α) : C(α, E) →L[𝕜] E :=
  (evalClm 𝕜 x).comp (linearIsometryBoundedOfCompact α E 𝕜).toLinearIsometry.toContinuousLinearMap
#align continuous_map.eval_clm ContinuousMap.evalClm

end

/- warning: continuous_map.linear_isometry_bounded_of_compact_symm_apply -> ContinuousMap.linearIsometryBoundedOfCompact_symm_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact_symm_apply ContinuousMap.linearIsometryBoundedOfCompact_symm_applyₓ'. -/
-- this lemma and the next are the analogues of those autogenerated by `@[simps]` for
-- `equiv_bounded_of_compact`, `add_equiv_bounded_of_compact`
@[simp]
theorem linearIsometryBoundedOfCompact_symm_apply (f : α →ᵇ E) :
    (linearIsometryBoundedOfCompact α E 𝕜).symm f = f.toContinuousMap :=
  rfl
#align continuous_map.linear_isometry_bounded_of_compact_symm_apply ContinuousMap.linearIsometryBoundedOfCompact_symm_apply

/- warning: continuous_map.linear_isometry_bounded_of_compact_apply_apply -> ContinuousMap.linearIsometryBoundedOfCompact_apply_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact_apply_apply ContinuousMap.linearIsometryBoundedOfCompact_apply_applyₓ'. -/
@[simp]
theorem linearIsometryBoundedOfCompact_apply_apply (f : C(α, E)) (a : α) :
    (linearIsometryBoundedOfCompact α E 𝕜 f) a = f a :=
  rfl
#align continuous_map.linear_isometry_bounded_of_compact_apply_apply ContinuousMap.linearIsometryBoundedOfCompact_apply_apply

/- warning: continuous_map.linear_isometry_bounded_of_compact_to_isometry_equiv -> ContinuousMap.linearIsometryBoundedOfCompact_toIsometryEquiv is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact_to_isometry_equiv ContinuousMap.linearIsometryBoundedOfCompact_toIsometryEquivₓ'. -/
@[simp]
theorem linearIsometryBoundedOfCompact_toIsometryEquiv :
    (linearIsometryBoundedOfCompact α E 𝕜).toIsometryEquiv = isometryEquivBoundedOfCompact α E :=
  rfl
#align continuous_map.linear_isometry_bounded_of_compact_to_isometry_equiv ContinuousMap.linearIsometryBoundedOfCompact_toIsometryEquiv

/- warning: continuous_map.linear_isometry_bounded_of_compact_to_add_equiv -> ContinuousMap.linearIsometryBoundedOfCompact_toAddEquiv is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact_to_add_equiv ContinuousMap.linearIsometryBoundedOfCompact_toAddEquivₓ'. -/
@[simp]
theorem linearIsometryBoundedOfCompact_toAddEquiv :
    (linearIsometryBoundedOfCompact α E 𝕜).toLinearEquiv.toAddEquiv =
      addEquivBoundedOfCompact α E :=
  rfl
#align continuous_map.linear_isometry_bounded_of_compact_to_add_equiv ContinuousMap.linearIsometryBoundedOfCompact_toAddEquiv

/- warning: continuous_map.linear_isometry_bounded_of_compact_of_compact_to_equiv -> ContinuousMap.linearIsometryBoundedOfCompact_of_compact_toEquiv is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.linear_isometry_bounded_of_compact_of_compact_to_equiv ContinuousMap.linearIsometryBoundedOfCompact_of_compact_toEquivₓ'. -/
@[simp]
theorem linearIsometryBoundedOfCompact_of_compact_toEquiv :
    (linearIsometryBoundedOfCompact α E 𝕜).toLinearEquiv.toEquiv = equivBoundedOfCompact α E :=
  rfl
#align continuous_map.linear_isometry_bounded_of_compact_of_compact_to_equiv ContinuousMap.linearIsometryBoundedOfCompact_of_compact_toEquiv

end

section

variable {𝕜 : Type _} {γ : Type _} [NormedField 𝕜] [NormedRing γ] [NormedAlgebra 𝕜 γ]

instance : NormedAlgebra 𝕜 C(α, γ) :=
  { ContinuousMap.normedSpace with }

end

end ContinuousMap

namespace ContinuousMap

section UniformContinuity

variable {α β : Type _}

variable [MetricSpace α] [CompactSpace α] [MetricSpace β]

/-!
We now set up some declarations making it convenient to use uniform continuity.
-/


/- warning: continuous_map.uniform_continuity -> ContinuousMap.uniform_continuity is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.uniform_continuity ContinuousMap.uniform_continuityₓ'. -/
theorem uniform_continuity (f : C(α, β)) (ε : ℝ) (h : 0 < ε) :
    ∃ δ > 0, ∀ {x y}, dist x y < δ → dist (f x) (f y) < ε :=
  Metric.uniformContinuous_iff.mp (CompactSpace.uniformContinuous_of_continuous f.Continuous) ε h
#align continuous_map.uniform_continuity ContinuousMap.uniform_continuity

/- warning: continuous_map.modulus -> ContinuousMap.modulus is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : MetricSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1)))] [_inst_3 : MetricSpace.{u2} β], (ContinuousMap.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) -> (forall (ε : Real), (LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) ε) -> Real)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : MetricSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1)))] [_inst_3 : MetricSpace.{u2} β], (ContinuousMap.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) -> (forall (ε : Real), (LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) ε) -> Real)
Case conversion may be inaccurate. Consider using '#align continuous_map.modulus ContinuousMap.modulusₓ'. -/
-- This definition allows us to separate the choice of some `δ`,
-- and the corresponding use of `dist a b < δ → dist (f a) (f b) < ε`,
-- even across different declarations.
/-- An arbitrarily chosen modulus of uniform continuity for a given function `f` and `ε > 0`.
-/
def modulus (f : C(α, β)) (ε : ℝ) (h : 0 < ε) : ℝ :=
  Classical.choose (uniform_continuity f ε h)
#align continuous_map.modulus ContinuousMap.modulus

/- warning: continuous_map.modulus_pos -> ContinuousMap.modulus_pos is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : MetricSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1)))] [_inst_3 : MetricSpace.{u2} β] (f : ContinuousMap.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) {ε : Real} {h : LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) ε}, LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) (ContinuousMap.modulus.{u1, u2} α β _inst_1 _inst_2 _inst_3 f ε h)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : MetricSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1)))] [_inst_3 : MetricSpace.{u1} β] (f : ContinuousMap.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1))) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) {ε : Real} {h : LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) ε}, LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) (ContinuousMap.modulus.{u2, u1} α β _inst_1 _inst_2 _inst_3 f ε h)
Case conversion may be inaccurate. Consider using '#align continuous_map.modulus_pos ContinuousMap.modulus_posₓ'. -/
theorem modulus_pos (f : C(α, β)) {ε : ℝ} {h : 0 < ε} : 0 < f.modulus ε h :=
  (Classical.choose_spec (uniform_continuity f ε h)).fst
#align continuous_map.modulus_pos ContinuousMap.modulus_pos

/- warning: continuous_map.dist_lt_of_dist_lt_modulus -> ContinuousMap.dist_lt_of_dist_lt_modulus is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : MetricSpace.{u1} α] [_inst_2 : CompactSpace.{u1} α (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1)))] [_inst_3 : MetricSpace.{u2} β] (f : ContinuousMap.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (ε : Real) (h : LT.lt.{0} Real Real.hasLt (OfNat.ofNat.{0} Real 0 (OfNat.mk.{0} Real 0 (Zero.zero.{0} Real Real.hasZero))) ε) {a : α} {b : α}, (LT.lt.{0} Real Real.hasLt (Dist.dist.{u1} α (PseudoMetricSpace.toHasDist.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1)) a b) (ContinuousMap.modulus.{u1, u2} α β _inst_1 _inst_2 _inst_3 f ε h)) -> (LT.lt.{0} Real Real.hasLt (Dist.dist.{u2} β (PseudoMetricSpace.toHasDist.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (ContinuousMap.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) (fun (_x : ContinuousMap.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) => α -> β) (ContinuousMap.hasCoeToFun.{u1, u2} α β (UniformSpace.toTopologicalSpace.{u1} α (PseudoMetricSpace.toUniformSpace.{u1} α (MetricSpace.toPseudoMetricSpace.{u1} α _inst_1))) (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (MetricSpace.toPseudoMetricSpace.{u2} β _inst_3)))) f b)) ε)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : MetricSpace.{u2} α] [_inst_2 : CompactSpace.{u2} α (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1)))] [_inst_3 : MetricSpace.{u1} β] (f : ContinuousMap.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1))) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) (ε : Real) (h : LT.lt.{0} Real Real.instLTReal (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.instZeroReal)) ε) {a : α} {b : α}, (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u2} α (PseudoMetricSpace.toDist.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1)) a b) (ContinuousMap.modulus.{u2, u1} α β _inst_1 _inst_2 _inst_3 f ε h)) -> (LT.lt.{0} Real Real.instLTReal (Dist.dist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (PseudoMetricSpace.toDist.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) (MetricSpace.toPseudoMetricSpace.{u1} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) a) _inst_3)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1))) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1))) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1))) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1))) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (ContinuousMap.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1))) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α (fun (_x : α) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : α) => β) _x) (ContinuousMapClass.toFunLike.{max u2 u1, u2, u1} (ContinuousMap.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1))) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3)))) α β (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1))) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))) (ContinuousMap.instContinuousMapClassContinuousMap.{u2, u1} α β (UniformSpace.toTopologicalSpace.{u2} α (PseudoMetricSpace.toUniformSpace.{u2} α (MetricSpace.toPseudoMetricSpace.{u2} α _inst_1))) (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (MetricSpace.toPseudoMetricSpace.{u1} β _inst_3))))) f b)) ε)
Case conversion may be inaccurate. Consider using '#align continuous_map.dist_lt_of_dist_lt_modulus ContinuousMap.dist_lt_of_dist_lt_modulusₓ'. -/
theorem dist_lt_of_dist_lt_modulus (f : C(α, β)) (ε : ℝ) (h : 0 < ε) {a b : α}
    (w : dist a b < f.modulus ε h) : dist (f a) (f b) < ε :=
  (Classical.choose_spec (uniform_continuity f ε h)).snd w
#align continuous_map.dist_lt_of_dist_lt_modulus ContinuousMap.dist_lt_of_dist_lt_modulus

end UniformContinuity

end ContinuousMap

section CompLeft

variable (X : Type _) {𝕜 β γ : Type _} [TopologicalSpace X] [CompactSpace X]
  [NontriviallyNormedField 𝕜]

variable [NormedAddCommGroup β] [NormedSpace 𝕜 β] [NormedAddCommGroup γ] [NormedSpace 𝕜 γ]

open ContinuousMap

/- warning: continuous_linear_map.comp_left_continuous_compact -> ContinuousLinearMap.compLeftContinuousCompact is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_linear_map.comp_left_continuous_compact ContinuousLinearMap.compLeftContinuousCompactₓ'. -/
/-- Postcomposition of continuous functions into a normed module by a continuous linear map is a
continuous linear map.
Transferred version of `continuous_linear_map.comp_left_continuous_bounded`,
upgraded version of `continuous_linear_map.comp_left_continuous`,
similar to `linear_map.comp_left`. -/
protected def ContinuousLinearMap.compLeftContinuousCompact (g : β →L[𝕜] γ) :
    C(X, β) →L[𝕜] C(X, γ) :=
  (linearIsometryBoundedOfCompact X γ 𝕜).symm.toLinearIsometry.toContinuousLinearMap.comp <|
    (g.compLeftContinuousBounded X).comp <|
      (linearIsometryBoundedOfCompact X β 𝕜).toLinearIsometry.toContinuousLinearMap
#align continuous_linear_map.comp_left_continuous_compact ContinuousLinearMap.compLeftContinuousCompact

/- warning: continuous_linear_map.to_linear_comp_left_continuous_compact -> ContinuousLinearMap.toLinear_compLeftContinuousCompact is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_linear_map.to_linear_comp_left_continuous_compact ContinuousLinearMap.toLinear_compLeftContinuousCompactₓ'. -/
@[simp]
theorem ContinuousLinearMap.toLinear_compLeftContinuousCompact (g : β →L[𝕜] γ) :
    (g.compLeftContinuousCompact X : C(X, β) →ₗ[𝕜] C(X, γ)) = g.compLeftContinuous 𝕜 X := by ext f;
  rfl
#align continuous_linear_map.to_linear_comp_left_continuous_compact ContinuousLinearMap.toLinear_compLeftContinuousCompact

/- warning: continuous_linear_map.comp_left_continuous_compact_apply -> ContinuousLinearMap.compLeftContinuousCompact_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_linear_map.comp_left_continuous_compact_apply ContinuousLinearMap.compLeftContinuousCompact_applyₓ'. -/
@[simp]
theorem ContinuousLinearMap.compLeftContinuousCompact_apply (g : β →L[𝕜] γ) (f : C(X, β)) (x : X) :
    g.compLeftContinuousCompact X f x = g (f x) :=
  rfl
#align continuous_linear_map.comp_left_continuous_compact_apply ContinuousLinearMap.compLeftContinuousCompact_apply

end CompLeft

namespace ContinuousMap

/-!
We now setup variations on `comp_right_* f`, where `f : C(X, Y)`
(that is, precomposition by a continuous map),
as a morphism `C(Y, T) → C(X, T)`, respecting various types of structure.

In particular:
* `comp_right_continuous_map`, the bundled continuous map (for this we need `X Y` compact).
* `comp_right_homeomorph`, when we precompose by a homeomorphism.
* `comp_right_alg_hom`, when `T = R` is a topological ring.
-/


section CompRight

#print ContinuousMap.compRightContinuousMap /-
/-- Precomposition by a continuous map is itself a continuous map between spaces of continuous maps.
-/
def compRightContinuousMap {X Y : Type _} (T : Type _) [TopologicalSpace X] [CompactSpace X]
    [TopologicalSpace Y] [CompactSpace Y] [MetricSpace T] (f : C(X, Y)) : C(C(Y, T), C(X, T))
    where
  toFun g := g.comp f
  continuous_toFun := by
    refine' metric.continuous_iff.mpr _
    intro g ε ε_pos
    refine' ⟨ε, ε_pos, fun g' h => _⟩
    rw [ContinuousMap.dist_lt_iff ε_pos] at h⊢
    · exact fun x => h (f x)
#align continuous_map.comp_right_continuous_map ContinuousMap.compRightContinuousMap
-/

/- warning: continuous_map.comp_right_continuous_map_apply -> ContinuousMap.compRightContinuousMap_apply is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u2}} (T : Type.{u3}) [_inst_1 : TopologicalSpace.{u1} X] [_inst_2 : CompactSpace.{u1} X _inst_1] [_inst_3 : TopologicalSpace.{u2} Y] [_inst_4 : CompactSpace.{u2} Y _inst_3] [_inst_5 : MetricSpace.{u3} T] (f : ContinuousMap.{u1, u2} X Y _inst_1 _inst_3) (g : ContinuousMap.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))), Eq.{max (succ u1) (succ u3)} (ContinuousMap.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (coeFn.{max (succ (max u2 u3)) (succ (max u1 u3)), max (succ (max u2 u3)) (succ (max u1 u3))} (ContinuousMap.{max u2 u3, max u1 u3} (ContinuousMap.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5))))) (fun (_x : ContinuousMap.{max u2 u3, max u1 u3} (ContinuousMap.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5))))) => (ContinuousMap.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) -> (ContinuousMap.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5))))) (ContinuousMap.hasCoeToFun.{max u2 u3, max u1 u3} (ContinuousMap.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u3} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5)))) (ContinuousMap.compactOpen.{u1, u3} X T _inst_1 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5))))) (ContinuousMap.compRightContinuousMap.{u1, u2, u3} X Y T _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) g) (ContinuousMap.comp.{u1, u2, u3} X Y T _inst_1 _inst_3 (UniformSpace.toTopologicalSpace.{u3} T (PseudoMetricSpace.toUniformSpace.{u3} T (MetricSpace.toPseudoMetricSpace.{u3} T _inst_5))) g f)
but is expected to have type
  forall {X : Type.{u3}} {Y : Type.{u2}} (T : Type.{u1}) [_inst_1 : TopologicalSpace.{u3} X] [_inst_2 : CompactSpace.{u3} X _inst_1] [_inst_3 : TopologicalSpace.{u2} Y] [_inst_4 : CompactSpace.{u2} Y _inst_3] [_inst_5 : MetricSpace.{u1} T] (f : ContinuousMap.{u3, u2} X Y _inst_1 _inst_3) (g : ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))), Eq.{max (succ u3) (succ u1)} ((fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) => ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) g) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u2) (succ u1), max (succ u3) (succ u1)} (ContinuousMap.{max u1 u2, max u1 u3} (ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5))))) (ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (fun (_x : ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) => (fun (x._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.699 : ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) => ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) _x) (ContinuousMapClass.toFunLike.{max (max u3 u2) u1, max u2 u1, max u3 u1} (ContinuousMap.{max u1 u2, max u1 u3} (ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5))))) (ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.instContinuousMapClassContinuousMap.{max u2 u1, max u3 u1} (ContinuousMap.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u2, u1} Y T _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))) (ContinuousMap.compactOpen.{u3, u1} X T _inst_1 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5)))))) (ContinuousMap.compRightContinuousMap.{u3, u2, u1} X Y T _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) g) (ContinuousMap.comp.{u3, u2, u1} X Y T _inst_1 _inst_3 (UniformSpace.toTopologicalSpace.{u1} T (PseudoMetricSpace.toUniformSpace.{u1} T (MetricSpace.toPseudoMetricSpace.{u1} T _inst_5))) g f)
Case conversion may be inaccurate. Consider using '#align continuous_map.comp_right_continuous_map_apply ContinuousMap.compRightContinuousMap_applyₓ'. -/
@[simp]
theorem compRightContinuousMap_apply {X Y : Type _} (T : Type _) [TopologicalSpace X]
    [CompactSpace X] [TopologicalSpace Y] [CompactSpace Y] [MetricSpace T] (f : C(X, Y))
    (g : C(Y, T)) : (compRightContinuousMap T f) g = g.comp f :=
  rfl
#align continuous_map.comp_right_continuous_map_apply ContinuousMap.compRightContinuousMap_apply

#print ContinuousMap.compRightHomeomorph /-
/-- Precomposition by a homeomorphism is itself a homeomorphism between spaces of continuous maps.
-/
def compRightHomeomorph {X Y : Type _} (T : Type _) [TopologicalSpace X] [CompactSpace X]
    [TopologicalSpace Y] [CompactSpace Y] [MetricSpace T] (f : X ≃ₜ Y) : C(Y, T) ≃ₜ C(X, T)
    where
  toFun := compRightContinuousMap T f.toContinuousMap
  invFun := compRightContinuousMap T f.symm.toContinuousMap
  left_inv g := ext fun _ => congr_arg g (f.apply_symm_apply _)
  right_inv g := ext fun _ => congr_arg g (f.symm_apply_apply _)
#align continuous_map.comp_right_homeomorph ContinuousMap.compRightHomeomorph
-/

/- warning: continuous_map.comp_right_alg_hom_continuous -> ContinuousMap.compRightAlgHom_continuous is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.comp_right_alg_hom_continuous ContinuousMap.compRightAlgHom_continuousₓ'. -/
theorem compRightAlgHom_continuous {X Y : Type _} (R A : Type _) [TopologicalSpace X]
    [CompactSpace X] [TopologicalSpace Y] [CompactSpace Y] [CommSemiring R] [Semiring A]
    [MetricSpace A] [TopologicalSemiring A] [Algebra R A] (f : C(X, Y)) :
    Continuous (compRightAlgHom R A f) :=
  map_continuous (compRightContinuousMap A f)
#align continuous_map.comp_right_alg_hom_continuous ContinuousMap.compRightAlgHom_continuous

end CompRight

section LocalNormalConvergence

/-! ### Local normal convergence

A sum of continuous functions (on a locally compact space) is "locally normally convergent" if the
sum of its sup-norms on any compact subset is summable. This implies convergence in the topology
of `C(X, E)` (i.e. locally uniform convergence). -/


open TopologicalSpace

variable {X : Type _} [TopologicalSpace X] [T2Space X] [LocallyCompactSpace X]

variable {E : Type _} [NormedAddCommGroup E] [CompleteSpace E]

/- warning: continuous_map.summable_of_locally_summable_norm -> ContinuousMap.summable_of_locally_summable_norm is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align continuous_map.summable_of_locally_summable_norm ContinuousMap.summable_of_locally_summable_normₓ'. -/
theorem summable_of_locally_summable_norm {ι : Type _} {F : ι → C(X, E)}
    (hF : ∀ K : Compacts X, Summable fun i => ‖(F i).restrict K‖) : Summable F :=
  by
  refine' (ContinuousMap.exists_tendsto_compactOpen_iff_forall _).2 fun K hK => _
  lift K to compacts X using hK
  have A : ∀ s : Finset ι, restrict (↑K) (∑ i in s, F i) = ∑ i in s, restrict K (F i) := by intro s;
    ext1 x; simp
  simpa only [HasSum, A] using summable_of_summable_norm (hF K)
#align continuous_map.summable_of_locally_summable_norm ContinuousMap.summable_of_locally_summable_norm

end LocalNormalConvergence

/-!
### Star structures

In this section, if `β` is a normed ⋆-group, then so is the space of
continuous functions from `α` to `β`, by using the star operation pointwise.

Furthermore, if `α` is compact and `β` is a C⋆-ring, then `C(α, β)` is a C⋆-ring.  -/


section NormedSpace

variable {α : Type _} {β : Type _}

variable [TopologicalSpace α] [NormedAddCommGroup β] [StarAddMonoid β] [NormedStarGroup β]

/- warning: bounded_continuous_function.mk_of_compact_star -> BoundedContinuousFunction.mkOfCompact_star is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : TopologicalSpace.{u1} α] [_inst_2 : NormedAddCommGroup.{u2} β] [_inst_3 : StarAddMonoid.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (NormedAddGroup.toAddGroup.{u2} β (NormedAddCommGroup.toNormedAddGroup.{u2} β _inst_2))))] [_inst_4 : NormedStarGroup.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2) _inst_3] [_inst_5 : CompactSpace.{u1} α _inst_1] (f : ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2))))), Eq.{succ (max u1 u2)} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2))) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2)) _inst_5 (Star.star.{max u1 u2} (ContinuousMap.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2))))) (ContinuousMap.hasStar.{u1, u2} α β _inst_1 (UniformSpace.toTopologicalSpace.{u2} β (PseudoMetricSpace.toUniformSpace.{u2} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2)))) (InvolutiveStar.toHasStar.{u2} β (StarAddMonoid.toHasInvolutiveStar.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2))))) _inst_3)) (NormedStarGroup.to_continuousStar.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2) _inst_3 _inst_4)) f)) (Star.star.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2))) (InvolutiveStar.toHasStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2))) (StarAddMonoid.toHasInvolutiveStar.{max u1 u2} (BoundedContinuousFunction.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2))) (BoundedContinuousFunction.addMonoid.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2)) (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β (SeminormedAddGroup.toAddGroup.{u2} β (SeminormedAddCommGroup.toSeminormedAddGroup.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2))))) (SeminormedAddCommGroup.to_lipschitzAdd.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2))) (BoundedContinuousFunction.starAddMonoid.{u1, u2} α β _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2) _inst_3 _inst_4))) (BoundedContinuousFunction.mkOfCompact.{u1, u2} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u2} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u2} β _inst_2)) _inst_5 f))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : TopologicalSpace.{u2} α] [_inst_2 : NormedAddCommGroup.{u1} β] [_inst_3 : StarAddMonoid.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (NormedAddGroup.toAddGroup.{u1} β (NormedAddCommGroup.toNormedAddGroup.{u1} β _inst_2))))] [_inst_4 : NormedStarGroup.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2) _inst_3] [_inst_5 : CompactSpace.{u2} α _inst_1] (f : ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2))))), Eq.{max (succ u2) (succ u1)} (BoundedContinuousFunction.{u2, u1} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2))) (BoundedContinuousFunction.mkOfCompact.{u2, u1} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2)) _inst_5 (Star.star.{max u1 u2} (ContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2))))) (ContinuousMap.instStarContinuousMap.{u2, u1} α β _inst_1 (UniformSpace.toTopologicalSpace.{u1} β (PseudoMetricSpace.toUniformSpace.{u1} β (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2)))) (InvolutiveStar.toStar.{u1} β (StarAddMonoid.toInvolutiveStar.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (NormedAddGroup.toAddGroup.{u1} β (NormedAddCommGroup.toNormedAddGroup.{u1} β _inst_2)))) _inst_3)) (NormedStarGroup.to_continuousStar.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2) _inst_3 _inst_4)) f)) (Star.star.{max u1 u2} (BoundedContinuousFunction.{u2, u1} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2))) (InvolutiveStar.toStar.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2))) (StarAddMonoid.toInvolutiveStar.{max u2 u1} (BoundedContinuousFunction.{u2, u1} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2))) (BoundedContinuousFunction.addMonoid.{u2, u1} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2)) (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β (NormedAddGroup.toAddGroup.{u1} β (NormedAddCommGroup.toNormedAddGroup.{u1} β _inst_2)))) (SeminormedAddCommGroup.to_lipschitzAdd.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2))) (BoundedContinuousFunction.starAddMonoid.{u2, u1} α β _inst_1 (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2) _inst_3 _inst_4))) (BoundedContinuousFunction.mkOfCompact.{u2, u1} α β _inst_1 (SeminormedAddCommGroup.toPseudoMetricSpace.{u1} β (NormedAddCommGroup.toSeminormedAddCommGroup.{u1} β _inst_2)) _inst_5 f))
Case conversion may be inaccurate. Consider using '#align bounded_continuous_function.mk_of_compact_star BoundedContinuousFunction.mkOfCompact_starₓ'. -/
theorem BoundedContinuousFunction.mkOfCompact_star [CompactSpace α] (f : C(α, β)) :
    mkOfCompact (star f) = star (mkOfCompact f) :=
  rfl
#align bounded_continuous_function.mk_of_compact_star BoundedContinuousFunction.mkOfCompact_star

instance [CompactSpace α] : NormedStarGroup C(α, β)
    where norm_star f := by
    rw [← BoundedContinuousFunction.norm_mkOfCompact, BoundedContinuousFunction.mkOfCompact_star,
      norm_star, BoundedContinuousFunction.norm_mkOfCompact]

end NormedSpace

section CstarRing

variable {α : Type _} {β : Type _}

variable [TopologicalSpace α] [NormedRing β] [StarRing β]

instance [CompactSpace α] [CstarRing β] : CstarRing C(α, β)
    where norm_star_mul_self := by
    intro f
    refine' le_antisymm _ _
    · rw [← sq, ContinuousMap.norm_le _ (sq_nonneg _)]
      intro x
      simp only [ContinuousMap.coe_mul, coe_star, Pi.mul_apply, Pi.star_apply,
        CstarRing.norm_star_mul_self, ← sq]
      refine' sq_le_sq' _ _
      · linarith [norm_nonneg (f x), norm_nonneg f]
      · exact ContinuousMap.norm_coe_le_norm f x
    · rw [← sq, ← Real.le_sqrt (norm_nonneg _) (norm_nonneg _),
        ContinuousMap.norm_le _ (Real.sqrt_nonneg _)]
      intro x
      rw [Real.le_sqrt (norm_nonneg _) (norm_nonneg _), sq, ← CstarRing.norm_star_mul_self]
      exact ContinuousMap.norm_coe_le_norm (star f * f) x

end CstarRing

end ContinuousMap

