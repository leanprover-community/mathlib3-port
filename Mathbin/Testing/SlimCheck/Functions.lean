import Mathbin.Data.List.Sigma 
import Mathbin.Data.Int.Range 
import Mathbin.Tactic.PrettyCases 
import Mathbin.Testing.SlimCheck.Sampleable 
import Mathbin.Testing.SlimCheck.Testable

/-!
## `slim_check`: generators for functions

This file defines `sampleable` instances for `α → β` functions and
`ℤ → ℤ` injective functions.

Functions are generated by creating a list of pairs and one more value
using the list as a lookup table and resorting to the additional value
when a value is not found in the table.

Injective functions are generated by creating a list of numbers and
a permutation of that list. The permutation insures that every input
is mapped to a unique output. When an input is not found in the list
the input itself is used as an output.

Injective functions `f : α → α` could be generated easily instead of
`ℤ → ℤ` by generating a `list α`, removing duplicates and creating a
permutations. One has to be careful when generating the domain to make
if vast enough that, when generating arguments to apply `f` to,
they argument should be likely to lie in the domain of `f`. This is
the reason that injective functions `f : ℤ → ℤ` are generated by
fixing the domain to the range `[-2*size .. -2*size]`, with `size`
the size parameter of the `gen` monad.

Much of the machinery provided in this file is applicable to generate
injective functions of type `α → α` and new instances should be easy
to define.

Other classes of functions such as monotone functions can generated using
similar techniques. For monotone functions, generating two lists, sorting them
and matching them should suffice, with appropriate default values.
Some care must be taken for shrinking such functions to make sure
their defining property is invariant through shrinking. Injective
functions are an example of how complicated it can get.
-/


universe u v w

variable{α : Type u}{β : Type v}{γ : Sort w}

namespace SlimCheck

/-- Data structure specifying a total function using a list of pairs
and a default value returned when the input is not in the domain of
the partial function.

`with_default f y` encodes `x ↦ f x` when `x ∈ f` and `x ↦ y`
otherwise.

We use `Σ` to encode mappings instead of `×` because we
rely on the association list API defined in `data.list.sigma`.
 -/
inductive total_function (α : Type u) (β : Type v) : Type max u v
  | with_default : List (Σ_ : α, β) → β → total_function

instance total_function.inhabited [Inhabited β] : Inhabited (total_function α β) :=
  ⟨total_function.with_default ∅ (default _)⟩

namespace TotalFunction

/-- Apply a total function to an argument. -/
def apply [DecidableEq α] : total_function α β → α → β
| total_function.with_default m y, x => (m.lookup x).getOrElse y

/--
Implementation of `has_repr (total_function α β)`.

Creates a string for a given `finmap` and output, `x₀ ↦ y₀, .. xₙ ↦ yₙ`
for each of the entries. The brackets are provided by the calling function.
-/
def repr_aux [HasRepr α] [HasRepr β] (m : List (Σ_ : α, β)) : Stringₓ :=
  Stringₓ.join$ List.qsort (fun x y => x < y) (m.map$ fun x => s!"{(reprₓ$ Sigma.fst x)} ↦ {reprₓ$ Sigma.snd x}, ")

/--
Produce a string for a given `total_function`.
The output is of the form `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, _ ↦ y]`.
-/
protected def reprₓ [HasRepr α] [HasRepr β] : total_function α β → Stringₓ
| total_function.with_default m y => s!"[{(repr_aux m)}_ ↦ {HasRepr.repr y}]"

instance  (α : Type u) (β : Type v) [HasRepr α] [HasRepr β] : HasRepr (total_function α β) :=
  ⟨total_function.repr⟩

/-- Create a `finmap` from a list of pairs. -/
def list.to_finmap' (xs : List (α × β)) : List (Σ_ : α, β) :=
  xs.map Prod.toSigma

section 

variable[sampleable α][sampleable β]

/-- Redefine `sizeof` to follow the structure of `sampleable` instances. -/
def total.sizeof : total_function α β → ℕ
| ⟨m, x⟩ => (1+@sizeof _ sampleable.wf m)+sizeof x

instance (priority := 2000) : SizeOf (total_function α β) :=
  ⟨total.sizeof⟩

variable[DecidableEq α]

/-- Shrink a total function by shrinking the lists that represent it. -/
protected def shrink : shrink_fn (total_function α β)
| ⟨m, x⟩ =>
  (sampleable.shrink (m, x)).map$
    fun ⟨⟨m', x'⟩, h⟩ =>
      ⟨⟨List.eraseDupkeys m', x'⟩,
        lt_of_le_of_ltₓ
          (by 
            unfoldWf <;> refine' @List.sizeof_erase_dupkeys _ _ _ (@sampleable.wf _ _) _)
          h⟩

variable[HasRepr α][HasRepr β]

instance pi.sampleable_ext : sampleable_ext (α → β) :=
  { ProxyRepr := total_function α β, interp := total_function.apply,
    sample :=
      do 
        let xs ← (sampleable.sample (List (α × β)) : gen (List (α × β)))
        let ⟨x⟩ ← (Uliftable.up$ sample β : gen (Ulift.{max u v} β))
        pure$ total_function.with_default (list.to_finmap' xs) x,
    shrink := total_function.shrink }

end 

section SampleableExt

open SampleableExt

instance (priority := 2000)pi_pred.sampleable_ext [sampleable_ext (α → Bool)] : sampleable_ext.{u + 1} (α → Prop) :=
  { ProxyRepr := proxy_repr (α → Bool), interp := fun m x => interp (α → Bool) m x, sample := sample (α → Bool),
    shrink := shrink }

instance (priority := 2000)pi_uncurry.sampleable_ext [sampleable_ext (α × β → γ)] :
  sampleable_ext.{imax (u + 1) (v + 1) w} (α → β → γ) :=
  { ProxyRepr := proxy_repr (α × β → γ), interp := fun m x y => interp (α × β → γ) m (x, y),
    sample := sample (α × β → γ), shrink := shrink }

end SampleableExt

end TotalFunction

/--
Data structure specifying a total function using a list of pairs
and a default value returned when the input is not in the domain of
the partial function.

`map_to_self f` encodes `x ↦ f x` when `x ∈ f` and `x ↦ x`,
i.e. `x` to itself, otherwise.

We use `Σ` to encode mappings instead of `×` because we
rely on the association list API defined in `data.list.sigma`.
-/
inductive injective_function (α : Type u) : Type u
  | map_to_self (xs : List (Σ_ : α, α)) :
  xs.map Sigma.fst ~ xs.map Sigma.snd → List.Nodup (xs.map Sigma.snd) → injective_function

instance  : Inhabited (injective_function α) :=
  ⟨⟨[], List.Perm.nil, List.nodup_nil⟩⟩

namespace InjectiveFunction

/-- Apply a total function to an argument. -/
def apply [DecidableEq α] : injective_function α → α → α
| injective_function.map_to_self m _ _, x => (m.lookup x).getOrElse x

/--
Produce a string for a given `total_function`.
The output is of the form `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, x ↦ x]`.
Unlike for `total_function`, the default value is not a constant
but the identity function.
-/
protected def reprₓ [HasRepr α] : injective_function α → Stringₓ
| injective_function.map_to_self m _ _ => s! "[{total_function.repr_aux m}x ↦ x]"

instance  (α : Type u) [HasRepr α] : HasRepr (injective_function α) :=
  ⟨injective_function.repr⟩

/-- Interpret a list of pairs as a total function, defaulting to
the identity function when no entries are found for a given function -/
def list.apply_id [DecidableEq α] (xs : List (α × α)) (x : α) : α :=
  ((xs.map Prod.toSigma).lookup x).getOrElse x

@[simp]
theorem list.apply_id_cons [DecidableEq α] (xs : List (α × α)) (x y z : α) :
  list.apply_id ((y, z) :: xs) x = if y = x then z else list.apply_id xs x :=
  by 
    simp only [list.apply_id, List.lookupₓ, eq_rec_constant, Prod.toSigma, List.map] <;> splitIfs <;> rfl

open Function _Root_.List

open _root_.prod(toSigma)

open _Root_.Nat

-- error in Testing.SlimCheck.Functions: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Meta.solveByElim'
theorem list.apply_id_zip_eq
[decidable_eq α]
{xs ys : list α}
(h₀ : list.nodup xs)
(h₁ : «expr = »(xs.length, ys.length))
(x y : α)
(i : exprℕ())
(h₂ : «expr = »(xs.nth i, some x)) : «expr ↔ »(«expr = »(list.apply_id.{u} (xs.zip ys) x, y), «expr = »(ys.nth i, some y)) :=
begin
  induction [expr xs] [] [] ["generalizing", ident ys, ident i],
  case [ident list.nil, ":", ident ys, ident i, ident h₁, ident h₂] { cases [expr h₂] [] },
  case [ident list.cons, ":", ident x', ident xs, ident xs_ih, ident ys, ident i, ident h₁, ident h₂] { cases [expr i] [],
    { injection [expr h₂] ["with", ident h₀, ident h₁],
      subst [expr h₀],
      cases [expr ys] [],
      { cases [expr h₁] [] },
      { simp [] [] ["only"] ["[", expr list.apply_id, ",", expr to_sigma, ",", expr option.get_or_else_some, ",", expr nth, ",", expr lookup_cons_eq, ",", expr zip_cons_cons, ",", expr list.map, "]"] [] [] } },
    { cases [expr ys] [],
      { cases [expr h₁] [] },
      { cases [expr h₀] ["with", "_", "_", ident h₀, ident h₁],
        simp [] [] ["only"] ["[", expr nth, ",", expr zip_cons_cons, ",", expr list.apply_id_cons, "]"] [] ["at", ident h₂, "⊢"],
        rw [expr if_neg] [],
        { apply [expr xs_ih]; solve_by_elim [] [] ["[", expr succ.inj, "]"] [] },
        { apply [expr h₀],
          apply [expr nth_mem h₂] } } } }
end

-- error in Testing.SlimCheck.Functions: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem apply_id_mem_iff
[decidable_eq α]
{xs ys : list α}
(h₀ : list.nodup xs)
(h₁ : «expr ~ »(xs, ys))
(x : α) : «expr ↔ »(«expr ∈ »(list.apply_id.{u} (xs.zip ys) x, ys), «expr ∈ »(x, xs)) :=
begin
  simp [] [] ["only"] ["[", expr list.apply_id, "]"] [] [],
  cases [expr h₃, ":", expr lookup x (map prod.to_sigma (xs.zip ys))] [],
  { dsimp [] ["[", expr option.get_or_else, "]"] [] [],
    rw [expr h₁.mem_iff] [] },
  { have [ident h₂] [":", expr ys.nodup] [":=", expr h₁.nodup_iff.1 h₀],
    replace [ident h₁] [":", expr «expr = »(xs.length, ys.length)] [":=", expr h₁.length_eq],
    dsimp [] [] [] [],
    induction [expr xs] [] [] ["generalizing", ident ys],
    case [ident list.nil, ":", ident ys, ident h₃, ident h₂, ident h₁] { contradiction },
    case [ident list.cons, ":", ident x', ident xs, ident xs_ih, ident ys, ident h₃, ident h₂, ident h₁] { cases [expr ys] ["with", ident y, ident ys],
      { cases [expr h₃] [] },
      dsimp [] ["[", expr lookup, "]"] [] ["at", ident h₃],
      split_ifs ["at", ident h₃] [],
      { subst [expr x'],
        subst [expr val],
        simp [] [] ["only"] ["[", expr mem_cons_iff, ",", expr true_or, ",", expr eq_self_iff_true, "]"] [] [] },
      { cases [expr h₀] ["with", "_", "_", ident h₀, ident h₅],
        cases [expr h₂] ["with", "_", "_", ident h₂, ident h₄],
        have [ident h₆] [] [":=", expr nat.succ.inj h₁],
        specialize [expr @xs_ih h₅ ys h₃ h₄ h₆],
        simp [] [] ["only"] ["[", expr ne.symm h, ",", expr xs_ih, ",", expr mem_cons_iff, ",", expr false_or, "]"] [] [],
        suffices [] [":", expr «expr ∈ »(val, ys)],
        tauto ["!"],
        erw ["[", "<-", expr option.mem_def, ",", expr mem_lookup_iff, "]"] ["at", ident h₃],
        simp [] [] ["only"] ["[", expr to_sigma, ",", expr mem_map, ",", expr heq_iff_eq, ",", expr prod.exists, "]"] [] ["at", ident h₃],
        rcases [expr h₃, "with", "⟨", ident a, ",", ident b, ",", ident h₃, ",", ident h₄, ",", ident h₅, "⟩"],
        subst [expr a],
        subst [expr b],
        apply [expr (mem_zip h₃).2],
        simp [] [] ["only"] ["[", expr nodupkeys, ",", expr keys, ",", expr comp, ",", expr prod.fst_to_sigma, ",", expr map_map, "]"] [] [],
        rwa [expr map_fst_zip _ _ (le_of_eq h₆)] [] } } }
end

theorem list.apply_id_eq_self [DecidableEq α] {xs ys : List α} (x : α) : x ∉ xs → list.apply_id.{u} (xs.zip ys) x = x :=
  by 
    intro h 
    dsimp [list.apply_id]
    rw [lookup_eq_none.2]
    rfl 
    simp only [keys, not_exists, to_sigma, exists_and_distrib_right, exists_eq_right, mem_map, comp_app, map_map,
      Prod.exists]
    intro y hy 
    exact h (mem_zip hy).1

-- error in Testing.SlimCheck.Functions: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem apply_id_injective
[decidable_eq α]
{xs ys : list α}
(h₀ : list.nodup xs)
(h₁ : «expr ~ »(xs, ys)) : injective.{u+1, u+1} (list.apply_id (xs.zip ys)) :=
begin
  intros [ident x, ident y, ident h],
  by_cases [expr hx, ":", expr «expr ∈ »(x, xs)]; by_cases [expr hy, ":", expr «expr ∈ »(y, xs)],
  { rw [expr mem_iff_nth] ["at", ident hx, ident hy],
    cases [expr hx] ["with", ident i, ident hx],
    cases [expr hy] ["with", ident j, ident hy],
    suffices [] [":", expr «expr = »(some x, some y)],
    { injection [expr this] [] },
    have [ident h₂] [] [":=", expr h₁.length_eq],
    rw ["[", expr list.apply_id_zip_eq h₀ h₂ _ _ _ hx, "]"] ["at", ident h],
    rw ["[", "<-", expr hx, ",", "<-", expr hy, "]"] [],
    congr,
    apply [expr nth_injective _ (h₁.nodup_iff.1 h₀)],
    { symmetry,
      rw [expr h] [],
      rw ["<-", expr list.apply_id_zip_eq] []; assumption },
    { rw ["<-", expr h₁.length_eq] [],
      rw [expr nth_eq_some] ["at", ident hx],
      cases [expr hx] ["with", ident hx, ident hx'],
      exact [expr hx] } },
  { rw ["<-", expr apply_id_mem_iff h₀ h₁] ["at", ident hx, ident hy],
    rw [expr h] ["at", ident hx],
    contradiction },
  { rw ["<-", expr apply_id_mem_iff h₀ h₁] ["at", ident hx, ident hy],
    rw [expr h] ["at", ident hx],
    contradiction },
  { rwa ["[", expr list.apply_id_eq_self, ",", expr list.apply_id_eq_self, "]"] ["at", ident h]; assumption }
end

open total_function(list.to_finmap')

open Sampleable

/--
Remove a slice of length `m` at index `n` in a list and a permutation, maintaining the property
that it is a permutation.
-/
def perm.slice [DecidableEq α] (n m : ℕ) : (Σ'xs ys : List α, xs ~ ys ∧ ys.nodup) → Σ'xs ys : List α, xs ~ ys ∧ ys.nodup
| ⟨xs, ys, h, h'⟩ =>
  let xs' := List.slice n m xs 
  have h₀ : xs' ~ ys.inter xs' := perm.slice_inter _ _ h h'
  ⟨xs', ys.inter xs', h₀, nodup_inter_of_nodup _ h'⟩

/--
A lazy list, in decreasing order, of sizes that should be
sliced off a list of length `n`
-/
def slice_sizes : ℕ → LazyList ℕ+
| n =>
  if h : 0 < n then
    have  : n / 2 < n :=
      div_lt_self h
        (by 
          decide)
    LazyList.cons ⟨_, h⟩ (slice_sizes$ n / 2)
  else LazyList.nil

/--
Shrink a permutation of a list, slicing a segment in the middle.

The sizes of the slice being removed start at `n` (with `n` the length
of the list) and then `n / 2`, then `n / 4`, etc down to 1. The slices
will be taken at index `0`, `n / k`, `2n / k`, `3n / k`, etc.
-/
protected def shrink_perm {α : Type} [DecidableEq α] [SizeOf α] : shrink_fn (Σ'xs ys : List α, xs ~ ys ∧ ys.nodup)
| xs =>
  do 
    let k := xs.1.length 
    let n ← slice_sizes k 
    let i ← LazyList.ofList$ List.finRange$ k / n 
    have  : («expr↑ » i*«expr↑ » n) < xs.1.length :=
        Nat.lt_of_div_lt_div
          (lt_of_le_of_ltₓ
            (by 
              simp only [Nat.mul_div_cancelₓ, gt_iff_lt, Finₓ.val_eq_coe, Pnat.pos])
            i.2)
      pure
        ⟨perm.slice (i*n) n xs,
          by 
            rcases xs with ⟨a, b, c, d⟩ <;>
              dsimp [sizeof_lt] <;>
                unfoldWf <;> simp only [perm.slice] <;> unfoldWf <;> apply List.sizeof_slice_lt _ _ n.2 _ this⟩

instance  [SizeOf α] : SizeOf (injective_function α) :=
  ⟨fun ⟨xs, _, _⟩ => sizeof (xs.map Sigma.fst)⟩

/--
Shrink an injective function slicing a segment in the middle of the domain and removing
the corresponding elements in the codomain, hence maintaining the property that
one is a permutation of the other.
-/
protected def shrink {α : Type} [SizeOf α] [DecidableEq α] : shrink_fn (injective_function α)
| ⟨xs, h₀, h₁⟩ =>
  do 
    let ⟨⟨xs', ys', h₀, h₁⟩, h₂⟩ ← injective_function.shrink_perm ⟨_, _, h₀, h₁⟩
    have h₃ : xs'.length ≤ ys'.length := le_of_eqₓ (perm.length_eq h₀)
      have h₄ : ys'.length ≤ xs'.length := le_of_eqₓ (perm.length_eq h₀.symm)
      pure
        ⟨⟨(List.zipₓ xs' ys').map Prod.toSigma,
            by 
              simp only [comp, map_fst_zip, map_snd_zip, Prod.fst_to_sigma, Prod.snd_to_sigma, map_map],
            by 
              simp only [comp, map_snd_zip, Prod.snd_to_sigma, map_map]⟩,
          by 
            revert h₂ <;>
              dsimp [sizeof_lt] <;>
                unfoldWf <;>
                  simp only [has_sizeof._match_1, map_map, comp, map_fst_zip, Prod.fst_to_sigma] <;>
                    unfoldWf <;> intro h₂ <;> convert h₂⟩

/-- Create an injective function from one list and a permutation of that list. -/
protected def mk (xs ys : List α) (h : xs ~ ys) (h' : ys.nodup) : injective_function α :=
  have h₀ : xs.length ≤ ys.length := le_of_eqₓ h.length_eq 
  have h₁ : ys.length ≤ xs.length := le_of_eqₓ h.length_eq.symm 
  injective_function.map_to_self (list.to_finmap' (xs.zip ys))
    (by 
      simp only [list.to_finmap', comp, map_fst_zip, map_snd_zip, Prod.fst_to_sigma, Prod.snd_to_sigma, map_map])
    (by 
      simp only [list.to_finmap', comp, map_snd_zip, Prod.snd_to_sigma, map_map])

-- error in Testing.SlimCheck.Functions: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
protected theorem injective [decidable_eq α] (f : injective_function α) : injective (apply f) :=
begin
  cases [expr f] ["with", ident xs, ident hperm, ident hnodup],
  generalize [ident h₀] [":"] [expr «expr = »(map sigma.fst xs, xs₀)],
  generalize [ident h₁] [":"] [expr «expr = »(xs.map «expr $ »(@id («exprΣ , »((_ : α), α) → α), @sigma.snd α (λ
      _ : α, α)), xs₁)],
  dsimp [] ["[", expr id, "]"] [] ["at", ident h₁],
  have [ident hxs] [":", expr «expr = »(xs, total_function.list.to_finmap' (xs₀.zip xs₁))] [],
  { rw ["[", "<-", expr h₀, ",", "<-", expr h₁, ",", expr list.to_finmap', "]"] [],
    clear [ident h₀, ident h₁, ident xs₀, ident xs₁, ident hperm, ident hnodup],
    induction [expr xs] [] [] [],
    case [ident list.nil] { simp [] [] ["only"] ["[", expr zip_nil_right, ",", expr map_nil, "]"] [] [] },
    case [ident list.cons, ":", ident xs_hd, ident xs_tl, ident xs_ih] { simp [] [] ["only"] ["[", expr true_and, ",", expr to_sigma, ",", expr eq_self_iff_true, ",", expr sigma.eta, ",", expr zip_cons_cons, ",", expr list.map, "]"] [] [],
      exact [expr xs_ih] } },
  revert [ident hperm, ident hnodup],
  rw [expr hxs] [],
  intros [],
  apply [expr apply_id_injective],
  { rwa ["[", "<-", expr h₀, ",", expr hxs, ",", expr hperm.nodup_iff, "]"] [] },
  { rwa ["[", "<-", expr hxs, ",", expr h₀, ",", expr h₁, "]"] ["at", ident hperm] }
end

-- error in Testing.SlimCheck.Functions: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
instance pi_injective.sampleable_ext : sampleable_ext {f : exprℤ() → exprℤ() // function.injective f} :=
{ proxy_repr := injective_function exprℤ(),
  interp := λ f, ⟨apply f, f.injective⟩,
  sample := «expr $ »(gen.sized, λ sz, do
   let xs' := int.range «expr- »(«expr + »(«expr * »(2, sz), 2)) «expr + »(«expr * »(2, sz), 2),
     ys ← gen.permutation_of xs',
     have Hinj : injective (λ
      r : exprℕ(), «expr + »(«expr- »((«expr + »(«expr * »(2, sz), 2) : exprℤ())), «expr↑ »(r))), from λ
     x y h, int.coe_nat_inj (add_right_injective _ h),
     let r : injective_function exprℤ() := injective_function.mk.{0} xs' ys.1 ys.2 «expr $ »(ys.2.nodup_iff.1, nodup_map Hinj (nodup_range _)) in
     pure r),
  shrink := @injective_function.shrink exprℤ() _ _ }

end InjectiveFunction

open Function

instance injective.testable (f : α → β)
  [I : testable (named_binder "x"$ ∀ (x : α), named_binder "y"$ ∀ (y : α), named_binder "H"$ f x = f y → x = y)] :
  testable (injective f) :=
  I

instance monotone.testable [Preorderₓ α] [Preorderₓ β] (f : α → β)
  [I : testable (named_binder "x"$ ∀ (x : α), named_binder "y"$ ∀ (y : α), named_binder "H"$ x ≤ y → f x ≤ f y)] :
  testable (Monotone f) :=
  I

instance antitone.testable [Preorderₓ α] [Preorderₓ β] (f : α → β)
  [I : testable (named_binder "x"$ ∀ (x : α), named_binder "y"$ ∀ (y : α), named_binder "H"$ x ≤ y → f y ≤ f x)] :
  testable (Antitone f) :=
  I

end SlimCheck

