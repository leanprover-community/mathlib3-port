/-
Copyright (c) 2022 Matej Penciak. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Matej Penciak, Moritz Doll, Fabien Clery

! This file was ported from Lean 3 source module linear_algebra.symplectic_group
! leanprover-community/mathlib commit 70fd9563a21e7b963887c9360bd29b2393e6225a
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Matrix.NonsingularInverse

/-!
# The Symplectic Group

This file defines the symplectic group and proves elementary properties.

## Main Definitions

`matrix.J`: the canonical `2n × 2n` skew-symmetric matrix
`symplectic_group`: the group of symplectic matrices

## TODO
* Every symplectic matrix has determinant 1.
* For `n = 1` the symplectic group coincides with the special linear group.
-/


open Matrix

variable {l R : Type _}

namespace Matrix

variable (l) [DecidableEq l] (R) [CommRing R]

section JMatrixLemmas

#print Matrix.J /-
/-- The matrix defining the canonical skew-symmetric bilinear form. -/
def J : Matrix (Sum l l) (Sum l l) R :=
  Matrix.fromBlocks 0 (-1) 1 0
#align matrix.J Matrix.J
-/

/- warning: matrix.J_transpose -> Matrix.J_transpose is a dubious translation:
lean 3 declaration is
  forall (l : Type.{u1}) (R : Type.{u2}) [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : CommRing.{u2} R], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.transpose.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2)) (Neg.neg.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasNeg.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (SubNegMonoid.toHasNeg.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_2))))))) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2))
but is expected to have type
  forall (l : Type.{u2}) (R : Type.{u1}) [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : CommRing.{u1} R], Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.transpose.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2)) (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.neg.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (Ring.toNeg.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2))
Case conversion may be inaccurate. Consider using '#align matrix.J_transpose Matrix.J_transposeₓ'. -/
@[simp]
theorem J_transpose : (J l R)ᵀ = -J l R :=
  by
  rw [J, from_blocks_transpose, ← neg_one_smul R (from_blocks _ _ _ _), from_blocks_smul,
    Matrix.transpose_zero, Matrix.transpose_one, transpose_neg]
  simp [from_blocks]
#align matrix.J_transpose Matrix.J_transpose

variable [Fintype l]

/- warning: matrix.J_squared -> Matrix.J_squared is a dubious translation:
lean 3 declaration is
  forall (l : Type.{u1}) (R : Type.{u2}) [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : CommRing.{u2} R] [_inst_3 : Fintype.{u1} l], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_3 _inst_3) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_2))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_2))))) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2)) (Neg.neg.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasNeg.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (SubNegMonoid.toHasNeg.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_2))))))) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasOne.{u2, u1} (Sum.{u1, u1} l l) R (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b) (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_2)))))) (AddMonoidWithOne.toOne.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_2))))))))))
but is expected to have type
  forall (l : Type.{u2}) (R : Type.{u1}) [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : CommRing.{u1} R] [_inst_3 : Fintype.{u2} l], Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_3 _inst_3) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_2)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_2))))) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2)) (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.neg.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (Ring.toNeg.{u1} R (CommRing.toRing.{u1} R _inst_2))) (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.one.{u1, u2} (Sum.{u2, u2} l l) R (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_2))) (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align matrix.J_squared Matrix.J_squaredₓ'. -/
theorem J_squared : J l R ⬝ J l R = -1 :=
  by
  rw [J, from_blocks_multiply]
  simp only [Matrix.zero_mul, Matrix.neg_mul, zero_add, neg_zero, Matrix.one_mul, add_zero]
  rw [← neg_zero, ← Matrix.fromBlocks_neg, ← from_blocks_one]
#align matrix.J_squared Matrix.J_squared

/- warning: matrix.J_inv -> Matrix.J_inv is a dubious translation:
lean 3 declaration is
  forall (l : Type.{u1}) (R : Type.{u2}) [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : CommRing.{u2} R] [_inst_3 : Fintype.{u1} l], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasInv.{u1, u2} (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_3 _inst_3) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b) _inst_2) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2)) (Neg.neg.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasNeg.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (SubNegMonoid.toHasNeg.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_2))))))) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2))
but is expected to have type
  forall (l : Type.{u2}) (R : Type.{u1}) [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : CommRing.{u1} R] [_inst_3 : Fintype.{u2} l], Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Inv.inv.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.inv.{u2, u1} (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_3 _inst_3) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b) _inst_2) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2)) (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.neg.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (Ring.toNeg.{u1} R (CommRing.toRing.{u1} R _inst_2))) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2))
Case conversion may be inaccurate. Consider using '#align matrix.J_inv Matrix.J_invₓ'. -/
theorem J_inv : (J l R)⁻¹ = -J l R :=
  by
  refine' Matrix.inv_eq_right_inv _
  rw [Matrix.mul_neg, J_squared]
  exact neg_neg 1
#align matrix.J_inv Matrix.J_inv

/- warning: matrix.J_det_mul_J_det -> Matrix.J_det_mul_J_det is a dubious translation:
lean 3 declaration is
  forall (l : Type.{u1}) (R : Type.{u2}) [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : CommRing.{u2} R] [_inst_3 : Fintype.{u1} l], Eq.{succ u2} R (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_2)))) (Matrix.det.{u2, u1} (Sum.{u1, u1} l l) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b) (Sum.fintype.{u1, u1} l l _inst_3 _inst_3) R _inst_2 (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2)) (Matrix.det.{u2, u1} (Sum.{u1, u1} l l) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b) (Sum.fintype.{u1, u1} l l _inst_3 _inst_3) R _inst_2 (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2))) (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_2))))))))
but is expected to have type
  forall (l : Type.{u1}) (R : Type.{u2}) [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : CommRing.{u2} R] [_inst_3 : Fintype.{u1} l], Eq.{succ u2} R (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_2))))) (Matrix.det.{u2, u1} (Sum.{u1, u1} l l) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.instDecidableEqSum.{u1, u1} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b) (instFintypeSum.{u1, u1} l l _inst_3 _inst_3) R _inst_2 (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2)) (Matrix.det.{u2, u1} (Sum.{u1, u1} l l) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.instDecidableEqSum.{u1, u1} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b) (instFintypeSum.{u1, u1} l l _inst_3 _inst_3) R _inst_2 (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2))) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_2)))))
Case conversion may be inaccurate. Consider using '#align matrix.J_det_mul_J_det Matrix.J_det_mul_J_detₓ'. -/
theorem J_det_mul_J_det : det (J l R) * det (J l R) = 1 :=
  by
  rw [← det_mul, J_squared]
  rw [← one_smul R (-1 : Matrix _ _ R)]
  rw [smul_neg, ← neg_smul, det_smul]
  simp only [Fintype.card_sum, det_one, mul_one]
  apply Even.neg_one_pow
  exact even_add_self _
#align matrix.J_det_mul_J_det Matrix.J_det_mul_J_det

#print Matrix.isUnit_det_J /-
theorem isUnit_det_J : IsUnit (det (J l R)) :=
  isUnit_iff_exists_inv.mpr ⟨det (J l R), J_det_mul_J_det _ _⟩
#align matrix.is_unit_det_J Matrix.isUnit_det_J
-/

end JMatrixLemmas

variable [Fintype l]

/- warning: matrix.symplectic_group -> Matrix.symplecticGroup is a dubious translation:
lean 3 declaration is
  forall (l : Type.{u1}) (R : Type.{u2}) [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : CommRing.{u2} R] [_inst_3 : Fintype.{u1} l], Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_2))) (Sum.fintype.{u1, u1} l l _inst_3 _inst_3) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))
but is expected to have type
  forall (l : Type.{u1}) (R : Type.{u2}) [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : CommRing.{u2} R] [_inst_3 : Fintype.{u1} l], Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_2))) (instFintypeSum.{u1, u1} l l _inst_3 _inst_3) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.instDecidableEqSum.{u1, u1} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))
Case conversion may be inaccurate. Consider using '#align matrix.symplectic_group Matrix.symplecticGroupₓ'. -/
/-- The group of symplectic matrices over a ring `R`. -/
def symplecticGroup : Submonoid (Matrix (Sum l l) (Sum l l) R)
    where
  carrier := { A | A ⬝ J l R ⬝ Aᵀ = J l R }
  mul_mem' := by
    intro a b ha hb
    simp only [mul_eq_mul, Set.mem_setOf_eq, transpose_mul] at *
    rw [← Matrix.mul_assoc, a.mul_assoc, a.mul_assoc, hb]
    exact ha
  one_mem' := by simp
#align matrix.symplectic_group Matrix.symplecticGroup

end Matrix

namespace SymplecticGroup

variable {l} {R} [DecidableEq l] [Fintype l] [CommRing R]

open Matrix

/- warning: symplectic_group.mem_iff -> SymplecticGroup.mem_iff is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) A (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)) (Matrix.transpose.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R A)) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3))
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R}, Iff (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) A (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)) (Matrix.transpose.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R A)) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3))
Case conversion may be inaccurate. Consider using '#align symplectic_group.mem_iff SymplecticGroup.mem_iffₓ'. -/
theorem mem_iff {A : Matrix (Sum l l) (Sum l l) R} :
    A ∈ symplecticGroup l R ↔ A ⬝ J l R ⬝ Aᵀ = J l R := by simp [symplectic_group]
#align symplectic_group.mem_iff SymplecticGroup.mem_iff

/- warning: symplectic_group.coe_matrix -> SymplecticGroup.coeMatrix is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R], Coe.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R)
but is expected to have type
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R], Coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (Subtype.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (fun (x : Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) => Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (instFintypeSum.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.instDecidableEqSum.{u1, u1} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (instFintypeSum.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.instDecidableEqSum.{u1, u1} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (instFintypeSum.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.instDecidableEqSum.{u1, u1} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) x (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R)
Case conversion may be inaccurate. Consider using '#align symplectic_group.coe_matrix SymplecticGroup.coeMatrixₓ'. -/
instance coeMatrix : Coe (symplecticGroup l R) (Matrix (Sum l l) (Sum l l) R) := by infer_instance
#align symplectic_group.coe_matrix SymplecticGroup.coeMatrix

section SymplecticJ

variable (l) (R)

/- warning: symplectic_group.J_mem -> SymplecticGroup.J_mem is a dubious translation:
lean 3 declaration is
  forall (l : Type.{u1}) (R : Type.{u2}) [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R], Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)
but is expected to have type
  forall (l : Type.{u2}) (R : Type.{u1}) [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R], Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3) (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)
Case conversion may be inaccurate. Consider using '#align symplectic_group.J_mem SymplecticGroup.J_memₓ'. -/
theorem J_mem : J l R ∈ symplecticGroup l R :=
  by
  rw [mem_iff, J, from_blocks_multiply, from_blocks_transpose, from_blocks_multiply]
  simp
#align symplectic_group.J_mem SymplecticGroup.J_mem

/- warning: symplectic_group.sym_J -> SymplecticGroup.symJ is a dubious translation:
lean 3 declaration is
  forall (l : Type.{u1}) (R : Type.{u2}) [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R], coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)
but is expected to have type
  forall (l : Type.{u1}) (R : Type.{u2}) [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R], Subtype.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (fun (x : Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) => Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (instFintypeSum.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.instDecidableEqSum.{u1, u1} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (instFintypeSum.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.instDecidableEqSum.{u1, u1} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (instFintypeSum.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.instDecidableEqSum.{u1, u1} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) x (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))
Case conversion may be inaccurate. Consider using '#align symplectic_group.sym_J SymplecticGroup.symJₓ'. -/
/-- The canonical skew-symmetric matrix as an element in the symplectic group. -/
def symJ : symplecticGroup l R :=
  ⟨J l R, J_mem l R⟩
#align symplectic_group.sym_J SymplecticGroup.symJ

variable {l} {R}

/- warning: symplectic_group.coe_J -> SymplecticGroup.coe_J is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) ((fun (a : Type.{max u1 u2}) (b : Type.{max u1 u2}) [self : HasLiftT.{succ (max u1 u2), succ (max u1 u2)} a b] => self.0) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (HasLiftT.mk.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (CoeTCₓ.coe.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (coeBase.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (SymplecticGroup.coeMatrix.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3)))) (SymplecticGroup.symJ.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3)) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R], Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Subtype.val.{succ (max u2 u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (fun (x : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) => Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Set.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R)) (Set.instMembershipSet.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R)) x (SetLike.coe.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))) (SymplecticGroup.symJ.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3)) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)
Case conversion may be inaccurate. Consider using '#align symplectic_group.coe_J SymplecticGroup.coe_Jₓ'. -/
@[simp]
theorem coe_J : ↑(symJ l R) = J l R :=
  rfl
#align symplectic_group.coe_J SymplecticGroup.coe_J

end SymplecticJ

variable {R} {A : Matrix (Sum l l) (Sum l l) R}

/- warning: symplectic_group.neg_mem -> SymplecticGroup.neg_mem is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R}, (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) -> (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) (Neg.neg.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasNeg.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (SubNegMonoid.toHasNeg.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_3))))))) A) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R}, (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) -> (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.neg.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (Ring.toNeg.{u1} R (CommRing.toRing.{u1} R _inst_3))) A) (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))
Case conversion may be inaccurate. Consider using '#align symplectic_group.neg_mem SymplecticGroup.neg_memₓ'. -/
theorem neg_mem (h : A ∈ symplecticGroup l R) : -A ∈ symplecticGroup l R :=
  by
  rw [mem_iff] at h⊢
  simp [h]
#align symplectic_group.neg_mem SymplecticGroup.neg_mem

/- warning: symplectic_group.symplectic_det -> SymplecticGroup.symplectic_det is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R}, (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) -> (IsUnit.{u2} R (Ring.toMonoid.{u2} R (CommRing.toRing.{u2} R _inst_3)) (Matrix.det.{u2, u1} (Sum.{u1, u1} l l) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) R _inst_3 A))
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R}, (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) -> (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (Matrix.det.{u1, u2} (Sum.{u2, u2} l l) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) R _inst_3 A))
Case conversion may be inaccurate. Consider using '#align symplectic_group.symplectic_det SymplecticGroup.symplectic_detₓ'. -/
theorem symplectic_det (hA : A ∈ symplecticGroup l R) : IsUnit <| det A :=
  by
  rw [isUnit_iff_exists_inv]
  use A.det
  refine' (is_unit_det_J l R).mul_left_cancel _
  rw [mul_one]
  rw [mem_iff] at hA
  apply_fun det  at hA
  simp only [det_mul, det_transpose] at hA
  rw [mul_comm A.det, mul_assoc] at hA
  exact hA
#align symplectic_group.symplectic_det SymplecticGroup.symplectic_det

/- warning: symplectic_group.transpose_mem -> SymplecticGroup.transpose_mem is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R}, (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) -> (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) (Matrix.transpose.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R A) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R}, (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) -> (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) (Matrix.transpose.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R A) (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))
Case conversion may be inaccurate. Consider using '#align symplectic_group.transpose_mem SymplecticGroup.transpose_memₓ'. -/
theorem transpose_mem (hA : A ∈ symplecticGroup l R) : Aᵀ ∈ symplecticGroup l R :=
  by
  rw [mem_iff] at hA⊢
  rw [transpose_transpose]
  have huA := symplectic_det hA
  have huAT : IsUnit Aᵀ.det := by
    rw [Matrix.det_transpose]
    exact huA
  calc
    Aᵀ ⬝ J l R ⬝ A = (-Aᵀ) ⬝ (J l R)⁻¹ ⬝ A := by
      rw [J_inv]
      simp
    _ = (-Aᵀ) ⬝ (A ⬝ J l R ⬝ Aᵀ)⁻¹ ⬝ A := by rw [hA]
    _ = (-Aᵀ ⬝ (Aᵀ⁻¹ ⬝ (J l R)⁻¹)) ⬝ A⁻¹ ⬝ A := by
      simp only [Matrix.mul_inv_rev, Matrix.mul_assoc, Matrix.neg_mul]
    _ = -(J l R)⁻¹ := by
      rw [mul_nonsing_inv_cancel_left _ _ huAT, nonsing_inv_mul_cancel_right _ _ huA]
    _ = J l R := by simp [J_inv]
    
#align symplectic_group.transpose_mem SymplecticGroup.transpose_mem

/- warning: symplectic_group.transpose_mem_iff -> SymplecticGroup.transpose_mem_iff is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) (Matrix.transpose.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R A) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R}, Iff (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) (Matrix.transpose.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R A) (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))
Case conversion may be inaccurate. Consider using '#align symplectic_group.transpose_mem_iff SymplecticGroup.transpose_mem_iffₓ'. -/
@[simp]
theorem transpose_mem_iff : Aᵀ ∈ symplecticGroup l R ↔ A ∈ symplecticGroup l R :=
  ⟨fun hA => by simpa using transpose_mem hA, transpose_mem⟩
#align symplectic_group.transpose_mem_iff SymplecticGroup.transpose_mem_iff

/- warning: symplectic_group.mem_iff' -> SymplecticGroup.mem_iff' is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Matrix.transpose.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R A) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)) A) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3))
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R}, Iff (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Matrix.transpose.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R A) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)) A) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3))
Case conversion may be inaccurate. Consider using '#align symplectic_group.mem_iff' SymplecticGroup.mem_iff'ₓ'. -/
theorem mem_iff' : A ∈ symplecticGroup l R ↔ Aᵀ ⬝ J l R ⬝ A = J l R := by
  rw [← transpose_mem_iff, mem_iff, transpose_transpose]
#align symplectic_group.mem_iff' SymplecticGroup.mem_iff'

instance : Inv (symplecticGroup l R)
    where inv A :=
    ⟨(-J l R) ⬝ (A : Matrix (Sum l l) (Sum l l) R)ᵀ ⬝ J l R,
      mul_mem (mul_mem (neg_mem <| J_mem _ _) <| transpose_mem A.2) <| J_mem _ _⟩

/- warning: symplectic_group.coe_inv -> SymplecticGroup.coe_inv is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R] (A : coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) ((fun (a : Type.{max u1 u2}) (b : Type.{max u1 u2}) [self : HasLiftT.{succ (max u1 u2), succ (max u1 u2)} a b] => self.0) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (HasLiftT.mk.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (CoeTCₓ.coe.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (coeBase.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (SymplecticGroup.coeMatrix.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3)))) (Inv.inv.{max u1 u2} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (SymplecticGroup.Matrix.SymplecticGroup.hasInv.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3) A)) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Neg.neg.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasNeg.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (SubNegMonoid.toHasNeg.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_3))))))) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)) (Matrix.transpose.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R ((fun (a : Type.{max u1 u2}) (b : Type.{max u1 u2}) [self : HasLiftT.{succ (max u1 u2), succ (max u1 u2)} a b] => self.0) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (HasLiftT.mk.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (CoeTCₓ.coe.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (coeBase.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (SymplecticGroup.coeMatrix.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3)))) A))) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3))
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R] (A : Subtype.{succ (max u2 u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (fun (x : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) => Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) x (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))), Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Subtype.val.{succ (max u2 u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (fun (x : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) => Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Set.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R)) (Set.instMembershipSet.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R)) x (SetLike.coe.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))) (Inv.inv.{max u2 u1} (Subtype.{succ (max u2 u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (fun (x : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) => Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) x (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))) (SymplecticGroup.hasInv.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3) A)) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.neg.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (Ring.toNeg.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)) (Matrix.transpose.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (Subtype.val.{succ (max u2 u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (fun (x : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) => Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Set.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R)) (Set.instMembershipSet.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R)) x (SetLike.coe.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))) A))) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3))
Case conversion may be inaccurate. Consider using '#align symplectic_group.coe_inv SymplecticGroup.coe_invₓ'. -/
theorem coe_inv (A : symplecticGroup l R) : (↑A⁻¹ : Matrix _ _ _) = (-J l R) ⬝ (↑A)ᵀ ⬝ J l R :=
  rfl
#align symplectic_group.coe_inv SymplecticGroup.coe_inv

/- warning: symplectic_group.inv_left_mul_aux -> SymplecticGroup.inv_left_mul_aux is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R}, (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Neg.neg.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasNeg.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (SubNegMonoid.toHasNeg.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_3))))))) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3) (Matrix.transpose.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R A)) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasOne.{u2, u1} (Sum.{u1, u1} l l) R (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b) (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3)))))) (AddMonoidWithOne.toOne.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_3))))))))))
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R}, (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) -> (Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.neg.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (Ring.toNeg.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3) (Matrix.transpose.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R A)) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)) A)) (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.one.{u1, u2} (Sum.{u2, u2} l l) R (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_3))) (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align symplectic_group.inv_left_mul_aux SymplecticGroup.inv_left_mul_auxₓ'. -/
theorem inv_left_mul_aux (hA : A ∈ symplecticGroup l R) : -J l R ⬝ Aᵀ ⬝ J l R ⬝ A = 1 :=
  calc
    -J l R ⬝ Aᵀ ⬝ J l R ⬝ A = (-J l R) ⬝ (Aᵀ ⬝ J l R ⬝ A) := by
      simp only [Matrix.mul_assoc, Matrix.neg_mul]
    _ = (-J l R) ⬝ J l R := by
      rw [mem_iff'] at hA
      rw [hA]
    _ = (-1 : R) • J l R ⬝ J l R := by simp only [Matrix.neg_mul, neg_smul, one_smul]
    _ = (-1 : R) • -1 := by rw [J_squared]
    _ = 1 := by simp only [neg_smul_neg, one_smul]
    
#align symplectic_group.inv_left_mul_aux SymplecticGroup.inv_left_mul_aux

/- warning: symplectic_group.coe_inv' -> SymplecticGroup.coe_inv' is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R] (A : coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) ((fun (a : Type.{max u1 u2}) (b : Type.{max u1 u2}) [self : HasLiftT.{succ (max u1 u2), succ (max u1 u2)} a b] => self.0) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (HasLiftT.mk.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (CoeTCₓ.coe.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (coeBase.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (SymplecticGroup.coeMatrix.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3)))) (Inv.inv.{max u1 u2} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (SymplecticGroup.Matrix.SymplecticGroup.hasInv.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3) A)) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasInv.{u1, u2} (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b) _inst_3) ((fun (a : Type.{max u1 u2}) (b : Type.{max u1 u2}) [self : HasLiftT.{succ (max u1 u2), succ (max u1 u2)} a b] => self.0) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (HasLiftT.mk.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (CoeTCₓ.coe.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (coeBase.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) l (fun (a : l) (b : l) => (fun (a : l) (b : l) => _inst_1 a b) a b) a b)))))) (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (SymplecticGroup.coeMatrix.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3)))) A))
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R] (A : Subtype.{succ (max u2 u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (fun (x : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) => Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) x (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))), Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Subtype.val.{succ (max u2 u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (fun (x : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) => Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Set.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R)) (Set.instMembershipSet.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R)) x (SetLike.coe.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))) (Inv.inv.{max u2 u1} (Subtype.{succ (max u2 u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (fun (x : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) => Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) x (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))) (SymplecticGroup.hasInv.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_2 _inst_3) A)) (Inv.inv.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.inv.{u2, u1} (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b) _inst_3) (Subtype.val.{succ (max u2 u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (fun (x : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) => Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Set.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R)) (Set.instMembershipSet.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R)) x (SetLike.coe.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2))) A))
Case conversion may be inaccurate. Consider using '#align symplectic_group.coe_inv' SymplecticGroup.coe_inv'ₓ'. -/
theorem coe_inv' (A : symplecticGroup l R) : (↑A⁻¹ : Matrix (Sum l l) (Sum l l) R) = A⁻¹ :=
  by
  refine' (coe_inv A).trans (inv_eq_left_inv _).symm
  simp [inv_left_mul_aux, coe_inv]
#align symplectic_group.coe_inv' SymplecticGroup.coe_inv'

/- warning: symplectic_group.inv_eq_symplectic_inv -> SymplecticGroup.inv_eq_symplectic_inv is a dubious translation:
lean 3 declaration is
  forall {l : Type.{u1}} {R : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} l] [_inst_2 : Fintype.{u1} l] [_inst_3 : CommRing.{u2} R] (A : Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R), (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.nonAssocSemiring.{u2, u1} (Sum.{u1, u1} l l) R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))) (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasInv.{u1, u2} (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (fun (a : Sum.{u1, u1} l l) (b : Sum.{u1, u1} l l) => Sum.decidableEq.{u1, u1} l (fun (a : l) (b : l) => _inst_1 a b) l (fun (a : l) (b : l) => _inst_1 a b) a b) _inst_3) A) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Matrix.mul.{u2, u1, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (Sum.fintype.{u1, u1} l l _inst_2 _inst_2) (Distrib.toHasMul.{u2} R (Ring.toDistrib.{u2} R (CommRing.toRing.{u2} R _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_3))))) (Neg.neg.{max u1 u2} (Matrix.{u1, u1, u2} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R) (Matrix.hasNeg.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R (SubNegMonoid.toHasNeg.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (AddCommGroupWithOne.toAddGroupWithOne.{u2} R (Ring.toAddCommGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_3))))))) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)) (Matrix.transpose.{u2, u1, u1} (Sum.{u1, u1} l l) (Sum.{u1, u1} l l) R A)) (Matrix.J.{u1, u2} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)))
but is expected to have type
  forall {l : Type.{u2}} {R : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} l] [_inst_2 : Fintype.{u2} l] [_inst_3 : CommRing.{u1} R] (A : Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R), (Membership.mem.{max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submonoid.{max u1 u2} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b))))) (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Submonoid.instSetLikeSubmonoid.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.nonAssocSemiring.{u1, u2} (Sum.{u2, u2} l l) R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))) (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b)))))) A (Matrix.symplecticGroup.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3 _inst_2)) -> (Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Inv.inv.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.inv.{u2, u1} (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (fun (a : Sum.{u2, u2} l l) (b : Sum.{u2, u2} l l) => Sum.instDecidableEqSum.{u2, u2} l l (fun (a : l) (b : l) => _inst_1 a b) (fun (a : l) (b : l) => _inst_1 a b) a b) _inst_3) A) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Matrix.mul.{u1, u2, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (instFintypeSum.{u2, u2} l l _inst_2 _inst_2) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_3))))) (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R) (Matrix.neg.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R (Ring.toNeg.{u1} R (CommRing.toRing.{u1} R _inst_3))) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)) (Matrix.transpose.{u1, u2, u2} (Sum.{u2, u2} l l) (Sum.{u2, u2} l l) R A)) (Matrix.J.{u2, u1} l R (fun (a : l) (b : l) => _inst_1 a b) _inst_3)))
Case conversion may be inaccurate. Consider using '#align symplectic_group.inv_eq_symplectic_inv SymplecticGroup.inv_eq_symplectic_invₓ'. -/
theorem inv_eq_symplectic_inv (A : Matrix (Sum l l) (Sum l l) R) (hA : A ∈ symplecticGroup l R) :
    A⁻¹ = (-J l R) ⬝ Aᵀ ⬝ J l R :=
  inv_eq_left_inv (by simp only [Matrix.neg_mul, inv_left_mul_aux hA])
#align symplectic_group.inv_eq_symplectic_inv SymplecticGroup.inv_eq_symplectic_inv

instance : Group (symplecticGroup l R) :=
  { SymplecticGroup.hasInv, Submonoid.toMonoid _ with
    mul_left_inv := fun A => by
      apply Subtype.ext
      simp only [Submonoid.coe_one, Submonoid.coe_mul, Matrix.neg_mul, coe_inv]
      rw [Matrix.mul_eq_mul, Matrix.neg_mul]
      exact inv_left_mul_aux A.2 }

end SymplecticGroup

