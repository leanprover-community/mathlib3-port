/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Mario Carneiro, Kevin Buzzard, Yury Kudryashov, Frédéric Dupuis,
  Heather Macbeth

! This file was ported from Lean 3 source module linear_algebra.span
! leanprover-community/mathlib commit 740acc0e6f9adf4423f92a485d0456fc271482da
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Basic
import Mathbin.Order.CompactlyGenerated
import Mathbin.Order.OmegaCompletePartialOrder

/-!
# The span of a set of vectors, as a submodule

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

* `submodule.span s` is defined to be the smallest submodule containing the set `s`.

## Notations

* We introduce the notation `R ∙ v` for the span of a singleton, `submodule.span R {v}`.  This is
  `\.`, not the same as the scalar multiplication `•`/`\bub`.

-/


variable {R R₂ K M M₂ V S : Type _}

namespace Submodule

open Function Set

open Pointwise

section AddCommMonoid

variable [Semiring R] [AddCommMonoid M] [Module R M]

variable {x : M} (p p' : Submodule R M)

variable [Semiring R₂] {σ₁₂ : R →+* R₂}

variable [AddCommMonoid M₂] [Module R₂ M₂]

section

variable (R)

#print Submodule.span /-
/-- The span of a set `s ⊆ M` is the smallest submodule of M that contains `s`. -/
def span (s : Set M) : Submodule R M :=
  infₛ { p | s ⊆ p }
#align submodule.span Submodule.span
-/

end

variable {s t : Set M}

/- warning: submodule.mem_span -> Submodule.mem_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {s : Set.{u2} M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (forall (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p)) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {s : Set.{u2} M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (forall (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p)) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p))
Case conversion may be inaccurate. Consider using '#align submodule.mem_span Submodule.mem_spanₓ'. -/
theorem mem_span : x ∈ span R s ↔ ∀ p : Submodule R M, s ⊆ p → x ∈ p :=
  mem_interᵢ₂
#align submodule.mem_span Submodule.mem_span

/- warning: submodule.subset_span -> Submodule.subset_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))
Case conversion may be inaccurate. Consider using '#align submodule.subset_span Submodule.subset_spanₓ'. -/
theorem subset_span : s ⊆ span R s := fun x h => mem_span.2 fun p hp => hp h
#align submodule.subset_span Submodule.subset_span

/- warning: submodule.span_le -> Submodule.span_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3}, Iff (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) p) (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {s : Set.{u1} M} {p : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3}, Iff (LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 s) p) (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) s (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) p))
Case conversion may be inaccurate. Consider using '#align submodule.span_le Submodule.span_leₓ'. -/
theorem span_le {p} : span R s ≤ p ↔ s ⊆ p :=
  ⟨Subset.trans subset_span, fun ss x h => mem_span.1 h _ ss⟩
#align submodule.span_le Submodule.span_le

/- warning: submodule.span_mono -> Submodule.span_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M} {t : Set.{u2} M}, (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s t) -> (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 t))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M} {t : Set.{u2} M}, (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) s t) -> (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 t))
Case conversion may be inaccurate. Consider using '#align submodule.span_mono Submodule.span_monoₓ'. -/
theorem span_mono (h : s ⊆ t) : span R s ≤ span R t :=
  span_le.2 <| Subset.trans h subset_span
#align submodule.span_mono Submodule.span_mono

/- warning: submodule.span_monotone -> Submodule.span_monotone is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Monotone.{u2, u2} (Set.{u2} M) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Set.{u2} M) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} M) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} M) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} M) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} M) (Set.completeBooleanAlgebra.{u2} M))))))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Monotone.{u2, u2} (Set.{u2} M) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Set.{u2} M) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} M) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} M) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} M) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} M) (Set.instCompleteBooleanAlgebraSet.{u2} M))))))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align submodule.span_monotone Submodule.span_monotoneₓ'. -/
theorem span_monotone : Monotone (span R : Set M → Submodule R M) := fun _ _ => span_mono
#align submodule.span_monotone Submodule.span_monotone

/- warning: submodule.span_eq_of_le -> Submodule.span_eq_of_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) {s : Set.{u2} M}, (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p)) -> (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) -> (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) p)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) {s : Set.{u2} M}, (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p)) -> (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) -> (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) p)
Case conversion may be inaccurate. Consider using '#align submodule.span_eq_of_le Submodule.span_eq_of_leₓ'. -/
theorem span_eq_of_le (h₁ : s ⊆ p) (h₂ : p ≤ span R s) : span R s = p :=
  le_antisymm (span_le.2 h₁) h₂
#align submodule.span_eq_of_le Submodule.span_eq_of_le

/- warning: submodule.span_eq -> Submodule.span_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p)) p
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p)) p
Case conversion may be inaccurate. Consider using '#align submodule.span_eq Submodule.span_eqₓ'. -/
theorem span_eq : span R (p : Set M) = p :=
  span_eq_of_le _ (Subset.refl _) subset_span
#align submodule.span_eq Submodule.span_eq

/- warning: submodule.span_eq_span -> Submodule.span_eq_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M} {t : Set.{u2} M}, (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 t))) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) t ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) -> (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 t))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M} {t : Set.{u2} M}, (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 t))) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) t (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) -> (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 t))
Case conversion may be inaccurate. Consider using '#align submodule.span_eq_span Submodule.span_eq_spanₓ'. -/
theorem span_eq_span (hs : s ⊆ span R t) (ht : t ⊆ span R s) : span R s = span R t :=
  le_antisymm (span_le.2 hs) (span_le.2 ht)
#align submodule.span_eq_span Submodule.span_eq_span

/- warning: submodule.span_coe_eq_restrict_scalars -> Submodule.span_coe_eq_restrictScalars is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {S : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) [_inst_7 : Semiring.{u3} S] [_inst_8 : SMul.{u3, u1} S R] [_inst_9 : Module.{u3, u2} S M _inst_7 _inst_2] [_inst_10 : IsScalarTower.{u3, u1, u2} S R M _inst_8 (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (SMulZeroClass.toHasSmul.{u3, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} S M (MulZeroClass.toHasZero.{u3} S (MulZeroOneClass.toMulZeroClass.{u3} S (MonoidWithZero.toMulZeroOneClass.{u3} S (Semiring.toMonoidWithZero.{u3} S _inst_7)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} S M (Semiring.toMonoidWithZero.{u3} S _inst_7) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} S M _inst_7 _inst_2 _inst_9))))], Eq.{succ u2} (Submodule.{u3, u2} S M _inst_7 _inst_2 _inst_9) (Submodule.span.{u3, u2} S M _inst_7 _inst_2 _inst_9 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p)) (Submodule.restrictScalars.{u3, u1, u2} S R M _inst_1 _inst_2 _inst_7 _inst_9 _inst_3 _inst_8 _inst_10 p)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} {S : Type.{u3}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (p : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) [_inst_7 : Semiring.{u3} S] [_inst_8 : SMul.{u3, u2} S R] [_inst_9 : Module.{u3, u1} S M _inst_7 _inst_2] [_inst_10 : IsScalarTower.{u3, u2, u1} S R M _inst_8 (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3)))) (SMulZeroClass.toSMul.{u3, u1} S M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u1} S M (MonoidWithZero.toZero.{u3} S (Semiring.toMonoidWithZero.{u3} S _inst_7)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u1} S M (Semiring.toMonoidWithZero.{u3} S _inst_7) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u3, u1} S M _inst_7 _inst_2 _inst_9))))], Eq.{succ u1} (Submodule.{u3, u1} S M _inst_7 _inst_2 _inst_9) (Submodule.span.{u3, u1} S M _inst_7 _inst_2 _inst_9 (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) p)) (Submodule.restrictScalars.{u3, u2, u1} S R M _inst_1 _inst_2 _inst_7 _inst_9 _inst_3 _inst_8 _inst_10 p)
Case conversion may be inaccurate. Consider using '#align submodule.span_coe_eq_restrict_scalars Submodule.span_coe_eq_restrictScalarsₓ'. -/
/-- A version of `submodule.span_eq` for when the span is by a smaller ring. -/
@[simp]
theorem span_coe_eq_restrictScalars [Semiring S] [SMul S R] [Module S M] [IsScalarTower S R M] :
    span S (p : Set M) = p.restrictScalars S :=
  span_eq (p.restrictScalars S)
#align submodule.span_coe_eq_restrict_scalars Submodule.span_coe_eq_restrictScalars

/- warning: submodule.map_span -> Submodule.map_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u3} M), Eq.{succ u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (Submodule.map.{u1, u2, u3, u4, max u3 u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ _inst_7 (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.span.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6 (Set.image.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u4, u2} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u3} R₂] {σ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u3, u1} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u4, u3} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u2} M), Eq.{succ u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (Submodule.map.{u4, u3, u2, u1, max u2 u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ _inst_7 (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u4, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.span.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6 (Set.image.{u2, u1} M M₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s))
Case conversion may be inaccurate. Consider using '#align submodule.map_span Submodule.map_spanₓ'. -/
theorem map_span [RingHomSurjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) (s : Set M) :
    (span R s).map f = span R₂ (f '' s) :=
  Eq.symm <|
    span_eq_of_le _ (Set.image_subset f subset_span) <|
      map_le_iff_le_comap.2 <| span_le.2 fun x hx => subset_span ⟨x, hx, rfl⟩
#align submodule.map_span Submodule.map_span

/- warning: linear_map.map_span -> LinearMap.map_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u3} M), Eq.{succ u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (Submodule.map.{u1, u2, u3, u4, max u3 u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ _inst_7 (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.span.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6 (Set.image.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u4, u2} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u3} R₂] {σ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u3, u1} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u4, u3} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u2} M), Eq.{succ u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (Submodule.map.{u4, u3, u2, u1, max u2 u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ _inst_7 (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u4, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.span.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6 (Set.image.{u2, u1} M M₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s))
Case conversion may be inaccurate. Consider using '#align linear_map.map_span LinearMap.map_spanₓ'. -/
alias Submodule.map_span ← _root_.linear_map.map_span
#align linear_map.map_span LinearMap.map_span

/- warning: submodule.map_span_le -> Submodule.map_span_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u3} M) (N : Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6), Iff (LE.le.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (Preorder.toLE.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (PartialOrder.toPreorder.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (SetLike.partialOrder.{u4, u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) M₂ (Submodule.setLike.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6)))) (Submodule.map.{u1, u2, u3, u4, max u3 u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ _inst_7 (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s)) N) (forall (m : M), (Membership.Mem.{u3, u3} M (Set.{u3} M) (Set.hasMem.{u3} M) m s) -> (Membership.Mem.{u4, u4} M₂ (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (SetLike.hasMem.{u4, u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) M₂ (Submodule.setLike.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f m) N))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u4, u2} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u3} R₂] {σ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u3, u1} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u4, u3} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u2} M) (N : Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6), Iff (LE.le.{u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (Preorder.toLE.{u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (PartialOrder.toPreorder.{u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (Submodule.completeLattice.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6))))) (Submodule.map.{u4, u3, u2, u1, max u2 u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ _inst_7 (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u4, u2} R M _inst_1 _inst_2 _inst_3 s)) N) (forall (m : M), (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) m s) -> (Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) m) (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) M₂ (Submodule.instSetLikeSubmodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f m) N))
Case conversion may be inaccurate. Consider using '#align submodule.map_span_le Submodule.map_span_leₓ'. -/
theorem map_span_le [RingHomSurjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) (s : Set M) (N : Submodule R₂ M₂) :
    map f (span R s) ≤ N ↔ ∀ m ∈ s, f m ∈ N :=
  by
  rw [f.map_span, span_le, Set.image_subset_iff]
  exact Iff.rfl
#align submodule.map_span_le Submodule.map_span_le

/- warning: linear_map.map_span_le -> LinearMap.map_span_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u3} M) (N : Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6), Iff (LE.le.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (Preorder.toLE.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (PartialOrder.toPreorder.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (SetLike.partialOrder.{u4, u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) M₂ (Submodule.setLike.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6)))) (Submodule.map.{u1, u2, u3, u4, max u3 u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ _inst_7 (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s)) N) (forall (m : M), (Membership.Mem.{u3, u3} M (Set.{u3} M) (Set.hasMem.{u3} M) m s) -> (Membership.Mem.{u4, u4} M₂ (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (SetLike.hasMem.{u4, u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) M₂ (Submodule.setLike.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f m) N))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u4, u2} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u3} R₂] {σ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u3, u1} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u4, u3} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u2} M) (N : Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6), Iff (LE.le.{u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (Preorder.toLE.{u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (PartialOrder.toPreorder.{u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (Submodule.completeLattice.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6))))) (Submodule.map.{u4, u3, u2, u1, max u2 u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ _inst_7 (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u4, u2} R M _inst_1 _inst_2 _inst_3 s)) N) (forall (m : M), (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) m s) -> (Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) m) (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) M₂ (Submodule.instSetLikeSubmodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f m) N))
Case conversion may be inaccurate. Consider using '#align linear_map.map_span_le LinearMap.map_span_leₓ'. -/
alias Submodule.map_span_le ← _root_.linear_map.map_span_le
#align linear_map.map_span_le LinearMap.map_span_le

/- warning: submodule.span_insert_zero -> Submodule.span_insert_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Insert.insert.{u2, u2} M (Set.{u2} M) (Set.hasInsert.{u2} M) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) s)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Insert.insert.{u2, u2} M (Set.{u2} M) (Set.instInsertSet.{u2} M) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) s)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)
Case conversion may be inaccurate. Consider using '#align submodule.span_insert_zero Submodule.span_insert_zeroₓ'. -/
@[simp]
theorem span_insert_zero : span R (insert (0 : M) s) = span R s :=
  by
  refine' le_antisymm _ (Submodule.span_mono (Set.subset_insert 0 s))
  rw [span_le, Set.insert_subset]
  exact ⟨by simp only [SetLike.mem_coe, Submodule.zero_mem], Submodule.subset_span⟩
#align submodule.span_insert_zero Submodule.span_insert_zero

/- warning: submodule.span_preimage_le -> Submodule.span_preimage_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] (f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u4} M₂), LE.le.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 (Set.preimage.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s)) (Submodule.comap.{u1, u2, u3, u4, max u3 u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6 s))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u4, u2} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u3} R₂] {σ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u3, u1} R₂ M₂ _inst_4 _inst_5] (f : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u1} M₂), LE.le.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u4, u2} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u4, u2} R M _inst_1 _inst_2 _inst_3 (Set.preimage.{u2, u1} M M₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s)) (Submodule.comap.{u4, u3, u2, u1, max u2 u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6 s))
Case conversion may be inaccurate. Consider using '#align submodule.span_preimage_le Submodule.span_preimage_leₓ'. -/
-- See also `span_preimage_eq` below.
theorem span_preimage_le (f : M →ₛₗ[σ₁₂] M₂) (s : Set M₂) :
    span R (f ⁻¹' s) ≤ (span R₂ s).comap f :=
  by
  rw [span_le, comap_coe]
  exact preimage_mono subset_span
#align submodule.span_preimage_le Submodule.span_preimage_le

/- warning: linear_map.span_preimage_le -> LinearMap.span_preimage_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] (f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u4} M₂), LE.le.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 (Set.preimage.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s)) (Submodule.comap.{u1, u2, u3, u4, max u3 u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6 s))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u4, u2} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u3} R₂] {σ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u3, u1} R₂ M₂ _inst_4 _inst_5] (f : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (s : Set.{u1} M₂), LE.le.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u4, u2} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u4, u2} R M _inst_1 _inst_2 _inst_3 (Set.preimage.{u2, u1} M M₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s)) (Submodule.comap.{u4, u3, u2, u1, max u2 u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6 s))
Case conversion may be inaccurate. Consider using '#align linear_map.span_preimage_le LinearMap.span_preimage_leₓ'. -/
alias Submodule.span_preimage_le ← _root_.linear_map.span_preimage_le
#align linear_map.span_preimage_le LinearMap.span_preimage_le

/- warning: submodule.closure_subset_span -> Submodule.closure_subset_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.setLike.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (AddSubmonoid.closure.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) s)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) (SetLike.coe.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.instSetLikeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.closure.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) s)) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))
Case conversion may be inaccurate. Consider using '#align submodule.closure_subset_span Submodule.closure_subset_spanₓ'. -/
theorem closure_subset_span {s : Set M} : (AddSubmonoid.closure s : Set M) ⊆ span R s :=
  (@AddSubmonoid.closure_le _ _ _ (span R s).toAddSubmonoid).mpr subset_span
#align submodule.closure_subset_span Submodule.closure_subset_span

/- warning: submodule.closure_le_to_add_submonoid_span -> Submodule.closure_le_toAddSubmonoid_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, LE.le.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Preorder.toLE.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SetLike.partialOrder.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.setLike.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (AddSubmonoid.closure.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) s) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, LE.le.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Preorder.toLE.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (PartialOrder.toPreorder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (OmegaCompletePartialOrder.toPartialOrder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (AddSubmonoid.closure.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) s) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))
Case conversion may be inaccurate. Consider using '#align submodule.closure_le_to_add_submonoid_span Submodule.closure_le_toAddSubmonoid_spanₓ'. -/
theorem closure_le_toAddSubmonoid_span {s : Set M} :
    AddSubmonoid.closure s ≤ (span R s).toAddSubmonoid :=
  closure_subset_span
#align submodule.closure_le_to_add_submonoid_span Submodule.closure_le_toAddSubmonoid_span

/- warning: submodule.span_closure -> Submodule.span_closure is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.setLike.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (AddSubmonoid.closure.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) s))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (SetLike.coe.{u2, u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) M (AddSubmonoid.instSetLikeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.closure.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) s))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)
Case conversion may be inaccurate. Consider using '#align submodule.span_closure Submodule.span_closureₓ'. -/
@[simp]
theorem span_closure {s : Set M} : span R (AddSubmonoid.closure s : Set M) = span R s :=
  le_antisymm (span_le.mpr closure_subset_span) (span_mono AddSubmonoid.subset_closure)
#align submodule.span_closure Submodule.span_closure

/- warning: submodule.span_induction -> Submodule.span_induction is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {s : Set.{u2} M} {p : M -> Prop}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) -> (forall (x : M), (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s) -> (p x)) -> (p (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) -> (forall (x : M) (y : M), (p x) -> (p y) -> (p (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y))) -> (forall (a : R) (x : M), (p x) -> (p (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a x))) -> (p x)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {s : Set.{u2} M} {p : M -> Prop}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) -> (forall (x : M), (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s) -> (p x)) -> (p (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) -> (forall (x : M) (y : M), (p x) -> (p y) -> (p (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y))) -> (forall (a : R) (x : M), (p x) -> (p (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) a x))) -> (p x)
Case conversion may be inaccurate. Consider using '#align submodule.span_induction Submodule.span_inductionₓ'. -/
/-- An induction principle for span membership. If `p` holds for 0 and all elements of `s`, and is
preserved under addition and scalar multiplication, then `p` holds for all elements of the span of
`s`. -/
@[elab_as_elim]
theorem span_induction {p : M → Prop} (h : x ∈ span R s) (Hs : ∀ x ∈ s, p x) (H0 : p 0)
    (H1 : ∀ x y, p x → p y → p (x + y)) (H2 : ∀ (a : R) (x), p x → p (a • x)) : p x :=
  (@span_le _ _ _ _ _ _ ⟨p, H1, H0, H2⟩).2 Hs h
#align submodule.span_induction Submodule.span_induction

/- warning: submodule.span_induction' -> Submodule.span_induction' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M} {p : forall (x : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) -> Prop}, (forall (x : M) (h : Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s), p x (Submodule.subset_span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s x h)) -> (p (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (Submodule.zero_mem.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) -> (forall (x : M) (hx : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (y : M) (hy : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)), (p x hx) -> (p y hy) -> (p (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y) (Submodule.add_mem.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) x y hx hy))) -> (forall (a : R) (x : M) (hx : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)), (p x hx) -> (p (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a x) (Submodule.smul_mem.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) x a hx))) -> (forall {x : M} (hx : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)), p x hx)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M} {p : forall (x : M), (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) -> Prop}, (forall (x : M) (h : Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s), p x (Submodule.subset_span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s x h)) -> (p (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Submodule.zero_mem.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) -> (forall (x : M) (hx : Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (y : M) (hy : Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)), (p x hx) -> (p y hy) -> (p (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y) (Submodule.add_mem.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) x y hx hy))) -> (forall (a : R) (x : M) (hx : Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)), (p x hx) -> (p (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) a x) (Submodule.smul_mem.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) x a hx))) -> (forall {x : M} (hx : Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)), p x hx)
Case conversion may be inaccurate. Consider using '#align submodule.span_induction' Submodule.span_induction'ₓ'. -/
/-- A dependent version of `submodule.span_induction`. -/
theorem span_induction' {p : ∀ x, x ∈ span R s → Prop} (Hs : ∀ (x) (h : x ∈ s), p x (subset_span h))
    (H0 : p 0 (Submodule.zero_mem _))
    (H1 : ∀ x hx y hy, p x hx → p y hy → p (x + y) (Submodule.add_mem _ ‹_› ‹_›))
    (H2 : ∀ (a : R) (x hx), p x hx → p (a • x) (Submodule.smul_mem _ _ ‹_›)) {x}
    (hx : x ∈ span R s) : p x hx :=
  by
  refine' Exists.elim _ fun (hx : x ∈ span R s) (hc : p x hx) => hc
  refine'
    span_induction hx (fun m hm => ⟨subset_span hm, Hs m hm⟩) ⟨zero_mem _, H0⟩
      (fun x y hx hy =>
        Exists.elim hx fun hx' hx =>
          Exists.elim hy fun hy' hy => ⟨add_mem hx' hy', H1 _ _ _ _ hx hy⟩)
      fun r x hx => Exists.elim hx fun hx' hx => ⟨smul_mem _ _ hx', H2 r _ _ hx⟩
#align submodule.span_induction' Submodule.span_induction'

/- warning: submodule.span_span_coe_preimage -> Submodule.span_span_coe_preimage is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.span.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Set.preimage.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))))))) s)) (Top.top.{u2} (Submodule.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.hasTop.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)))) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.span.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)))) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Set.preimage.{u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)))) M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)))) s)) (Top.top.{u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)))) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.instTopSubmodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)))) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))))
Case conversion may be inaccurate. Consider using '#align submodule.span_span_coe_preimage Submodule.span_span_coe_preimageₓ'. -/
@[simp]
theorem span_span_coe_preimage : span R ((coe : span R s → M) ⁻¹' s) = ⊤ :=
  eq_top_iff.2 fun x =>
    Subtype.recOn x fun x hx _ =>
      by
      refine' span_induction' (fun x hx => _) _ (fun x y _ _ => _) (fun r x _ => _) hx
      · exact subset_span hx
      · exact zero_mem _
      · exact add_mem
      · exact smul_mem _ _
#align submodule.span_span_coe_preimage Submodule.span_span_coe_preimage

#print Submodule.span_nat_eq_addSubmonoid_closure /-
theorem span_nat_eq_addSubmonoid_closure (s : Set M) :
    (span ℕ s).toAddSubmonoid = AddSubmonoid.closure s :=
  by
  refine' Eq.symm (AddSubmonoid.closure_eq_of_le subset_span _)
  apply add_submonoid.to_nat_submodule.symm.to_galois_connection.l_le _
  rw [span_le]
  exact AddSubmonoid.subset_closure
#align submodule.span_nat_eq_add_submonoid_closure Submodule.span_nat_eq_addSubmonoid_closure
-/

/- warning: submodule.span_nat_eq -> Submodule.span_nat_eq is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] (s : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))), Eq.{succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Submodule.toAddSubmonoid.{0, u1} Nat M Nat.semiring _inst_2 (AddCommMonoid.natModule.{u1} M _inst_2) (Submodule.span.{0, u1} Nat M Nat.semiring _inst_2 (AddCommMonoid.natModule.{u1} M _inst_2) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) M (AddSubmonoid.setLike.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))))) s))) s
but is expected to have type
  forall {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] (s : AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))), Eq.{succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Submodule.toAddSubmonoid.{0, u1} Nat M Nat.semiring _inst_2 (AddCommMonoid.natModule.{u1} M _inst_2) (Submodule.span.{0, u1} Nat M Nat.semiring _inst_2 (AddCommMonoid.natModule.{u1} M _inst_2) (SetLike.coe.{u1, u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) M (AddSubmonoid.instSetLikeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) s))) s
Case conversion may be inaccurate. Consider using '#align submodule.span_nat_eq Submodule.span_nat_eqₓ'. -/
@[simp]
theorem span_nat_eq (s : AddSubmonoid M) : (span ℕ (s : Set M)).toAddSubmonoid = s := by
  rw [span_nat_eq_add_submonoid_closure, s.closure_eq]
#align submodule.span_nat_eq Submodule.span_nat_eq

/- warning: submodule.span_int_eq_add_subgroup_closure -> Submodule.span_int_eq_addSubgroup_closure is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_7 : AddCommGroup.{u1} M] (s : Set.{u1} M), Eq.{succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)) (Submodule.toAddSubgroup.{0, u1} Int M Int.ring _inst_7 (AddCommGroup.intModule.{u1} M _inst_7) (Submodule.span.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_7) (AddCommGroup.intModule.{u1} M _inst_7) s)) (AddSubgroup.closure.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7) s)
but is expected to have type
  forall {M : Type.{u1}} [_inst_7 : AddCommGroup.{u1} M] (s : Set.{u1} M), Eq.{succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)) (Submodule.toAddSubgroup.{0, u1} Int M Int.instRingInt _inst_7 (AddCommGroup.intModule.{u1} M _inst_7) (Submodule.span.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_7) (AddCommGroup.intModule.{u1} M _inst_7) s)) (AddSubgroup.closure.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7) s)
Case conversion may be inaccurate. Consider using '#align submodule.span_int_eq_add_subgroup_closure Submodule.span_int_eq_addSubgroup_closureₓ'. -/
theorem span_int_eq_addSubgroup_closure {M : Type _} [AddCommGroup M] (s : Set M) :
    (span ℤ s).toAddSubgroup = AddSubgroup.closure s :=
  Eq.symm <|
    AddSubgroup.closure_eq_of_le _ subset_span fun x hx =>
      span_induction hx (fun x hx => AddSubgroup.subset_closure hx) (AddSubgroup.zero_mem _)
        (fun _ _ => AddSubgroup.add_mem _) fun _ _ _ => AddSubgroup.zsmul_mem _ ‹_› _
#align submodule.span_int_eq_add_subgroup_closure Submodule.span_int_eq_addSubgroup_closure

/- warning: submodule.span_int_eq -> Submodule.span_int_eq is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_7 : AddCommGroup.{u1} M] (s : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)), Eq.{succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)) (Submodule.toAddSubgroup.{0, u1} Int M Int.ring _inst_7 (AddCommGroup.intModule.{u1} M _inst_7) (Submodule.span.{0, u1} Int M Int.semiring (AddCommGroup.toAddCommMonoid.{u1} M _inst_7) (AddCommGroup.intModule.{u1} M _inst_7) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)) (Set.{u1} M) (HasLiftT.mk.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)) (Set.{u1} M) (CoeTCₓ.coe.{succ u1, succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)) (Set.{u1} M) (SetLike.Set.hasCoeT.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)) M (AddSubgroup.setLike.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7))))) s))) s
but is expected to have type
  forall {M : Type.{u1}} [_inst_7 : AddCommGroup.{u1} M] (s : AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)), Eq.{succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)) (Submodule.toAddSubgroup.{0, u1} Int M Int.instRingInt _inst_7 (AddCommGroup.intModule.{u1} M _inst_7) (Submodule.span.{0, u1} Int M Int.instSemiringInt (AddCommGroup.toAddCommMonoid.{u1} M _inst_7) (AddCommGroup.intModule.{u1} M _inst_7) (SetLike.coe.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)) M (AddSubgroup.instSetLikeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_7)) s))) s
Case conversion may be inaccurate. Consider using '#align submodule.span_int_eq Submodule.span_int_eqₓ'. -/
@[simp]
theorem span_int_eq {M : Type _} [AddCommGroup M] (s : AddSubgroup M) :
    (span ℤ (s : Set M)).toAddSubgroup = s := by rw [span_int_eq_add_subgroup_closure, s.closure_eq]
#align submodule.span_int_eq Submodule.span_int_eq

section

variable (R M)

/- warning: submodule.gi -> Submodule.gi is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], GaloisInsertion.{u2, u2} (Set.{u2} M) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Set.{u2} M) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} M) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} M) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} M) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} M) (Set.completeBooleanAlgebra.{u2} M))))))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], GaloisInsertion.{u2, u2} (Set.{u2} M) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Set.{u2} M) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} M) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} M) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} M) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} M) (Set.instCompleteBooleanAlgebraSet.{u2} M))))))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.gi Submodule.giₓ'. -/
/-- `span` forms a Galois insertion with the coercion from submodule to set. -/
protected def gi : GaloisInsertion (@span R M _ _ _) coe
    where
  choice s _ := span R s
  gc s t := span_le
  le_l_u s := subset_span
  choice_eq s h := rfl
#align submodule.gi Submodule.gi

end

/- warning: submodule.span_empty -> Submodule.span_empty is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (EmptyCollection.emptyCollection.{u2} (Set.{u2} M) (Set.hasEmptyc.{u2} M))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (EmptyCollection.emptyCollection.{u2} (Set.{u2} M) (Set.instEmptyCollectionSet.{u2} M))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.span_empty Submodule.span_emptyₓ'. -/
@[simp]
theorem span_empty : span R (∅ : Set M) = ⊥ :=
  (Submodule.gi R M).gc.l_bot
#align submodule.span_empty Submodule.span_empty

/- warning: submodule.span_univ -> Submodule.span_univ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.univ.{u2} M)) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.univ.{u2} M)) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.span_univ Submodule.span_univₓ'. -/
@[simp]
theorem span_univ : span R (univ : Set M) = ⊤ :=
  eq_top_iff.2 <| SetLike.le_def.2 <| subset_span
#align submodule.span_univ Submodule.span_univ

/- warning: submodule.span_union -> Submodule.span_union is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (s : Set.{u2} M) (t : Set.{u2} M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Union.union.{u2} (Set.{u2} M) (Set.hasUnion.{u2} M) s t)) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 t))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (s : Set.{u2} M) (t : Set.{u2} M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Union.union.{u2} (Set.{u2} M) (Set.instUnionSet.{u2} M) s t)) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 t))
Case conversion may be inaccurate. Consider using '#align submodule.span_union Submodule.span_unionₓ'. -/
theorem span_union (s t : Set M) : span R (s ∪ t) = span R s ⊔ span R t :=
  (Submodule.gi R M).gc.l_sup
#align submodule.span_union Submodule.span_union

/- warning: submodule.span_Union -> Submodule.span_unionᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} (s : ι -> (Set.{u2} M)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.unionᵢ.{u2, u3} M ι (fun (i : ι) => s i))) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (s i)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} (s : ι -> (Set.{u2} M)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.unionᵢ.{u2, u3} M ι (fun (i : ι) => s i))) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (s i)))
Case conversion may be inaccurate. Consider using '#align submodule.span_Union Submodule.span_unionᵢₓ'. -/
theorem span_unionᵢ {ι} (s : ι → Set M) : span R (⋃ i, s i) = ⨆ i, span R (s i) :=
  (Submodule.gi R M).gc.l_supᵢ
#align submodule.span_Union Submodule.span_unionᵢ

/- warning: submodule.span_Union₂ -> Submodule.span_unionᵢ₂ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} {κ : ι -> Sort.{u4}} (s : forall (i : ι), (κ i) -> (Set.{u2} M)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.unionᵢ.{u2, u3} M ι (fun (i : ι) => Set.unionᵢ.{u2, u4} M (κ i) (fun (j : κ i) => s i j)))) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => supᵢ.{u2, u4} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (κ i) (fun (j : κ i) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (s i j))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u4}} {κ : ι -> Sort.{u3}} (s : forall (i : ι), (κ i) -> (Set.{u2} M)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.unionᵢ.{u2, u4} M ι (fun (i : ι) => Set.unionᵢ.{u2, u3} M (κ i) (fun (j : κ i) => s i j)))) (supᵢ.{u2, u4} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (κ i) (fun (j : κ i) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (s i j))))
Case conversion may be inaccurate. Consider using '#align submodule.span_Union₂ Submodule.span_unionᵢ₂ₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
theorem span_unionᵢ₂ {ι} {κ : ι → Sort _} (s : ∀ i, κ i → Set M) :
    span R (⋃ (i) (j), s i j) = ⨆ (i) (j), span R (s i j) :=
  (Submodule.gi R M).gc.l_supᵢ₂
#align submodule.span_Union₂ Submodule.span_unionᵢ₂

/- warning: submodule.span_attach_bUnion -> Submodule.span_attach_bunionᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : DecidableEq.{succ u2} M] {α : Type.{u3}} (s : Finset.{u3} α) (f : (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} α) Type.{u3} (Finset.hasCoeToSort.{u3} α) s) -> (Finset.{u2} M)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} M) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} M) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} M) (Set.{u2} M) (Finset.Set.hasCoeT.{u2} M))) (Finset.bunionᵢ.{u3, u2} (Subtype.{succ u3} α (fun (x : α) => Membership.Mem.{u3, u3} α (Finset.{u3} α) (Finset.hasMem.{u3} α) x s)) M (fun (a : M) (b : M) => _inst_7 a b) (Finset.attach.{u3} α s) f))) (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} α) Type.{u3} (Finset.hasCoeToSort.{u3} α) s) (fun (x : coeSort.{succ u3, succ (succ u3)} (Finset.{u3} α) Type.{u3} (Finset.hasCoeToSort.{u3} α) s) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} M) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} M) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} M) (Set.{u2} M) (Finset.Set.hasCoeT.{u2} M))) (f x))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_7 : DecidableEq.{succ u3} M] {α : Type.{u2}} (s : Finset.{u2} α) (f : (Subtype.{succ u2} α (fun (x : α) => Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) x s)) -> (Finset.{u3} M)), Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 (Finset.toSet.{u3} M (Finset.bunionᵢ.{u2, u3} (Subtype.{succ u2} α (fun (x : α) => Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) x s)) M (fun (a : M) (b : M) => _inst_7 a b) (Finset.attach.{u2} α s) f))) (supᵢ.{u3, succ u2} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u3} R M _inst_1 _inst_2 _inst_3))) (Subtype.{succ u2} α (fun (x : α) => Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) x s)) (fun (x : Subtype.{succ u2} α (fun (x : α) => Membership.mem.{u2, u2} α (Finset.{u2} α) (Finset.instMembershipFinset.{u2} α) x s)) => Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 (Finset.toSet.{u3} M (f x))))
Case conversion may be inaccurate. Consider using '#align submodule.span_attach_bUnion Submodule.span_attach_bunionᵢₓ'. -/
theorem span_attach_bunionᵢ [DecidableEq M] {α : Type _} (s : Finset α) (f : s → Finset M) :
    span R (s.attach.bunionᵢ f : Set M) = ⨆ x, span R (f x) := by simpa [span_Union]
#align submodule.span_attach_bUnion Submodule.span_attach_bunionᵢ

/- warning: submodule.sup_span -> Submodule.sup_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Union.union.{u2} (Set.{u2} M) (Set.hasUnion.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p) s))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Union.union.{u2} (Set.{u2} M) (Set.instUnionSet.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p) s))
Case conversion may be inaccurate. Consider using '#align submodule.sup_span Submodule.sup_spanₓ'. -/
theorem sup_span : p ⊔ span R s = span R (p ∪ s) := by rw [Submodule.span_union, p.span_eq]
#align submodule.sup_span Submodule.sup_span

/- warning: submodule.span_sup -> Submodule.span_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) p) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Union.union.{u2} (Set.{u2} M) (Set.hasUnion.{u2} M) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) p) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Union.union.{u2} (Set.{u2} M) (Set.instUnionSet.{u2} M) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p)))
Case conversion may be inaccurate. Consider using '#align submodule.span_sup Submodule.span_supₓ'. -/
theorem span_sup : span R s ⊔ p = span R (s ∪ p) := by rw [Submodule.span_union, p.span_eq]
#align submodule.span_sup Submodule.span_sup

-- mathport name: «expr ∙ »
notation:1000
  /- Note that the character `∙` U+2219 used below is different from the scalar multiplication
character `•` U+2022 and the matrix multiplication character `⬝` U+2B1D. -/
R " ∙ " x => span R (@singleton _ _ Set.hasSingleton x)

/- warning: submodule.span_eq_supr_of_singleton_spans -> Submodule.span_eq_supᵢ_of_singleton_spans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (s : Set.{u2} M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (supᵢ.{u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) M (fun (x : M) => supᵢ.{u2, 0} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s) (fun (H : Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (s : Set.{u2} M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (supᵢ.{u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) M (fun (x : M) => supᵢ.{u2, 0} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s) (fun (H : Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) x))))
Case conversion may be inaccurate. Consider using '#align submodule.span_eq_supr_of_singleton_spans Submodule.span_eq_supᵢ_of_singleton_spansₓ'. -/
theorem span_eq_supᵢ_of_singleton_spans (s : Set M) : span R s = ⨆ x ∈ s, R ∙ x := by
  simp only [← span_Union, Set.bunionᵢ_of_singleton s]
#align submodule.span_eq_supr_of_singleton_spans Submodule.span_eq_supᵢ_of_singleton_spans

/- warning: submodule.span_range_eq_supr -> Submodule.span_range_eq_supᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Type.{u3}} {v : ι -> M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.range.{u2, succ u3} M ι v)) (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) (v i))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Type.{u3}} {v : ι -> M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.range.{u2, succ u3} M ι v)) (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) (v i))))
Case conversion may be inaccurate. Consider using '#align submodule.span_range_eq_supr Submodule.span_range_eq_supᵢₓ'. -/
theorem span_range_eq_supᵢ {ι : Type _} {v : ι → M} : span R (range v) = ⨆ i, R ∙ v i := by
  rw [span_eq_supr_of_singleton_spans, supᵢ_range]
#align submodule.span_range_eq_supr Submodule.span_range_eq_supᵢ

/- warning: submodule.span_smul_le -> Submodule.span_smul_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (s : Set.{u2} M) (r : R), LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (SMul.smul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) r s)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (s : Set.{u2} M) (r : R), LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (HSMul.hSMul.{u1, u2, u2} R (Set.{u2} M) (Set.{u2} M) (instHSMul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))))) r s)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)
Case conversion may be inaccurate. Consider using '#align submodule.span_smul_le Submodule.span_smul_leₓ'. -/
theorem span_smul_le (s : Set M) (r : R) : span R (r • s) ≤ span R s :=
  by
  rw [span_le]
  rintro _ ⟨x, hx, rfl⟩
  exact smul_mem (span R s) r (subset_span hx)
#align submodule.span_smul_le Submodule.span_smul_le

/- warning: submodule.subset_span_trans -> Submodule.subset_span_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {U : Set.{u2} M} {V : Set.{u2} M} {W : Set.{u2} M}, (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) U ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 V))) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) V ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 W))) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) U ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 W)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {U : Set.{u2} M} {V : Set.{u2} M} {W : Set.{u2} M}, (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) U (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 V))) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) V (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 W))) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) U (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 W)))
Case conversion may be inaccurate. Consider using '#align submodule.subset_span_trans Submodule.subset_span_transₓ'. -/
theorem subset_span_trans {U V W : Set M} (hUV : U ⊆ Submodule.span R V)
    (hVW : V ⊆ Submodule.span R W) : U ⊆ Submodule.span R W :=
  (Submodule.gi R M).gc.le_u_l_trans hUV hVW
#align submodule.subset_span_trans Submodule.subset_span_trans

#print Submodule.span_smul_eq_of_isUnit /-
/-- See `submodule.span_smul_eq` (in `ring_theory.ideal.operations`) for
`span R (r • s) = r • span R s` that holds for arbitrary `r` in a `comm_semiring`. -/
theorem span_smul_eq_of_isUnit (s : Set M) (r : R) (hr : IsUnit r) : span R (r • s) = span R s :=
  by
  apply le_antisymm
  · apply span_smul_le
  · convert span_smul_le (r • s) ((hr.unit⁻¹ : _) : R)
    rw [smul_smul]
    erw [hr.unit.inv_val]
    rw [one_smul]
#align submodule.span_smul_eq_of_is_unit Submodule.span_smul_eq_of_isUnit
-/

/- warning: submodule.coe_supr_of_directed -> Submodule.coe_supᵢ_of_directed is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} [hι : Nonempty.{u3} ι] (S : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)), (Directed.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) ι (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) S) -> (Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι S)) (Set.unionᵢ.{u2, u3} M ι (fun (i : ι) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (S i))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {ι : Sort.{u3}} [hι : Nonempty.{u3} ι] (S : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)), (Directed.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) ι (fun (x._@.Mathlib.LinearAlgebra.Span._hyg.5711 : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (x._@.Mathlib.LinearAlgebra.Span._hyg.5713 : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) => LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) x._@.Mathlib.LinearAlgebra.Span._hyg.5711 x._@.Mathlib.LinearAlgebra.Span._hyg.5713) S) -> (Eq.{succ u1} (Set.{u1} M) (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι S)) (Set.unionᵢ.{u1, u3} M ι (fun (i : ι) => SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (S i))))
Case conversion may be inaccurate. Consider using '#align submodule.coe_supr_of_directed Submodule.coe_supᵢ_of_directedₓ'. -/
@[simp]
theorem coe_supᵢ_of_directed {ι} [hι : Nonempty ι] (S : ι → Submodule R M)
    (H : Directed (· ≤ ·) S) : ((supᵢ S : Submodule R M) : Set M) = ⋃ i, S i :=
  by
  refine' subset.antisymm _ (Union_subset <| le_supᵢ S)
  suffices (span R (⋃ i, (S i : Set M)) : Set M) ⊆ ⋃ i : ι, ↑(S i) by
    simpa only [span_Union, span_eq] using this
  refine' fun x hx => span_induction hx (fun _ => id) _ _ _ <;> simp only [mem_Union, exists_imp]
  · exact hι.elim fun i => ⟨i, (S i).zero_mem⟩
  · intro x y i hi j hj
    rcases H i j with ⟨k, ik, jk⟩
    exact ⟨k, add_mem (ik hi) (jk hj)⟩
  · exact fun a x i hi => ⟨i, smul_mem _ a hi⟩
#align submodule.coe_supr_of_directed Submodule.coe_supᵢ_of_directed

/- warning: submodule.mem_supr_of_directed -> Submodule.mem_supᵢ_of_directed is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} [_inst_7 : Nonempty.{u3} ι] (S : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)), (Directed.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) ι (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) S) -> (forall {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι S)) (Exists.{u3} ι (fun (i : ι) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (S i))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {ι : Sort.{u3}} [_inst_7 : Nonempty.{u3} ι] (S : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)), (Directed.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) ι (fun (x._@.Mathlib.LinearAlgebra.Span._hyg.6009 : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (x._@.Mathlib.LinearAlgebra.Span._hyg.6011 : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) => LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) x._@.Mathlib.LinearAlgebra.Span._hyg.6009 x._@.Mathlib.LinearAlgebra.Span._hyg.6011) S) -> (forall {x : M}, Iff (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι S)) (Exists.{u3} ι (fun (i : ι) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (S i))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_supr_of_directed Submodule.mem_supᵢ_of_directedₓ'. -/
@[simp]
theorem mem_supᵢ_of_directed {ι} [Nonempty ι] (S : ι → Submodule R M) (H : Directed (· ≤ ·) S) {x} :
    x ∈ supᵢ S ↔ ∃ i, x ∈ S i :=
  by
  rw [← SetLike.mem_coe, coe_supr_of_directed S H, mem_Union]
  rfl
#align submodule.mem_supr_of_directed Submodule.mem_supᵢ_of_directed

/- warning: submodule.mem_Sup_of_directed -> Submodule.mem_supₛ_of_directed is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)} {z : M}, (Set.Nonempty.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) s) -> (DirectedOn.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) s) -> (Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z (SupSet.supₛ.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) s)) (Exists.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (fun (y : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) => Exists.{0} (Membership.Mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Set.hasMem.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y s) (fun (H : Membership.Mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Set.hasMem.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y s) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z y))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)} {z : M}, (Set.Nonempty.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) s) -> (DirectedOn.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (fun (x._@.Mathlib.LinearAlgebra.Span._hyg.6142 : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (x._@.Mathlib.LinearAlgebra.Span._hyg.6144 : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) => LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) x._@.Mathlib.LinearAlgebra.Span._hyg.6142 x._@.Mathlib.LinearAlgebra.Span._hyg.6144) s) -> (Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z (SupSet.supₛ.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) s)) (Exists.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (fun (y : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) => And (Membership.mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Set.instMembershipSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y s) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z y))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_Sup_of_directed Submodule.mem_supₛ_of_directedₓ'. -/
theorem mem_supₛ_of_directed {s : Set (Submodule R M)} {z} (hs : s.Nonempty)
    (hdir : DirectedOn (· ≤ ·) s) : z ∈ supₛ s ↔ ∃ y ∈ s, z ∈ y :=
  by
  haveI : Nonempty s := hs.to_subtype
  simp only [supₛ_eq_supᵢ', mem_supr_of_directed _ hdir.directed_coe, SetCoe.exists, Subtype.coe_mk]
#align submodule.mem_Sup_of_directed Submodule.mem_supₛ_of_directed

/- warning: submodule.coe_supr_of_chain -> Submodule.coe_supᵢ_of_chain is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (a : OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (supᵢ.{u2, 1} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) Nat (fun (k : Nat) => coeFn.{succ u2, succ u2} (OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (fun (_x : OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) => Nat -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (OrderHom.hasCoeToFun.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a k))) (Set.unionᵢ.{u2, 1} M Nat (fun (k : Nat) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (coeFn.{succ u2, succ u2} (OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (fun (_x : OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) => Nat -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (OrderHom.hasCoeToFun.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a k)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (a : OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (supᵢ.{u2, 1} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) Nat (fun (k : Nat) => OrderHom.toFun.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a k))) (Set.unionᵢ.{u2, 1} M Nat (fun (k : Nat) => SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OrderHom.toFun.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a k)))
Case conversion may be inaccurate. Consider using '#align submodule.coe_supr_of_chain Submodule.coe_supᵢ_of_chainₓ'. -/
@[norm_cast, simp]
theorem coe_supᵢ_of_chain (a : ℕ →o Submodule R M) : (↑(⨆ k, a k) : Set M) = ⋃ k, (a k : Set M) :=
  coe_supᵢ_of_directed a a.Monotone.directed_le
#align submodule.coe_supr_of_chain Submodule.coe_supᵢ_of_chain

/- warning: submodule.coe_scott_continuous -> Submodule.coe_scott_continuous is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], OmegaCompletePartialOrder.Continuous'.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CompleteLattice.omegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (CompleteLattice.omegaCompletePartialOrder.{u2} (Set.{u2} M) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} M) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} M) (Set.completeBooleanAlgebra.{u2} M))))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], OmegaCompletePartialOrder.Continuous'.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} M) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} M) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} M) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} M) (Set.instCompleteBooleanAlgebraSet.{u2} M))))) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.coe_scott_continuous Submodule.coe_scott_continuousₓ'. -/
/-- We can regard `coe_supr_of_chain` as the statement that `coe : (submodule R M) → set M` is
Scott continuous for the ω-complete partial order induced by the complete lattice structures. -/
theorem coe_scott_continuous :
    OmegaCompletePartialOrder.Continuous' (coe : Submodule R M → Set M) :=
  ⟨SetLike.coe_mono, coe_supᵢ_of_chain⟩
#align submodule.coe_scott_continuous Submodule.coe_scott_continuous

/- warning: submodule.mem_supr_of_chain -> Submodule.mem_supᵢ_of_chain is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (a : OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (m : M), Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u2, 1} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) Nat (fun (k : Nat) => coeFn.{succ u2, succ u2} (OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (fun (_x : OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) => Nat -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (OrderHom.hasCoeToFun.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a k))) (Exists.{1} Nat (fun (k : Nat) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (coeFn.{succ u2, succ u2} (OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (fun (_x : OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) => Nat -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (OrderHom.hasCoeToFun.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a k)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (a : OrderHom.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) (m : M), Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u2, 1} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) Nat (fun (k : Nat) => OrderHom.toFun.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a k))) (Exists.{1} Nat (fun (k : Nat) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (OrderHom.toFun.{0, u2} Nat (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a k)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_supr_of_chain Submodule.mem_supᵢ_of_chainₓ'. -/
@[simp]
theorem mem_supᵢ_of_chain (a : ℕ →o Submodule R M) (m : M) : (m ∈ ⨆ k, a k) ↔ ∃ k, m ∈ a k :=
  mem_supᵢ_of_directed a a.Monotone.directed_le
#align submodule.mem_supr_of_chain Submodule.mem_supᵢ_of_chain

section

variable {p p'}

/- warning: submodule.mem_sup -> Submodule.mem_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p p')) (Exists.{succ u2} M (fun (y : M) => Exists.{0} (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y p) (fun (H : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y p) => Exists.{succ u2} M (fun (z : M) => Exists.{0} (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z p') (fun (H : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z p') => Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) y z) x)))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p p')) (Exists.{succ u2} M (fun (y : M) => And (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y p) (Exists.{succ u2} M (fun (z : M) => And (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z p') (Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) y z) x)))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_sup Submodule.mem_supₓ'. -/
theorem mem_sup : x ∈ p ⊔ p' ↔ ∃ y ∈ p, ∃ z ∈ p', y + z = x :=
  ⟨fun h => by
    rw [← span_eq p, ← span_eq p', ← span_union] at h
    apply span_induction h
    · rintro y (h | h)
      · exact ⟨y, h, 0, by simp, by simp⟩
      · exact ⟨0, by simp, y, h, by simp⟩
    · exact ⟨0, by simp, 0, by simp⟩
    · rintro _ _ ⟨y₁, hy₁, z₁, hz₁, rfl⟩ ⟨y₂, hy₂, z₂, hz₂, rfl⟩
      exact ⟨_, add_mem hy₁ hy₂, _, add_mem hz₁ hz₂, by simp [add_assoc] <;> cc⟩
    · rintro a _ ⟨y, hy, z, hz, rfl⟩
      exact ⟨_, smul_mem _ a hy, _, smul_mem _ a hz, by simp [smul_add]⟩, by
    rintro ⟨y, hy, z, hz, rfl⟩ <;>
      exact add_mem ((le_sup_left : p ≤ p ⊔ p') hy) ((le_sup_right : p' ≤ p ⊔ p') hz)⟩
#align submodule.mem_sup Submodule.mem_sup

/- warning: submodule.mem_sup' -> Submodule.mem_sup' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p p')) (Exists.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) (fun (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) => Exists.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p') (fun (z : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p') => Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p))))) y) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p') M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p') M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p') M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p') M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p'))))) z)) x)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p p')) (Exists.{succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p)) (fun (y : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p)) => Exists.{succ u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p')) (fun (z : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p')) => Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p)) y) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p')) z)) x)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_sup' Submodule.mem_sup'ₓ'. -/
theorem mem_sup' : x ∈ p ⊔ p' ↔ ∃ (y : p)(z : p'), (y : M) + z = x :=
  mem_sup.trans <| by simp only [SetLike.exists, coe_mk]
#align submodule.mem_sup' Submodule.mem_sup'

variable (p p')

/- warning: submodule.coe_sup -> Submodule.coe_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p p')) (HAdd.hAdd.{u2, u2, u2} (Set.{u2} M) (Set.{u2} M) (Set.{u2} M) (instHAdd.{u2} (Set.{u2} M) (Set.add.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p p')) (HAdd.hAdd.{u2, u2, u2} (Set.{u2} M) (Set.{u2} M) (Set.{u2} M) (instHAdd.{u2} (Set.{u2} M) (Set.add.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p'))
Case conversion may be inaccurate. Consider using '#align submodule.coe_sup Submodule.coe_supₓ'. -/
theorem coe_sup : ↑(p ⊔ p') = (p + p' : Set M) :=
  by
  ext
  rw [SetLike.mem_coe, mem_sup, Set.mem_add]
  simp
#align submodule.coe_sup Submodule.coe_sup

/- warning: submodule.sup_to_add_submonoid -> Submodule.sup_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p p')) (HasSup.sup.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Lattice.toSemilatticeSup.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (ConditionallyCompleteLattice.toLattice.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.toConditionallyCompleteLattice.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.completeLattice.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p p')) (HasSup.sup.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Lattice.toSemilatticeSup.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (ConditionallyCompleteLattice.toLattice.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.toConditionallyCompleteLattice.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p'))
Case conversion may be inaccurate. Consider using '#align submodule.sup_to_add_submonoid Submodule.sup_toAddSubmonoidₓ'. -/
theorem sup_toAddSubmonoid : (p ⊔ p').toAddSubmonoid = p.toAddSubmonoid ⊔ p'.toAddSubmonoid :=
  by
  ext x
  rw [mem_to_add_submonoid, mem_sup, AddSubmonoid.mem_sup]
  rfl
#align submodule.sup_to_add_submonoid Submodule.sup_toAddSubmonoid

/- warning: submodule.sup_to_add_subgroup -> Submodule.sup_toAddSubgroup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_7 : Ring.{u1} R] [_inst_8 : AddCommGroup.{u2} M] [_inst_9 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8)] (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9) (p' : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9), Eq.{succ u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) (Submodule.toAddSubgroup.{u1, u2} R M _inst_7 _inst_8 _inst_9 (HasSup.sup.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9) (Submodule.completeLattice.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9))))) p p')) (HasSup.sup.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) (SemilatticeSup.toHasSup.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) (Lattice.toSemilatticeSup.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) (ConditionallyCompleteLattice.toLattice.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) (CompleteLattice.toConditionallyCompleteLattice.{u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)) (AddSubgroup.completeLattice.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8)))))) (Submodule.toAddSubgroup.{u1, u2} R M _inst_7 _inst_8 _inst_9 p) (Submodule.toAddSubgroup.{u1, u2} R M _inst_7 _inst_8 _inst_9 p'))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_7 : Ring.{u2} R] [_inst_8 : AddCommGroup.{u1} M] [_inst_9 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8)] (p : Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9) (p' : Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9), Eq.{succ u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_8)) (Submodule.toAddSubgroup.{u2, u1} R M _inst_7 _inst_8 _inst_9 (HasSup.sup.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9) (SemilatticeSup.toHasSup.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9) (Lattice.toSemilatticeSup.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9) (ConditionallyCompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9))))) p p')) (HasSup.sup.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_8)) (SemilatticeSup.toHasSup.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_8)) (Lattice.toSemilatticeSup.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_8)) (ConditionallyCompleteLattice.toLattice.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_8)) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_8)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_8)))))) (Submodule.toAddSubgroup.{u2, u1} R M _inst_7 _inst_8 _inst_9 p) (Submodule.toAddSubgroup.{u2, u1} R M _inst_7 _inst_8 _inst_9 p'))
Case conversion may be inaccurate. Consider using '#align submodule.sup_to_add_subgroup Submodule.sup_toAddSubgroupₓ'. -/
theorem sup_toAddSubgroup {R M : Type _} [Ring R] [AddCommGroup M] [Module R M]
    (p p' : Submodule R M) : (p ⊔ p').toAddSubgroup = p.toAddSubgroup ⊔ p'.toAddSubgroup :=
  by
  ext x
  rw [mem_to_add_subgroup, mem_sup, AddSubgroup.mem_sup]
  rfl
#align submodule.sup_to_add_subgroup Submodule.sup_toAddSubgroup

end

/- warning: submodule.mem_span_singleton_self -> Submodule.mem_span_singleton_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) x))
Case conversion may be inaccurate. Consider using '#align submodule.mem_span_singleton_self Submodule.mem_span_singleton_selfₓ'. -/
theorem mem_span_singleton_self (x : M) : x ∈ R ∙ x :=
  subset_span rfl
#align submodule.mem_span_singleton_self Submodule.mem_span_singleton_self

/- warning: submodule.nontrivial_span_singleton -> Submodule.nontrivial_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M}, (Ne.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) -> (Nontrivial.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M}, (Ne.{succ u2} M x (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) -> (Nontrivial.{u2} (Subtype.{succ u2} M (fun (x_1 : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x_1 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) x)))))
Case conversion may be inaccurate. Consider using '#align submodule.nontrivial_span_singleton Submodule.nontrivial_span_singletonₓ'. -/
theorem nontrivial_span_singleton {x : M} (h : x ≠ 0) : Nontrivial (R ∙ x) :=
  ⟨by
    use 0, x, Submodule.mem_span_singleton_self x
    intro H
    rw [eq_comm, Submodule.mk_eq_zero] at H
    exact h H⟩
#align submodule.nontrivial_span_singleton Submodule.nontrivial_span_singleton

/- warning: submodule.mem_span_singleton -> Submodule.mem_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {y : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) y))) (Exists.{succ u1} R (fun (a : R) => Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a y) x))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {y : M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) y))) (Exists.{succ u1} R (fun (a : R) => Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) a y) x))
Case conversion may be inaccurate. Consider using '#align submodule.mem_span_singleton Submodule.mem_span_singletonₓ'. -/
theorem mem_span_singleton {y : M} : (x ∈ R ∙ y) ↔ ∃ a : R, a • y = x :=
  ⟨fun h => by
    apply span_induction h
    · rintro y (rfl | ⟨⟨⟩⟩)
      exact ⟨1, by simp⟩
    · exact ⟨0, by simp⟩
    · rintro _ _ ⟨a, rfl⟩ ⟨b, rfl⟩
      exact ⟨a + b, by simp [add_smul]⟩
    · rintro a _ ⟨b, rfl⟩
      exact ⟨a * b, by simp [smul_smul]⟩, by
    rintro ⟨a, y, rfl⟩ <;> exact smul_mem _ _ (subset_span <| by simp)⟩
#align submodule.mem_span_singleton Submodule.mem_span_singleton

/- warning: submodule.le_span_singleton_iff -> Submodule.le_span_singleton_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {v₀ : M}, Iff (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) s (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) v₀))) (forall (v : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) v s) -> (Exists.{succ u1} R (fun (r : R) => Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) r v₀) v)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {s : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3} {v₀ : M}, Iff (LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) s (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) v₀))) (forall (v : M), (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) v s) -> (Exists.{succ u2} R (fun (r : R) => Eq.{succ u1} M (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) r v₀) v)))
Case conversion may be inaccurate. Consider using '#align submodule.le_span_singleton_iff Submodule.le_span_singleton_iffₓ'. -/
theorem le_span_singleton_iff {s : Submodule R M} {v₀ : M} :
    (s ≤ R ∙ v₀) ↔ ∀ v ∈ s, ∃ r : R, r • v₀ = v := by simp_rw [SetLike.le_def, mem_span_singleton]
#align submodule.le_span_singleton_iff Submodule.le_span_singleton_iff

variable (R)

/- warning: submodule.span_singleton_eq_top_iff -> Submodule.span_singleton_eq_top_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Iff (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (forall (v : M), Exists.{succ u1} R (fun (r : R) => Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) r x) v))
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Iff (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) x)) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (forall (v : M), Exists.{succ u1} R (fun (r : R) => Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) r x) v))
Case conversion may be inaccurate. Consider using '#align submodule.span_singleton_eq_top_iff Submodule.span_singleton_eq_top_iffₓ'. -/
theorem span_singleton_eq_top_iff (x : M) : (R ∙ x) = ⊤ ↔ ∀ v, ∃ r : R, r • x = v :=
  by
  rw [eq_top_iff, le_span_singleton_iff]
  tauto
#align submodule.span_singleton_eq_top_iff Submodule.span_singleton_eq_top_iff

/- warning: submodule.span_zero_singleton -> Submodule.span_zero_singleton is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.span_zero_singleton Submodule.span_zero_singletonₓ'. -/
@[simp]
theorem span_zero_singleton : (R ∙ (0 : M)) = ⊥ :=
  by
  ext
  simp [mem_span_singleton, eq_comm]
#align submodule.span_zero_singleton Submodule.span_zero_singleton

/- warning: submodule.span_singleton_eq_range -> Submodule.span_singleton_eq_range is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (y : M), Eq.{succ u2} (Set.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) y))) (Set.range.{u2, succ u1} M R (fun (_x : R) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) _x y))
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (y : M), Eq.{succ u2} (Set.{u2} M) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) y))) (Set.range.{u2, succ u1} M R (fun (_x : R) => HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) _x y))
Case conversion may be inaccurate. Consider using '#align submodule.span_singleton_eq_range Submodule.span_singleton_eq_rangeₓ'. -/
theorem span_singleton_eq_range (y : M) : ↑(R ∙ y) = range ((· • y) : R → M) :=
  Set.ext fun x => mem_span_singleton
#align submodule.span_singleton_eq_range Submodule.span_singleton_eq_range

/- warning: submodule.span_singleton_smul_le -> Submodule.span_singleton_smul_le is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {S : Type.{u3}} [_inst_7 : Monoid.{u3} S] [_inst_8 : SMul.{u3, u1} S R] [_inst_9 : MulAction.{u3, u2} S M _inst_7] [_inst_10 : IsScalarTower.{u3, u1, u2} S R M _inst_8 (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (MulAction.toHasSmul.{u3, u2} S M _inst_7 _inst_9)] (r : S) (x : M), LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) (SMul.smul.{u3, u2} S M (MulAction.toHasSmul.{u3, u2} S M _inst_7 _inst_9) r x))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x))
but is expected to have type
  forall (R : Type.{u2}) {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {S : Type.{u3}} [_inst_7 : Monoid.{u3} S] [_inst_8 : SMul.{u3, u2} S R] [_inst_9 : MulAction.{u3, u1} S M _inst_7] [_inst_10 : IsScalarTower.{u3, u2, u1} S R M _inst_8 (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3)))) (MulAction.toSMul.{u3, u1} S M _inst_7 _inst_9)] (r : S) (x : M), LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) (HSMul.hSMul.{u3, u1, u1} S M M (instHSMul.{u3, u1} S M (MulAction.toSMul.{u3, u1} S M _inst_7 _inst_9)) r x))) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) x))
Case conversion may be inaccurate. Consider using '#align submodule.span_singleton_smul_le Submodule.span_singleton_smul_leₓ'. -/
theorem span_singleton_smul_le {S} [Monoid S] [SMul S R] [MulAction S M] [IsScalarTower S R M]
    (r : S) (x : M) : (R ∙ r • x) ≤ R ∙ x :=
  by
  rw [span_le, Set.singleton_subset_iff, SetLike.mem_coe]
  exact smul_of_tower_mem _ _ (mem_span_singleton_self _)
#align submodule.span_singleton_smul_le Submodule.span_singleton_smul_le

/- warning: submodule.span_singleton_group_smul_eq -> Submodule.span_singleton_group_smul_eq is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {G : Type.{u3}} [_inst_7 : Group.{u3} G] [_inst_8 : SMul.{u3, u1} G R] [_inst_9 : MulAction.{u3, u2} G M (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_7))] [_inst_10 : IsScalarTower.{u3, u1, u2} G R M _inst_8 (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (MulAction.toHasSmul.{u3, u2} G M (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_7)) _inst_9)] (g : G) (x : M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) (SMul.smul.{u3, u2} G M (MulAction.toHasSmul.{u3, u2} G M (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_7)) _inst_9) g x))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x))
but is expected to have type
  forall (R : Type.{u2}) {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {G : Type.{u3}} [_inst_7 : Group.{u3} G] [_inst_8 : SMul.{u3, u2} G R] [_inst_9 : MulAction.{u3, u1} G M (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_7))] [_inst_10 : IsScalarTower.{u3, u2, u1} G R M _inst_8 (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3)))) (MulAction.toSMul.{u3, u1} G M (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_7)) _inst_9)] (g : G) (x : M), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) (HSMul.hSMul.{u3, u1, u1} G M M (instHSMul.{u3, u1} G M (MulAction.toSMul.{u3, u1} G M (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G _inst_7)) _inst_9)) g x))) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) x))
Case conversion may be inaccurate. Consider using '#align submodule.span_singleton_group_smul_eq Submodule.span_singleton_group_smul_eqₓ'. -/
theorem span_singleton_group_smul_eq {G} [Group G] [SMul G R] [MulAction G M] [IsScalarTower G R M]
    (g : G) (x : M) : (R ∙ g • x) = R ∙ x :=
  by
  refine' le_antisymm (span_singleton_smul_le R g x) _
  convert span_singleton_smul_le R g⁻¹ (g • x)
  exact (inv_smul_smul g x).symm
#align submodule.span_singleton_group_smul_eq Submodule.span_singleton_group_smul_eq

variable {R}

/- warning: submodule.span_singleton_smul_eq -> Submodule.span_singleton_smul_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {r : R}, (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) r) -> (forall (x : M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) r x))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {r : R}, (IsUnit.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) r) -> (forall (x : M), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) r x))) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) x)))
Case conversion may be inaccurate. Consider using '#align submodule.span_singleton_smul_eq Submodule.span_singleton_smul_eqₓ'. -/
theorem span_singleton_smul_eq {r : R} (hr : IsUnit r) (x : M) : (R ∙ r • x) = R ∙ x :=
  by
  lift r to Rˣ using hr
  rw [← Units.smul_def]
  exact span_singleton_group_smul_eq R r x
#align submodule.span_singleton_smul_eq Submodule.span_singleton_smul_eq

/- warning: submodule.disjoint_span_singleton -> Submodule.disjoint_span_singleton is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {E : Type.{u2}} [_inst_7 : DivisionRing.{u1} K] [_inst_8 : AddCommGroup.{u2} E] [_inst_9 : Module.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8)] {s : Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9} {x : E}, Iff (Disjoint.{u2} (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9) E (Submodule.setLike.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9)) (Submodule.orderBot.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9) s (Submodule.span.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9 (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) x))) ((Membership.Mem.{u2, u2} E (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9) E (Submodule.setLike.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9)) x s) -> (Eq.{succ u2} E x (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_8))))))))))
but is expected to have type
  forall {K : Type.{u2}} {E : Type.{u1}} [_inst_7 : DivisionRing.{u2} K] [_inst_8 : AddCommGroup.{u1} E] [_inst_9 : Module.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8)] {s : Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9} {x : E}, Iff (Disjoint.{u1} (Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) (Submodule.completeLattice.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) s (Submodule.span.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9 (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.instSingletonSet.{u1} E) x))) ((Membership.mem.{u1, u1} E (Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) E (Submodule.instSetLikeSubmodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9)) x s) -> (Eq.{succ u1} E x (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_8)))))))))
Case conversion may be inaccurate. Consider using '#align submodule.disjoint_span_singleton Submodule.disjoint_span_singletonₓ'. -/
theorem disjoint_span_singleton {K E : Type _} [DivisionRing K] [AddCommGroup E] [Module K E]
    {s : Submodule K E} {x : E} : Disjoint s (K ∙ x) ↔ x ∈ s → x = 0 :=
  by
  refine' disjoint_def.trans ⟨fun H hx => H x hx <| subset_span <| mem_singleton x, _⟩
  intro H y hy hyx
  obtain ⟨c, rfl⟩ := mem_span_singleton.1 hyx
  by_cases hc : c = 0
  · rw [hc, zero_smul]
  · rw [s.smul_mem_iff hc] at hy
    rw [H hy, smul_zero]
#align submodule.disjoint_span_singleton Submodule.disjoint_span_singleton

/- warning: submodule.disjoint_span_singleton' -> Submodule.disjoint_span_singleton' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {E : Type.{u2}} [_inst_7 : DivisionRing.{u1} K] [_inst_8 : AddCommGroup.{u2} E] [_inst_9 : Module.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8)] {p : Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9} {x : E}, (Ne.{succ u2} E x (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_8))))))))) -> (Iff (Disjoint.{u2} (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9) E (Submodule.setLike.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9)) (Submodule.orderBot.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9) p (Submodule.span.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9 (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) x))) (Not (Membership.Mem.{u2, u2} E (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9) E (Submodule.setLike.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_8) _inst_9)) x p)))
but is expected to have type
  forall {K : Type.{u2}} {E : Type.{u1}} [_inst_7 : DivisionRing.{u2} K] [_inst_8 : AddCommGroup.{u1} E] [_inst_9 : Module.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8)] {p : Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9} {x : E}, (Ne.{succ u1} E x (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_8)))))))) -> (Iff (Disjoint.{u1} (Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) (Submodule.completeLattice.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) p (Submodule.span.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9 (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.instSingletonSet.{u1} E) x))) (Not (Membership.mem.{u1, u1} E (Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9) E (Submodule.instSetLikeSubmodule.{u2, u1} K E (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_7)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_8) _inst_9)) x p)))
Case conversion may be inaccurate. Consider using '#align submodule.disjoint_span_singleton' Submodule.disjoint_span_singleton'ₓ'. -/
theorem disjoint_span_singleton' {K E : Type _} [DivisionRing K] [AddCommGroup E] [Module K E]
    {p : Submodule K E} {x : E} (x0 : x ≠ 0) : Disjoint p (K ∙ x) ↔ x ∉ p :=
  disjoint_span_singleton.trans ⟨fun h₁ h₂ => x0 (h₁ h₂), fun h₁ h₂ => (h₁ h₂).elim⟩
#align submodule.disjoint_span_singleton' Submodule.disjoint_span_singleton'

/- warning: submodule.mem_span_singleton_trans -> Submodule.mem_span_singleton_trans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {y : M} {z : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) y))) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) z))) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) z)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {y : M} {z : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) y))) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) z))) -> (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) z)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_span_singleton_trans Submodule.mem_span_singleton_transₓ'. -/
theorem mem_span_singleton_trans {x y z : M} (hxy : x ∈ R ∙ y) (hyz : y ∈ R ∙ z) : x ∈ R ∙ z :=
  by
  rw [← SetLike.mem_coe, ← singleton_subset_iff] at *
  exact Submodule.subset_span_trans hxy hyz
#align submodule.mem_span_singleton_trans Submodule.mem_span_singleton_trans

/- warning: submodule.mem_span_insert -> Submodule.mem_span_insert is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {s : Set.{u2} M} {y : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Insert.insert.{u2, u2} M (Set.{u2} M) (Set.hasInsert.{u2} M) y s))) (Exists.{succ u1} R (fun (a : R) => Exists.{succ u2} M (fun (z : M) => Exists.{0} (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (fun (H : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) => Eq.{succ u2} M x (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a y) z)))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {s : Set.{u2} M} {y : M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Insert.insert.{u2, u2} M (Set.{u2} M) (Set.instInsertSet.{u2} M) y s))) (Exists.{succ u1} R (fun (a : R) => Exists.{succ u2} M (fun (z : M) => And (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Eq.{succ u2} M x (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) a y) z)))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_span_insert Submodule.mem_span_insertₓ'. -/
theorem mem_span_insert {y} : x ∈ span R (insert y s) ↔ ∃ a : R, ∃ z ∈ span R s, x = a • y + z :=
  by
  simp only [← union_singleton, span_union, mem_sup, mem_span_singleton, exists_prop,
    exists_exists_eq_and]
  rw [exists_comm]
  simp only [eq_comm, add_comm, exists_and_left]
#align submodule.mem_span_insert Submodule.mem_span_insert

/- warning: submodule.mem_span_pair -> Submodule.mem_span_pair is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {y : M} {z : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Insert.insert.{u2, u2} M (Set.{u2} M) (Set.hasInsert.{u2} M) x (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) y)))) (Exists.{succ u1} R (fun (a : R) => Exists.{succ u1} R (fun (b : R) => Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) a x) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) b y)) z)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {y : M} {z : M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) z (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Insert.insert.{u2, u2} M (Set.{u2} M) (Set.instInsertSet.{u2} M) x (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) y)))) (Exists.{succ u1} R (fun (a : R) => Exists.{succ u1} R (fun (b : R) => Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) a x) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) b y)) z)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_span_pair Submodule.mem_span_pairₓ'. -/
theorem mem_span_pair {x y z : M} : z ∈ span R ({x, y} : Set M) ↔ ∃ a b : R, a • x + b • y = z := by
  simp_rw [mem_span_insert, mem_span_singleton, exists_prop, exists_exists_eq_and, eq_comm]
#align submodule.mem_span_pair Submodule.mem_span_pair

#print Submodule.span_insert /-
theorem span_insert (x) (s : Set M) : span R (insert x s) = span R ({x} : Set M) ⊔ span R s := by
  rw [insert_eq, span_union]
#align submodule.span_insert Submodule.span_insert
-/

/- warning: submodule.span_insert_eq_span -> Submodule.span_insert_eq_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {s : Set.{u2} M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) -> (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Insert.insert.{u2, u2} M (Set.{u2} M) (Set.hasInsert.{u2} M) x s)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M} {s : Set.{u2} M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) -> (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Insert.insert.{u2, u2} M (Set.{u2} M) (Set.instInsertSet.{u2} M) x s)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))
Case conversion may be inaccurate. Consider using '#align submodule.span_insert_eq_span Submodule.span_insert_eq_spanₓ'. -/
theorem span_insert_eq_span (h : x ∈ span R s) : span R (insert x s) = span R s :=
  span_eq_of_le _ (Set.insert_subset.mpr ⟨h, subset_span⟩) (span_mono <| subset_insert _ _)
#align submodule.span_insert_eq_span Submodule.span_insert_eq_span

/- warning: submodule.span_span -> Submodule.span_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)
Case conversion may be inaccurate. Consider using '#align submodule.span_span Submodule.span_spanₓ'. -/
theorem span_span : span R (span R s : Set M) = span R s :=
  span_eq _
#align submodule.span_span Submodule.span_span

variable (R S s)

/- warning: submodule.span_le_restrict_scalars -> Submodule.span_le_restrictScalars is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} (S : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (s : Set.{u2} M) [_inst_7 : Semiring.{u3} S] [_inst_8 : SMul.{u1, u3} R S] [_inst_9 : Module.{u3, u2} S M _inst_7 _inst_2] [_inst_10 : IsScalarTower.{u1, u3, u2} R S M _inst_8 (SMulZeroClass.toHasSmul.{u3, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} S M (MulZeroClass.toHasZero.{u3} S (MulZeroOneClass.toMulZeroClass.{u3} S (MonoidWithZero.toMulZeroOneClass.{u3} S (Semiring.toMonoidWithZero.{u3} S _inst_7)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} S M (Semiring.toMonoidWithZero.{u3} S _inst_7) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} S M _inst_7 _inst_2 _inst_9)))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))], LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Submodule.restrictScalars.{u1, u3, u2} R S M _inst_7 _inst_2 _inst_1 _inst_3 _inst_9 _inst_8 _inst_10 (Submodule.span.{u3, u2} S M _inst_7 _inst_2 _inst_9 s))
but is expected to have type
  forall (R : Type.{u2}) {M : Type.{u1}} (S : Type.{u3}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (s : Set.{u1} M) [_inst_7 : Semiring.{u3} S] [_inst_8 : SMul.{u2, u3} R S] [_inst_9 : Module.{u3, u1} S M _inst_7 _inst_2] [_inst_10 : IsScalarTower.{u2, u3, u1} R S M _inst_8 (SMulZeroClass.toSMul.{u3, u1} S M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u1} S M (MonoidWithZero.toZero.{u3} S (Semiring.toMonoidWithZero.{u3} S _inst_7)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u1} S M (Semiring.toMonoidWithZero.{u3} S _inst_7) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u3, u1} S M _inst_7 _inst_2 _inst_9)))) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))], LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 s) (Submodule.restrictScalars.{u2, u3, u1} R S M _inst_7 _inst_2 _inst_1 _inst_3 _inst_9 _inst_8 _inst_10 (Submodule.span.{u3, u1} S M _inst_7 _inst_2 _inst_9 s))
Case conversion may be inaccurate. Consider using '#align submodule.span_le_restrict_scalars Submodule.span_le_restrictScalarsₓ'. -/
/-- If `R` is "smaller" ring than `S` then the span by `R` is smaller than the span by `S`. -/
theorem span_le_restrictScalars [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :
    span R s ≤ (span S s).restrictScalars R :=
  Submodule.span_le.2 Submodule.subset_span
#align submodule.span_le_restrict_scalars Submodule.span_le_restrictScalars

/- warning: submodule.span_subset_span -> Submodule.span_subset_span is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} (S : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (s : Set.{u2} M) [_inst_7 : Semiring.{u3} S] [_inst_8 : SMul.{u1, u3} R S] [_inst_9 : Module.{u3, u2} S M _inst_7 _inst_2] [_inst_10 : IsScalarTower.{u1, u3, u2} R S M _inst_8 (SMulZeroClass.toHasSmul.{u3, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} S M (MulZeroClass.toHasZero.{u3} S (MulZeroOneClass.toMulZeroClass.{u3} S (MonoidWithZero.toMulZeroOneClass.{u3} S (Semiring.toMonoidWithZero.{u3} S _inst_7)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} S M (Semiring.toMonoidWithZero.{u3} S _inst_7) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} S M _inst_7 _inst_2 _inst_9)))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))], HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u3, u2} S M _inst_7 _inst_2 _inst_9) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u3, u2} S M _inst_7 _inst_2 _inst_9) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u3, u2} S M _inst_7 _inst_2 _inst_9) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u3, u2} S M _inst_7 _inst_2 _inst_9) M (Submodule.setLike.{u3, u2} S M _inst_7 _inst_2 _inst_9)))) (Submodule.span.{u3, u2} S M _inst_7 _inst_2 _inst_9 s))
but is expected to have type
  forall (R : Type.{u2}) {M : Type.{u1}} (S : Type.{u3}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (s : Set.{u1} M) [_inst_7 : Semiring.{u3} S] [_inst_8 : SMul.{u2, u3} R S] [_inst_9 : Module.{u3, u1} S M _inst_7 _inst_2] [_inst_10 : IsScalarTower.{u2, u3, u1} R S M _inst_8 (SMulZeroClass.toSMul.{u3, u1} S M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u1} S M (MonoidWithZero.toZero.{u3} S (Semiring.toMonoidWithZero.{u3} S _inst_7)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u1} S M (Semiring.toMonoidWithZero.{u3} S _inst_7) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u3, u1} S M _inst_7 _inst_2 _inst_9)))) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))], HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 s)) (SetLike.coe.{u1, u1} (Submodule.{u3, u1} S M _inst_7 _inst_2 _inst_9) M (Submodule.instSetLikeSubmodule.{u3, u1} S M _inst_7 _inst_2 _inst_9) (Submodule.span.{u3, u1} S M _inst_7 _inst_2 _inst_9 s))
Case conversion may be inaccurate. Consider using '#align submodule.span_subset_span Submodule.span_subset_spanₓ'. -/
/-- A version of `submodule.span_le_restrict_scalars` with coercions. -/
@[simp]
theorem span_subset_span [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :
    ↑(span R s) ⊆ (span S s : Set M) :=
  span_le_restrictScalars R S s
#align submodule.span_subset_span Submodule.span_subset_span

/- warning: submodule.span_span_of_tower -> Submodule.span_span_of_tower is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} (S : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (s : Set.{u2} M) [_inst_7 : Semiring.{u3} S] [_inst_8 : SMul.{u1, u3} R S] [_inst_9 : Module.{u3, u2} S M _inst_7 _inst_2] [_inst_10 : IsScalarTower.{u1, u3, u2} R S M _inst_8 (SMulZeroClass.toHasSmul.{u3, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u2} S M (MulZeroClass.toHasZero.{u3} S (MulZeroOneClass.toMulZeroClass.{u3} S (MonoidWithZero.toMulZeroOneClass.{u3} S (Semiring.toMonoidWithZero.{u3} S _inst_7)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} S M (Semiring.toMonoidWithZero.{u3} S _inst_7) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u3, u2} S M _inst_7 _inst_2 _inst_9)))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))], Eq.{succ u2} (Submodule.{u3, u2} S M _inst_7 _inst_2 _inst_9) (Submodule.span.{u3, u2} S M _inst_7 _inst_2 _inst_9 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.span.{u3, u2} S M _inst_7 _inst_2 _inst_9 s)
but is expected to have type
  forall (R : Type.{u2}) {M : Type.{u1}} (S : Type.{u3}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (s : Set.{u1} M) [_inst_7 : Semiring.{u3} S] [_inst_8 : SMul.{u2, u3} R S] [_inst_9 : Module.{u3, u1} S M _inst_7 _inst_2] [_inst_10 : IsScalarTower.{u2, u3, u1} R S M _inst_8 (SMulZeroClass.toSMul.{u3, u1} S M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u1} S M (MonoidWithZero.toZero.{u3} S (Semiring.toMonoidWithZero.{u3} S _inst_7)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u1} S M (Semiring.toMonoidWithZero.{u3} S _inst_7) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u3, u1} S M _inst_7 _inst_2 _inst_9)))) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_3))))], Eq.{succ u1} (Submodule.{u3, u1} S M _inst_7 _inst_2 _inst_9) (Submodule.span.{u3, u1} S M _inst_7 _inst_2 _inst_9 (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 s))) (Submodule.span.{u3, u1} S M _inst_7 _inst_2 _inst_9 s)
Case conversion may be inaccurate. Consider using '#align submodule.span_span_of_tower Submodule.span_span_of_towerₓ'. -/
/-- Taking the span by a large ring of the span by the small ring is the same as taking the span
by just the large ring. -/
theorem span_span_of_tower [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :
    span S (span R s : Set M) = span S s :=
  le_antisymm (span_le.2 <| span_subset_span R S s) (span_mono subset_span)
#align submodule.span_span_of_tower Submodule.span_span_of_tower

variable {R S s}

/- warning: submodule.span_eq_bot -> Submodule.span_eq_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Iff (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (forall (x : M), (Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s) -> (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Iff (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (forall (x : M), (Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s) -> (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))
Case conversion may be inaccurate. Consider using '#align submodule.span_eq_bot Submodule.span_eq_botₓ'. -/
theorem span_eq_bot : span R (s : Set M) = ⊥ ↔ ∀ x ∈ s, (x : M) = 0 :=
  eq_bot_iff.trans
    ⟨fun H x h => (mem_bot R).1 <| H <| subset_span h, fun H =>
      span_le.2 fun x h => (mem_bot R).2 <| H x h⟩
#align submodule.span_eq_bot Submodule.span_eq_bot

/- warning: submodule.span_singleton_eq_bot -> Submodule.span_singleton_eq_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M}, Iff (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {x : M}, Iff (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) x)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Eq.{succ u2} M x (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align submodule.span_singleton_eq_bot Submodule.span_singleton_eq_botₓ'. -/
@[simp]
theorem span_singleton_eq_bot : (R ∙ x) = ⊥ ↔ x = 0 :=
  span_eq_bot.trans <| by simp
#align submodule.span_singleton_eq_bot Submodule.span_singleton_eq_bot

/- warning: submodule.span_zero -> Submodule.span_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (OfNat.ofNat.{u2} (Set.{u2} M) 0 (OfNat.mk.{u2} (Set.{u2} M) 0 (Zero.zero.{u2} (Set.{u2} M) (Set.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_3))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (OfNat.ofNat.{u2} (Set.{u2} M) 0 (Zero.toOfNat0.{u2} (Set.{u2} M) (Set.zero.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.span_zero Submodule.span_zeroₓ'. -/
@[simp]
theorem span_zero : span R (0 : Set M) = ⊥ := by rw [← singleton_zero, span_singleton_eq_bot]
#align submodule.span_zero Submodule.span_zero

/- warning: submodule.span_singleton_eq_span_singleton -> Submodule.span_singleton_eq_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_7 : Ring.{u1} R] [_inst_8 : AddCommGroup.{u2} M] [_inst_9 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8)] [_inst_10 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_7))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_8))))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_8)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_7))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_8)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_7)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_8)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9))))] {x : M} {y : M}, Iff (Eq.{succ u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) y))) (Exists.{succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_7)) (fun (z : Units.{u1} R (Ring.toMonoid.{u1} R _inst_7)) => Eq.{succ u2} M (SMul.smul.{u1, u2} (Units.{u1} R (Ring.toMonoid.{u1} R _inst_7)) M (Units.hasSmul.{u1, u2} R M (Ring.toMonoid.{u1} R _inst_7) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_8)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_7))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_8)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_7)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_8)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_7) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9))))) z x) y))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_7 : Ring.{u2} R] [_inst_8 : AddCommGroup.{u1} M] [_inst_9 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8)] [_inst_10 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_8))))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_8))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_8))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_8))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9))))] {x : M} {y : M}, Iff (Eq.{succ u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) x)) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) y))) (Exists.{succ u2} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7)))) (fun (z : Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7)))) => Eq.{succ u1} M (HSMul.hSMul.{u2, u1, u1} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7)))) M M (instHSMul.{u2, u1} (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7)))) M (Units.instSMulUnits.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_8))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_8))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_7)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_8))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M _inst_8) _inst_9)))))) z x) y))
Case conversion may be inaccurate. Consider using '#align submodule.span_singleton_eq_span_singleton Submodule.span_singleton_eq_span_singletonₓ'. -/
theorem span_singleton_eq_span_singleton {R M : Type _} [Ring R] [AddCommGroup M] [Module R M]
    [NoZeroSMulDivisors R M] {x y : M} : ((R ∙ x) = R ∙ y) ↔ ∃ z : Rˣ, z • x = y :=
  by
  by_cases hx : x = 0
  · rw [hx, span_zero_singleton, eq_comm, span_singleton_eq_bot]
    exact ⟨fun hy => ⟨1, by rw [hy, smul_zero]⟩, fun ⟨_, hz⟩ => by rw [← hz, smul_zero]⟩
  by_cases hy : y = 0
  · rw [hy, span_zero_singleton, span_singleton_eq_bot]
    exact ⟨fun hx => ⟨1, by rw [hx, smul_zero]⟩, fun ⟨z, hz⟩ => (smul_eq_zero_iff_eq z).mp hz⟩
  constructor
  · intro hxy
    cases'
      mem_span_singleton.mp
        (by
          rw [hxy]
          apply mem_span_singleton_self) with
      v hv
    cases'
      mem_span_singleton.mp
        (by
          rw [← hxy]
          apply mem_span_singleton_self) with
      i hi
    have vi : v * i = 1 := by
      rw [← one_smul R y, ← hi, smul_smul] at hv
      exact smul_left_injective R hy hv
    have iv : i * v = 1 := by
      rw [← one_smul R x, ← hv, smul_smul] at hi
      exact smul_left_injective R hx hi
    exact ⟨⟨v, i, vi, iv⟩, hv⟩
  · rintro ⟨v, rfl⟩
    rw [span_singleton_group_smul_eq]
#align submodule.span_singleton_eq_span_singleton Submodule.span_singleton_eq_span_singleton

/- warning: submodule.span_image -> Submodule.span_image is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] {s : Set.{u3} M} [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6), Eq.{succ u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (Submodule.span.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6 (Set.image.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s)) (Submodule.map.{u1, u2, u3, u4, max u3 u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ _inst_7 (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u4, u2} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u3} R₂] {σ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u3, u1} R₂ M₂ _inst_4 _inst_5] {s : Set.{u2} M} [_inst_7 : RingHomSurjective.{u4, u3} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6), Eq.{succ u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (Submodule.span.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6 (Set.image.{u2, u1} M M₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s)) (Submodule.map.{u4, u3, u2, u1, max u2 u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂ _inst_7 (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (Submodule.span.{u4, u2} R M _inst_1 _inst_2 _inst_3 s))
Case conversion may be inaccurate. Consider using '#align submodule.span_image Submodule.span_imageₓ'. -/
@[simp]
theorem span_image [RingHomSurjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) :
    span R₂ (f '' s) = map f (span R s) :=
  (map_span f s).symm
#align submodule.span_image Submodule.span_image

/- warning: submodule.apply_mem_span_image_of_mem_span -> Submodule.apply_mem_span_image_of_mem_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) {x : M} {s : Set.{u3} M}, (Membership.Mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s)) -> (Membership.Mem.{u4, u4} M₂ (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (SetLike.hasMem.{u4, u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) M₂ (Submodule.setLike.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f x) (Submodule.span.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6 (Set.image.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s)))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u4, u2} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u3} R₂] {σ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u3, u1} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u4, u3} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) {x : M} {s : Set.{u2} M}, (Membership.mem.{u2, u2} M (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u4, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u4, u2} R M _inst_1 _inst_2 _inst_3 s)) -> (Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) M₂ (Submodule.instSetLikeSubmodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f x) (Submodule.span.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6 (Set.image.{u2, u1} M M₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s)))
Case conversion may be inaccurate. Consider using '#align submodule.apply_mem_span_image_of_mem_span Submodule.apply_mem_span_image_of_mem_spanₓ'. -/
theorem apply_mem_span_image_of_mem_span [RingHomSurjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) {x : M}
    {s : Set M} (h : x ∈ Submodule.span R s) : f x ∈ Submodule.span R₂ (f '' s) :=
  by
  rw [Submodule.span_image]
  exact Submodule.mem_map_of_mem h
#align submodule.apply_mem_span_image_of_mem_span Submodule.apply_mem_span_image_of_mem_span

/- warning: submodule.map_subtype_span_singleton -> Submodule.map_subtype_span_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.map.{u1, u1, u2, u2, u2} R R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M _inst_1 _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} R R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M _inst_1 _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) (Submodule.span.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_3 p) (Singleton.singleton.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) (Set.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p)) (Set.hasSingleton.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p)) x))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) p) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x p))))) x)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {p : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3} (x : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x p)), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.map.{u2, u2, u1, u1, u1} R R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x p)) M _inst_1 _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3 p) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3 p) _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomSurjective.ids.{u2} R _inst_1) (LinearMap.{u2, u2, u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x p)) M (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3 p) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3 p) _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u2, u2, u1, u1} R R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x p)) M _inst_1 _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3 p) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3 p) _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Submodule.subtype.{u2, u1} R M _inst_1 _inst_2 _inst_3 p) (Submodule.span.{u2, u1} R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x p)) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3 p) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3 p) (Singleton.singleton.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x p)) (Set.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x p))) (Set.instSingletonSet.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x p))) x))) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) p)) x)))
Case conversion may be inaccurate. Consider using '#align submodule.map_subtype_span_singleton Submodule.map_subtype_span_singletonₓ'. -/
@[simp]
theorem map_subtype_span_singleton {p : Submodule R M} (x : p) :
    map p.Subtype (R ∙ x) = R ∙ (x : M) := by simp [← span_image]
#align submodule.map_subtype_span_singleton Submodule.map_subtype_span_singleton

/- warning: submodule.not_mem_span_of_apply_not_mem_span_image -> Submodule.not_mem_span_of_apply_not_mem_span_image is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) {x : M} {s : Set.{u3} M}, (Not (Membership.Mem.{u4, u4} M₂ (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) (SetLike.hasMem.{u4, u4} (Submodule.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6) M₂ (Submodule.setLike.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f x) (Submodule.span.{u2, u4} R₂ M₂ _inst_4 _inst_5 _inst_6 (Set.image.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s)))) -> (Not (Membership.Mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s)))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u4, u2} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u3} R₂] {σ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u3, u1} R₂ M₂ _inst_4 _inst_5] [_inst_7 : RingHomSurjective.{u4, u3} R R₂ _inst_1 _inst_4 σ₁₂] (f : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) {x : M} {s : Set.{u2} M}, (Not (Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6) M₂ (Submodule.instSetLikeSubmodule.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f x) (Submodule.span.{u3, u1} R₂ M₂ _inst_4 _inst_5 _inst_6 (Set.image.{u2, u1} M M₂ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) s)))) -> (Not (Membership.mem.{u2, u2} M (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u4, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u4, u2} R M _inst_1 _inst_2 _inst_3 s)))
Case conversion may be inaccurate. Consider using '#align submodule.not_mem_span_of_apply_not_mem_span_image Submodule.not_mem_span_of_apply_not_mem_span_imageₓ'. -/
/-- `f` is an explicit argument so we can `apply` this theorem and obtain `h` as a new goal. -/
theorem not_mem_span_of_apply_not_mem_span_image [RingHomSurjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) {x : M}
    {s : Set M} (h : f x ∉ Submodule.span R₂ (f '' s)) : x ∉ Submodule.span R s :=
  h.imp (apply_mem_span_image_of_mem_span f)
#align submodule.not_mem_span_of_apply_not_mem_span_image Submodule.not_mem_span_of_apply_not_mem_span_image

/- warning: submodule.supr_span -> Submodule.supᵢ_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Set.{u2} M)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (p i))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.unionᵢ.{u2, u3} M ι (fun (i : ι) => p i)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Set.{u2} M)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (p i))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.unionᵢ.{u2, u3} M ι (fun (i : ι) => p i)))
Case conversion may be inaccurate. Consider using '#align submodule.supr_span Submodule.supᵢ_spanₓ'. -/
theorem supᵢ_span {ι : Sort _} (p : ι → Set M) : (⨆ i, span R (p i)) = span R (⋃ i, p i) :=
  le_antisymm (supᵢ_le fun i => span_mono <| subset_unionᵢ _ i) <|
    span_le.mpr <| unionᵢ_subset fun i m hm => mem_supᵢ_of_mem i <| subset_span hm
#align submodule.supr_span Submodule.supᵢ_span

/- warning: submodule.supr_eq_span -> Submodule.supᵢ_eq_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Set.unionᵢ.{u2, u3} M ι (fun (i : ι) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (p i))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i)) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Set.unionᵢ.{u1, u3} M ι (fun (i : ι) => SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (p i))))
Case conversion may be inaccurate. Consider using '#align submodule.supr_eq_span Submodule.supᵢ_eq_spanₓ'. -/
theorem supᵢ_eq_span {ι : Sort _} (p : ι → Submodule R M) : (⨆ i, p i) = span R (⋃ i, ↑(p i)) := by
  simp_rw [← supr_span, span_eq]
#align submodule.supr_eq_span Submodule.supᵢ_eq_span

/- warning: submodule.supr_to_add_submonoid -> Submodule.supᵢ_toAddSubmonoid is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)), Eq.{succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) (supᵢ.{u2, u3} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (ConditionallyCompleteLattice.toHasSup.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (CompleteLattice.toConditionallyCompleteLattice.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoid.completeLattice.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) ι (fun (i : ι) => Submodule.toAddSubmonoid.{u1, u2} R M _inst_1 _inst_2 _inst_3 (p i)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)), Eq.{succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Submodule.toAddSubmonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) (supᵢ.{u1, u3} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (ConditionallyCompleteLattice.toSupSet.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) ι (fun (i : ι) => Submodule.toAddSubmonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (p i)))
Case conversion may be inaccurate. Consider using '#align submodule.supr_to_add_submonoid Submodule.supᵢ_toAddSubmonoidₓ'. -/
theorem supᵢ_toAddSubmonoid {ι : Sort _} (p : ι → Submodule R M) :
    (⨆ i, p i).toAddSubmonoid = ⨆ i, (p i).toAddSubmonoid :=
  by
  refine' le_antisymm (fun x => _) (supᵢ_le fun i => to_add_submonoid_mono <| le_supᵢ _ i)
  simp_rw [supr_eq_span, AddSubmonoid.supᵢ_eq_closure, mem_to_add_submonoid, coe_to_add_submonoid]
  intro hx
  refine' Submodule.span_induction hx (fun x hx => _) _ (fun x y hx hy => _) fun r x hx => _
  · exact AddSubmonoid.subset_closure hx
  · exact AddSubmonoid.zero_mem _
  · exact AddSubmonoid.add_mem _ hx hy
  · apply AddSubmonoid.closure_induction hx
    · rintro x ⟨_, ⟨i, rfl⟩, hix : x ∈ p i⟩
      apply AddSubmonoid.subset_closure (set.mem_Union.mpr ⟨i, _⟩)
      exact smul_mem _ r hix
    · rw [smul_zero]
      exact AddSubmonoid.zero_mem _
    · intro x y hx hy
      rw [smul_add]
      exact AddSubmonoid.add_mem _ hx hy
#align submodule.supr_to_add_submonoid Submodule.supᵢ_toAddSubmonoid

/- warning: submodule.supr_induction -> Submodule.supᵢ_induction is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) {C : M -> Prop} {x : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) -> (forall (i : ι) (x : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (p i)) -> (C x)) -> (C (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) -> (forall (x : M) (y : M), (C x) -> (C y) -> (C (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y))) -> (C x)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) {C : M -> Prop} {x : M}, (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) -> (forall (i : ι) (x : M), (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (p i)) -> (C x)) -> (C (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) -> (forall (x : M) (y : M), (C x) -> (C y) -> (C (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) x y))) -> (C x)
Case conversion may be inaccurate. Consider using '#align submodule.supr_induction Submodule.supᵢ_inductionₓ'. -/
/-- An induction principle for elements of `⨆ i, p i`.
If `C` holds for `0` and all elements of `p i` for all `i`, and is preserved under addition,
then it holds for all elements of the supremum of `p`. -/
@[elab_as_elim]
theorem supᵢ_induction {ι : Sort _} (p : ι → Submodule R M) {C : M → Prop} {x : M}
    (hx : x ∈ ⨆ i, p i) (hp : ∀ (i), ∀ x ∈ p i, C x) (h0 : C 0)
    (hadd : ∀ x y, C x → C y → C (x + y)) : C x :=
  by
  rw [← mem_to_add_submonoid, supr_to_add_submonoid] at hx
  exact AddSubmonoid.supᵢ_induction _ hx hp h0 hadd
#align submodule.supr_induction Submodule.supᵢ_induction

/- warning: submodule.supr_induction' -> Submodule.supᵢ_induction' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) {C : forall (x : M), (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) -> Prop}, (forall (i : ι) (x : M) (H : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (p i)), C x (Submodule.mem_supᵢ_of_mem.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 ι x (fun (i : ι) => p i) i H)) -> (C (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))) (ZeroMemClass.zero_mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddSubmonoidClass.to_zeroMemClass.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i)))) -> (forall (x : M) (y : M) (hx : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) (hy : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) y (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))), (C x hx) -> (C y hy) -> (C (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y) (AddMemClass.add_mem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3) (AddSubmonoidClass.to_addMemClass.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i)) x y hx hy))) -> (forall {x : M} (hx : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))), C x hx)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) {C : forall (x : M), (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) -> Prop}, (forall (i : ι) (x : M) (H : Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (p i)), C x (Submodule.mem_supᵢ_of_mem.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 ι x (fun (i : ι) => p i) i H)) -> (C (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) (ZeroMemClass.zero_mem.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (AddSubmonoidClass.toZeroMemClass.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M _inst_1 _inst_2 _inst_3)) (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i)))) -> (forall (x : M) (y : M) (hx : Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) (hy : Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) y (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))), (C x hx) -> (C y hy) -> (C (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) x y) (AddMemClass.add_mem.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))) (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (AddSubmonoidClass.toAddMemClass.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M _inst_1 _inst_2 _inst_3)) (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i)) x y hx hy))) -> (forall {x : M} (hx : Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))), C x hx)
Case conversion may be inaccurate. Consider using '#align submodule.supr_induction' Submodule.supᵢ_induction'ₓ'. -/
/-- A dependent version of `submodule.supr_induction`. -/
@[elab_as_elim]
theorem supᵢ_induction' {ι : Sort _} (p : ι → Submodule R M) {C : ∀ x, (x ∈ ⨆ i, p i) → Prop}
    (hp : ∀ (i), ∀ x ∈ p i, C x (mem_supᵢ_of_mem i ‹_›)) (h0 : C 0 (zero_mem _))
    (hadd : ∀ x y hx hy, C x hx → C y hy → C (x + y) (add_mem ‹_› ‹_›)) {x : M}
    (hx : x ∈ ⨆ i, p i) : C x hx :=
  by
  refine' Exists.elim _ fun (hx : x ∈ ⨆ i, p i) (hc : C x hx) => hc
  refine' supr_induction p hx (fun i x hx => _) _ fun x y => _
  · exact ⟨_, hp _ _ hx⟩
  · exact ⟨_, h0⟩
  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩
    refine' ⟨_, hadd _ _ _ _ Cx Cy⟩
#align submodule.supr_induction' Submodule.supᵢ_induction'

/- warning: submodule.span_singleton_le_iff_mem -> Submodule.span_singleton_le_iff_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (m : M) (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Iff (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) m)) p) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m p)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (m : M) (p : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3), Iff (LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) m)) p) (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) m p)
Case conversion may be inaccurate. Consider using '#align submodule.span_singleton_le_iff_mem Submodule.span_singleton_le_iff_memₓ'. -/
@[simp]
theorem span_singleton_le_iff_mem (m : M) (p : Submodule R M) : (R ∙ m) ≤ p ↔ m ∈ p := by
  rw [span_le, singleton_subset_iff, SetLike.mem_coe]
#align submodule.span_singleton_le_iff_mem Submodule.span_singleton_le_iff_mem

#print Submodule.singleton_span_isCompactElement /-
theorem singleton_span_isCompactElement (x : M) :
    CompleteLattice.IsCompactElement (span R {x} : Submodule R M) :=
  by
  rw [CompleteLattice.isCompactElement_iff_le_of_directed_supₛ_le]
  intro d hemp hdir hsup
  have : x ∈ Sup d := (set_like.le_def.mp hsup) (mem_span_singleton_self x)
  obtain ⟨y, ⟨hyd, hxy⟩⟩ := (mem_Sup_of_directed hemp hdir).mp this
  exact ⟨y, ⟨hyd, by simpa only [span_le, singleton_subset_iff] ⟩⟩
#align submodule.singleton_span_is_compact_element Submodule.singleton_span_isCompactElement
-/

#print Submodule.finset_span_isCompactElement /-
/-- The span of a finite subset is compact in the lattice of submodules. -/
theorem finset_span_isCompactElement (S : Finset M) :
    CompleteLattice.IsCompactElement (span R S : Submodule R M) :=
  by
  rw [span_eq_supr_of_singleton_spans]
  simp only [Finset.mem_coe]
  rw [← Finset.sup_eq_supᵢ]
  exact
    CompleteLattice.finset_sup_compact_of_compact S fun x _ => singleton_span_is_compact_element x
#align submodule.finset_span_is_compact_element Submodule.finset_span_isCompactElement
-/

#print Submodule.finite_span_isCompactElement /-
/-- The span of a finite subset is compact in the lattice of submodules. -/
theorem finite_span_isCompactElement (S : Set M) (h : S.Finite) :
    CompleteLattice.IsCompactElement (span R S : Submodule R M) :=
  Finite.coe_toFinset h ▸ finset_span_isCompactElement h.toFinset
#align submodule.finite_span_is_compact_element Submodule.finite_span_isCompactElement
-/

instance : IsCompactlyGenerated (Submodule R M) :=
  ⟨fun s =>
    ⟨(fun x => span R {x}) '' s,
      ⟨fun t ht => by
        rcases(Set.mem_image _ _ _).1 ht with ⟨x, hx, rfl⟩
        apply singleton_span_is_compact_element, by
        rw [supₛ_eq_supᵢ, supᵢ_image, ← span_eq_supr_of_singleton_spans, span_eq]⟩⟩⟩

/- warning: submodule.submodule_eq_Sup_le_nonzero_spans -> Submodule.submodule_eq_supₛ_le_nonzero_spans is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) p (SupSet.supₛ.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (setOf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (fun (T : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) => Exists.{succ u2} M (fun (m : M) => Exists.{0} (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m p) (fun (hm : Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m p) => Exists.{0} (Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (fun (hz : Ne.{succ u2} M m (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) => Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) T (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) m))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (p : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) p (SupSet.supₛ.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) (setOf.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (fun (T : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) => Exists.{succ u1} M (fun (m : M) => Exists.{0} (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) m p) (fun (hm : Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) m p) => Exists.{0} (Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (fun (hz : Ne.{succ u1} M m (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) => Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) T (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) m))))))))
Case conversion may be inaccurate. Consider using '#align submodule.submodule_eq_Sup_le_nonzero_spans Submodule.submodule_eq_supₛ_le_nonzero_spansₓ'. -/
/-- A submodule is equal to the supremum of the spans of the submodule's nonzero elements. -/
theorem submodule_eq_supₛ_le_nonzero_spans (p : Submodule R M) :
    p = supₛ { T : Submodule R M | ∃ (m : M)(hm : m ∈ p)(hz : m ≠ 0), T = span R {m} } :=
  by
  let S := { T : Submodule R M | ∃ (m : M)(hm : m ∈ p)(hz : m ≠ 0), T = span R {m} }
  apply le_antisymm
  · intro m hm
    by_cases h : m = 0
    · rw [h]
      simp
    · exact @le_supₛ _ _ S _ ⟨m, ⟨hm, ⟨h, rfl⟩⟩⟩ m (mem_span_singleton_self m)
  · rw [supₛ_le_iff]
    rintro S ⟨_, ⟨_, ⟨_, rfl⟩⟩⟩
    rwa [span_singleton_le_iff_mem]
#align submodule.submodule_eq_Sup_le_nonzero_spans Submodule.submodule_eq_supₛ_le_nonzero_spans

/- warning: submodule.lt_sup_iff_not_mem -> Submodule.lt_sup_iff_not_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {I : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {a : M}, Iff (LT.lt.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) I (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) I (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) a)))) (Not (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) a I))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {I : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3} {a : M}, Iff (LT.lt.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Preorder.toLT.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) I (HasSup.sup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) I (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) a)))) (Not (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) a I))
Case conversion may be inaccurate. Consider using '#align submodule.lt_sup_iff_not_mem Submodule.lt_sup_iff_not_memₓ'. -/
theorem lt_sup_iff_not_mem {I : Submodule R M} {a : M} : (I < I ⊔ R ∙ a) ↔ a ∉ I :=
  by
  constructor
  · intro h
    by_contra akey
    have h1 : (I ⊔ R ∙ a) ≤ I := by
      simp only [sup_le_iff]
      constructor
      · exact le_refl I
      · exact (span_singleton_le_iff_mem a I).mpr akey
    have h2 := gt_of_ge_of_gt h1 h
    exact lt_irrefl I h2
  · intro h
    apply set_like.lt_iff_le_and_exists.mpr
    constructor
    simp only [le_sup_left]
    use a
    constructor
    swap
    · assumption
    · have : (R ∙ a) ≤ I ⊔ R ∙ a := le_sup_right
      exact this (mem_span_singleton_self a)
#align submodule.lt_sup_iff_not_mem Submodule.lt_sup_iff_not_mem

/- warning: submodule.mem_supr -> Submodule.mem_supᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) {m : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u2, u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) (forall (N : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3), (forall (i : ι), LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) (p i) N) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m N))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {ι : Sort.{u3}} (p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) {m : M}, Iff (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u1, u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) (forall (N : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3), (forall (i : ι), LE.le.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))))) (p i) N) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) m N))
Case conversion may be inaccurate. Consider using '#align submodule.mem_supr Submodule.mem_supᵢₓ'. -/
theorem mem_supᵢ {ι : Sort _} (p : ι → Submodule R M) {m : M} :
    (m ∈ ⨆ i, p i) ↔ ∀ N, (∀ i, p i ≤ N) → m ∈ N :=
  by
  rw [← span_singleton_le_iff_mem, le_supᵢ_iff]
  simp only [span_singleton_le_iff_mem]
#align submodule.mem_supr Submodule.mem_supᵢ

section

open Classical

/- warning: submodule.mem_span_finite_of_mem_span -> Submodule.mem_span_finite_of_mem_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {S : Set.{u2} M} {x : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 S)) -> (Exists.{succ u2} (Finset.{u2} M) (fun (T : Finset.{u2} M) => And (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} M) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} M) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} M) (Set.{u2} M) (Finset.Set.hasCoeT.{u2} M))) T) S) (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} M) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} M) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} M) (Set.{u2} M) (Finset.Set.hasCoeT.{u2} M))) T)))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {S : Set.{u2} M} {x : M}, (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 S)) -> (Exists.{succ u2} (Finset.{u2} M) (fun (T : Finset.{u2} M) => And (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) (Finset.toSet.{u2} M T) S) (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Finset.toSet.{u2} M T)))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_span_finite_of_mem_span Submodule.mem_span_finite_of_mem_spanₓ'. -/
/-- For every element in the span of a set, there exists a finite subset of the set
such that the element is contained in the span of the subset. -/
theorem mem_span_finite_of_mem_span {S : Set M} {x : M} (hx : x ∈ span R S) :
    ∃ T : Finset M, ↑T ⊆ S ∧ x ∈ span R (T : Set M) :=
  by
  refine' span_induction hx (fun x hx => _) _ _ _
  · refine' ⟨{x}, _, _⟩
    · rwa [Finset.coe_singleton, Set.singleton_subset_iff]
    · rw [Finset.coe_singleton]
      exact Submodule.mem_span_singleton_self x
  · use ∅
    simp
  · rintro x y ⟨X, hX, hxX⟩ ⟨Y, hY, hyY⟩
    refine' ⟨X ∪ Y, _, _⟩
    · rw [Finset.coe_union]
      exact Set.union_subset hX hY
    rw [Finset.coe_union, span_union, mem_sup]
    exact ⟨x, hxX, y, hyY, rfl⟩
  · rintro a x ⟨T, hT, h2⟩
    exact ⟨T, hT, smul_mem _ _ h2⟩
#align submodule.mem_span_finite_of_mem_span Submodule.mem_span_finite_of_mem_span

end

variable {M' : Type _} [AddCommMonoid M'] [Module R M'] (q₁ q₁' : Submodule R M')

/- warning: submodule.prod -> Submodule.prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) -> (forall {M' : Type.{u3}} [_inst_7 : AddCommMonoid.{u3} M'] [_inst_8 : Module.{u1, u3} R M' _inst_1 _inst_7], (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) -> (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) -> (forall {M' : Type.{u3}} [_inst_7 : AddCommMonoid.{u3} M'] [_inst_8 : Module.{u1, u3} R M' _inst_1 _inst_7], (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) -> (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M') _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)))
Case conversion may be inaccurate. Consider using '#align submodule.prod Submodule.prodₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- The product of two submodules is a submodule. -/
def prod : Submodule R (M × M') :=
  {
    p.toAddSubmonoid.Prod q₁.toAddSubmonoid with
    carrier := p ×ˢ q₁
    smul_mem' := by rintro a ⟨x, y⟩ ⟨hx, hy⟩ <;> exact ⟨smul_mem _ a hx, smul_mem _ a hy⟩ }
#align submodule.prod Submodule.prod

/- warning: submodule.prod_coe -> Submodule.prod_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) {M' : Type.{u3}} [_inst_7 : AddCommMonoid.{u3} M'] [_inst_8 : Module.{u1, u3} R M' _inst_1 _inst_7] (q₁ : Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8), Eq.{succ (max u2 u3)} (Set.{max u2 u3} (Prod.{u2, u3} M M')) ((fun (a : Type.{max u2 u3}) (b : Type.{max u2 u3}) [self : HasLiftT.{succ (max u2 u3), succ (max u2 u3)} a b] => self.0) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Set.{max u2 u3} (Prod.{u2, u3} M M')) (HasLiftT.mk.{succ (max u2 u3), succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Set.{max u2 u3} (Prod.{u2, u3} M M')) (CoeTCₓ.coe.{succ (max u2 u3), succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Set.{max u2 u3} (Prod.{u2, u3} M M')) (SetLike.Set.hasCoeT.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Prod.{u2, u3} M M') (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8))))) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 p M' _inst_7 _inst_8 q₁)) (Set.prod.{u2, u3} M M' ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (Set.{u3} M') (HasLiftT.mk.{succ u3, succ u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (Set.{u3} M') (CoeTCₓ.coe.{succ u3, succ u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (Set.{u3} M') (SetLike.Set.hasCoeT.{u3, u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) M' (Submodule.setLike.{u1, u3} R M' _inst_1 _inst_7 _inst_8)))) q₁))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] (p : Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) {M' : Type.{u2}} [_inst_7 : AddCommMonoid.{u2} M'] [_inst_8 : Module.{u1, u2} R M' _inst_1 _inst_7] (q₁ : Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8), Eq.{max (succ u3) (succ u2)} (Set.{max u3 u2} (Prod.{u3, u2} M M')) (SetLike.coe.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Prod.{u3, u2} M M') (Submodule.instSetLikeSubmodule.{u1, max u3 u2} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.prod.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 p M' _inst_7 _inst_8 q₁)) (Set.prod.{u3, u2} M M' (SetLike.coe.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) p) (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) M' (Submodule.instSetLikeSubmodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) q₁))
Case conversion may be inaccurate. Consider using '#align submodule.prod_coe Submodule.prod_coeₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
@[simp]
theorem prod_coe : (prod p q₁ : Set (M × M')) = p ×ˢ q₁ :=
  rfl
#align submodule.prod_coe Submodule.prod_coe

/- warning: submodule.mem_prod -> Submodule.mem_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {M' : Type.{u3}} [_inst_7 : AddCommMonoid.{u3} M'] [_inst_8 : Module.{u1, u3} R M' _inst_1 _inst_7] {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {q : Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8} {x : Prod.{u2, u3} M M'}, Iff (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} M M') (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Prod.{u2, u3} M M') (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8))) x (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 p M' _inst_7 _inst_8 q)) (And (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Prod.fst.{u2, u3} M M' x) p) (Membership.Mem.{u3, u3} M' (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) M' (Submodule.setLike.{u1, u3} R M' _inst_1 _inst_7 _inst_8)) (Prod.snd.{u2, u3} M M' x) q))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] {M' : Type.{u1}} [_inst_7 : AddCommMonoid.{u1} M'] [_inst_8 : Module.{u3, u1} R M' _inst_1 _inst_7] {p : Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3} {q : Submodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8} {x : Prod.{u2, u1} M M'}, Iff (Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} M M') (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} M M') _inst_1 (Prod.instAddCommMonoidSum.{u2, u1} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u3, u2, u1} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} M M') _inst_1 (Prod.instAddCommMonoidSum.{u2, u1} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u3, u2, u1} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Prod.{u2, u1} M M') (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} M M') _inst_1 (Prod.instAddCommMonoidSum.{u2, u1} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u3, u2, u1} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8))) x (Submodule.prod.{u3, u2, u1} R M _inst_1 _inst_2 _inst_3 p M' _inst_7 _inst_8 q)) (And (Membership.mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u3, u2} R M _inst_1 _inst_2 _inst_3)) (Prod.fst.{u2, u1} M M' x) p) (Membership.mem.{u1, u1} M' (Submodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8) M' (Submodule.instSetLikeSubmodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8)) (Prod.snd.{u2, u1} M M' x) q))
Case conversion may be inaccurate. Consider using '#align submodule.mem_prod Submodule.mem_prodₓ'. -/
@[simp]
theorem mem_prod {p : Submodule R M} {q : Submodule R M'} {x : M × M'} :
    x ∈ prod p q ↔ x.1 ∈ p ∧ x.2 ∈ q :=
  Set.mem_prod
#align submodule.mem_prod Submodule.mem_prod

/- warning: submodule.span_prod_le -> Submodule.span_prod_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {M' : Type.{u3}} [_inst_7 : AddCommMonoid.{u3} M'] [_inst_8 : Module.{u1, u3} R M' _inst_1 _inst_7] (s : Set.{u2} M) (t : Set.{u3} M'), LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Prod.{u2, u3} M M') (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8))))) (Submodule.span.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8) (Set.prod.{u2, u3} M M' s t)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s) M' _inst_7 _inst_8 (Submodule.span.{u1, u3} R M' _inst_1 _inst_7 _inst_8 t))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {M' : Type.{u2}} [_inst_7 : AddCommMonoid.{u2} M'] [_inst_8 : Module.{u1, u2} R M' _inst_1 _inst_7] (s : Set.{u3} M) (t : Set.{u2} M'), LE.le.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Preorder.toLE.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (PartialOrder.toPreorder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.completeLattice.{u1, max u3 u2} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)))))) (Submodule.span.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8) (Set.prod.{u3, u2} M M' s t)) (Submodule.prod.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s) M' _inst_7 _inst_8 (Submodule.span.{u1, u2} R M' _inst_1 _inst_7 _inst_8 t))
Case conversion may be inaccurate. Consider using '#align submodule.span_prod_le Submodule.span_prod_leₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
theorem span_prod_le (s : Set M) (t : Set M') : span R (s ×ˢ t) ≤ prod (span R s) (span R t) :=
  span_le.2 <| Set.prod_mono subset_span subset_span
#align submodule.span_prod_le Submodule.span_prod_le

/- warning: submodule.prod_top -> Submodule.prod_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {M' : Type.{u3}} [_inst_7 : AddCommMonoid.{u3} M'] [_inst_8 : Module.{u1, u3} R M' _inst_1 _inst_7], Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_2 _inst_3)) M' _inst_7 _inst_8 (Top.top.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (Submodule.hasTop.{u1, u3} R M' _inst_1 _inst_7 _inst_8))) (Top.top.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.hasTop.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {M' : Type.{u2}} [_inst_7 : AddCommMonoid.{u2} M'] [_inst_8 : Module.{u1, u2} R M' _inst_1 _inst_7], Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.prod.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 (Top.top.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.instTopSubmodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)) M' _inst_7 _inst_8 (Top.top.{u2} (Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) (Submodule.instTopSubmodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8))) (Top.top.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.instTopSubmodule.{u1, max u3 u2} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)))
Case conversion may be inaccurate. Consider using '#align submodule.prod_top Submodule.prod_topₓ'. -/
@[simp]
theorem prod_top : (prod ⊤ ⊤ : Submodule R (M × M')) = ⊤ := by ext <;> simp
#align submodule.prod_top Submodule.prod_top

/- warning: submodule.prod_bot -> Submodule.prod_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {M' : Type.{u3}} [_inst_7 : AddCommMonoid.{u3} M'] [_inst_8 : Module.{u1, u3} R M' _inst_1 _inst_7], Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_3)) M' _inst_7 _inst_8 (Bot.bot.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (Submodule.hasBot.{u1, u3} R M' _inst_1 _inst_7 _inst_8))) (Bot.bot.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.hasBot.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {M' : Type.{u2}} [_inst_7 : AddCommMonoid.{u2} M'] [_inst_8 : Module.{u1, u2} R M' _inst_1 _inst_7], Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.prod.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 (Bot.bot.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.instBotSubmodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)) M' _inst_7 _inst_8 (Bot.bot.{u2} (Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) (Submodule.instBotSubmodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8))) (Bot.bot.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.instBotSubmodule.{u1, max u3 u2} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)))
Case conversion may be inaccurate. Consider using '#align submodule.prod_bot Submodule.prod_botₓ'. -/
@[simp]
theorem prod_bot : (prod ⊥ ⊥ : Submodule R (M × M')) = ⊥ := by ext ⟨x, y⟩ <;> simp [Prod.zero_eq_mk]
#align submodule.prod_bot Submodule.prod_bot

/- warning: submodule.prod_mono -> Submodule.prod_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {M' : Type.{u3}} [_inst_7 : AddCommMonoid.{u3} M'] [_inst_8 : Module.{u1, u3} R M' _inst_1 _inst_7] {p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3} {q : Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8} {q' : Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8}, (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) p p') -> (LE.le.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (Preorder.toLE.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (SetLike.partialOrder.{u3, u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) M' (Submodule.setLike.{u1, u3} R M' _inst_1 _inst_7 _inst_8)))) q q') -> (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Prod.{u2, u3} M M') (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8))))) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 p M' _inst_7 _inst_8 q) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 p' M' _inst_7 _inst_8 q'))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] {M' : Type.{u1}} [_inst_7 : AddCommMonoid.{u1} M'] [_inst_8 : Module.{u3, u1} R M' _inst_1 _inst_7] {p : Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3} {p' : Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3} {q : Submodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8} {q' : Submodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8}, (LE.le.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Preorder.toLE.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u3, u2} R M _inst_1 _inst_2 _inst_3))))) p p') -> (LE.le.{u1} (Submodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8) (Preorder.toLE.{u1} (Submodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8) (PartialOrder.toPreorder.{u1} (Submodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u3, u1} R M' _inst_1 _inst_7 _inst_8) (Submodule.completeLattice.{u3, u1} R M' _inst_1 _inst_7 _inst_8))))) q q') -> (LE.le.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} M M') _inst_1 (Prod.instAddCommMonoidSum.{u2, u1} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u3, u2, u1} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Preorder.toLE.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} M M') _inst_1 (Prod.instAddCommMonoidSum.{u2, u1} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u3, u2, u1} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (PartialOrder.toPreorder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} M M') _inst_1 (Prod.instAddCommMonoidSum.{u2, u1} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u3, u2, u1} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} M M') _inst_1 (Prod.instAddCommMonoidSum.{u2, u1} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u3, u2, u1} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} M M') _inst_1 (Prod.instAddCommMonoidSum.{u2, u1} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u3, u2, u1} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.completeLattice.{u3, max u2 u1} R (Prod.{u2, u1} M M') _inst_1 (Prod.instAddCommMonoidSum.{u2, u1} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u3, u2, u1} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)))))) (Submodule.prod.{u3, u2, u1} R M _inst_1 _inst_2 _inst_3 p M' _inst_7 _inst_8 q) (Submodule.prod.{u3, u2, u1} R M _inst_1 _inst_2 _inst_3 p' M' _inst_7 _inst_8 q'))
Case conversion may be inaccurate. Consider using '#align submodule.prod_mono Submodule.prod_monoₓ'. -/
theorem prod_mono {p p' : Submodule R M} {q q' : Submodule R M'} :
    p ≤ p' → q ≤ q' → prod p q ≤ prod p' q' :=
  prod_mono
#align submodule.prod_mono Submodule.prod_mono

/- warning: submodule.prod_inf_prod -> Submodule.prod_inf_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) {M' : Type.{u3}} [_inst_7 : AddCommMonoid.{u3} M'] [_inst_8 : Module.{u1, u3} R M' _inst_1 _inst_7] (q₁ : Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (q₁' : Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (HasInf.inf.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.hasInf.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 p M' _inst_7 _inst_8 q₁) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 p' M' _inst_7 _inst_8 q₁')) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 (HasInf.inf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.hasInf.{u1, u2} R M _inst_1 _inst_2 _inst_3) p p') M' _inst_7 _inst_8 (HasInf.inf.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (Submodule.hasInf.{u1, u3} R M' _inst_1 _inst_7 _inst_8) q₁ q₁'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] (p : Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (p' : Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) {M' : Type.{u2}} [_inst_7 : AddCommMonoid.{u2} M'] [_inst_8 : Module.{u1, u2} R M' _inst_1 _inst_7] (q₁ : Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) (q₁' : Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8), Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (HasInf.inf.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.instHasInfSubmodule.{u1, max u3 u2} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.prod.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 p M' _inst_7 _inst_8 q₁) (Submodule.prod.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 p' M' _inst_7 _inst_8 q₁')) (Submodule.prod.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 (HasInf.inf.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.instHasInfSubmodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) p p') M' _inst_7 _inst_8 (HasInf.inf.{u2} (Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) (Submodule.instHasInfSubmodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) q₁ q₁'))
Case conversion may be inaccurate. Consider using '#align submodule.prod_inf_prod Submodule.prod_inf_prodₓ'. -/
@[simp]
theorem prod_inf_prod : prod p q₁ ⊓ prod p' q₁' = prod (p ⊓ p') (q₁ ⊓ q₁') :=
  SetLike.coe_injective Set.prod_inter_prod
#align submodule.prod_inf_prod Submodule.prod_inf_prod

/- warning: submodule.prod_sup_prod -> Submodule.prod_sup_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (p' : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) {M' : Type.{u3}} [_inst_7 : AddCommMonoid.{u3} M'] [_inst_8 : Module.{u1, u3} R M' _inst_1 _inst_7] (q₁ : Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (q₁' : Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (HasSup.sup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (SemilatticeSup.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Lattice.toSemilatticeSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (ConditionallyCompleteLattice.toLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M') _inst_1 (Prod.addCommMonoid.{u2, u3} M M' _inst_2 _inst_7) (Prod.module.{u1, u2, u3} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)))))) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 p M' _inst_7 _inst_8 q₁) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 p' M' _inst_7 _inst_8 q₁')) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) p p') M' _inst_7 _inst_8 (HasSup.sup.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (SemilatticeSup.toHasSup.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (Lattice.toSemilatticeSup.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (ConditionallyCompleteLattice.toLattice.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M' _inst_1 _inst_7 _inst_8) (Submodule.completeLattice.{u1, u3} R M' _inst_1 _inst_7 _inst_8))))) q₁ q₁'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] (p : Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (p' : Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) {M' : Type.{u2}} [_inst_7 : AddCommMonoid.{u2} M'] [_inst_8 : Module.{u1, u2} R M' _inst_1 _inst_7] (q₁ : Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) (q₁' : Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8), Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (HasSup.sup.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (SemilatticeSup.toHasSup.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Lattice.toSemilatticeSup.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (ConditionallyCompleteLattice.toLattice.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u2 u3} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)) (Submodule.completeLattice.{u1, max u3 u2} R (Prod.{u3, u2} M M') _inst_1 (Prod.instAddCommMonoidSum.{u3, u2} M M' _inst_2 _inst_7) (Prod.instModuleProdInstAddCommMonoidSum.{u1, u3, u2} R M M' _inst_1 _inst_2 _inst_7 _inst_3 _inst_8)))))) (Submodule.prod.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 p M' _inst_7 _inst_8 q₁) (Submodule.prod.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 p' M' _inst_7 _inst_8 q₁')) (Submodule.prod.{u1, u3, u2} R M _inst_1 _inst_2 _inst_3 (HasSup.sup.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SemilatticeSup.toHasSup.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Lattice.toSemilatticeSup.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toLattice.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u3} R M _inst_1 _inst_2 _inst_3))))) p p') M' _inst_7 _inst_8 (HasSup.sup.{u2} (Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M' _inst_1 _inst_7 _inst_8) (Submodule.completeLattice.{u1, u2} R M' _inst_1 _inst_7 _inst_8))))) q₁ q₁'))
Case conversion may be inaccurate. Consider using '#align submodule.prod_sup_prod Submodule.prod_sup_prodₓ'. -/
@[simp]
theorem prod_sup_prod : prod p q₁ ⊔ prod p' q₁' = prod (p ⊔ p') (q₁ ⊔ q₁') :=
  by
  refine'
    le_antisymm (sup_le (prod_mono le_sup_left le_sup_left) (prod_mono le_sup_right le_sup_right)) _
  simp [SetLike.le_def]; intro xx yy hxx hyy
  rcases mem_sup.1 hxx with ⟨x, hx, x', hx', rfl⟩
  rcases mem_sup.1 hyy with ⟨y, hy, y', hy', rfl⟩
  refine' mem_sup.2 ⟨(x, y), ⟨hx, hy⟩, (x', y'), ⟨hx', hy'⟩, rfl⟩
#align submodule.prod_sup_prod Submodule.prod_sup_prod

end AddCommMonoid

section AddCommGroup

variable [Ring R] [AddCommGroup M] [Module R M]

/- warning: submodule.span_neg -> Submodule.span_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (s : Set.{u2} M), Eq.{succ u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (Neg.neg.{u2} (Set.{u2} M) (Set.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) s)) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 s)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (s : Set.{u2} M), Eq.{succ u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (Neg.neg.{u2} (Set.{u2} M) (Set.neg.{u2} M (NegZeroClass.toNeg.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2)))))) s)) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 s)
Case conversion may be inaccurate. Consider using '#align submodule.span_neg Submodule.span_negₓ'. -/
@[simp]
theorem span_neg (s : Set M) : span R (-s) = span R s :=
  calc
    span R (-s) = span R ((-LinearMap.id : M →ₗ[R] M) '' s) := by simp
    _ = map (-LinearMap.id) (span R s) := ((-LinearMap.id).map_span _).symm
    _ = span R s := by simp
    
#align submodule.span_neg Submodule.span_neg

/- warning: submodule.mem_span_insert' -> Submodule.mem_span_insert' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {x : M} {y : M} {s : Set.{u2} M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (Insert.insert.{u2, u2} M (Set.{u2} M) (Set.hasInsert.{u2} M) y s))) (Exists.{succ u1} R (fun (a : R) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))) x (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)))) a y)) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 s)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {x : M} {y : M} {s : Set.{u2} M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (Insert.insert.{u2, u2} M (Set.{u2} M) (Set.instInsertSet.{u2} M) y s))) (Exists.{succ u1} R (fun (a : R) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))))) x (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3))))) a y)) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 s)))
Case conversion may be inaccurate. Consider using '#align submodule.mem_span_insert' Submodule.mem_span_insert'ₓ'. -/
theorem mem_span_insert' {x y} {s : Set M} :
    x ∈ span R (insert y s) ↔ ∃ a : R, x + a • y ∈ span R s :=
  by
  rw [mem_span_insert]; constructor
  · rintro ⟨a, z, hz, rfl⟩
    exact ⟨-a, by simp [hz, add_assoc]⟩
  · rintro ⟨a, h⟩
    exact ⟨-a, _, h, by simp [add_comm, add_left_comm]⟩
#align submodule.mem_span_insert' Submodule.mem_span_insert'

instance : IsModularLattice (Submodule R M) :=
  ⟨fun x y z xz a ha => by
    rw [mem_inf, mem_sup] at ha
    rcases ha with ⟨⟨b, hb, c, hc, rfl⟩, haz⟩
    rw [mem_sup]
    refine' ⟨b, hb, c, mem_inf.2 ⟨hc, _⟩, rfl⟩
    rw [← add_sub_cancel c b, add_comm]
    apply z.sub_mem haz (xz hb)⟩

end AddCommGroup

section AddCommGroup

variable [Semiring R] [Semiring R₂]

variable [AddCommGroup M] [Module R M] [AddCommGroup M₂] [Module R₂ M₂]

variable {τ₁₂ : R →+* R₂} [RingHomSurjective τ₁₂]

variable {F : Type _} [sc : SemilinearMapClass F τ₁₂ M M₂]

include sc

/- warning: submodule.comap_map_eq -> Submodule.comap_map_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : AddCommGroup.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)] [_inst_5 : AddCommGroup.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_5)] {τ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u5}} [sc : SemilinearMapClass.{u5, u1, u2, u3, u4} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_5) _inst_4 _inst_6] (f : F) (p : Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4), Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) (Submodule.comap.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ F sc f (Submodule.map.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ _inst_7 F sc f p)) (HasSup.sup.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) (SemilatticeSup.toHasSup.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) (Lattice.toSemilatticeSup.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) (ConditionallyCompleteLattice.toLattice.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) (Submodule.completeLattice.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4))))) p (LinearMap.ker.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ F sc f))
but is expected to have type
  forall {R : Type.{u5}} {R₂ : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u5} R] [_inst_2 : Semiring.{u3} R₂] [_inst_3 : AddCommGroup.{u4} M] [_inst_4 : Module.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3)] [_inst_5 : AddCommGroup.{u2} M₂] [_inst_6 : Module.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_5)] {τ₁₂ : RingHom.{u5, u3} R R₂ (Semiring.toNonAssocSemiring.{u5} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u5, u3} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u1}} [sc : SemilinearMapClass.{u1, u5, u3, u4, u2} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_5) _inst_4 _inst_6] (f : F) (p : Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4), Eq.{succ u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (Submodule.comap.{u5, u3, u4, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ F sc f (Submodule.map.{u5, u3, u4, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ _inst_7 F sc f p)) (HasSup.sup.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (SemilatticeSup.toHasSup.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (Lattice.toSemilatticeSup.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (ConditionallyCompleteLattice.toLattice.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (Submodule.completeLattice.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4))))) p (LinearMap.ker.{u5, u3, u4, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ F sc f))
Case conversion may be inaccurate. Consider using '#align submodule.comap_map_eq Submodule.comap_map_eqₓ'. -/
theorem comap_map_eq (f : F) (p : Submodule R M) : comap f (map f p) = p ⊔ LinearMap.ker f :=
  by
  refine' le_antisymm _ (sup_le (le_comap_map _ _) (comap_mono bot_le))
  rintro x ⟨y, hy, e⟩
  exact mem_sup.2 ⟨y, hy, x - y, by simpa using sub_eq_zero.2 e.symm, by simp⟩
#align submodule.comap_map_eq Submodule.comap_map_eq

/- warning: submodule.comap_map_eq_self -> Submodule.comap_map_eq_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : AddCommGroup.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)] [_inst_5 : AddCommGroup.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_5)] {τ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u5}} [sc : SemilinearMapClass.{u5, u1, u2, u3, u4} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_5) _inst_4 _inst_6] {f : F} {p : Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4}, (LE.le.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) (Preorder.toLE.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) (SetLike.partialOrder.{u3, u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) M (Submodule.setLike.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4)))) (LinearMap.ker.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ F sc f) p) -> (Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_4) (Submodule.comap.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ F sc f (Submodule.map.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ _inst_7 F sc f p)) p)
but is expected to have type
  forall {R : Type.{u5}} {R₂ : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u5} R] [_inst_2 : Semiring.{u3} R₂] [_inst_3 : AddCommGroup.{u4} M] [_inst_4 : Module.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3)] [_inst_5 : AddCommGroup.{u2} M₂] [_inst_6 : Module.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_5)] {τ₁₂ : RingHom.{u5, u3} R R₂ (Semiring.toNonAssocSemiring.{u5} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u5, u3} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u1}} [sc : SemilinearMapClass.{u1, u5, u3, u4, u2} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_5) _inst_4 _inst_6] {f : F} {p : Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4}, (LE.le.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (Preorder.toLE.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (PartialOrder.toPreorder.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (Submodule.completeLattice.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4))))) (LinearMap.ker.{u5, u3, u4, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ F sc f) p) -> (Eq.{succ u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_4) (Submodule.comap.{u5, u3, u4, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ F sc f (Submodule.map.{u5, u3, u4, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_5) _inst_4 _inst_6 τ₁₂ _inst_7 F sc f p)) p)
Case conversion may be inaccurate. Consider using '#align submodule.comap_map_eq_self Submodule.comap_map_eq_selfₓ'. -/
theorem comap_map_eq_self {f : F} {p : Submodule R M} (h : LinearMap.ker f ≤ p) :
    comap f (map f p) = p := by rw [Submodule.comap_map_eq, sup_of_le_left h]
#align submodule.comap_map_eq_self Submodule.comap_map_eq_self

omit sc

end AddCommGroup

end Submodule

namespace LinearMap

open Submodule Function

section AddCommGroup

variable [Semiring R] [Semiring R₂]

variable [AddCommGroup M] [AddCommGroup M₂]

variable [Module R M] [Module R₂ M₂]

variable {τ₁₂ : R →+* R₂} [RingHomSurjective τ₁₂]

variable {F : Type _} [sc : SemilinearMapClass F τ₁₂ M M₂]

include R

include sc

/- warning: linear_map.map_le_map_iff -> LinearMap.map_le_map_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : AddCommGroup.{u3} M] [_inst_4 : AddCommGroup.{u4} M₂] [_inst_5 : Module.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4)] {τ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u5}} [sc : SemilinearMapClass.{u5, u1, u2, u3, u4} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6] (f : F) {p : Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5} {p' : Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5}, Iff (LE.le.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (Preorder.toLE.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (PartialOrder.toPreorder.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (SetLike.partialOrder.{u4, u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) M₂ (Submodule.setLike.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6)))) (Submodule.map.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f p) (Submodule.map.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f p')) (LE.le.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Preorder.toLE.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (SetLike.partialOrder.{u3, u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) M (Submodule.setLike.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5)))) p (HasSup.sup.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (SemilatticeSup.toHasSup.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Lattice.toSemilatticeSup.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (ConditionallyCompleteLattice.toLattice.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Submodule.completeLattice.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5))))) p' (LinearMap.ker.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ F sc f)))
but is expected to have type
  forall {R : Type.{u5}} {R₂ : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u5} R] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : AddCommGroup.{u4} M] [_inst_4 : AddCommGroup.{u3} M₂] [_inst_5 : Module.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3)] [_inst_6 : Module.{u2, u3} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4)] {τ₁₂ : RingHom.{u5, u2} R R₂ (Semiring.toNonAssocSemiring.{u5} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u5, u2} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u1}} [sc : SemilinearMapClass.{u1, u5, u2, u4, u3} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4) _inst_5 _inst_6] (f : F) {p : Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5} {p' : Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5}, Iff (LE.le.{u3} (Submodule.{u2, u3} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4) _inst_6) (Preorder.toLE.{u3} (Submodule.{u2, u3} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4) _inst_6) (PartialOrder.toPreorder.{u3} (Submodule.{u2, u3} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4) _inst_6) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Submodule.{u2, u3} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4) _inst_6) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Submodule.{u2, u3} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4) _inst_6) (Submodule.completeLattice.{u2, u3} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4) _inst_6))))) (Submodule.map.{u5, u2, u4, u3, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f p) (Submodule.map.{u5, u2, u4, u3, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f p')) (LE.le.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5) (Preorder.toLE.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5) (PartialOrder.toPreorder.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5) (Submodule.completeLattice.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5))))) p (HasSup.sup.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5) (SemilatticeSup.toHasSup.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5) (Lattice.toSemilatticeSup.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5) (ConditionallyCompleteLattice.toLattice.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u4} (Submodule.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5) (Submodule.completeLattice.{u5, u4} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) _inst_5))))) p' (LinearMap.ker.{u5, u2, u4, u3, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M _inst_3) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ F sc f)))
Case conversion may be inaccurate. Consider using '#align linear_map.map_le_map_iff LinearMap.map_le_map_iffₓ'. -/
protected theorem map_le_map_iff (f : F) {p p'} : map f p ≤ map f p' ↔ p ≤ p' ⊔ ker f := by
  rw [map_le_iff_le_comap, Submodule.comap_map_eq]
#align linear_map.map_le_map_iff LinearMap.map_le_map_iff

/- warning: linear_map.map_le_map_iff' -> LinearMap.map_le_map_iff' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : AddCommGroup.{u3} M] [_inst_4 : AddCommGroup.{u4} M₂] [_inst_5 : Module.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4)] {τ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u5}} [sc : SemilinearMapClass.{u5, u1, u2, u3, u4} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6] {f : F}, (Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (LinearMap.ker.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ F sc f) (Bot.bot.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Submodule.hasBot.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5))) -> (forall {p : Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5} {p' : Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5}, Iff (LE.le.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (Preorder.toLE.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (PartialOrder.toPreorder.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (SetLike.partialOrder.{u4, u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) M₂ (Submodule.setLike.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6)))) (Submodule.map.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f p) (Submodule.map.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f p')) (LE.le.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Preorder.toLE.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (SetLike.partialOrder.{u3, u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) M (Submodule.setLike.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5)))) p p'))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u5}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} R₂] [_inst_3 : AddCommGroup.{u5} M] [_inst_4 : AddCommGroup.{u2} M₂] [_inst_5 : Module.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3)] [_inst_6 : Module.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4)] {τ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u4, u3} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u1}} [sc : SemilinearMapClass.{u1, u4, u3, u5, u2} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_5 _inst_6] {f : F}, (Eq.{succ u5} (Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5) (LinearMap.ker.{u4, u3, u5, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ F sc f) (Bot.bot.{u5} (Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5) (Submodule.instBotSubmodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5))) -> (forall {p : Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5} {p' : Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5}, Iff (LE.le.{u2} (Submodule.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_6) (Preorder.toLE.{u2} (Submodule.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_6) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_6) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_6) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_6) (Submodule.completeLattice.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_6))))) (Submodule.map.{u4, u3, u5, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f p) (Submodule.map.{u4, u3, u5, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f p')) (LE.le.{u5} (Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5) (Preorder.toLE.{u5} (Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5) (PartialOrder.toPreorder.{u5} (Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u5} (Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u5} (Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5) (Submodule.completeLattice.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5))))) p p'))
Case conversion may be inaccurate. Consider using '#align linear_map.map_le_map_iff' LinearMap.map_le_map_iff'ₓ'. -/
theorem map_le_map_iff' {f : F} (hf : ker f = ⊥) {p p'} : map f p ≤ map f p' ↔ p ≤ p' := by
  rw [LinearMap.map_le_map_iff, hf, sup_bot_eq]
#align linear_map.map_le_map_iff' LinearMap.map_le_map_iff'

/- warning: linear_map.map_injective -> LinearMap.map_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : AddCommGroup.{u3} M] [_inst_4 : AddCommGroup.{u4} M₂] [_inst_5 : Module.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4)] {τ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u5}} [sc : SemilinearMapClass.{u5, u1, u2, u3, u4} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6] {f : F}, (Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (LinearMap.ker.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ F sc f) (Bot.bot.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Submodule.hasBot.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5))) -> (Function.Injective.{succ u3, succ u4} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (Submodule.map.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f))
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u5}} {M₂ : Type.{u2}} [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u3} R₂] [_inst_3 : AddCommGroup.{u5} M] [_inst_4 : AddCommGroup.{u2} M₂] [_inst_5 : Module.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3)] [_inst_6 : Module.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4)] {τ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u4, u3} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u1}} [sc : SemilinearMapClass.{u1, u4, u3, u5, u2} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_5 _inst_6] {f : F}, (Eq.{succ u5} (Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5) (LinearMap.ker.{u4, u3, u5, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ F sc f) (Bot.bot.{u5} (Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5) (Submodule.instBotSubmodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5))) -> (Function.Injective.{succ u5, succ u2} (Submodule.{u4, u5} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) _inst_5) (Submodule.{u3, u2} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_6) (Submodule.map.{u4, u3, u5, u2, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M _inst_3) (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f))
Case conversion may be inaccurate. Consider using '#align linear_map.map_injective LinearMap.map_injectiveₓ'. -/
theorem map_injective {f : F} (hf : ker f = ⊥) : Injective (map f) := fun p p' h =>
  le_antisymm ((map_le_map_iff' hf).1 (le_of_eq h)) ((map_le_map_iff' hf).1 (ge_of_eq h))
#align linear_map.map_injective LinearMap.map_injective

/- warning: linear_map.map_eq_top_iff -> LinearMap.map_eq_top_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} R₂] [_inst_3 : AddCommGroup.{u3} M] [_inst_4 : AddCommGroup.{u4} M₂] [_inst_5 : Module.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4)] {τ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u1, u2} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u5}} [sc : SemilinearMapClass.{u5, u1, u2, u3, u4} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6] {f : F}, (Eq.{succ u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (LinearMap.range.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ F sc _inst_7 f) (Top.top.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (Submodule.hasTop.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6))) -> (forall {p : Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5}, Iff (Eq.{succ u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (Submodule.map.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f p) (Top.top.{u4} (Submodule.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6) (Submodule.hasTop.{u2, u4} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_6))) (Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (HasSup.sup.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (SemilatticeSup.toHasSup.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Lattice.toSemilatticeSup.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (ConditionallyCompleteLattice.toLattice.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Submodule.completeLattice.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5))))) p (LinearMap.ker.{u1, u2, u3, u4, u5} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) (AddCommGroup.toAddCommMonoid.{u4} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ F sc f)) (Top.top.{u3} (Submodule.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Submodule.hasTop.{u1, u3} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5))))
but is expected to have type
  forall {R : Type.{u3}} {R₂ : Type.{u4}} {M : Type.{u2}} {M₂ : Type.{u5}} [_inst_1 : Semiring.{u3} R] [_inst_2 : Semiring.{u4} R₂] [_inst_3 : AddCommGroup.{u2} M] [_inst_4 : AddCommGroup.{u5} M₂] [_inst_5 : Module.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] [_inst_6 : Module.{u4, u5} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4)] {τ₁₂ : RingHom.{u3, u4} R R₂ (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u4} R₂ _inst_2)} [_inst_7 : RingHomSurjective.{u3, u4} R R₂ _inst_1 _inst_2 τ₁₂] {F : Type.{u1}} [sc : SemilinearMapClass.{u1, u3, u4, u2, u5} F R R₂ _inst_1 _inst_2 τ₁₂ M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4) _inst_5 _inst_6] {f : F}, (Eq.{succ u5} (Submodule.{u4, u5} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4) _inst_6) (LinearMap.range.{u3, u4, u2, u5, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ F sc _inst_7 f) (Top.top.{u5} (Submodule.{u4, u5} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4) _inst_6) (Submodule.instTopSubmodule.{u4, u5} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4) _inst_6))) -> (forall {p : Submodule.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5}, Iff (Eq.{succ u5} (Submodule.{u4, u5} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4) _inst_6) (Submodule.map.{u3, u4, u2, u5, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ _inst_7 F sc f p) (Top.top.{u5} (Submodule.{u4, u5} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4) _inst_6) (Submodule.instTopSubmodule.{u4, u5} R₂ M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4) _inst_6))) (Eq.{succ u2} (Submodule.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5) (HasSup.sup.{u2} (Submodule.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5) (SemilatticeSup.toHasSup.{u2} (Submodule.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5) (Submodule.completeLattice.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5))))) p (LinearMap.ker.{u3, u4, u2, u5, u1} R R₂ M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) (AddCommGroup.toAddCommMonoid.{u5} M₂ _inst_4) _inst_5 _inst_6 τ₁₂ F sc f)) (Top.top.{u2} (Submodule.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5) (Submodule.instTopSubmodule.{u3, u2} R M _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5))))
Case conversion may be inaccurate. Consider using '#align linear_map.map_eq_top_iff LinearMap.map_eq_top_iffₓ'. -/
theorem map_eq_top_iff {f : F} (hf : range f = ⊤) {p : Submodule R M} :
    p.map f = ⊤ ↔ p ⊔ LinearMap.ker f = ⊤ := by
  simp_rw [← top_le_iff, ← hf, range_eq_map, LinearMap.map_le_map_iff]
#align linear_map.map_eq_top_iff LinearMap.map_eq_top_iff

end AddCommGroup

section

variable (R) (M) [Semiring R] [AddCommMonoid M] [Module R M]

#print LinearMap.toSpanSingleton /-
/-- Given an element `x` of a module `M` over `R`, the natural map from
    `R` to scalar multiples of `x`.-/
@[simps]
def toSpanSingleton (x : M) : R →ₗ[R] M :=
  LinearMap.id.smul_right x
#align linear_map.to_span_singleton LinearMap.toSpanSingleton
-/

/- warning: linear_map.span_singleton_eq_range -> LinearMap.span_singleton_eq_range is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)) (LinearMap.range.{u1, u1, u1, u2, max u1 u2} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u1, u2} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.toSpanSingleton.{u1, u2} R M _inst_1 _inst_2 _inst_3 x))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) x)) (LinearMap.range.{u1, u1, u1, u2, max u1 u2} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u1, u2} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.toSpanSingleton.{u1, u2} R M _inst_1 _inst_2 _inst_3 x))
Case conversion may be inaccurate. Consider using '#align linear_map.span_singleton_eq_range LinearMap.span_singleton_eq_rangeₓ'. -/
/-- The range of `to_span_singleton x` is the span of `x`.-/
theorem span_singleton_eq_range (x : M) : (R ∙ x) = (toSpanSingleton R M x).range :=
  Submodule.ext fun y => by
    refine' Iff.trans _ linear_map.mem_range.symm
    exact mem_span_singleton
#align linear_map.span_singleton_eq_range LinearMap.span_singleton_eq_range

/- warning: linear_map.to_span_singleton_one -> LinearMap.toSpanSingleton_one is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3) (fun (_x : LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3) => R -> M) (LinearMap.hasCoeToFun.{u1, u1, u1, u2} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.toSpanSingleton.{u1, u2} R M _inst_1 _inst_2 _inst_3 x) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) x
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (x : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : R) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u2} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.toSpanSingleton.{u1, u2} R M _inst_1 _inst_2 _inst_3 x) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) x
Case conversion may be inaccurate. Consider using '#align linear_map.to_span_singleton_one LinearMap.toSpanSingleton_oneₓ'. -/
@[simp]
theorem toSpanSingleton_one (x : M) : toSpanSingleton R M x 1 = x :=
  one_smul _ _
#align linear_map.to_span_singleton_one LinearMap.toSpanSingleton_one

/- warning: linear_map.to_span_singleton_zero -> LinearMap.toSpanSingleton_zero is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2], Eq.{max (succ u1) (succ u2)} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3) (LinearMap.toSpanSingleton.{u1, u2} R M _inst_1 _inst_2 _inst_3 (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (OfNat.ofNat.{max u1 u2} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3) 0 (OfNat.mk.{max u1 u2} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3) 0 (Zero.zero.{max u1 u2} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3) (LinearMap.hasZero.{u1, u1, u1, u2} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) _inst_2 (Semiring.toModule.{u1} R _inst_1) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))
but is expected to have type
  forall (R : Type.{u2}) (M : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2], Eq.{max (succ u2) (succ u1)} (LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_3) (LinearMap.toSpanSingleton.{u2, u1} R M _inst_1 _inst_2 _inst_3 (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (OfNat.ofNat.{max u2 u1} (LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_3) 0 (Zero.toOfNat0.{max u2 u1} (LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_3) (LinearMap.instZeroLinearMap.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align linear_map.to_span_singleton_zero LinearMap.toSpanSingleton_zeroₓ'. -/
@[simp]
theorem toSpanSingleton_zero : toSpanSingleton R M 0 = 0 :=
  by
  ext
  simp
#align linear_map.to_span_singleton_zero LinearMap.toSpanSingleton_zero

end

section AddCommMonoid

variable [Semiring R] [AddCommMonoid M] [Module R M]

variable [Semiring R₂] [AddCommMonoid M₂] [Module R₂ M₂]

variable {σ₁₂ : R →+* R₂}

/- warning: linear_map.eq_on_span -> LinearMap.eqOn_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {s : Set.{u3} M} {f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6} {g : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6}, (Set.EqOn.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g) s) -> (forall {{x : M}}, (Membership.Mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s)) -> (Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g x)))
but is expected to have type
  forall {R : Type.{u3}} {R₂ : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u4} M] [_inst_3 : Module.{u3, u4} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u2, u1} R₂ M₂ _inst_4 _inst_5] {σ₁₂ : RingHom.{u3, u2} R R₂ (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {s : Set.{u4} M} {f : LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6} {g : LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6}, (Set.EqOn.{u4, u1} M M₂ (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u4, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u4, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g) s) -> (forall {{x : M}}, (Membership.mem.{u4, u4} M (Submodule.{u3, u4} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u4, u4} (Submodule.{u3, u4} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u3, u4} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u3, u4} R M _inst_1 _inst_2 _inst_3 s)) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) x) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u4, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f x) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u4, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g x)))
Case conversion may be inaccurate. Consider using '#align linear_map.eq_on_span LinearMap.eqOn_spanₓ'. -/
/-- If two linear maps are equal on a set `s`, then they are equal on `submodule.span s`.

See also `linear_map.eq_on_span'` for a version using `set.eq_on`. -/
theorem eqOn_span {s : Set M} {f g : M →ₛₗ[σ₁₂] M₂} (H : Set.EqOn f g s) ⦃x⦄ (h : x ∈ span R s) :
    f x = g x := by apply span_induction h H <;> simp (config := { contextual := true })
#align linear_map.eq_on_span LinearMap.eqOn_span

/- warning: linear_map.eq_on_span' -> LinearMap.eqOn_span' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {s : Set.{u3} M} {f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6} {g : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6}, (Set.EqOn.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g) s) -> (Set.EqOn.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Set.{u3} M) (HasLiftT.mk.{succ u3, succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Set.{u3} M) (CoeTCₓ.coe.{succ u3, succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Set.{u3} M) (SetLike.Set.hasCoeT.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)))) (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s)))
but is expected to have type
  forall {R : Type.{u3}} {R₂ : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u4} M] [_inst_3 : Module.{u3, u4} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u2, u1} R₂ M₂ _inst_4 _inst_5] {σ₁₂ : RingHom.{u3, u2} R R₂ (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {s : Set.{u4} M} {f : LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6} {g : LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6}, (Set.EqOn.{u4, u1} M M₂ (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u4, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u4, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g) s) -> (Set.EqOn.{u4, u1} M M₂ (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u4, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u4, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g) (SetLike.coe.{u4, u4} (Submodule.{u3, u4} R M _inst_1 _inst_2 _inst_3) M (Submodule.instSetLikeSubmodule.{u3, u4} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u3, u4} R M _inst_1 _inst_2 _inst_3 s)))
Case conversion may be inaccurate. Consider using '#align linear_map.eq_on_span' LinearMap.eqOn_span'ₓ'. -/
/-- If two linear maps are equal on a set `s`, then they are equal on `submodule.span s`.

This version uses `set.eq_on`, and the hidden argument will expand to `h : x ∈ (span R s : set M)`.
See `linear_map.eq_on_span` for a version that takes `h : x ∈ span R s` as an argument. -/
theorem eqOn_span' {s : Set M} {f g : M →ₛₗ[σ₁₂] M₂} (H : Set.EqOn f g s) :
    Set.EqOn f g (span R s : Set M) :=
  eqOn_span H
#align linear_map.eq_on_span' LinearMap.eqOn_span'

/- warning: linear_map.ext_on -> LinearMap.ext_on is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {s : Set.{u3} M} {f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6} {g : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6}, (Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 s) (Top.top.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.hasTop.{u1, u3} R M _inst_1 _inst_2 _inst_3))) -> (Set.EqOn.{u3, u4} M M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g) s) -> (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) f g)
but is expected to have type
  forall {R : Type.{u3}} {R₂ : Type.{u2}} {M : Type.{u4}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u4} M] [_inst_3 : Module.{u3, u4} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u2, u1} R₂ M₂ _inst_4 _inst_5] {σ₁₂ : RingHom.{u3, u2} R R₂ (Semiring.toNonAssocSemiring.{u3} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {s : Set.{u4} M} {f : LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6} {g : LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6}, (Eq.{succ u4} (Submodule.{u3, u4} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u3, u4} R M _inst_1 _inst_2 _inst_3 s) (Top.top.{u4} (Submodule.{u3, u4} R M _inst_1 _inst_2 _inst_3) (Submodule.instTopSubmodule.{u3, u4} R M _inst_1 _inst_2 _inst_3))) -> (Set.EqOn.{u4, u1} M M₂ (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u4, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u3, u2, u4, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g) s) -> (Eq.{max (succ u4) (succ u1)} (LinearMap.{u3, u2, u4, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) f g)
Case conversion may be inaccurate. Consider using '#align linear_map.ext_on LinearMap.ext_onₓ'. -/
/-- If `s` generates the whole module and linear maps `f`, `g` are equal on `s`, then they are
equal. -/
theorem ext_on {s : Set M} {f g : M →ₛₗ[σ₁₂] M₂} (hv : span R s = ⊤) (h : Set.EqOn f g s) : f = g :=
  LinearMap.ext fun x => eqOn_span h (eq_top_iff'.1 hv _)
#align linear_map.ext_on LinearMap.ext_on

/- warning: linear_map.ext_on_range -> LinearMap.ext_on_range is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {R₂ : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u2} R₂] [_inst_5 : AddCommMonoid.{u4} M₂] [_inst_6 : Module.{u2, u4} R₂ M₂ _inst_4 _inst_5] {σ₁₂ : RingHom.{u1, u2} R R₂ (Semiring.toNonAssocSemiring.{u1} R _inst_1) (Semiring.toNonAssocSemiring.{u2} R₂ _inst_4)} {ι : Type.{u5}} {v : ι -> M} {f : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6} {g : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6}, (Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u3} R M _inst_1 _inst_2 _inst_3 (Set.range.{u3, succ u5} M ι v)) (Top.top.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.hasTop.{u1, u3} R M _inst_1 _inst_2 _inst_3))) -> (forall (i : ι), Eq.{succ u4} M₂ (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (v i)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u2, u3, u4} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g (v i))) -> (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u2, u3, u4} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) f g)
but is expected to have type
  forall {R : Type.{u4}} {R₂ : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u4, u2} R M _inst_1 _inst_2] [_inst_4 : Semiring.{u3} R₂] [_inst_5 : AddCommMonoid.{u1} M₂] [_inst_6 : Module.{u3, u1} R₂ M₂ _inst_4 _inst_5] {σ₁₂ : RingHom.{u4, u3} R R₂ (Semiring.toNonAssocSemiring.{u4} R _inst_1) (Semiring.toNonAssocSemiring.{u3} R₂ _inst_4)} {ι : Type.{u5}} {v : ι -> M} {f : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6} {g : LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6}, (Eq.{succ u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u4, u2} R M _inst_1 _inst_2 _inst_3 (Set.range.{u2, succ u5} M ι v)) (Top.top.{u2} (Submodule.{u4, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.instTopSubmodule.{u4, u2} R M _inst_1 _inst_2 _inst_3))) -> (forall (i : ι), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) (v i)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) f (v i)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u4, u3, u2, u1} R R₂ M M₂ _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 σ₁₂) g (v i))) -> (Eq.{max (succ u2) (succ u1)} (LinearMap.{u4, u3, u2, u1} R R₂ _inst_1 _inst_4 σ₁₂ M M₂ _inst_2 _inst_5 _inst_3 _inst_6) f g)
Case conversion may be inaccurate. Consider using '#align linear_map.ext_on_range LinearMap.ext_on_rangeₓ'. -/
/-- If the range of `v : ι → M` generates the whole module and linear maps `f`, `g` are equal at
each `v i`, then they are equal. -/
theorem ext_on_range {ι : Type _} {v : ι → M} {f g : M →ₛₗ[σ₁₂] M₂} (hv : span R (Set.range v) = ⊤)
    (h : ∀ i, f (v i) = g (v i)) : f = g :=
  ext_on hv (Set.forall_range_iff.2 h)
#align linear_map.ext_on_range LinearMap.ext_on_range

end AddCommMonoid

section Field

variable {K V} [Field K] [AddCommGroup V] [Module K V]

noncomputable section

open Classical

/- warning: linear_map.span_singleton_sup_ker_eq_top -> LinearMap.span_singleton_sup_ker_eq_top is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (f : LinearMap.{u1, u1, u2, u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) V K (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) _inst_3 (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) {x : V}, (Ne.{succ u1} K (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LinearMap.{u1, u1, u2, u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) V K (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) _inst_3 (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (fun (_x : LinearMap.{u1, u1, u2, u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) V K (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) _inst_3 (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) => V -> K) (LinearMap.hasCoeToFun.{u1, u1, u2, u1} K K V K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) _inst_3 (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) f x) (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))))))) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (HasSup.sup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x)) (LinearMap.ker.{u1, u1, u2, u1, max u2 u1} K K V K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) _inst_3 (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearMap.{u1, u1, u2, u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) V K (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) _inst_3 (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearMap.semilinearMapClass.{u1, u1, u2, u1} K K V K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) _inst_3 (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) f)) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : Field.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] (f : LinearMap.{u2, u2, u1, u2} K K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))))) V K (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} K (NonUnitalRing.toNonUnitalNonAssocRing.{u2} K (NonUnitalCommRing.toNonUnitalRing.{u2} K (CommRing.toNonUnitalCommRing.{u2} K (Field.toCommRing.{u2} K _inst_1)))))) _inst_3 (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u2} K _inst_1)) {x : V}, (Ne.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : V) => K) x) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (LinearMap.{u2, u2, u1, u2} K K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))))) V K (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} K (NonUnitalRing.toNonUnitalNonAssocRing.{u2} K (NonUnitalCommRing.toNonUnitalRing.{u2} K (CommRing.toNonUnitalCommRing.{u2} K (Field.toCommRing.{u2} K _inst_1)))))) _inst_3 (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u2} K _inst_1)) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : V) => K) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u2} K K V K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} K (NonUnitalRing.toNonUnitalNonAssocRing.{u2} K (NonUnitalCommRing.toNonUnitalRing.{u2} K (CommRing.toNonUnitalCommRing.{u2} K (Field.toCommRing.{u2} K _inst_1)))))) _inst_3 (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u2} K _inst_1) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))))) f x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : V) => K) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : V) => K) x) (CommMonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : V) => K) x) (CommGroupWithZero.toCommMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : V) => K) x) (Semifield.toCommGroupWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : V) => K) x) (Field.toSemifield.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : V) => K) x) _inst_1))))))) -> (Eq.{succ u1} (Submodule.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (HasSup.sup.{u1} (Submodule.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u1} (Submodule.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u1} (Submodule.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u1} (Submodule.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) (Submodule.span.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (Singleton.singleton.{u1, u1} V (Set.{u1} V) (Set.instSingletonSet.{u1} V) x)) (LinearMap.ker.{u2, u2, u1, u2, max u2 u1} K K V K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} K (NonUnitalRing.toNonUnitalNonAssocRing.{u2} K (NonUnitalCommRing.toNonUnitalRing.{u2} K (CommRing.toNonUnitalCommRing.{u2} K (Field.toCommRing.{u2} K _inst_1)))))) _inst_3 (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u2} K _inst_1) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))))) (LinearMap.{u2, u2, u1, u2} K K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))))) V K (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} K (NonUnitalRing.toNonUnitalNonAssocRing.{u2} K (NonUnitalCommRing.toNonUnitalRing.{u2} K (CommRing.toNonUnitalCommRing.{u2} K (Field.toCommRing.{u2} K _inst_1)))))) _inst_3 (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u2} K _inst_1)) (LinearMap.instSemilinearMapClassLinearMap.{u2, u2, u1, u2} K K V K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} K (NonUnitalRing.toNonUnitalNonAssocRing.{u2} K (NonUnitalCommRing.toNonUnitalRing.{u2} K (CommRing.toNonUnitalCommRing.{u2} K (Field.toCommRing.{u2} K _inst_1)))))) _inst_3 (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u2} K _inst_1) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1)))))) f)) (Top.top.{u1} (Submodule.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u1} K V (DivisionSemiring.toSemiring.{u2} K (Semifield.toDivisionSemiring.{u2} K (Field.toSemifield.{u2} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align linear_map.span_singleton_sup_ker_eq_top LinearMap.span_singleton_sup_ker_eq_topₓ'. -/
theorem span_singleton_sup_ker_eq_top (f : V →ₗ[K] K) {x : V} (hx : f x ≠ 0) :
    (K ∙ x) ⊔ f.ker = ⊤ :=
  eq_top_iff.2 fun y hy =>
    Submodule.mem_sup.2
      ⟨(f y * (f x)⁻¹) • x, Submodule.mem_span_singleton.2 ⟨f y * (f x)⁻¹, rfl⟩,
        ⟨y - (f y * (f x)⁻¹) • x, by
          rw [LinearMap.mem_ker, f.map_sub, f.map_smul, smul_eq_mul, mul_assoc, inv_mul_cancel hx,
            mul_one, sub_self],
          by simp only [add_sub_cancel'_right]⟩⟩
#align linear_map.span_singleton_sup_ker_eq_top LinearMap.span_singleton_sup_ker_eq_top

variable (K V)

/- warning: linear_map.ker_to_span_singleton -> LinearMap.ker_toSpanSingleton is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {x : V}, (Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (Eq.{succ u1} (Submodule.{u1, u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearMap.ker.{u1, u1, u1, u2, max u1 u2} K K K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearMap.{u1, u1, u1, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) K V (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u1, u2} K K K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (LinearMap.toSpanSingleton.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x)) (Bot.bot.{u1} (Submodule.{u1, u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (Submodule.hasBot.{u1, u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {x : V}, (Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) -> (Eq.{succ u1} (Submodule.{u1, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (Semiring.toModule.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (LinearMap.ker.{u1, u1, u1, u2, max u1 u2} K K K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Semiring.toModule.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (LinearMap.{u1, u1, u1, u2} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) K V (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Semiring.toModule.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u1, u2} K K K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Semiring.toModule.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (LinearMap.toSpanSingleton.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x)) (Bot.bot.{u1} (Submodule.{u1, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (Semiring.toModule.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (Submodule.instBotSubmodule.{u1, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))) (Semiring.toModule.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_to_span_singleton LinearMap.ker_toSpanSingletonₓ'. -/
theorem ker_toSpanSingleton {x : V} (h : x ≠ 0) : (toSpanSingleton K V x).ker = ⊥ :=
  by
  ext c; constructor
  · intro hc
    rw [Submodule.mem_bot]
    rw [mem_ker] at hc
    by_contra hc'
    have : x = 0
    calc
      x = c⁻¹ • c • x := by rw [← mul_smul, inv_mul_cancel hc', one_smul]
      _ = c⁻¹ • (to_span_singleton K V x) c := rfl
      _ = 0 := by rw [hc, smul_zero]
      
    tauto
  · rw [mem_ker, Submodule.mem_bot]
    intro h
    rw [h]
    simp
#align linear_map.ker_to_span_singleton LinearMap.ker_toSpanSingleton

end Field

end LinearMap

open LinearMap

namespace LinearEquiv

section Field

variable (K V) [Field K] [AddCommGroup V] [Module K V]

/- warning: linear_equiv.to_span_nonzero_singleton -> LinearEquiv.toSpanNonzeroSingleton is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (x : V), (Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (LinearEquiv.{u1, u1, u1, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearEquiv.toSpanNonzeroSingleton._proof_1.{u1} K _inst_1) (LinearEquiv.toSpanNonzeroSingleton._proof_2.{u1} K _inst_1) K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Submodule.addCommMonoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))))
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (x : V), (Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) -> (LinearEquiv.{u1, u1, u1, u2} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_span_nonzero_singleton LinearEquiv.toSpanNonzeroSingletonₓ'. -/
/-- Given a nonzero element `x` of a vector space `V` over a field `K`, the natural
    map from `K` to the span of `x`, with invertibility check to consider it as an
    isomorphism.-/
def toSpanNonzeroSingleton (x : V) (h : x ≠ 0) : K ≃ₗ[K] K ∙ x :=
  LinearEquiv.trans
    (LinearEquiv.ofInjective (LinearMap.toSpanSingleton K V x)
      (ker_eq_bot.1 <| LinearMap.ker_toSpanSingleton K V h))
    (LinearEquiv.ofEq (toSpanSingleton K V x).range (K ∙ x) (span_singleton_eq_range K V x).symm)
#align linear_equiv.to_span_nonzero_singleton LinearEquiv.toSpanNonzeroSingleton

/- warning: linear_equiv.to_span_nonzero_singleton_one -> LinearEquiv.toSpanNonzeroSingleton_one is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (x : V) (h : Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))), Eq.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearEquiv.{u1, u1, u1, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearEquiv.toSpanNonzeroSingleton._proof_1.{u1} K _inst_1) (LinearEquiv.toSpanNonzeroSingleton._proof_2.{u1} K _inst_1) K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Submodule.addCommMonoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x)))) (fun (_x : LinearEquiv.{u1, u1, u1, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearEquiv.toSpanNonzeroSingleton._proof_1.{u1} K _inst_1) (LinearEquiv.toSpanNonzeroSingleton._proof_2.{u1} K _inst_1) K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Submodule.addCommMonoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x)))) => K -> (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x)))) (LinearEquiv.hasCoeToFun.{u1, u1, u1, u2} K K K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Submodule.addCommMonoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearEquiv.toSpanNonzeroSingleton._proof_1.{u1} K _inst_1) (LinearEquiv.toSpanNonzeroSingleton._proof_2.{u1} K _inst_1)) (LinearEquiv.toSpanNonzeroSingleton.{u1, u2} K V _inst_1 _inst_2 _inst_3 x h) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))))) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.Mem.{u2, u2} V (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (x : V) (h : Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : K) => Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (Semiring.toOne.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (LinearEquiv.{u1, u1, u1, u2} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : K) => Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) _x) (SMulHomClass.toFunLike.{max u1 u2, u1, u1, u2} (LinearEquiv.{u1, u1, u1, u2} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (SMulZeroClass.toSMul.{u1, u1} K K (AddMonoid.toZero.{u1} K (AddCommMonoid.toAddMonoid.{u1} K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))))) (DistribSMul.toSMulZeroClass.{u1, u1} K K (AddMonoid.toAddZeroClass.{u1} K (AddCommMonoid.toAddMonoid.{u1} K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))))) (DistribMulAction.toDistribSMul.{u1, u1} K K (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (AddCommMonoid.toAddMonoid.{u1} K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1))))))) (Module.toDistribMulAction.{u1, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1))))) (SMulZeroClass.toSMul.{u1, u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (AddMonoid.toZero.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (AddCommMonoid.toAddMonoid.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))))) (DistribSMul.toSMulZeroClass.{u1, u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (AddMonoid.toAddZeroClass.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (AddCommMonoid.toAddMonoid.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))))) (DistribMulAction.toDistribSMul.{u1, u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (AddCommMonoid.toAddMonoid.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Module.toDistribMulAction.{u1, u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))))))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u2, u1, u1, u2} (LinearEquiv.{u1, u1, u1, u2} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (AddCommMonoid.toAddMonoid.{u1} K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1))))))) (AddCommMonoid.toAddMonoid.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Module.toDistribMulAction.{u1, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1)) (Module.toDistribMulAction.{u1, u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (SemilinearMapClass.distribMulActionHomClass.{u1, u1, u2, max u1 u2} K K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (LinearEquiv.{u1, u1, u1, u2} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u1, u2, max u1 u2} K K K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (LinearEquiv.{u1, u1, u1, u2} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u1, u2} K K K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))))) (LinearEquiv.toSpanNonzeroSingleton.{u1, u2} K V _inst_1 _inst_2 _inst_3 x h) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (Semiring.toOne.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))
Case conversion may be inaccurate. Consider using '#align linear_equiv.to_span_nonzero_singleton_one LinearEquiv.toSpanNonzeroSingleton_oneₓ'. -/
theorem toSpanNonzeroSingleton_one (x : V) (h : x ≠ 0) :
    LinearEquiv.toSpanNonzeroSingleton K V x h 1 =
      (⟨x, Submodule.mem_span_singleton_self x⟩ : K ∙ x) :=
  by
  apply set_like.coe_eq_coe.mp
  have : ↑(to_span_nonzero_singleton K V x h 1) = to_span_singleton K V x 1 := rfl
  rw [this, to_span_singleton_one, Submodule.coe_mk]
#align linear_equiv.to_span_nonzero_singleton_one LinearEquiv.toSpanNonzeroSingleton_one

/- warning: linear_equiv.coord -> LinearEquiv.coord is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (x : V), (Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (LinearEquiv.{u1, u1, u2, u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearEquiv.coord._proof_1.{u1} K _inst_1) (LinearEquiv.coord._proof_2.{u1} K _inst_1) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) K (Submodule.addCommMonoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (x : V), (Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) -> (LinearEquiv.{u1, u1, u2, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1))
Case conversion may be inaccurate. Consider using '#align linear_equiv.coord LinearEquiv.coordₓ'. -/
/-- Given a nonzero element `x` of a vector space `V` over a field `K`, the natural map
    from the span of `x` to `K`.-/
abbrev coord (x : V) (h : x ≠ 0) : (K ∙ x) ≃ₗ[K] K :=
  (toSpanNonzeroSingleton K V x h).symm
#align linear_equiv.coord LinearEquiv.coord

/- warning: linear_equiv.coord_self -> LinearEquiv.coord_self is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (x : V) (h : Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))), Eq.{succ u1} K (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LinearEquiv.{u1, u1, u2, u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearEquiv.coord._proof_1.{u1} K _inst_1) (LinearEquiv.coord._proof_2.{u1} K _inst_1) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) K (Submodule.addCommMonoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (fun (_x : LinearEquiv.{u1, u1, u2, u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearEquiv.coord._proof_1.{u1} K _inst_1) (LinearEquiv.coord._proof_2.{u1} K _inst_1) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) K (Submodule.addCommMonoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) -> K) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u1} K K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (Submodule.addCommMonoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (LinearEquiv.coord._proof_1.{u1} K _inst_1) (LinearEquiv.coord._proof_2.{u1} K _inst_1)) (LinearEquiv.coord.{u1, u2} K V _inst_1 _inst_2 _inst_3 x h) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.Mem.{u2, u2} V (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))))
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Field.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (x : V) (h : Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) => K) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (LinearEquiv.{u1, u1, u2, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1)) (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (fun (_x : Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) => K) _x) (SMulHomClass.toFunLike.{max u1 u2, u1, u2, u1} (LinearEquiv.{u1, u1, u2, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1)) K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (SMulZeroClass.toSMul.{u1, u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (AddMonoid.toZero.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (AddCommMonoid.toAddMonoid.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))))) (DistribSMul.toSMulZeroClass.{u1, u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (AddMonoid.toAddZeroClass.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (AddCommMonoid.toAddMonoid.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))))) (DistribMulAction.toDistribSMul.{u1, u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (AddCommMonoid.toAddMonoid.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Module.toDistribMulAction.{u1, u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))))))) (SMulZeroClass.toSMul.{u1, u1} K K (AddMonoid.toZero.{u1} K (AddCommMonoid.toAddMonoid.{u1} K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))))) (DistribSMul.toSMulZeroClass.{u1, u1} K K (AddMonoid.toAddZeroClass.{u1} K (AddCommMonoid.toAddMonoid.{u1} K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))))) (DistribMulAction.toDistribSMul.{u1, u1} K K (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (AddCommMonoid.toAddMonoid.{u1} K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1))))))) (Module.toDistribMulAction.{u1, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1))))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u2, u1, u2, u1} (LinearEquiv.{u1, u1, u2, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1)) K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (AddCommMonoid.toAddMonoid.{u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (AddCommMonoid.toAddMonoid.{u1} K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1))))))) (Module.toDistribMulAction.{u1, u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) (Module.toDistribMulAction.{u1, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1)) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u1, max u1 u2} K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (LinearEquiv.{u1, u1, u2, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u2, u1, max u1 u2} K K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (LinearEquiv.{u1, u1, u2, u1} K K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u2, u1} K K (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonUnitalRing.toNonUnitalNonAssocRing.{u1} K (NonUnitalCommRing.toNonUnitalRing.{u1} K (CommRing.toNonUnitalCommRing.{u1} K (Field.toCommRing.{u1} K _inst_1)))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) (LinearMap.instModuleToSemiringToDivisionSemiringToSemifieldToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRingToNonUnitalCommRingToCommRing.{u1} K _inst_1) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))))) (LinearEquiv.coord.{u1, u2} K V _inst_1 _inst_2 _inst_3 x h) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) => K) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) => K) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))) (Semiring.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) => K) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))) (DivisionSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) => K) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))) (Semifield.toDivisionSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) => K) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))) (Field.toSemifield.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x)))) => K) (Subtype.mk.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x_1 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) x))) x (Submodule.mem_span_singleton_self.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 x))) _inst_1))))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.coord_self LinearEquiv.coord_selfₓ'. -/
theorem coord_self (x : V) (h : x ≠ 0) :
    (coord K V x h) (⟨x, Submodule.mem_span_singleton_self x⟩ : K ∙ x) = 1 := by
  rw [← to_span_nonzero_singleton_one K V x h, LinearEquiv.symm_apply_apply]
#align linear_equiv.coord_self LinearEquiv.coord_self

end Field

end LinearEquiv

