/-
Copyright (c) 2020 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Mario Carneiro, Alexander Bentkamp, Anne Baanen

! This file was ported from Lean 3 source module linear_algebra.linear_independent
! leanprover-community/mathlib commit ef7acf407d265ad4081c8998687e994fa80ba70c
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.BigOperators.Fin
import Mathbin.LinearAlgebra.Finsupp
import Mathbin.LinearAlgebra.Prod
import Mathbin.SetTheory.Cardinal.Basic

/-!

# Linear independence

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines linear independence in a module or vector space.

It is inspired by Isabelle/HOL's linear algebra, and hence indirectly by HOL Light.

We define `linear_independent R v` as `ker (finsupp.total ι M R v) = ⊥`. Here `finsupp.total` is the
linear map sending a function `f : ι →₀ R` with finite support to the linear combination of vectors
from `v` with these coefficients. Then we prove that several other statements are equivalent to this
one, including injectivity of `finsupp.total ι M R v` and some versions with explicitly written
linear combinations.

## Main definitions
All definitions are given for families of vectors, i.e. `v : ι → M` where `M` is the module or
vector space and `ι : Type*` is an arbitrary indexing type.

* `linear_independent R v` states that the elements of the family `v` are linearly independent.

* `linear_independent.repr hv x` returns the linear combination representing `x : span R (range v)`
on the linearly independent vectors `v`, given `hv : linear_independent R v`
(using classical choice). `linear_independent.repr hv` is provided as a linear map.

## Main statements

We prove several specialized tests for linear independence of families of vectors and of sets of
vectors.

* `fintype.linear_independent_iff`: if `ι` is a finite type, then any function `f : ι → R` has
  finite support, so we can reformulate the statement using `∑ i : ι, f i • v i` instead of a sum
  over an auxiliary `s : finset ι`;
* `linear_independent_empty_type`: a family indexed by an empty type is linearly independent;
* `linear_independent_unique_iff`: if `ι` is a singleton, then `linear_independent K v` is
  equivalent to `v default ≠ 0`;
* linear_independent_option`, `linear_independent_sum`, `linear_independent_fin_cons`,
  `linear_independent_fin_succ`: type-specific tests for linear independence of families of vector
  fields;
* `linear_independent_insert`, `linear_independent_union`, `linear_independent_pair`,
  `linear_independent_singleton`: linear independence tests for set operations.

In many cases we additionally provide dot-style operations (e.g., `linear_independent.union`) to
make the linear independence tests usable as `hv.insert ha` etc.

We also prove that, when working over a division ring,
any family of vectors includes a linear independent subfamily spanning the same subspace.

## Implementation notes

We use families instead of sets because it allows us to say that two identical vectors are linearly
dependent.

If you want to use sets, use the family `(λ x, x : s → M)` given a set `s : set M`. The lemmas
`linear_independent.to_subtype_range` and `linear_independent.of_subtype_range` connect those two
worlds.

## Tags

linearly dependent, linear dependence, linearly independent, linear independence

-/


noncomputable section

open Function Set Submodule

open Classical BigOperators Cardinal

universe u

variable {ι : Type _} {ι' : Type _} {R : Type _} {K : Type _}

variable {M : Type _} {M' M'' : Type _} {V : Type u} {V' : Type _}

section Module

variable {v : ι → M}

variable [Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M'']

variable [Module R M] [Module R M'] [Module R M'']

variable {a b : R} {x y : M}

variable (R) (v)

#print LinearIndependent /-
/-- `linear_independent R v` states the family of vectors `v` is linearly independent over `R`. -/
def LinearIndependent : Prop :=
  (Finsupp.total ι M R v).ker = ⊥
#align linear_independent LinearIndependent
-/

variable {R} {v}

/- warning: linear_independent_iff -> linearIndependent_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2], Iff (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5) (forall (l : Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))), (Eq.{succ u3} M (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) (fun (_x : LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) => (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u1, u3, u2} ι M R _inst_1 _inst_2 _inst_5 v) l) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))))) -> (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) l (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.zero.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2], Iff (LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5) (forall (l : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))), (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} ι M R _inst_1 _inst_2 _inst_5 v) l) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) _inst_2))))) -> (Eq.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) l (OfNat.ofNat.{max u3 u2} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) 0 (Zero.toOfNat0.{max u3 u2} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.zero.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_iff linearIndependent_iffₓ'. -/
theorem linearIndependent_iff : LinearIndependent R v ↔ ∀ l, Finsupp.total ι M R v l = 0 → l = 0 :=
  by simp [LinearIndependent, LinearMap.ker_eq_bot']
#align linear_independent_iff linearIndependent_iff

/- warning: linear_independent_iff' -> linearIndependent_iff' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2], Iff (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5) (forall (s : Finset.{u1} ι) (g : ι -> R), (Eq.{succ u3} M (Finset.sum.{u3, u1} M ι _inst_2 s (fun (i : ι) => SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (g i) (v i))) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))))) -> (forall (i : ι), (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i s) -> (Eq.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2], Iff (LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5) (forall (s : Finset.{u3} ι) (g : ι -> R), (Eq.{succ u1} M (Finset.sum.{u1, u3} M ι _inst_2 s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) (g i) (v i))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) -> (forall (i : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (Eq.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_iff' linearIndependent_iff'ₓ'. -/
theorem linearIndependent_iff' :
    LinearIndependent R v ↔
      ∀ s : Finset ι, ∀ g : ι → R, (∑ i in s, g i • v i) = 0 → ∀ i ∈ s, g i = 0 :=
  linearIndependent_iff.trans
    ⟨fun hf s g hg i his =>
      have h :=
        hf (∑ i in s, Finsupp.single i (g i)) <| by
          simpa only [LinearMap.map_sum, Finsupp.total_single] using hg
      calc
        g i = (Finsupp.lapply i : (ι →₀ R) →ₗ[R] R) (Finsupp.single i (g i)) := by
          rw [Finsupp.lapply_apply, Finsupp.single_eq_same]
        _ = ∑ j in s, (Finsupp.lapply i : (ι →₀ R) →ₗ[R] R) (Finsupp.single j (g j)) :=
          (Eq.symm <|
            Finset.sum_eq_single i
              (fun j hjs hji => by rw [Finsupp.lapply_apply, Finsupp.single_eq_of_ne hji])
              fun hnis => hnis.elim his)
        _ = (∑ j in s, Finsupp.single j (g j)) i :=
          (Finsupp.lapply i : (ι →₀ R) →ₗ[R] R).map_sum.symm
        _ = 0 := Finsupp.ext_iff.1 h i
        ,
      fun hf l hl =>
      Finsupp.ext fun i =>
        by_contradiction fun hni => hni <| hf _ _ hl _ <| Finsupp.mem_support_iff.2 hni⟩
#align linear_independent_iff' linearIndependent_iff'

/- warning: linear_independent_iff'' -> linearIndependent_iff'' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2], Iff (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5) (forall (s : Finset.{u1} ι) (g : ι -> R), (forall (i : ι), (Not (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i s)) -> (Eq.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))))) -> (Eq.{succ u3} M (Finset.sum.{u3, u1} M ι _inst_2 s (fun (i : ι) => SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (g i) (v i))) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))))) -> (forall (i : ι), Eq.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2], Iff (LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5) (forall (s : Finset.{u3} ι) (g : ι -> R), (forall (i : ι), (Not (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s)) -> (Eq.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))))) -> (Eq.{succ u1} M (Finset.sum.{u1, u3} M ι _inst_2 s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) (g i) (v i))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) -> (forall (i : ι), Eq.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_iff'' linearIndependent_iff''ₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i «expr ∉ » s) -/
theorem linearIndependent_iff'' :
    LinearIndependent R v ↔
      ∀ (s : Finset ι) (g : ι → R) (hg : ∀ (i) (_ : i ∉ s), g i = 0),
        (∑ i in s, g i • v i) = 0 → ∀ i, g i = 0 :=
  linearIndependent_iff'.trans
    ⟨fun H s g hg hv i => if his : i ∈ s then H s g hv i his else hg i his, fun H s g hg i hi =>
      by
      convert
        H s (fun j => if j ∈ s then g j else 0) (fun j hj => if_neg hj)
          (by simp_rw [ite_smul, zero_smul, Finset.sum_extend_by_zero, hg]) i
      exact (if_pos hi).symm⟩
#align linear_independent_iff'' linearIndependent_iff''

/- warning: not_linear_independent_iff -> not_linearIndependent_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2], Iff (Not (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5)) (Exists.{succ u1} (Finset.{u1} ι) (fun (s : Finset.{u1} ι) => Exists.{max (succ u1) (succ u2)} (ι -> R) (fun (g : ι -> R) => And (Eq.{succ u3} M (Finset.sum.{u3, u1} M ι _inst_2 s (fun (i : ι) => SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (g i) (v i))) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))))) (Exists.{succ u1} ι (fun (i : ι) => Exists.{0} (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i s) (fun (H : Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) i s) => Ne.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2], Iff (Not (LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5)) (Exists.{succ u3} (Finset.{u3} ι) (fun (s : Finset.{u3} ι) => Exists.{max (succ u3) (succ u2)} (ι -> R) (fun (g : ι -> R) => And (Eq.{succ u1} M (Finset.sum.{u1, u3} M ι _inst_2 s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) (g i) (v i))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (Exists.{succ u3} ι (fun (i : ι) => And (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) (Ne.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))))))))))
Case conversion may be inaccurate. Consider using '#align not_linear_independent_iff not_linearIndependent_iffₓ'. -/
theorem not_linearIndependent_iff :
    ¬LinearIndependent R v ↔
      ∃ s : Finset ι, ∃ g : ι → R, (∑ i in s, g i • v i) = 0 ∧ ∃ i ∈ s, g i ≠ 0 :=
  by
  rw [linearIndependent_iff']
  simp only [exists_prop, not_forall]
#align not_linear_independent_iff not_linearIndependent_iff

/- warning: fintype.linear_independent_iff -> Fintype.linearIndependent_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_8 : Fintype.{u1} ι], Iff (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5) (forall (g : ι -> R), (Eq.{succ u3} M (Finset.sum.{u3, u1} M ι _inst_2 (Finset.univ.{u1} ι _inst_8) (fun (i : ι) => SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (g i) (v i))) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))))) -> (forall (i : ι), Eq.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_8 : Fintype.{u3} ι], Iff (LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5) (forall (g : ι -> R), (Eq.{succ u1} M (Finset.sum.{u1, u3} M ι _inst_2 (Finset.univ.{u3} ι _inst_8) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) (g i) (v i))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) -> (forall (i : ι), Eq.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align fintype.linear_independent_iff Fintype.linearIndependent_iffₓ'. -/
theorem Fintype.linearIndependent_iff [Fintype ι] :
    LinearIndependent R v ↔ ∀ g : ι → R, (∑ i, g i • v i) = 0 → ∀ i, g i = 0 :=
  by
  refine'
    ⟨fun H g => by simpa using linearIndependent_iff'.1 H Finset.univ g, fun H =>
      linearIndependent_iff''.2 fun s g hg hs i => H _ _ _⟩
  rw [← hs]
  refine' (Finset.sum_subset (Finset.subset_univ _) fun i _ hi => _).symm
  rw [hg i hi, zero_smul]
#align fintype.linear_independent_iff Fintype.linearIndependent_iff

/- warning: fintype.linear_independent_iff' -> Fintype.linearIndependent_iff' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_8 : Fintype.{u1} ι], Iff (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5) (Eq.{succ (max u1 u2)} (Submodule.{u2, max u1 u2} R (forall (i : ι), (fun (i : ι) => R) i) _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i))) (LinearMap.ker.{u2, u2, max u1 u2, u3, max (max u1 u2) u3} R R (forall (i : ι), (fun (i : ι) => R) i) M _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (forall (i : ι), (fun (i : ι) => R) i) M (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5) (LinearMap.semilinearMapClass.{u2, u2, max u1 u2, u3} R R (forall (i : ι), (fun (i : ι) => R) i) M _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (LinearEquiv.{0, 0, max u1 u2 u3, max (max u1 u2) u3} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (forall (i : ι), LinearMap.{u2, u2, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (i : ι) => R) i) M ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5) (LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (forall (i : ι), (fun (i : ι) => R) i) M (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5) (Pi.addCommMonoid.{u1, max u2 u3} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (i : ι) => R) i) M ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u3} R R ((fun (i : ι) => R) i) M _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u1 u2, u3} R R (forall (i : ι), (fun (i : ι) => R) i) M _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u1, max u2 u3, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (i : ι) => R) i) M ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u3} R R ((fun (i : ι) => R) i) M _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.module.{u2, u2, 0, u2, u3} R R Nat ((fun (i : ι) => R) i) M _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u3} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u3} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) (Module.toDistribMulAction.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.module.{u2, u2, 0, max u1 u2, u3} R R Nat (forall (i : ι), (fun (i : ι) => R) i) M _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u3} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u3} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) (Module.toDistribMulAction.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (fun (_x : LinearEquiv.{0, 0, max u1 u2 u3, max (max u1 u2) u3} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (forall (i : ι), LinearMap.{u2, u2, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (i : ι) => R) i) M ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5) (LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (forall (i : ι), (fun (i : ι) => R) i) M (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5) (Pi.addCommMonoid.{u1, max u2 u3} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (i : ι) => R) i) M ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u3} R R ((fun (i : ι) => R) i) M _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u1 u2, u3} R R (forall (i : ι), (fun (i : ι) => R) i) M _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u1, max u2 u3, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (i : ι) => R) i) M ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u3} R R ((fun (i : ι) => R) i) M _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.module.{u2, u2, 0, u2, u3} R R Nat ((fun (i : ι) => R) i) M _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u3} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u3} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) (Module.toDistribMulAction.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.module.{u2, u2, 0, max u1 u2, u3} R R Nat (forall (i : ι), (fun (i : ι) => R) i) M _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u3} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u3} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) (Module.toDistribMulAction.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) => (forall (i : ι), LinearMap.{u2, u2, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (i : ι) => R) i) M ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5) -> (LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (forall (i : ι), (fun (i : ι) => R) i) M (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5)) (LinearEquiv.hasCoeToFun.{0, 0, max u1 u2 u3, max (max u1 u2) u3} Nat Nat (forall (i : ι), LinearMap.{u2, u2, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (i : ι) => R) i) M ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5) (LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (forall (i : ι), (fun (i : ι) => R) i) M (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5) Nat.semiring Nat.semiring (Pi.addCommMonoid.{u1, max u2 u3} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (i : ι) => R) i) M ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u3} R R ((fun (i : ι) => R) i) M _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u1 u2, u3} R R (forall (i : ι), (fun (i : ι) => R) i) M _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u1, max u2 u3, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (i : ι) => R) i) M ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u3} R R ((fun (i : ι) => R) i) M _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.module.{u2, u2, 0, u2, u3} R R Nat ((fun (i : ι) => R) i) M _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) _inst_2 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u3} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u3} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) (Module.toDistribMulAction.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.module.{u2, u2, 0, max u1 u2, u3} R R Nat (forall (i : ι), (fun (i : ι) => R) i) M _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) _inst_2 (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u3} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u3} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) (Module.toDistribMulAction.{u2, u3} R M _inst_1 _inst_2 _inst_5))) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring)) (LinearMap.lsum.{u2, u3, u1, u2, 0} R M ι _inst_1 (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) Nat _inst_2 _inst_5 _inst_8 (fun (a : ι) (b : ι) => Classical.propDecidable (Eq.{succ u1} ι a b)) Nat.semiring (AddCommMonoid.natModule.{u3} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u3} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M _inst_2) (Module.toDistribMulAction.{u2, u3} R M _inst_1 _inst_2 _inst_5))) (fun (i : ι) => LinearMap.smulRight.{u2, u2, u3, u2} R ((fun (i : ι) => R) i) M ((fun (i : ι) => R) i) _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) _inst_5 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_1 ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i) _inst_5 (IsScalarTower.left.{u2, u3} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (MulActionWithZero.toMulAction.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5))) (LinearMap.id.{u2, u2} R ((fun (i : ι) => R) i) _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) ((fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)) (v i)))) (Bot.bot.{max u1 u2} (Submodule.{u2, max u1 u2} R (forall (i : ι), (fun (i : ι) => R) i) _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i))) (Submodule.hasBot.{u2, max u1 u2} R (forall (i : ι), (fun (i : ι) => R) i) _inst_1 (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i)) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => (fun (i : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) i)))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_8 : Fintype.{u3} ι], Iff (LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5) (Eq.{max (succ u3) (succ u2)} (Submodule.{u2, max u3 u2} R (ι -> R) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1))) (LinearMap.ker.{u2, u2, max u3 u2, u1, max (max u3 u2) u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) => LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (fun (i : ι) => LinearMap.smulRight.{u2, u2, u1, u2} R R M R _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_5 (Semiring.toModule.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R _inst_1) _inst_5 (IsScalarTower.left.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (MulActionWithZero.toMulAction.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))) (LinearMap.id.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (v i))) (LinearMap.instSemilinearMapClassLinearMap.{u2, u2, max u3 u2, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1), max (max (succ u2) (succ u3)) (succ u1)} (LinearEquiv.{0, 0, max (max u2 u1) u3, max u1 u2 u3} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u3, max u2 u1, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, u2, u1} R R Nat R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, max u2 u3, u1} R R Nat (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (_x : forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) => LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) _x) (SMulHomClass.toFunLike.{max (max u2 u3) u1, 0, max (max u2 u3) u1, max (max u2 u3) u1} (LinearEquiv.{0, 0, max (max u2 u1) u3, max u1 u2 u3} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u3, max u2 u1, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, u2, u1} R R Nat R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, max u2 u3, u1} R R Nat (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) Nat (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (SMulZeroClass.toSMul.{0, max (max u2 u3) u1} Nat (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (AddMonoid.toZero.{max (max u2 u3) u1} (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (AddCommMonoid.toAddMonoid.{max (max u2 u3) u1} (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (DistribSMul.toSMulZeroClass.{0, max (max u2 u3) u1} Nat (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (AddCommMonoid.toAddMonoid.{max (max u2 u3) u1} (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (DistribMulAction.toDistribSMul.{0, max (max u2 u3) u1} Nat (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat Nat.semiring)) (AddCommMonoid.toAddMonoid.{max (max u2 u3) u1} (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Module.toDistribMulAction.{0, max (max u2 u3) u1} Nat (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat.semiring (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u3, max u2 u1, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, u2, u1} R R Nat R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))))))) (SMulZeroClass.toSMul.{0, max (max u2 u3) u1} Nat (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (AddMonoid.toZero.{max (max u2 u3) u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (AddCommMonoid.toAddMonoid.{max (max u2 u3) u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (DistribSMul.toSMulZeroClass.{0, max (max u2 u3) u1} Nat (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (AddMonoid.toAddZeroClass.{max (max u2 u3) u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (AddCommMonoid.toAddMonoid.{max (max u2 u3) u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (DistribMulAction.toDistribSMul.{0, max (max u2 u3) u1} Nat (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat Nat.semiring)) (AddCommMonoid.toAddMonoid.{max (max u2 u3) u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Module.toDistribMulAction.{0, max (max u2 u3) u1} Nat (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) Nat.semiring (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, max u2 u3, u1} R R Nat (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5))))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u2 u3) u1, 0, max (max u2 u3) u1, max (max u2 u3) u1} (LinearEquiv.{0, 0, max (max u2 u1) u3, max u1 u2 u3} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u3, max u2 u1, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, u2, u1} R R Nat R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, max u2 u3, u1} R R Nat (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) Nat (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat Nat.semiring)) (AddCommMonoid.toAddMonoid.{max (max u2 u3) u1} (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (AddCommMonoid.toAddMonoid.{max (max u2 u3) u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Module.toDistribMulAction.{0, max (max u2 u3) u1} Nat (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat.semiring (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u3, max u2 u1, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, u2, u1} R R Nat R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) (Module.toDistribMulAction.{0, max (max u2 u3) u1} Nat (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) Nat.semiring (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, max u2 u3, u1} R R Nat (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (SemilinearMapClass.distribMulActionHomClass.{0, max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} Nat (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (LinearEquiv.{0, 0, max (max u2 u1) u3, max u1 u2 u3} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u3, max u2 u1, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, u2, u1} R R Nat R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, max u2 u3, u1} R R Nat (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) Nat.semiring (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u3, max u2 u1, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, u2, u1} R R Nat R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, max u2 u3, u1} R R Nat (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5))) (SemilinearEquivClass.instSemilinearMapClass.{0, 0, max (max u2 u3) u1, max (max u2 u3) u1, max (max u2 u3) u1} Nat Nat (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (LinearEquiv.{0, 0, max (max u2 u1) u3, max u1 u2 u3} Nat Nat Nat.semiring Nat.semiring (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u3, max u2 u1, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, u2, u1} R R Nat R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, max u2 u3, u1} R R Nat (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) Nat.semiring Nat.semiring (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u3, max u2 u1, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, u2, u1} R R Nat R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, max u2 u3, u1} R R Nat (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5))) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{0, 0, max (max u2 u3) u1, max (max u2 u3) u1} Nat Nat (forall (i : ι), LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (ι -> R) M (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5) Nat.semiring Nat.semiring (Pi.addCommMonoid.{u3, max u2 u1} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.module.{u3, max u2 u1, 0} ι (fun (i : ι) => LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R M (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5) Nat Nat.semiring (fun (i : ι) => LinearMap.addCommMonoid.{u2, u2, u2, u1} R R R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : ι) => LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, u2, u1} R R Nat R M _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) _inst_2 (Semiring.toModule.{u2} R _inst_1) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, 0, max u2 u3, u1} R R Nat (ι -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5))) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHom.id.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) (RingHomInvPair.ids.{0} Nat Nat.semiring) (RingHomInvPair.ids.{0} Nat Nat.semiring)))))) (LinearMap.lsum.{u2, u1, u3, u2, 0} R M ι _inst_1 (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (i : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (i : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (i : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) Nat _inst_2 _inst_5 _inst_8 (fun (a : ι) (b : ι) => Classical.propDecidable (Eq.{succ u3} ι a b)) Nat.semiring (AddCommMonoid.natModule.{u1} M _inst_2) (AddMonoid.nat_smulCommClass'.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} M _inst_2) (Module.toDistribMulAction.{u2, u1} R M _inst_1 _inst_2 _inst_5))) (fun (i : ι) => LinearMap.smulRight.{u2, u2, u1, u2} R R M R _inst_1 _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) _inst_5 (Semiring.toModule.{u2} R _inst_1) _inst_1 (Semiring.toModule.{u2} R _inst_1) _inst_5 (IsScalarTower.left.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (MulActionWithZero.toMulAction.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))) (LinearMap.id.{u2, u2} R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (v i)))) (Bot.bot.{max u3 u2} (Submodule.{u2, max u3 u2} R (ι -> R) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1))) (Submodule.instBotSubmodule.{u2, max u3 u2} R (ι -> R) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1)))) (Pi.module.{u3, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.1397 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align fintype.linear_independent_iff' Fintype.linearIndependent_iff'ₓ'. -/
/-- A finite family of vectors `v i` is linear independent iff the linear map that sends
`c : ι → R` to `∑ i, c i • v i` has the trivial kernel. -/
theorem Fintype.linearIndependent_iff' [Fintype ι] :
    LinearIndependent R v ↔
      (LinearMap.lsum R (fun i : ι => R) ℕ fun i => LinearMap.id.smul_right (v i)).ker = ⊥ :=
  by simp [Fintype.linearIndependent_iff, LinearMap.ker_eq_bot', funext_iff] <;> skip
#align fintype.linear_independent_iff' Fintype.linearIndependent_iff'

/- warning: fintype.not_linear_independent_iff -> Fintype.not_linearIndependent_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_8 : Fintype.{u1} ι], Iff (Not (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5)) (Exists.{max (succ u1) (succ u2)} (ι -> R) (fun (g : ι -> R) => And (Eq.{succ u3} M (Finset.sum.{u3, u1} M ι _inst_2 (Finset.univ.{u1} ι _inst_8) (fun (i : ι) => SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (g i) (v i))) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))))) (Exists.{succ u1} ι (fun (i : ι) => Ne.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_8 : Fintype.{u3} ι], Iff (Not (LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5)) (Exists.{max (succ u3) (succ u2)} (ι -> R) (fun (g : ι -> R) => And (Eq.{succ u1} M (Finset.sum.{u1, u3} M ι _inst_2 (Finset.univ.{u3} ι _inst_8) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) (g i) (v i))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (Exists.{succ u3} ι (fun (i : ι) => Ne.{succ u2} R (g i) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align fintype.not_linear_independent_iff Fintype.not_linearIndependent_iffₓ'. -/
theorem Fintype.not_linearIndependent_iff [Fintype ι] :
    ¬LinearIndependent R v ↔ ∃ g : ι → R, (∑ i, g i • v i) = 0 ∧ ∃ i, g i ≠ 0 := by
  simpa using not_iff_not.2 Fintype.linearIndependent_iff
#align fintype.not_linear_independent_iff Fintype.not_linearIndependent_iff

/- warning: linear_independent_empty_type -> linearIndependent_empty_type is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_8 : IsEmpty.{succ u1} ι], LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_8 : IsEmpty.{succ u3} ι], LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5
Case conversion may be inaccurate. Consider using '#align linear_independent_empty_type linearIndependent_empty_typeₓ'. -/
theorem linearIndependent_empty_type [IsEmpty ι] : LinearIndependent R v :=
  linearIndependent_iff.mpr fun v hv => Subsingleton.elim v 0
#align linear_independent_empty_type linearIndependent_empty_type

/- warning: linear_independent.ne_zero -> LinearIndependent.ne_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_8 : Nontrivial.{u2} R] (i : ι), (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5) -> (Ne.{succ u3} M (v i) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_8 : Nontrivial.{u2} R] (i : ι), (LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5) -> (Ne.{succ u1} M (v i) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align linear_independent.ne_zero LinearIndependent.ne_zeroₓ'. -/
theorem LinearIndependent.ne_zero [Nontrivial R] (i : ι) (hv : LinearIndependent R v) : v i ≠ 0 :=
  fun h =>
  zero_ne_one' R <|
    Eq.symm
      (by
        suffices (Finsupp.single i 1 : ι →₀ R) i = 0 by simpa
        rw [linearIndependent_iff.1 hv (Finsupp.single i 1)]
        · simp
        · simp [h])
#align linear_independent.ne_zero LinearIndependent.ne_zero

/- warning: linear_independent.comp -> LinearIndependent.comp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {ι' : Type.{u2}} {R : Type.{u3}} {M : Type.{u4}} {v : ι -> M} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u4} M] [_inst_5 : Module.{u3, u4} R M _inst_1 _inst_2], (LinearIndependent.{u1, u3, u4} ι R M v _inst_1 _inst_2 _inst_5) -> (forall (f : ι' -> ι), (Function.Injective.{succ u2, succ u1} ι' ι f) -> (LinearIndependent.{u2, u3, u4} ι' R M (Function.comp.{succ u2, succ u1, succ u4} ι' ι M v f) _inst_1 _inst_2 _inst_5))
but is expected to have type
  forall {ι : Type.{u4}} {ι' : Type.{u1}} {R : Type.{u3}} {M : Type.{u2}} {v : ι -> M} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u3, u2} R M _inst_1 _inst_2], (LinearIndependent.{u4, u3, u2} ι R M v _inst_1 _inst_2 _inst_5) -> (forall (f : ι' -> ι), (Function.Injective.{succ u1, succ u4} ι' ι f) -> (LinearIndependent.{u1, u3, u2} ι' R M (Function.comp.{succ u1, succ u4, succ u2} ι' ι M v f) _inst_1 _inst_2 _inst_5))
Case conversion may be inaccurate. Consider using '#align linear_independent.comp LinearIndependent.compₓ'. -/
/-- A subfamily of a linearly independent family (i.e., a composition with an injective map) is a
linearly independent family. -/
theorem LinearIndependent.comp (h : LinearIndependent R v) (f : ι' → ι) (hf : Injective f) :
    LinearIndependent R (v ∘ f) :=
  by
  rw [linearIndependent_iff, Finsupp.total_comp]
  intro l hl
  have h_map_domain : ∀ x, (Finsupp.mapDomain f l) (f x) = 0 := by
    rw [linearIndependent_iff.1 h (Finsupp.mapDomain f l) hl] <;> simp
  ext x
  convert h_map_domain x
  rw [Finsupp.mapDomain_apply hf]
#align linear_independent.comp LinearIndependent.comp

/- warning: linear_independent.coe_range -> LinearIndependent.coe_range is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2], (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5) -> (LinearIndependent.{u3, u2, u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) (Set.range.{u3, succ u1} M ι v)) R M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) (Set.range.{u3, succ u1} M ι v)) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) (Set.range.{u3, succ u1} M ι v)) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) (Set.range.{u3, succ u1} M ι v)) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) (Set.range.{u3, succ u1} M ι v)) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (Set.{u3} M) (Set.hasMem.{u3} M) x (Set.range.{u3, succ u1} M ι v))))))) _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2], (LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5) -> (LinearIndependent.{u1, u2, u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (Set.range.{u1, succ u3} M ι v))) R M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (Set.range.{u1, succ u3} M ι v))) _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.coe_range LinearIndependent.coe_rangeₓ'. -/
theorem LinearIndependent.coe_range (i : LinearIndependent R v) :
    LinearIndependent R (coe : range v → M) := by simpa using i.comp _ (range_splitting_injective v)
#align linear_independent.coe_range LinearIndependent.coe_range

/- warning: linear_independent.map -> LinearIndependent.map is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {M' : Type.{u4}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : AddCommMonoid.{u4} M'] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : Module.{u2, u4} R M' _inst_1 _inst_3], (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5) -> (forall {f : LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6}, (Disjoint.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (SetLike.partialOrder.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_5)) (Submodule.orderBot.{u2, u3} R M _inst_1 _inst_2 _inst_5) (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_5 (Set.range.{u3, succ u1} M ι v)) (LinearMap.ker.{u2, u2, u3, u4, max u3 u4} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) (LinearMap.semilinearMapClass.{u2, u2, u3, u4} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f)) -> (LinearIndependent.{u1, u2, u4} ι R M' (Function.comp.{succ u1, succ u3, succ u4} ι M M' (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) (fun (_x : LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u2, u2, u3, u4} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f) v) _inst_1 _inst_3 _inst_6))
but is expected to have type
  forall {ι : Type.{u4}} {R : Type.{u3}} {M : Type.{u2}} {M' : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M'] [_inst_5 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_6 : Module.{u3, u1} R M' _inst_1 _inst_3], (LinearIndependent.{u4, u3, u2} ι R M v _inst_1 _inst_2 _inst_5) -> (forall {f : LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6}, (Disjoint.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_5) (Submodule.completeLattice.{u3, u2} R M _inst_1 _inst_2 _inst_5))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u3, u2} R M _inst_1 _inst_2 _inst_5) (Submodule.span.{u3, u2} R M _inst_1 _inst_2 _inst_5 (Set.range.{u2, succ u4} M ι v)) (LinearMap.ker.{u3, u3, u2, u1, max u2 u1} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u2, u1} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f)) -> (LinearIndependent.{u4, u3, u1} ι R M' (Function.comp.{succ u4, succ u2, succ u1} ι M M' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M') _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f) v) _inst_1 _inst_3 _inst_6))
Case conversion may be inaccurate. Consider using '#align linear_independent.map LinearIndependent.mapₓ'. -/
/-- If `v` is a linearly independent family of vectors and the kernel of a linear map `f` is
disjoint with the submodule spanned by the vectors of `v`, then `f ∘ v` is a linearly independent
family of vectors. See also `linear_independent.map'` for a special case assuming `ker f = ⊥`. -/
theorem LinearIndependent.map (hv : LinearIndependent R v) {f : M →ₗ[R] M'}
    (hf_inj : Disjoint (span R (range v)) f.ker) : LinearIndependent R (f ∘ v) :=
  by
  rw [disjoint_iff_inf_le, ← Set.image_univ, Finsupp.span_image_eq_map_total,
    map_inf_eq_map_inf_comap, map_le_iff_le_comap, comap_bot, Finsupp.supported_univ, top_inf_eq] at
    hf_inj
  unfold LinearIndependent at hv⊢
  rw [hv, le_bot_iff] at hf_inj
  haveI : Inhabited M := ⟨0⟩
  rw [Finsupp.total_comp, @Finsupp.lmapDomain_total _ _ R _ _ _ _ _ _ _ _ _ _ f, LinearMap.ker_comp,
    hf_inj]
  exact fun _ => rfl
#align linear_independent.map LinearIndependent.map

/- warning: linear_independent.map' -> LinearIndependent.map' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {M' : Type.{u4}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : AddCommMonoid.{u4} M'] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : Module.{u2, u4} R M' _inst_1 _inst_3], (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5) -> (forall (f : LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6), (Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (LinearMap.ker.{u2, u2, u3, u4, max u3 u4} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) (LinearMap.semilinearMapClass.{u2, u2, u3, u4} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f) (Bot.bot.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (Submodule.hasBot.{u2, u3} R M _inst_1 _inst_2 _inst_5))) -> (LinearIndependent.{u1, u2, u4} ι R M' (Function.comp.{succ u1, succ u3, succ u4} ι M M' (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) (fun (_x : LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u2, u2, u3, u4} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f) v) _inst_1 _inst_3 _inst_6))
but is expected to have type
  forall {ι : Type.{u4}} {R : Type.{u3}} {M : Type.{u2}} {M' : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M'] [_inst_5 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_6 : Module.{u3, u1} R M' _inst_1 _inst_3], (LinearIndependent.{u4, u3, u2} ι R M v _inst_1 _inst_2 _inst_5) -> (forall (f : LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6), (Eq.{succ u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_5) (LinearMap.ker.{u3, u3, u2, u1, max u2 u1} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u2, u1} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f) (Bot.bot.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_5) (Submodule.instBotSubmodule.{u3, u2} R M _inst_1 _inst_2 _inst_5))) -> (LinearIndependent.{u4, u3, u1} ι R M' (Function.comp.{succ u4, succ u2, succ u1} ι M M' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M') _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f) v) _inst_1 _inst_3 _inst_6))
Case conversion may be inaccurate. Consider using '#align linear_independent.map' LinearIndependent.map'ₓ'. -/
/-- An injective linear map sends linearly independent families of vectors to linearly independent
families of vectors. See also `linear_independent.map` for a more general statement. -/
theorem LinearIndependent.map' (hv : LinearIndependent R v) (f : M →ₗ[R] M') (hf_inj : f.ker = ⊥) :
    LinearIndependent R (f ∘ v) :=
  hv.map <| by simp [hf_inj]
#align linear_independent.map' LinearIndependent.map'

/- warning: linear_independent.of_comp -> LinearIndependent.of_comp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {M' : Type.{u4}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : AddCommMonoid.{u4} M'] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : Module.{u2, u4} R M' _inst_1 _inst_3] (f : LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6), (LinearIndependent.{u1, u2, u4} ι R M' (Function.comp.{succ u1, succ u3, succ u4} ι M M' (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) (fun (_x : LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u2, u2, u3, u4} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f) v) _inst_1 _inst_3 _inst_6) -> (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {ι : Type.{u4}} {R : Type.{u3}} {M : Type.{u2}} {M' : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M'] [_inst_5 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_6 : Module.{u3, u1} R M' _inst_1 _inst_3] (f : LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6), (LinearIndependent.{u4, u3, u1} ι R M' (Function.comp.{succ u4, succ u2, succ u1} ι M M' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M') _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f) v) _inst_1 _inst_3 _inst_6) -> (LinearIndependent.{u4, u3, u2} ι R M v _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.of_comp LinearIndependent.of_compₓ'. -/
/-- If the image of a family of vectors under a linear map is linearly independent, then so is
the original family. -/
theorem LinearIndependent.of_comp (f : M →ₗ[R] M') (hfv : LinearIndependent R (f ∘ v)) :
    LinearIndependent R v :=
  linearIndependent_iff'.2 fun s g hg i his =>
    have : (∑ i : ι in s, g i • f (v i)) = 0 := by
      simp_rw [← f.map_smul, ← f.map_sum, hg, f.map_zero]
    linearIndependent_iff'.1 hfv s g this i his
#align linear_independent.of_comp LinearIndependent.of_comp

/- warning: linear_map.linear_independent_iff -> LinearMap.linearIndependent_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {M' : Type.{u4}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : AddCommMonoid.{u4} M'] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_6 : Module.{u2, u4} R M' _inst_1 _inst_3] (f : LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6), (Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (LinearMap.ker.{u2, u2, u3, u4, max u3 u4} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) (LinearMap.semilinearMapClass.{u2, u2, u3, u4} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f) (Bot.bot.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (Submodule.hasBot.{u2, u3} R M _inst_1 _inst_2 _inst_5))) -> (Iff (LinearIndependent.{u1, u2, u4} ι R M' (Function.comp.{succ u1, succ u3, succ u4} ι M M' (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) (fun (_x : LinearMap.{u2, u2, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u2, u2, u3, u4} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f) v) _inst_1 _inst_3 _inst_6) (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5))
but is expected to have type
  forall {ι : Type.{u4}} {R : Type.{u3}} {M : Type.{u2}} {M' : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u1} M'] [_inst_5 : Module.{u3, u2} R M _inst_1 _inst_2] [_inst_6 : Module.{u3, u1} R M' _inst_1 _inst_3] (f : LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6), (Eq.{succ u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_5) (LinearMap.ker.{u3, u3, u2, u1, max u2 u1} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u2, u1} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f) (Bot.bot.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_5) (Submodule.instBotSubmodule.{u3, u2} R M _inst_1 _inst_2 _inst_5))) -> (Iff (LinearIndependent.{u4, u3, u1} ι R M' (Function.comp.{succ u4, succ u2, succ u1} ι M M' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_2 _inst_3 _inst_5 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M') _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R M M' _inst_1 _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f) v) _inst_1 _inst_3 _inst_6) (LinearIndependent.{u4, u3, u2} ι R M v _inst_1 _inst_2 _inst_5))
Case conversion may be inaccurate. Consider using '#align linear_map.linear_independent_iff LinearMap.linearIndependent_iffₓ'. -/
/-- If `f` is an injective linear map, then the family `f ∘ v` is linearly independent
if and only if the family `v` is linearly independent. -/
protected theorem LinearMap.linearIndependent_iff (f : M →ₗ[R] M') (hf_inj : f.ker = ⊥) :
    LinearIndependent R (f ∘ v) ↔ LinearIndependent R v :=
  ⟨fun h => h.of_comp f, fun h => h.map <| by simp only [hf_inj, disjoint_bot_right]⟩
#align linear_map.linear_independent_iff LinearMap.linearIndependent_iff

/- warning: linear_independent_of_subsingleton -> linearIndependent_of_subsingleton is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] [_inst_8 : Subsingleton.{succ u2} R], LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_8 : Subsingleton.{succ u2} R], LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5
Case conversion may be inaccurate. Consider using '#align linear_independent_of_subsingleton linearIndependent_of_subsingletonₓ'. -/
@[nontriviality]
theorem linearIndependent_of_subsingleton [Subsingleton R] : LinearIndependent R v :=
  linearIndependent_iff.2 fun l hl => Subsingleton.elim _ _
#align linear_independent_of_subsingleton linearIndependent_of_subsingleton

/- warning: linear_independent_equiv -> linearIndependent_equiv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {ι' : Type.{u2}} {R : Type.{u3}} {M : Type.{u4}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u4} M] [_inst_5 : Module.{u3, u4} R M _inst_1 _inst_2] (e : Equiv.{succ u1, succ u2} ι ι') {f : ι' -> M}, Iff (LinearIndependent.{u1, u3, u4} ι R M (Function.comp.{succ u1, succ u2, succ u4} ι ι' M f (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} ι ι') (fun (_x : Equiv.{succ u1, succ u2} ι ι') => ι -> ι') (Equiv.hasCoeToFun.{succ u1, succ u2} ι ι') e)) _inst_1 _inst_2 _inst_5) (LinearIndependent.{u2, u3, u4} ι' R M f _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {ι : Type.{u4}} {ι' : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] (e : Equiv.{succ u4, succ u3} ι ι') {f : ι' -> M}, Iff (LinearIndependent.{u4, u2, u1} ι R M (Function.comp.{succ u4, succ u3, succ u1} ι ι' M f (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} ι ι') ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : ι) => ι') _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} ι ι') e)) _inst_1 _inst_2 _inst_5) (LinearIndependent.{u3, u2, u1} ι' R M f _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent_equiv linearIndependent_equivₓ'. -/
theorem linearIndependent_equiv (e : ι ≃ ι') {f : ι' → M} :
    LinearIndependent R (f ∘ e) ↔ LinearIndependent R f :=
  ⟨fun h => Function.comp.right_id f ▸ e.self_comp_symm ▸ h.comp _ e.symm.Injective, fun h =>
    h.comp _ e.Injective⟩
#align linear_independent_equiv linearIndependent_equiv

/- warning: linear_independent_equiv' -> linearIndependent_equiv' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {ι' : Type.{u2}} {R : Type.{u3}} {M : Type.{u4}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u4} M] [_inst_5 : Module.{u3, u4} R M _inst_1 _inst_2] (e : Equiv.{succ u1, succ u2} ι ι') {f : ι' -> M} {g : ι -> M}, (Eq.{max (succ u1) (succ u4)} (ι -> M) (Function.comp.{succ u1, succ u2, succ u4} ι ι' M f (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} ι ι') (fun (_x : Equiv.{succ u1, succ u2} ι ι') => ι -> ι') (Equiv.hasCoeToFun.{succ u1, succ u2} ι ι') e)) g) -> (Iff (LinearIndependent.{u1, u3, u4} ι R M g _inst_1 _inst_2 _inst_5) (LinearIndependent.{u2, u3, u4} ι' R M f _inst_1 _inst_2 _inst_5))
but is expected to have type
  forall {ι : Type.{u4}} {ι' : Type.{u3}} {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] (e : Equiv.{succ u4, succ u3} ι ι') {f : ι' -> M} {g : ι -> M}, (Eq.{max (succ u4) (succ u2)} (ι -> M) (Function.comp.{succ u4, succ u3, succ u2} ι ι' M f (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} ι ι') ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : ι) => ι') _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} ι ι') e)) g) -> (Iff (LinearIndependent.{u4, u1, u2} ι R M g _inst_1 _inst_2 _inst_5) (LinearIndependent.{u3, u1, u2} ι' R M f _inst_1 _inst_2 _inst_5))
Case conversion may be inaccurate. Consider using '#align linear_independent_equiv' linearIndependent_equiv'ₓ'. -/
theorem linearIndependent_equiv' (e : ι ≃ ι') {f : ι' → M} {g : ι → M} (h : f ∘ e = g) :
    LinearIndependent R g ↔ LinearIndependent R f :=
  h ▸ linearIndependent_equiv e
#align linear_independent_equiv' linearIndependent_equiv'

#print linearIndependent_subtype_range /-
theorem linearIndependent_subtype_range {ι} {f : ι → M} (hf : Injective f) :
    LinearIndependent R (coe : range f → M) ↔ LinearIndependent R f :=
  Iff.symm <| linearIndependent_equiv' (Equiv.ofInjective f hf) rfl
#align linear_independent_subtype_range linearIndependent_subtype_range
-/

alias linearIndependent_subtype_range ↔ LinearIndependent.of_subtype_range _
#align linear_independent.of_subtype_range LinearIndependent.of_subtype_range

#print linearIndependent_image /-
theorem linearIndependent_image {ι} {s : Set ι} {f : ι → M} (hf : Set.InjOn f s) :
    (LinearIndependent R fun x : s => f x) ↔ LinearIndependent R fun x : f '' s => (x : M) :=
  linearIndependent_equiv' (Equiv.Set.imageOfInjOn _ _ hf) rfl
#align linear_independent_image linearIndependent_image
-/

/- warning: linear_independent_span -> linearIndependent_span is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2], (LinearIndependent.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5) -> (LinearIndependent.{u1, u2, u3} ι R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_5)) (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_5 (Set.range.{u3, succ u1} M ι v))) (fun (i : ι) => Subtype.mk.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_2 _inst_5)) x (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_5 (Set.range.{u3, succ u1} M ι v))) (v i) (Submodule.subset_span.{u2, u3} R M _inst_1 _inst_2 _inst_5 (Set.range.{u3, succ u1} M ι v) (v i) (Set.mem_range_self.{u3, succ u1} M ι v i))) _inst_1 (Submodule.addCommMonoid.{u2, u3} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_5 (Set.range.{u3, succ u1} M ι v))) (Submodule.module.{u2, u3} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u2, u3} R M _inst_1 _inst_2 _inst_5 (Set.range.{u3, succ u1} M ι v))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2], (LinearIndependent.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5) -> (LinearIndependent.{u3, u2, u1} ι R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_5)) x (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_5 (Set.range.{u1, succ u3} M ι v)))) (fun (i : ι) => Subtype.mk.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_5)) x (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_5 (Set.range.{u1, succ u3} M ι v))) (v i) (Submodule.subset_span.{u2, u1} R M _inst_1 _inst_2 _inst_5 (Set.range.{u1, succ u3} M ι v) (v i) (Set.mem_range_self.{succ u3, u1} M ι v i))) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_5 (Set.range.{u1, succ u3} M ι v))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_5 (Set.range.{u1, succ u3} M ι v))))
Case conversion may be inaccurate. Consider using '#align linear_independent_span linearIndependent_spanₓ'. -/
theorem linearIndependent_span (hs : LinearIndependent R v) :
    @LinearIndependent ι R (span R (range v)) (fun i : ι => ⟨v i, subset_span (mem_range_self i)⟩) _
      _ _ :=
  LinearIndependent.of_comp (span R (range v)).Subtype hs
#align linear_independent_span linearIndependent_span

/- warning: linear_independent.fin_cons' -> LinearIndependent.fin_cons' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] {m : Nat} (x : M) (v : (Fin m) -> M), (LinearIndependent.{0, u1, u2} (Fin m) R M v _inst_1 _inst_2 _inst_5) -> (forall (c : R) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_5)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.range.{u2, 1} M (Fin m) v))), (Eq.{succ u2} M (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_5)))) c x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_5)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.range.{u2, 1} M (Fin m) v))) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_5)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.range.{u2, 1} M (Fin m) v))) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_5)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.range.{u2, 1} M (Fin m) v))) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_5)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.range.{u2, 1} M (Fin m) v))) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_5)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.range.{u2, 1} M (Fin m) v))))))) y)) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) -> (Eq.{succ u1} R c (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))) -> (LinearIndependent.{0, u1, u2} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) R M (Fin.cons.{u2} m (fun (ᾰ : Fin (Nat.succ m)) => M) x v) _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] {m : Nat} (x : M) (v : (Fin m) -> M), (LinearIndependent.{0, u2, u1} (Fin m) R M v _inst_1 _inst_2 _inst_5) -> (forall (c : R) (y : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_5)) x (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_5 (Set.range.{u1, 1} M (Fin m) v)))), (Eq.{succ u1} M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))) c x) (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_5) (Submodule.span.{u2, u1} R M _inst_1 _inst_2 _inst_5 (Set.range.{u1, 1} M (Fin m) v)))) y)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) -> (Eq.{succ u2} R c (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))))) -> (LinearIndependent.{0, u2, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) R M (Fin.cons.{u1} m (fun (ᾰ : Fin (Nat.succ m)) => M) x v) _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.fin_cons' LinearIndependent.fin_cons'ₓ'. -/
/-- See `linear_independent.fin_cons` for a family of elements in a vector space. -/
theorem LinearIndependent.fin_cons' {m : ℕ} (x : M) (v : Fin m → M) (hli : LinearIndependent R v)
    (x_ortho : ∀ (c : R) (y : Submodule.span R (Set.range v)), c • x + y = (0 : M) → c = 0) :
    LinearIndependent R (Fin.cons x v : Fin m.succ → M) :=
  by
  rw [Fintype.linearIndependent_iff] at hli⊢
  rintro g total_eq j
  simp_rw [Fin.sum_univ_succ, Fin.cons_zero, Fin.cons_succ] at total_eq
  have : g 0 = 0 :=
    by
    refine' x_ortho (g 0) ⟨∑ i : Fin m, g i.succ • v i, _⟩ total_eq
    exact sum_mem fun i _ => smul_mem _ _ (subset_span ⟨i, rfl⟩)
  rw [this, zero_smul, zero_add] at total_eq
  exact Fin.cases this (hli _ total_eq) j
#align linear_independent.fin_cons' LinearIndependent.fin_cons'

/- warning: linear_independent.restrict_scalars -> LinearIndependent.restrict_scalars is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {K : Type.{u3}} {M : Type.{u4}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u4} M] [_inst_5 : Module.{u2, u4} R M _inst_1 _inst_2] [_inst_8 : Semiring.{u3} K] [_inst_9 : SMulWithZero.{u2, u3} R K (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (MulZeroClass.toHasZero.{u3} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} K (Semiring.toNonAssocSemiring.{u3} K _inst_8))))] [_inst_10 : Module.{u3, u4} K M _inst_8 _inst_2] [_inst_11 : IsScalarTower.{u2, u3, u4} R K M (SMulZeroClass.toHasSmul.{u2, u3} R K (MulZeroClass.toHasZero.{u3} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} K (Semiring.toNonAssocSemiring.{u3} K _inst_8)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R K (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (MulZeroClass.toHasZero.{u3} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} K (Semiring.toNonAssocSemiring.{u3} K _inst_8)))) _inst_9)) (SMulZeroClass.toHasSmul.{u3, u4} K M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u3, u4} K M (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K _inst_8)))) (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u4} K M (Semiring.toMonoidWithZero.{u3} K _inst_8) (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_2))) (Module.toMulActionWithZero.{u3, u4} K M _inst_8 _inst_2 _inst_10)))) (SMulZeroClass.toHasSmul.{u2, u4} R M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u4} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u4} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_2))) (Module.toMulActionWithZero.{u2, u4} R M _inst_1 _inst_2 _inst_5))))], (Function.Injective.{succ u2, succ u3} R K (fun (r : R) => SMul.smul.{u2, u3} R K (SMulZeroClass.toHasSmul.{u2, u3} R K (MulZeroClass.toHasZero.{u3} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} K (Semiring.toNonAssocSemiring.{u3} K _inst_8)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R K (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (MulZeroClass.toHasZero.{u3} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} K (Semiring.toNonAssocSemiring.{u3} K _inst_8)))) _inst_9)) r (OfNat.ofNat.{u3} K 1 (OfNat.mk.{u3} K 1 (One.one.{u3} K (AddMonoidWithOne.toOne.{u3} K (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} K (NonAssocSemiring.toAddCommMonoidWithOne.{u3} K (Semiring.toNonAssocSemiring.{u3} K _inst_8))))))))) -> (LinearIndependent.{u1, u3, u4} ι K M v _inst_8 _inst_2 _inst_10) -> (LinearIndependent.{u1, u2, u4} ι R M v _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {ι : Type.{u4}} {R : Type.{u2}} {K : Type.{u3}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] [_inst_8 : Semiring.{u3} K] [_inst_9 : SMulWithZero.{u2, u3} R K (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K _inst_8))] [_inst_10 : Module.{u3, u1} K M _inst_8 _inst_2] [_inst_11 : IsScalarTower.{u2, u3, u1} R K M (SMulZeroClass.toSMul.{u2, u3} R K (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K _inst_8)) (SMulWithZero.toSMulZeroClass.{u2, u3} R K (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K _inst_8)) _inst_9)) (SMulZeroClass.toSMul.{u3, u1} K M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u3, u1} K M (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K _inst_8)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u3, u1} K M (Semiring.toMonoidWithZero.{u3} K _inst_8) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u3, u1} K M _inst_8 _inst_2 _inst_10)))) (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_2 _inst_5))))], (Function.Injective.{succ u2, succ u3} R K (fun (r : R) => HSMul.hSMul.{u2, u3, u3} R K K (instHSMul.{u2, u3} R K (SMulZeroClass.toSMul.{u2, u3} R K (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K _inst_8)) (SMulWithZero.toSMulZeroClass.{u2, u3} R K (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K _inst_8)) _inst_9))) r (OfNat.ofNat.{u3} K 1 (One.toOfNat1.{u3} K (Semiring.toOne.{u3} K _inst_8))))) -> (LinearIndependent.{u4, u3, u1} ι K M v _inst_8 _inst_2 _inst_10) -> (LinearIndependent.{u4, u2, u1} ι R M v _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.restrict_scalars LinearIndependent.restrict_scalarsₓ'. -/
/-- A set of linearly independent vectors in a module `M` over a semiring `K` is also linearly
independent over a subring `R` of `K`.
The implementation uses minimal assumptions about the relationship between `R`, `K` and `M`.
The version where `K` is an `R`-algebra is `linear_independent.restrict_scalars_algebras`.
 -/
theorem LinearIndependent.restrict_scalars [Semiring K] [SMulWithZero R K] [Module K M]
    [IsScalarTower R K M] (hinj : Function.Injective fun r : R => r • (1 : K))
    (li : LinearIndependent K v) : LinearIndependent R v :=
  by
  refine' linear_independent_iff'.mpr fun s g hg i hi => hinj (Eq.trans _ (zero_smul _ _).symm)
  refine' (linear_independent_iff'.mp li : _) _ _ _ i hi
  simp_rw [smul_assoc, one_smul]
  exact hg
#align linear_independent.restrict_scalars LinearIndependent.restrict_scalars

#print linearIndependent_finset_map_embedding_subtype /-
/-- Every finite subset of a linearly independent set is linearly independent. -/
theorem linearIndependent_finset_map_embedding_subtype (s : Set M)
    (li : LinearIndependent R (coe : s → M)) (t : Finset s) :
    LinearIndependent R (coe : Finset.map (Embedding.subtype s) t → M) :=
  by
  let f : t.map (embedding.subtype s) → s := fun x =>
    ⟨x.1, by
      obtain ⟨x, h⟩ := x
      rw [Finset.mem_map] at h
      obtain ⟨a, ha, rfl⟩ := h
      simp only [Subtype.coe_prop, embedding.coe_subtype]⟩
  convert LinearIndependent.comp li f _
  rintro ⟨x, hx⟩ ⟨y, hy⟩
  rw [Finset.mem_map] at hx hy
  obtain ⟨a, ha, rfl⟩ := hx
  obtain ⟨b, hb, rfl⟩ := hy
  simp only [imp_self, Subtype.mk_eq_mk]
#align linear_independent_finset_map_embedding_subtype linearIndependent_finset_map_embedding_subtype
-/

/- warning: linear_independent_bounded_of_finset_linear_independent_bounded -> linearIndependent_bounded_of_finset_linearIndependent_bounded is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] {n : Nat}, (forall (s : Finset.{u2} M), (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} M) Type.{u2} (Finset.hasCoeToSort.{u2} M) s) R M (fun (i : coeSort.{succ u2, succ (succ u2)} (Finset.{u2} M) Type.{u2} (Finset.hasCoeToSort.{u2} M) s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} M) Type.{u2} (Finset.hasCoeToSort.{u2} M) s) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} M) Type.{u2} (Finset.hasCoeToSort.{u2} M) s) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} M) Type.{u2} (Finset.hasCoeToSort.{u2} M) s) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} M) Type.{u2} (Finset.hasCoeToSort.{u2} M) s) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Finset.{u2} M) (Finset.hasMem.{u2} M) x s))))) i) _inst_1 _inst_2 _inst_5) -> (LE.le.{0} Nat Nat.hasLe (Finset.card.{u2} M s) n)) -> (forall (s : Set.{u2} M), (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) R M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s)))))) _inst_1 _inst_2 _inst_5) -> (LE.le.{succ u2} Cardinal.{u2} Cardinal.hasLe.{u2} (Cardinal.mk.{u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s)) ((fun (a : Type) (b : Type.{succ u2}) [self : HasLiftT.{1, succ (succ u2)} a b] => self.0) Nat Cardinal.{u2} (HasLiftT.mk.{1, succ (succ u2)} Nat Cardinal.{u2} (CoeTCₓ.coe.{1, succ (succ u2)} Nat Cardinal.{u2} (Nat.castCoe.{succ u2} Cardinal.{u2} Cardinal.hasNatCast.{u2}))) n)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] {n : Nat}, (forall (s : Finset.{u2} M), (LinearIndependent.{u2, u1, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Finset.{u2} M) (Finset.instMembershipFinset.{u2} M) x s)) R M (fun (i : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Finset.{u2} M) (Finset.instMembershipFinset.{u2} M) x s)) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Finset.{u2} M) (Finset.instMembershipFinset.{u2} M) x s) i) _inst_1 _inst_2 _inst_5) -> (LE.le.{0} Nat instLENat (Finset.card.{u2} M s) n)) -> (forall (s : Set.{u2} M), (LinearIndependent.{u2, u1, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s)) R M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s)) _inst_1 _inst_2 _inst_5) -> (LE.le.{succ u2} Cardinal.{u2} Cardinal.instLECardinal.{u2} (Cardinal.mk.{u2} (Set.Elem.{u2} M s)) (Nat.cast.{succ u2} Cardinal.{u2} Cardinal.instNatCastCardinal.{u2} n)))
Case conversion may be inaccurate. Consider using '#align linear_independent_bounded_of_finset_linear_independent_bounded linearIndependent_bounded_of_finset_linearIndependent_boundedₓ'. -/
/-- If every finite set of linearly independent vectors has cardinality at most `n`,
then the same is true for arbitrary sets of linearly independent vectors.
-/
theorem linearIndependent_bounded_of_finset_linearIndependent_bounded {n : ℕ}
    (H : ∀ s : Finset M, (LinearIndependent R fun i : s => (i : M)) → s.card ≤ n) :
    ∀ s : Set M, LinearIndependent R (coe : s → M) → (#s) ≤ n :=
  by
  intro s li
  apply Cardinal.card_le_of
  intro t
  rw [← Finset.card_map (embedding.subtype s)]
  apply H
  apply linearIndependent_finset_map_embedding_subtype _ li
#align linear_independent_bounded_of_finset_linear_independent_bounded linearIndependent_bounded_of_finset_linearIndependent_bounded

section Subtype

/-! The following lemmas use the subtype defined by a set in `M` as the index set `ι`. -/


/- warning: linear_independent_comp_subtype -> linearIndependent_comp_subtype is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] {s : Set.{u1} ι}, Iff (LinearIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) R M (Function.comp.{succ u1, succ u1, succ u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι M v ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x s))))))) _inst_1 _inst_2 _inst_5) (forall (l : Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))), (Membership.Mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) (Submodule.setLike.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) l (Finsupp.supported.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) s)) -> (Eq.{succ u3} M (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) (fun (_x : LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) => (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u1, u3, u2} ι M R _inst_1 _inst_2 _inst_5 v) l) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))))) -> (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) l (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.zero.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] {s : Set.{u3} ι}, Iff (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι s) R M (Function.comp.{succ u3, succ u3, succ u1} (Set.Elem.{u3} ι s) ι M v (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x s))) _inst_1 _inst_2 _inst_5) (forall (l : Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))), (Membership.mem.{max u3 u2, max u2 u3} (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (Submodule.instSetLikeSubmodule.{u2, max u3 u2} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) l (Finsupp.supported.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) s)) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} ι M R _inst_1 _inst_2 _inst_5 v) l) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) _inst_2))))) -> (Eq.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) l (OfNat.ofNat.{max u3 u2} (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) 0 (Zero.toOfNat0.{max u3 u2} (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (Finsupp.zero.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_comp_subtype linearIndependent_comp_subtypeₓ'. -/
theorem linearIndependent_comp_subtype {s : Set ι} :
    LinearIndependent R (v ∘ coe : s → M) ↔
      ∀ l ∈ Finsupp.supported R R s, (Finsupp.total ι M R v) l = 0 → l = 0 :=
  by
  simp only [linearIndependent_iff, (· ∘ ·), Finsupp.mem_supported, Finsupp.total_apply,
    Set.subset_def, Finset.mem_coe]
  constructor
  · intro h l hl₁ hl₂
    have := h (l.subtype_domain s) ((Finsupp.sum_subtypeDomain_index hl₁).trans hl₂)
    exact (Finsupp.subtypeDomain_eq_zero_iff hl₁).1 this
  · intro h l hl
    refine' Finsupp.embDomain_eq_zero.1 (h (l.emb_domain <| Function.Embedding.subtype s) _ _)
    · suffices ∀ i hi, ¬l ⟨i, hi⟩ = 0 → i ∈ s by simpa
      intros
      assumption
    · rwa [Finsupp.embDomain_eq_mapDomain, Finsupp.sum_mapDomain_index]
      exacts[fun _ => zero_smul _ _, fun _ _ _ => add_smul _ _ _]
#align linear_independent_comp_subtype linearIndependent_comp_subtype

/- warning: linear_dependent_comp_subtype' -> linearDependent_comp_subtype' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] {s : Set.{u1} ι}, Iff (Not (LinearIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) R M (Function.comp.{succ u1, succ u1, succ u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι M v ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x s))))))) _inst_1 _inst_2 _inst_5)) (Exists.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (fun (f : Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) => And (Membership.Mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) (Submodule.setLike.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) f (Finsupp.supported.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) s)) (And (Eq.{succ u3} M (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) (fun (_x : LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) => (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u1, u3, u2} ι M R _inst_1 _inst_2 _inst_5 v) f) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))))) (Ne.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) f (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.zero.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] {s : Set.{u3} ι}, Iff (Not (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι s) R M (Function.comp.{succ u3, succ u3, succ u1} (Set.Elem.{u3} ι s) ι M v (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x s))) _inst_1 _inst_2 _inst_5)) (Exists.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (f : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => And (Membership.mem.{max u3 u2, max u2 u3} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (Submodule.instSetLikeSubmodule.{u2, max u3 u2} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) f (Finsupp.supported.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) s)) (And (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) f) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} ι M R _inst_1 _inst_2 _inst_5 v) f) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) f) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) f) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) f) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) f) _inst_2))))) (Ne.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) f (OfNat.ofNat.{max u3 u2} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) 0 (Zero.toOfNat0.{max u3 u2} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.zero.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align linear_dependent_comp_subtype' linearDependent_comp_subtype'ₓ'. -/
theorem linearDependent_comp_subtype' {s : Set ι} :
    ¬LinearIndependent R (v ∘ coe : s → M) ↔
      ∃ f : ι →₀ R, f ∈ Finsupp.supported R R s ∧ Finsupp.total ι M R v f = 0 ∧ f ≠ 0 :=
  by simp [linearIndependent_comp_subtype]
#align linear_dependent_comp_subtype' linearDependent_comp_subtype'

/- warning: linear_dependent_comp_subtype -> linearDependent_comp_subtype is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] {s : Set.{u1} ι}, Iff (Not (LinearIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) R M (Function.comp.{succ u1, succ u1, succ u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι M v ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x s))))))) _inst_1 _inst_2 _inst_5)) (Exists.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (fun (f : Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) => And (Membership.Mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) (Submodule.setLike.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) f (Finsupp.supported.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) s)) (And (Eq.{succ u3} M (Finset.sum.{u3, u1} M ι _inst_2 (Finsupp.support.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) f) (fun (i : ι) => SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_2 _inst_5)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (fun (_x : Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) => ι -> R) (Finsupp.coeFun.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) f i) (v i))) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))))) (Ne.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) f (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.zero.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] {s : Set.{u3} ι}, Iff (Not (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι s) R M (Function.comp.{succ u3, succ u3, succ u1} (Set.Elem.{u3} ι s) ι M v (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x s))) _inst_1 _inst_2 _inst_5)) (Exists.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (f : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => And (Membership.mem.{max u3 u2, max u2 u3} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (Submodule.instSetLikeSubmodule.{u2, max u3 u2} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) f (Finsupp.supported.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) s)) (And (Eq.{succ u1} M (Finset.sum.{u1, u3} M ι _inst_2 (Finsupp.support.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) f) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) M M (instHSMul.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) M (SMulZeroClass.toSMul.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) M (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) M (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2)) (Module.toMulActionWithZero.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) i) M _inst_1 _inst_2 _inst_5))))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) _x) (Finsupp.funLike.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) f i) (v i))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_2))))) (Ne.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) f (OfNat.ofNat.{max u3 u2} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) 0 (Zero.toOfNat0.{max u3 u2} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.zero.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align linear_dependent_comp_subtype linearDependent_comp_subtypeₓ'. -/
/-- A version of `linear_dependent_comp_subtype'` with `finsupp.total` unfolded. -/
theorem linearDependent_comp_subtype {s : Set ι} :
    ¬LinearIndependent R (v ∘ coe : s → M) ↔
      ∃ f : ι →₀ R, f ∈ Finsupp.supported R R s ∧ (∑ i in f.support, f i • v i) = 0 ∧ f ≠ 0 :=
  linearDependent_comp_subtype'
#align linear_dependent_comp_subtype linearDependent_comp_subtype

/- warning: linear_independent_subtype -> linearIndependent_subtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Iff (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s))))) x) _inst_1 _inst_2 _inst_5) (forall (l : Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))), (Membership.Mem.{max u2 u1, max u2 u1} (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.hasMem.{max u2 u1, max u2 u1} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (Submodule.setLike.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) l (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) -> (Eq.{succ u2} M (coeFn.{max (succ (max u2 u1)) (succ u2), max (succ (max u2 u1)) (succ u2)} (LinearMap.{u1, u1, max u2 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5) (fun (_x : LinearMap.{u1, u1, max u2 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5) => (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u2 u1, u2} R R (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u2, u2, u1} M M R _inst_1 _inst_2 _inst_5 (id.{succ u2} M)) l) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) -> (Eq.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) l (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) 0 (OfNat.mk.{max u2 u1} (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) 0 (Zero.zero.{max u2 u1} (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Finsupp.zero.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Iff (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} M s) R M (fun (x : Set.Elem.{u2} M s) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s) x) _inst_1 _inst_2 _inst_5) (forall (l : Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))), (Membership.mem.{max u1 u2, max u1 u2} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.instSetLikeSubmodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) l (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) l) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), succ u2} (LinearMap.{u1, u1, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5) (Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (fun (_x : Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u1 u2, u2} R R (Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u2, u2, u1} M M R _inst_1 _inst_2 _inst_5 (id.{succ u2} M)) l) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) l) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) l) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) l) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) l) _inst_2))))) -> (Eq.{max (succ u1) (succ u2)} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) l (OfNat.ofNat.{max u1 u2} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) 0 (Zero.toOfNat0.{max u1 u2} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Finsupp.zero.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_subtype linearIndependent_subtypeₓ'. -/
theorem linearIndependent_subtype {s : Set M} :
    LinearIndependent R (fun x => x : s → M) ↔
      ∀ l ∈ Finsupp.supported R R s, (Finsupp.total M M R id) l = 0 → l = 0 :=
  by apply @linearIndependent_comp_subtype _ _ _ id
#align linear_independent_subtype linearIndependent_subtype

/- warning: linear_independent_comp_subtype_disjoint -> linearIndependent_comp_subtype_disjoint is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] {s : Set.{u1} ι}, Iff (LinearIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) R M (Function.comp.{succ u1, succ u1, succ u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι M v ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x s))))))) _inst_1 _inst_2 _inst_5) (Disjoint.{max u1 u2} (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) (Submodule.setLike.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) (Submodule.orderBot.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.supported.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) s) (LinearMap.ker.{u2, u2, max u1 u2, u3, max (max u1 u2) u3} R R (Finsupp.{u1, u2} ι R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (LinearMap.{u2, u2, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) (LinearMap.semilinearMapClass.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u1, u3, u2} ι M R _inst_1 _inst_2 _inst_5 v)))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] {s : Set.{u3} ι}, Iff (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι s) R M (Function.comp.{succ u3, succ u3, succ u1} (Set.Elem.{u3} ι s) ι M v (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x s))) _inst_1 _inst_2 _inst_5) (Disjoint.{max u2 u3} (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Submodule.completeLattice.{u2, max u3 u2} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, max u3 u2} R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.supported.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) s) (LinearMap.ker.{u2, u2, max u3 u2, u1, max (max u3 u2) u1} R R (Finsupp.{u3, u2} ι R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u2, u2} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} ι M R _inst_1 _inst_2 _inst_5 v)))
Case conversion may be inaccurate. Consider using '#align linear_independent_comp_subtype_disjoint linearIndependent_comp_subtype_disjointₓ'. -/
theorem linearIndependent_comp_subtype_disjoint {s : Set ι} :
    LinearIndependent R (v ∘ coe : s → M) ↔
      Disjoint (Finsupp.supported R R s) (Finsupp.total ι M R v).ker :=
  by rw [linearIndependent_comp_subtype, LinearMap.disjoint_ker]
#align linear_independent_comp_subtype_disjoint linearIndependent_comp_subtype_disjoint

/- warning: linear_independent_subtype_disjoint -> linearIndependent_subtype_disjoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Iff (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s))))) x) _inst_1 _inst_2 _inst_5) (Disjoint.{max u2 u1} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.partialOrder.{max u2 u1, max u2 u1} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (Submodule.setLike.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Submodule.orderBot.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s) (LinearMap.ker.{u1, u1, max u2 u1, u2, max u2 u1} R R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5) (LinearMap.semilinearMapClass.{u1, u1, max u2 u1, u2} R R (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u2, u2, u1} M M R _inst_1 _inst_2 _inst_5 (id.{succ u2} M))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Iff (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} M s) R M (fun (x : Set.Elem.{u2} M s) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s) x) _inst_1 _inst_2 _inst_5) (Disjoint.{max u1 u2} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (OmegaCompletePartialOrder.toPartialOrder.{max u1 u2} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (CompleteLattice.instOmegaCompletePartialOrder.{max u1 u2} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Submodule.completeLattice.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s) (LinearMap.ker.{u1, u1, max u1 u2, u2, max u1 u2} R R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u1 u2, u2} R R (Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u2, u2, u1} M M R _inst_1 _inst_2 _inst_5 (id.{succ u2} M))))
Case conversion may be inaccurate. Consider using '#align linear_independent_subtype_disjoint linearIndependent_subtype_disjointₓ'. -/
theorem linearIndependent_subtype_disjoint {s : Set M} :
    LinearIndependent R (fun x => x : s → M) ↔
      Disjoint (Finsupp.supported R R s) (Finsupp.total M M R id).ker :=
  by apply @linearIndependent_comp_subtype_disjoint _ _ _ id
#align linear_independent_subtype_disjoint linearIndependent_subtype_disjoint

/- warning: linear_independent_iff_total_on -> linearIndependent_iff_totalOn is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Iff (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s))))) x) _inst_1 _inst_2 _inst_5) (Eq.{succ (max u2 u1)} (Submodule.{u1, max u2 u1} R (coeSort.{succ (max u2 u1), succ (succ (max u2 u1))} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) Type.{max u2 u1} (SetLike.hasCoeToSort.{max u2 u1, max u2 u1} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (Submodule.setLike.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) _inst_1 (Submodule.addCommMonoid.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.module.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) (LinearMap.ker.{u1, u1, max u2 u1, u2, max u2 u1} R R (coeSort.{succ (max u2 u1), succ (succ (max u2 u1))} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) Type.{max u2 u1} (SetLike.hasCoeToSort.{max u2 u1, max u2 u1} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (Submodule.setLike.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_5)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) _inst_1 _inst_1 (Submodule.addCommMonoid.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (Submodule.module.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (coeSort.{succ (max u2 u1), succ (succ (max u2 u1))} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) Type.{max u2 u1} (SetLike.hasCoeToSort.{max u2 u1, max u2 u1} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (Submodule.setLike.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_5)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (Submodule.addCommMonoid.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (Submodule.module.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s)))) (LinearMap.semilinearMapClass.{u1, u1, max u2 u1, u2} R R (coeSort.{succ (max u2 u1), succ (succ (max u2 u1))} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) Type.{max u2 u1} (SetLike.hasCoeToSort.{max u2 u1, max u2 u1} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (Submodule.setLike.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_5)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) _inst_1 _inst_1 (Submodule.addCommMonoid.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (Submodule.module.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.totalOn.{u2, u2, u1} M M R _inst_1 _inst_2 _inst_5 (id.{succ u2} M) s)) (Bot.bot.{max u2 u1} (Submodule.{u1, max u2 u1} R (coeSort.{succ (max u2 u1), succ (succ (max u2 u1))} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) Type.{max u2 u1} (SetLike.hasCoeToSort.{max u2 u1, max u2 u1} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (Submodule.setLike.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) _inst_1 (Submodule.addCommMonoid.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.module.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) (Submodule.hasBot.{u1, max u2 u1} R (coeSort.{succ (max u2 u1), succ (succ (max u2 u1))} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) Type.{max u2 u1} (SetLike.hasCoeToSort.{max u2 u1, max u2 u1} (Submodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (Submodule.setLike.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) _inst_1 (Submodule.addCommMonoid.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.module.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_5 : Module.{u1, u2} R M _inst_1 _inst_2] {s : Set.{u2} M}, Iff (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} M s) R M (fun (x : Set.Elem.{u2} M s) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s) x) _inst_1 _inst_2 _inst_5) (Eq.{max (succ u1) (succ u2)} (Submodule.{u1, max u1 u2} R (Subtype.{succ (max u2 u1)} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (x : Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) => Membership.mem.{max u2 u1, max u2 u1} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.instSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) x (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) (LinearMap.ker.{u1, u1, max u1 u2, u2, max u1 u2} R R (Subtype.{succ (max u2 u1)} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (x : Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) => Membership.mem.{max u2 u1, max u2 u1} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.instSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) x (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_5)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s)))) _inst_1 _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Subtype.{succ (max u2 u1)} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (x : Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) => Membership.mem.{max u2 u1, max u2 u1} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.instSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) x (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_5)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s)))) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u1 u2, u2} R R (Subtype.{succ (max u2 u1)} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (x : Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) => Membership.mem.{max u2 u1, max u2 u1} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.instSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) x (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_5)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s)))) _inst_1 _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_5 (Set.image.{u2, u2} M M (id.{succ u2} M) s))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.totalOn.{u2, u2, u1} M M R _inst_1 _inst_2 _inst_5 (id.{succ u2} M) s)) (Bot.bot.{max u1 u2} (Submodule.{u1, max u1 u2} R (Subtype.{succ (max u2 u1)} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (x : Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) => Membership.mem.{max u2 u1, max u2 u1} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.instSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) x (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) (Submodule.instBotSubmodule.{u1, max u1 u2} R (Subtype.{succ (max u2 u1)} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (x : Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) => Membership.mem.{max u2 u1, max u2 u1} (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.instSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) x (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u1} R (Finsupp.{u2, u1} M R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)))))
Case conversion may be inaccurate. Consider using '#align linear_independent_iff_total_on linearIndependent_iff_totalOnₓ'. -/
theorem linearIndependent_iff_totalOn {s : Set M} :
    LinearIndependent R (fun x => x : s → M) ↔ (Finsupp.totalOn M M R id s).ker = ⊥ := by
  rw [Finsupp.totalOn, LinearMap.ker, LinearMap.comap_codRestrict, map_bot, comap_bot,
    LinearMap.ker_comp, linearIndependent_subtype_disjoint, disjoint_iff_inf_le, ←
    map_comap_subtype, map_le_iff_le_comap, comap_bot, ker_subtype, le_bot_iff]
#align linear_independent_iff_total_on linearIndependent_iff_totalOn

/- warning: linear_independent.restrict_of_comp_subtype -> LinearIndependent.restrict_of_comp_subtype is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} R M _inst_1 _inst_2] {s : Set.{u1} ι}, (LinearIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) R M (Function.comp.{succ u1, succ u1, succ u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι M v ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x s))))))) _inst_1 _inst_2 _inst_5) -> (LinearIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) s) R M (Set.restrict.{u1, u3} ι (fun (ᾰ : ι) => M) s v) _inst_1 _inst_2 _inst_5)
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_5 : Module.{u2, u1} R M _inst_1 _inst_2] {s : Set.{u3} ι}, (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι s) R M (Function.comp.{succ u3, succ u3, succ u1} (Set.Elem.{u3} ι s) ι M v (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x s))) _inst_1 _inst_2 _inst_5) -> (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι s) R M (Set.restrict.{u3, u1} ι (fun (ᾰ : ι) => M) s v) _inst_1 _inst_2 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.restrict_of_comp_subtype LinearIndependent.restrict_of_comp_subtypeₓ'. -/
theorem LinearIndependent.restrict_of_comp_subtype {s : Set ι}
    (hs : LinearIndependent R (v ∘ coe : s → M)) : LinearIndependent R (s.restrict v) :=
  hs
#align linear_independent.restrict_of_comp_subtype LinearIndependent.restrict_of_comp_subtype

variable (R M)

#print linearIndependent_empty /-
theorem linearIndependent_empty : LinearIndependent R (fun x => x : (∅ : Set M) → M) := by
  simp [linearIndependent_subtype_disjoint]
#align linear_independent_empty linearIndependent_empty
-/

variable {R M}

#print LinearIndependent.mono /-
theorem LinearIndependent.mono {t s : Set M} (h : t ⊆ s) :
    LinearIndependent R (fun x => x : s → M) → LinearIndependent R (fun x => x : t → M) :=
  by
  simp only [linearIndependent_subtype_disjoint]
  exact Disjoint.mono_left (Finsupp.supported_mono h)
#align linear_independent.mono LinearIndependent.mono
-/

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/
#print linearIndependent_of_finite /-
theorem linearIndependent_of_finite (s : Set M)
    (H : ∀ (t) (_ : t ⊆ s), Set.Finite t → LinearIndependent R (fun x => x : t → M)) :
    LinearIndependent R (fun x => x : s → M) :=
  linearIndependent_subtype.2 fun l hl =>
    linearIndependent_subtype.1 (H _ hl (Finset.finite_toSet _)) l (Subset.refl _)
#align linear_independent_of_finite linearIndependent_of_finite
-/

#print linearIndependent_unionᵢ_of_directed /-
theorem linearIndependent_unionᵢ_of_directed {η : Type _} {s : η → Set M} (hs : Directed (· ⊆ ·) s)
    (h : ∀ i, LinearIndependent R (fun x => x : s i → M)) :
    LinearIndependent R (fun x => x : (⋃ i, s i) → M) :=
  by
  by_cases hη : Nonempty η
  · skip
    refine' linearIndependent_of_finite (⋃ i, s i) fun t ht ft => _
    rcases finite_subset_Union ft ht with ⟨I, fi, hI⟩
    rcases hs.finset_le fi.to_finset with ⟨i, hi⟩
    exact (h i).mono (subset.trans hI <| Union₂_subset fun j hj => hi j (fi.mem_to_finset.2 hj))
  · refine' (linearIndependent_empty _ _).mono _
    rintro _ ⟨_, ⟨i, _⟩, _⟩
    exact hη ⟨i⟩
#align linear_independent_Union_of_directed linearIndependent_unionᵢ_of_directed
-/

#print linearIndependent_unionₛ_of_directed /-
theorem linearIndependent_unionₛ_of_directed {s : Set (Set M)} (hs : DirectedOn (· ⊆ ·) s)
    (h : ∀ a ∈ s, LinearIndependent R (fun x => x : (a : Set M) → M)) :
    LinearIndependent R (fun x => x : ⋃₀ s → M) := by
  rw [sUnion_eq_Union] <;>
    exact linearIndependent_unionᵢ_of_directed hs.directed_coe (by simpa using h)
#align linear_independent_sUnion_of_directed linearIndependent_unionₛ_of_directed
-/

#print linearIndependent_bunionᵢ_of_directed /-
theorem linearIndependent_bunionᵢ_of_directed {η} {s : Set η} {t : η → Set M}
    (hs : DirectedOn (t ⁻¹'o (· ⊆ ·)) s) (h : ∀ a ∈ s, LinearIndependent R (fun x => x : t a → M)) :
    LinearIndependent R (fun x => x : (⋃ a ∈ s, t a) → M) := by
  rw [bUnion_eq_Union] <;>
    exact
      linearIndependent_unionᵢ_of_directed (directed_comp.2 <| hs.directed_coe) (by simpa using h)
#align linear_independent_bUnion_of_directed linearIndependent_bunionᵢ_of_directed
-/

end Subtype

end Module

/-! ### Properties which require `ring R` -/


section Module

variable {v : ι → M}

variable [Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M'']

variable [Module R M] [Module R M'] [Module R M'']

variable {a b : R} {x y : M}

/- warning: linear_independent_iff_injective_total -> linearIndependent_iff_injective_total is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)], Iff (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (Function.Injective.{max (succ u1) (succ u2), succ u3} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) (fun (_x : LinearMap.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) => (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Finsupp.total.{u1, u3, u2} ι M R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 v)))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)], Iff (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Function.Injective.{max (succ u3) (succ u2), succ u1} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (fun (_x : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Finsupp.total.{u3, u1, u2} ι M R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 v)))
Case conversion may be inaccurate. Consider using '#align linear_independent_iff_injective_total linearIndependent_iff_injective_totalₓ'. -/
theorem linearIndependent_iff_injective_total :
    LinearIndependent R v ↔ Function.Injective (Finsupp.total ι M R v) :=
  linearIndependent_iff.trans
    (injective_iff_map_eq_zero (Finsupp.total ι M R v).toAddMonoidHom).symm
#align linear_independent_iff_injective_total linearIndependent_iff_injective_total

/- warning: linear_independent.injective_total -> LinearIndependent.injective_total is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)], (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (Function.Injective.{max (succ u1) (succ u2), succ u3} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) (fun (_x : LinearMap.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) => (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Finsupp.total.{u1, u3, u2} ι M R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 v)))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)], (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (Function.Injective.{max (succ u3) (succ u2), succ u1} (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (fun (_x : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Finsupp.total.{u3, u1, u2} ι M R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 v)))
Case conversion may be inaccurate. Consider using '#align linear_independent.injective_total LinearIndependent.injective_totalₓ'. -/
alias linearIndependent_iff_injective_total ↔ LinearIndependent.injective_total _
#align linear_independent.injective_total LinearIndependent.injective_total

/- warning: linear_independent.injective -> LinearIndependent.injective is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] [_inst_8 : Nontrivial.{u2} R], (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (Function.Injective.{succ u1, succ u3} ι M v)
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_8 : Nontrivial.{u2} R], (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (Function.Injective.{succ u3, succ u1} ι M v)
Case conversion may be inaccurate. Consider using '#align linear_independent.injective LinearIndependent.injectiveₓ'. -/
theorem LinearIndependent.injective [Nontrivial R] (hv : LinearIndependent R v) : Injective v :=
  by
  intro i j hij
  let l : ι →₀ R := Finsupp.single i (1 : R) - Finsupp.single j 1
  have h_total : Finsupp.total ι M R v l = 0 :=
    by
    simp_rw [LinearMap.map_sub, Finsupp.total_apply]
    simp [hij]
  have h_single_eq : Finsupp.single i (1 : R) = Finsupp.single j 1 :=
    by
    rw [linearIndependent_iff] at hv
    simp [eq_add_of_sub_eq' (hv l h_total)]
  simpa [Finsupp.single_eq_single_iff] using h_single_eq
#align linear_independent.injective LinearIndependent.injective

/- warning: linear_independent.to_subtype_range -> LinearIndependent.to_subtype_range is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {ι : Type.{u3}} {f : ι -> M}, (LinearIndependent.{u3, u1, u2} ι R M f (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.range.{u2, succ u3} M ι f)) R M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.range.{u2, succ u3} M ι f)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.range.{u2, succ u3} M ι f)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.range.{u2, succ u3} M ι f)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.range.{u2, succ u3} M ι f)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x (Set.range.{u2, succ u3} M ι f))))))) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {ι : Type.{u3}} {f : ι -> M}, (LinearIndependent.{u3, u2, u1} ι R M f (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (LinearIndependent.{u1, u2, u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (Set.range.{u1, succ u3} M ι f))) R M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (Set.range.{u1, succ u3} M ι f))) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.to_subtype_range LinearIndependent.to_subtype_rangeₓ'. -/
theorem LinearIndependent.to_subtype_range {ι} {f : ι → M} (hf : LinearIndependent R f) :
    LinearIndependent R (coe : range f → M) :=
  by
  nontriviality R
  exact (linearIndependent_subtype_range hf.injective).2 hf
#align linear_independent.to_subtype_range LinearIndependent.to_subtype_range

/- warning: linear_independent.to_subtype_range' -> LinearIndependent.to_subtype_range' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {ι : Type.{u3}} {f : ι -> M}, (LinearIndependent.{u3, u1, u2} ι R M f (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (forall {t : Set.{u2} M}, (Eq.{succ u2} (Set.{u2} M) (Set.range.{u2, succ u3} M ι f) t) -> (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) R M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x t)))))) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {ι : Type.{u3}} {f : ι -> M}, (LinearIndependent.{u3, u2, u1} ι R M f (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (forall {t : Set.{u1} M}, (Eq.{succ u1} (Set.{u1} M) (Set.range.{u1, succ u3} M ι f) t) -> (LinearIndependent.{u1, u2, u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x t)) R M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x t)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))
Case conversion may be inaccurate. Consider using '#align linear_independent.to_subtype_range' LinearIndependent.to_subtype_range'ₓ'. -/
theorem LinearIndependent.to_subtype_range' {ι} {f : ι → M} (hf : LinearIndependent R f) {t}
    (ht : range f = t) : LinearIndependent R (coe : t → M) :=
  ht ▸ hf.to_subtype_range
#align linear_independent.to_subtype_range' LinearIndependent.to_subtype_range'

/- warning: linear_independent.image_of_comp -> LinearIndependent.image_of_comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {ι : Type.{u3}} {ι' : Type.{u4}} (s : Set.{u3} ι) (f : ι -> ι') (g : ι' -> M), (LinearIndependent.{u3, u1, u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R M (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) => g (f ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeSubtype.{succ u3} ι (fun (x : ι) => Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) x s))))) x))) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (LinearIndependent.{u4, u1, u2} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) R M (fun (x : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) => g ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) ι' (HasLiftT.mk.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) ι' (CoeTCₓ.coe.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) ι' (coeBase.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι') Type.{u4} (Set.hasCoeToSort.{u4} ι') (Set.image.{u3, u4} ι ι' f s)) ι' (coeSubtype.{succ u4} ι' (fun (x : ι') => Membership.Mem.{u4, u4} ι' (Set.{u4} ι') (Set.hasMem.{u4} ι') x (Set.image.{u3, u4} ι ι' f s)))))) x)) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {ι : Type.{u4}} {ι' : Type.{u3}} (s : Set.{u4} ι) (f : ι -> ι') (g : ι' -> M), (LinearIndependent.{u4, u2, u1} (Set.Elem.{u4} ι s) R M (fun (x : Set.Elem.{u4} ι s) => g (f (Subtype.val.{succ u4} ι (fun (x : ι) => Membership.mem.{u4, u4} ι (Set.{u4} ι) (Set.instMembershipSet.{u4} ι) x s) x))) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι' (Set.image.{u4, u3} ι ι' f s)) R M (fun (x : Set.Elem.{u3} ι' (Set.image.{u4, u3} ι ι' f s)) => g (Subtype.val.{succ u3} ι' (fun (x : ι') => Membership.mem.{u3, u3} ι' (Set.{u3} ι') (Set.instMembershipSet.{u3} ι') x (Set.image.{u4, u3} ι ι' f s)) x)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.image_of_comp LinearIndependent.image_of_compₓ'. -/
theorem LinearIndependent.image_of_comp {ι ι'} (s : Set ι) (f : ι → ι') (g : ι' → M)
    (hs : LinearIndependent R fun x : s => g (f x)) : LinearIndependent R fun x : f '' s => g x :=
  by
  nontriviality R
  have : inj_on f s := inj_on_iff_injective.2 hs.injective.of_comp
  exact (linearIndependent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs
#align linear_independent.image_of_comp LinearIndependent.image_of_comp

/- warning: linear_independent.image -> LinearIndependent.image is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {ι : Type.{u3}} {s : Set.{u3} ι} {f : ι -> M}, (LinearIndependent.{u3, u1, u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) R M (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) => f ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeSubtype.{succ u3} ι (fun (x : ι) => Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) x s))))) x)) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.image.{u3, u2} ι M f s)) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.image.{u3, u2} ι M f s)) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.image.{u3, u2} ι M f s)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.image.{u3, u2} ι M f s)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.image.{u3, u2} ι M f s)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.image.{u3, u2} ι M f s)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x (Set.image.{u3, u2} ι M f s)))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {ι : Type.{u3}} {s : Set.{u3} ι} {f : ι -> M}, (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι s) R M (fun (x : Set.Elem.{u3} ι s) => f (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x s) x)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (LinearIndependent.{u1, u2, u1} (Set.Elem.{u1} M (Set.image.{u3, u1} ι M f s)) R M (fun (x : Set.Elem.{u1} M (Set.image.{u3, u1} ι M f s)) => Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (Set.image.{u3, u1} ι M f s)) x) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.image LinearIndependent.imageₓ'. -/
theorem LinearIndependent.image {ι} {s : Set ι} {f : ι → M}
    (hs : LinearIndependent R fun x : s => f x) : LinearIndependent R fun x : f '' s => (x : M) :=
  by convert LinearIndependent.image_of_comp s f id hs
#align linear_independent.image LinearIndependent.image

/- warning: linear_independent.group_smul -> LinearIndependent.group_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] {G : Type.{u4}} [hG : Group.{u4} G] [_inst_8 : DistribMulAction.{u4, u2} G R (DivInvMonoid.toMonoid.{u4} G (Group.toDivInvMonoid.{u4} G hG)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))] [_inst_9 : DistribMulAction.{u4, u3} G M (DivInvMonoid.toMonoid.{u4} G (Group.toDivInvMonoid.{u4} G hG)) (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_2)))] [_inst_10 : IsScalarTower.{u4, u2, u3} G R M (SMulZeroClass.toHasSmul.{u4, u2} G R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (DistribSMul.toSmulZeroClass.{u4, u2} G R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (DistribMulAction.toDistribSMul.{u4, u2} G R (DivInvMonoid.toMonoid.{u4} G (Group.toDivInvMonoid.{u4} G hG)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) _inst_8))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (Module.toMulActionWithZero.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)))) (SMulZeroClass.toHasSmul.{u4, u3} G M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_2))))) (DistribSMul.toSmulZeroClass.{u4, u3} G M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_2)))) (DistribMulAction.toDistribSMul.{u4, u3} G M (DivInvMonoid.toMonoid.{u4} G (Group.toDivInvMonoid.{u4} G hG)) (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_2))) _inst_9)))] [_inst_11 : SMulCommClass.{u4, u2, u3} G R M (SMulZeroClass.toHasSmul.{u4, u3} G M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_2))))) (DistribSMul.toSmulZeroClass.{u4, u3} G M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_2)))) (DistribMulAction.toDistribSMul.{u4, u3} G M (DivInvMonoid.toMonoid.{u4} G (Group.toDivInvMonoid.{u4} G hG)) (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_2))) _inst_9))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (Module.toMulActionWithZero.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5))))] {v : ι -> M}, (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (forall (w : ι -> G), LinearIndependent.{u1, u2, u3} ι R M (SMul.smul.{max u1 u4, max u1 u3} (ι -> G) (ι -> M) (Pi.smul'.{u1, u4, u3} ι (fun (ᾰ : ι) => G) (fun (ᾰ : ι) => M) (fun (i : ι) => SMulZeroClass.toHasSmul.{u4, u3} G M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_2))))) (DistribSMul.toSmulZeroClass.{u4, u3} G M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_2)))) (DistribMulAction.toDistribSMul.{u4, u3} G M (DivInvMonoid.toMonoid.{u4} G (Group.toDivInvMonoid.{u4} G hG)) (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_2))) _inst_9)))) w v) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)
but is expected to have type
  forall {ι : Type.{u4}} {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {G : Type.{u3}} [hG : Group.{u3} G] [_inst_8 : DistribMulAction.{u3, u2} G R (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G hG)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_1)))] [_inst_9 : DistribMulAction.{u3, u1} G M (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G hG)) (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))] [_inst_10 : IsScalarTower.{u3, u2, u1} G R M (SMulZeroClass.toSMul.{u3, u2} G R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (DistribSMul.toSMulZeroClass.{u3, u2} G R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_1)))) (DistribMulAction.toDistribSMul.{u3, u2} G R (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G hG)) (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R _inst_1))) _inst_8))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)))) (SMulZeroClass.toSMul.{u3, u1} G M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (DistribSMul.toSMulZeroClass.{u3, u1} G M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))) (DistribMulAction.toDistribSMul.{u3, u1} G M (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G hG)) (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) _inst_9)))] [_inst_11 : SMulCommClass.{u3, u2, u1} G R M (SMulZeroClass.toSMul.{u3, u1} G M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (DistribSMul.toSMulZeroClass.{u3, u1} G M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))) (DistribMulAction.toDistribSMul.{u3, u1} G M (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G hG)) (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) _inst_9))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))))] {v : ι -> M}, (LinearIndependent.{u4, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (forall (w : ι -> G), LinearIndependent.{u4, u2, u1} ι R M (HSMul.hSMul.{max u4 u3, max u4 u1, max u4 u1} (ι -> G) (ι -> M) (ι -> M) (instHSMul.{max u4 u3, max u4 u1} (ι -> G) (ι -> M) (Pi.smul'.{u4, u3, u1} ι (fun (a._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.6561 : ι) => G) (fun (a._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.6555 : ι) => M) (fun (i : ι) => SMulZeroClass.toSMul.{u3, u1} G M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (DistribSMul.toSMulZeroClass.{u3, u1} G M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2)))) (DistribMulAction.toDistribSMul.{u3, u1} G M (DivInvMonoid.toMonoid.{u3} G (Group.toDivInvMonoid.{u3} G hG)) (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_2))) _inst_9))))) w v) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.group_smul LinearIndependent.group_smulₓ'. -/
theorem LinearIndependent.group_smul {G : Type _} [hG : Group G] [DistribMulAction G R]
    [DistribMulAction G M] [IsScalarTower G R M] [SMulCommClass G R M] {v : ι → M}
    (hv : LinearIndependent R v) (w : ι → G) : LinearIndependent R (w • v) :=
  by
  rw [linearIndependent_iff''] at hv⊢
  intro s g hgs hsum i
  refine' (smul_eq_zero_iff_eq (w i)).1 _
  refine' hv s (fun i => w i • g i) (fun i hi => _) _ i
  · dsimp only
    exact (hgs i hi).symm ▸ smul_zero _
  · rw [← hsum, Finset.sum_congr rfl _]
    intros
    erw [Pi.smul_apply, smul_assoc, smul_comm]
#align linear_independent.group_smul LinearIndependent.group_smul

/- warning: linear_independent.units_smul -> LinearIndependent.units_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] {v : ι -> M}, (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (forall (w : ι -> (Units.{u2} R (Ring.toMonoid.{u2} R _inst_1))), LinearIndependent.{u1, u2, u3} ι R M (SMul.smul.{max u1 u2, max u1 u3} (ι -> (Units.{u2} R (Ring.toMonoid.{u2} R _inst_1))) (ι -> M) (Pi.smul'.{u1, u2, u3} ι (fun (ᾰ : ι) => Units.{u2} R (Ring.toMonoid.{u2} R _inst_1)) (fun (ᾰ : ι) => M) (fun (i : ι) => Units.hasSmul.{u2, u3} R M (Ring.toMonoid.{u2} R _inst_1) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (Module.toMulActionWithZero.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)))))) w v) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {v : ι -> M}, (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (forall (w : ι -> (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))), LinearIndependent.{u3, u2, u1} ι R M (HSMul.hSMul.{max u3 u2, max u3 u1, max u3 u1} (ι -> (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (ι -> M) (ι -> M) (instHSMul.{max u3 u2, max u3 u1} (ι -> (Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (ι -> M) (Pi.smul'.{u3, u2, u1} ι (fun (a._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.6791 : ι) => Units.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (fun (a._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.6785 : ι) => M) (fun (i : ι) => Units.instSMulUnits.{u2, u1} R M (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))))))) w v) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.units_smul LinearIndependent.units_smulₓ'. -/
-- This lemma cannot be proved with `linear_independent.group_smul` since the action of
-- `Rˣ` on `R` is not commutative.
theorem LinearIndependent.units_smul {v : ι → M} (hv : LinearIndependent R v) (w : ι → Rˣ) :
    LinearIndependent R (w • v) :=
  by
  rw [linearIndependent_iff''] at hv⊢
  intro s g hgs hsum i
  rw [← (w i).mul_left_eq_zero]
  refine' hv s (fun i => g i • w i) (fun i hi => _) _ i
  · dsimp only
    exact (hgs i hi).symm ▸ zero_smul _ _
  · rw [← hsum, Finset.sum_congr rfl _]
    intros
    erw [Pi.smul_apply, smul_assoc]
    rfl
#align linear_independent.units_smul LinearIndependent.units_smul

section Maximal

universe v w

#print LinearIndependent.Maximal /-
/--
A linearly independent family is maximal if there is no strictly larger linearly independent family.
-/
@[nolint unused_arguments]
def LinearIndependent.Maximal {ι : Type w} {R : Type u} [Semiring R] {M : Type v} [AddCommMonoid M]
    [Module R M] {v : ι → M} (i : LinearIndependent R v) : Prop :=
  ∀ (s : Set M) (i' : LinearIndependent R (coe : s → M)) (h : range v ≤ s), range v = s
#align linear_independent.maximal LinearIndependent.Maximal
-/

#print LinearIndependent.maximal_iff /-
/-- An alternative characterization of a maximal linearly independent family,
quantifying over types (in the same universe as `M`) into which the indexing family injects.
-/
theorem LinearIndependent.maximal_iff {ι : Type w} {R : Type u} [Ring R] [Nontrivial R] {M : Type v}
    [AddCommGroup M] [Module R M] {v : ι → M} (i : LinearIndependent R v) :
    i.Maximal ↔
      ∀ (κ : Type v) (w : κ → M) (i' : LinearIndependent R w) (j : ι → κ) (h : w ∘ j = v),
        Surjective j :=
  by
  fconstructor
  · rintro p κ w i' j rfl
    specialize p (range w) i'.coe_range (range_comp_subset_range _ _)
    rw [range_comp, ← @image_univ _ _ w] at p
    exact range_iff_surjective.mp (image_injective.mpr i'.injective p)
  · intro p w i' h
    specialize
      p w (coe : w → M) i' (fun i => ⟨v i, range_subset_iff.mp h i⟩)
        (by
          ext
          simp)
    have q := congr_arg (fun s => (coe : w → M) '' s) p.range_eq
    dsimp at q
    rw [← image_univ, image_image] at q
    simpa using q
#align linear_independent.maximal_iff LinearIndependent.maximal_iff
-/

end Maximal

/- warning: linear_independent.eq_of_smul_apply_eq_smul_apply -> LinearIndependent.eq_of_smul_apply_eq_smul_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {M : Type.{u3}} [_inst_8 : AddCommGroup.{u3} M] [_inst_9 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)] {v : ι -> M}, (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_9) -> (forall (c : R) (d : R) (i : ι) (j : ι), (Ne.{succ u2} R c (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))))))) -> (Eq.{succ u3} M (SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)))) (Module.toMulActionWithZero.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_9)))) c (v i)) (SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_8)))) (Module.toMulActionWithZero.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_8) _inst_9)))) d (v j))) -> (Eq.{succ u1} ι i j))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {M : Type.{u2}} [_inst_8 : AddCommGroup.{u2} M] [_inst_9 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8)] {v : ι -> M}, (LinearIndependent.{u3, u1, u2} ι R M v (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9) -> (forall (c : R) (d : R) (i : ι) (j : ι), (Ne.{succ u1} R c (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))))) -> (Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_8))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_8))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_8))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9))))) c (v i)) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_8))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_8))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_8))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_8) _inst_9))))) d (v j))) -> (Eq.{succ u3} ι i j))
Case conversion may be inaccurate. Consider using '#align linear_independent.eq_of_smul_apply_eq_smul_apply LinearIndependent.eq_of_smul_apply_eq_smul_applyₓ'. -/
/-- Linear independent families are injective, even if you multiply either side. -/
theorem LinearIndependent.eq_of_smul_apply_eq_smul_apply {M : Type _} [AddCommGroup M] [Module R M]
    {v : ι → M} (li : LinearIndependent R v) (c d : R) (i j : ι) (hc : c ≠ 0)
    (h : c • v i = d • v j) : i = j :=
  by
  let l : ι →₀ R := Finsupp.single i c - Finsupp.single j d
  have h_total : Finsupp.total ι M R v l = 0 :=
    by
    simp_rw [LinearMap.map_sub, Finsupp.total_apply]
    simp [h]
  have h_single_eq : Finsupp.single i c = Finsupp.single j d :=
    by
    rw [linearIndependent_iff] at li
    simp [eq_add_of_sub_eq' (li l h_total)]
  rcases(Finsupp.single_eq_single_iff _ _ _ _).mp h_single_eq with (⟨this, _⟩ | ⟨hc, _⟩)
  · exact this
  · contradiction
#align linear_independent.eq_of_smul_apply_eq_smul_apply LinearIndependent.eq_of_smul_apply_eq_smul_apply

section Subtype

/-! The following lemmas use the subtype defined by a set in `M` as the index set `ι`. -/


/- warning: linear_independent.disjoint_span_image -> LinearIndependent.disjoint_span_image is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)], (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (forall {s : Set.{u1} ι} {t : Set.{u1} ι}, (Disjoint.{u1} (Set.{u1} ι) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} ι) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} ι) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} ι) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} ι) (Set.completeBooleanAlgebra.{u1} ι)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} ι) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} ι) (Set.booleanAlgebra.{u1} ι))) s t) -> (Disjoint.{u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (SetLike.partialOrder.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.orderBot.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.image.{u1, u3} ι M v s)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.image.{u1, u3} ι M v t))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)], (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (forall {s : Set.{u3} ι} {t : Set.{u3} ι}, (Disjoint.{u3} (Set.{u3} ι) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} ι) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))) (BoundedOrder.toOrderBot.{u3} (Set.{u3} ι) (Preorder.toLE.{u3} (Set.{u3} ι) (PartialOrder.toPreorder.{u3} (Set.{u3} ι) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} ι) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))))) (CompleteLattice.toBoundedOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))) s t) -> (Disjoint.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.image.{u3, u1} ι M v s)) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.image.{u3, u1} ι M v t))))
Case conversion may be inaccurate. Consider using '#align linear_independent.disjoint_span_image LinearIndependent.disjoint_span_imageₓ'. -/
theorem LinearIndependent.disjoint_span_image (hv : LinearIndependent R v) {s t : Set ι}
    (hs : Disjoint s t) : Disjoint (Submodule.span R <| v '' s) (Submodule.span R <| v '' t) :=
  by
  simp only [disjoint_def, Finsupp.mem_span_image_iff_total]
  rintro _ ⟨l₁, hl₁, rfl⟩ ⟨l₂, hl₂, H⟩
  rw [hv.injective_total.eq_iff] at H; subst l₂
  have : l₁ = 0 := submodule.disjoint_def.mp (Finsupp.disjoint_supported_supported hs) _ hl₁ hl₂
  simp [this]
#align linear_independent.disjoint_span_image LinearIndependent.disjoint_span_image

/- warning: linear_independent.not_mem_span_image -> LinearIndependent.not_mem_span_image is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] [_inst_8 : Nontrivial.{u2} R], (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (forall {s : Set.{u1} ι} {x : ι}, (Not (Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x s)) -> (Not (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (v x) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.image.{u1, u3} ι M v s)))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_8 : Nontrivial.{u2} R], (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (forall {s : Set.{u3} ι} {x : ι}, (Not (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x s)) -> (Not (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) (v x) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.image.{u3, u1} ι M v s)))))
Case conversion may be inaccurate. Consider using '#align linear_independent.not_mem_span_image LinearIndependent.not_mem_span_imageₓ'. -/
theorem LinearIndependent.not_mem_span_image [Nontrivial R] (hv : LinearIndependent R v) {s : Set ι}
    {x : ι} (h : x ∉ s) : v x ∉ Submodule.span R (v '' s) :=
  by
  have h' : v x ∈ Submodule.span R (v '' {x}) :=
    by
    rw [Set.image_singleton]
    exact mem_span_singleton_self (v x)
  intro w
  apply LinearIndependent.ne_zero x hv
  refine' disjoint_def.1 (hv.disjoint_span_image _) (v x) h' w
  simpa using h
#align linear_independent.not_mem_span_image LinearIndependent.not_mem_span_image

/- warning: linear_independent.total_ne_of_not_mem_support -> LinearIndependent.total_ne_of_not_mem_support is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] [_inst_8 : Nontrivial.{u2} R], (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (forall {x : ι} (f : Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))), (Not (Membership.Mem.{u1, u1} ι (Finset.{u1} ι) (Finset.hasMem.{u1} ι) x (Finsupp.support.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) f))) -> (Ne.{succ u3} M (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) (fun (_x : LinearMap.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) => (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Finsupp.total.{u1, u3, u2} ι M R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 v) f) (v x)))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_8 : Nontrivial.{u2} R], (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (forall {x : ι} (f : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))), (Not (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) x (Finsupp.support.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) f))) -> (Ne.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => M) f) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (fun (_x : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Finsupp.total.{u3, u1, u2} ι M R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 v) f) (v x)))
Case conversion may be inaccurate. Consider using '#align linear_independent.total_ne_of_not_mem_support LinearIndependent.total_ne_of_not_mem_supportₓ'. -/
theorem LinearIndependent.total_ne_of_not_mem_support [Nontrivial R] (hv : LinearIndependent R v)
    {x : ι} (f : ι →₀ R) (h : x ∉ f.support) : Finsupp.total ι M R v f ≠ v x :=
  by
  replace h : x ∉ (f.support : Set ι) := h
  have p := hv.not_mem_span_image h
  intro w
  rw [← w] at p
  rw [Finsupp.span_image_eq_map_total] at p
  simp only [not_exists, not_and, mem_map] at p
  exact p f (f.mem_supported_support R) rfl
#align linear_independent.total_ne_of_not_mem_support LinearIndependent.total_ne_of_not_mem_support

/- warning: linear_independent_sum -> linearIndependent_sum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {ι' : Type.{u2}} {R : Type.{u3}} {M : Type.{u4}} [_inst_1 : Ring.{u3} R] [_inst_2 : AddCommGroup.{u4} M] [_inst_5 : Module.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2)] {v : (Sum.{u1, u2} ι ι') -> M}, Iff (LinearIndependent.{max u1 u2, u3, u4} (Sum.{u1, u2} ι ι') R M v (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) (And (LinearIndependent.{u1, u3, u4} ι R M (Function.comp.{succ u1, max (succ u1) (succ u2), succ u4} ι (Sum.{u1, u2} ι ι') M v (Sum.inl.{u1, u2} ι ι')) (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) (And (LinearIndependent.{u2, u3, u4} ι' R M (Function.comp.{succ u2, max (succ u1) (succ u2), succ u4} ι' (Sum.{u1, u2} ι ι') M v (Sum.inr.{u1, u2} ι ι')) (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) (Disjoint.{u4} (Submodule.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) (SetLike.partialOrder.{u4, u4} (Submodule.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) M (Submodule.setLike.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5)) (Submodule.orderBot.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) (Submodule.span.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5 (Set.range.{u4, succ u1} M ι (Function.comp.{succ u1, max (succ u1) (succ u2), succ u4} ι (Sum.{u1, u2} ι ι') M v (Sum.inl.{u1, u2} ι ι')))) (Submodule.span.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5 (Set.range.{u4, succ u2} M ι' (Function.comp.{succ u2, max (succ u1) (succ u2), succ u4} ι' (Sum.{u1, u2} ι ι') M v (Sum.inr.{u1, u2} ι ι')))))))
but is expected to have type
  forall {ι : Type.{u4}} {ι' : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {v : (Sum.{u4, u3} ι ι') -> M}, Iff (LinearIndependent.{max u4 u3, u2, u1} (Sum.{u4, u3} ι ι') R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (And (LinearIndependent.{u4, u2, u1} ι R M (Function.comp.{succ u4, max (succ u4) (succ u3), succ u1} ι (Sum.{u4, u3} ι ι') M v (Sum.inl.{u4, u3} ι ι')) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (And (LinearIndependent.{u3, u2, u1} ι' R M (Function.comp.{succ u3, max (succ u4) (succ u3), succ u1} ι' (Sum.{u4, u3} ι ι') M v (Sum.inr.{u4, u3} ι ι')) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Disjoint.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u4} M ι (Function.comp.{succ u4, max (succ u4) (succ u3), succ u1} ι (Sum.{u4, u3} ι ι') M v (Sum.inl.{u4, u3} ι ι')))) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι' (Function.comp.{succ u3, max (succ u4) (succ u3), succ u1} ι' (Sum.{u4, u3} ι ι') M v (Sum.inr.{u4, u3} ι ι')))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_sum linearIndependent_sumₓ'. -/
theorem linearIndependent_sum {v : Sum ι ι' → M} :
    LinearIndependent R v ↔
      LinearIndependent R (v ∘ Sum.inl) ∧
        LinearIndependent R (v ∘ Sum.inr) ∧
          Disjoint (Submodule.span R (range (v ∘ Sum.inl)))
            (Submodule.span R (range (v ∘ Sum.inr))) :=
  by
  rw [range_comp v, range_comp v]
  refine'
    ⟨fun h =>
      ⟨h.comp _ Sum.inl_injective, h.comp _ Sum.inr_injective,
        h.disjoint_span_image is_compl_range_inl_range_inr.1⟩,
      _⟩
  rintro ⟨hl, hr, hlr⟩
  rw [linearIndependent_iff'] at *
  intro s g hg i hi
  have :
    ((∑ i in s.preimage Sum.inl (sum.inl_injective.inj_on _), (fun x => g x • v x) (Sum.inl i)) +
        ∑ i in s.preimage Sum.inr (sum.inr_injective.inj_on _), (fun x => g x • v x) (Sum.inr i)) =
      0 :=
    by
    rw [Finset.sum_preimage', Finset.sum_preimage', ← Finset.sum_union, ← Finset.filter_or]
    · simpa only [← mem_union, range_inl_union_range_inr, mem_univ, Finset.filter_True]
    · exact Finset.disjoint_filter.2 fun x _ hx => disjoint_left.1 is_compl_range_inl_range_inr.1 hx
  · rw [← eq_neg_iff_add_eq_zero] at this
    rw [disjoint_def'] at hlr
    have A := hlr _ (sum_mem fun i hi => _) _ (neg_mem <| sum_mem fun i hi => _) this
    · cases' i with i i
      · exact hl _ _ A i (Finset.mem_preimage.2 hi)
      · rw [this, neg_eq_zero] at A
        exact hr _ _ A i (Finset.mem_preimage.2 hi)
    · exact smul_mem _ _ (subset_span ⟨Sum.inl i, mem_range_self _, rfl⟩)
    · exact smul_mem _ _ (subset_span ⟨Sum.inr i, mem_range_self _, rfl⟩)
#align linear_independent_sum linearIndependent_sum

/- warning: linear_independent.sum_type -> LinearIndependent.sum_type is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {ι' : Type.{u2}} {R : Type.{u3}} {M : Type.{u4}} {v : ι -> M} [_inst_1 : Ring.{u3} R] [_inst_2 : AddCommGroup.{u4} M] [_inst_5 : Module.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2)] {v' : ι' -> M}, (LinearIndependent.{u1, u3, u4} ι R M v (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) -> (LinearIndependent.{u2, u3, u4} ι' R M v' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) -> (Disjoint.{u4} (Submodule.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) (SetLike.partialOrder.{u4, u4} (Submodule.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) M (Submodule.setLike.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5)) (Submodule.orderBot.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) (Submodule.span.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5 (Set.range.{u4, succ u1} M ι v)) (Submodule.span.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5 (Set.range.{u4, succ u2} M ι' v'))) -> (LinearIndependent.{max u1 u2, u3, u4} (Sum.{u1, u2} ι ι') R M (Sum.elim.{u1, u2, succ u4} ι ι' M v v') (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5)
but is expected to have type
  forall {ι : Type.{u4}} {ι' : Type.{u1}} {R : Type.{u3}} {M : Type.{u2}} {v : ι -> M} [_inst_1 : Ring.{u3} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {v' : ι' -> M}, (LinearIndependent.{u4, u3, u2} ι R M v (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (LinearIndependent.{u1, u3, u2} ι' R M v' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (Disjoint.{u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.completeLattice.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.span.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u4} M ι v)) (Submodule.span.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u1} M ι' v'))) -> (LinearIndependent.{max u1 u4, u3, u2} (Sum.{u4, u1} ι ι') R M (Sum.elim.{u4, u1, succ u2} ι ι' M v v') (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.sum_type LinearIndependent.sum_typeₓ'. -/
theorem LinearIndependent.sum_type {v' : ι' → M} (hv : LinearIndependent R v)
    (hv' : LinearIndependent R v')
    (h : Disjoint (Submodule.span R (range v)) (Submodule.span R (range v'))) :
    LinearIndependent R (Sum.elim v v') :=
  linearIndependent_sum.2 ⟨hv, hv', h⟩
#align linear_independent.sum_type LinearIndependent.sum_type

/- warning: linear_independent.union -> LinearIndependent.union is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {s : Set.{u2} M} {t : Set.{u2} M}, (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) t) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x t))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (Disjoint.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) (Submodule.orderBot.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 s) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 t)) -> (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Union.union.{u2} (Set.{u2} M) (Set.hasUnion.{u2} M) s t)) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Union.union.{u2} (Set.{u2} M) (Set.hasUnion.{u2} M) s t)) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Union.union.{u2} (Set.{u2} M) (Set.hasUnion.{u2} M) s t)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Union.union.{u2} (Set.{u2} M) (Set.hasUnion.{u2} M) s t)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Union.union.{u2} (Set.{u2} M) (Set.hasUnion.{u2} M) s t)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Union.union.{u2} (Set.{u2} M) (Set.hasUnion.{u2} M) s t)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x (Union.union.{u2} (Set.{u2} M) (Set.hasUnion.{u2} M) s t)))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {s : Set.{u2} M} {t : Set.{u2} M}, (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} M s) R M (fun (x : Set.Elem.{u2} M s) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} M t) R M (fun (x : Set.Elem.{u2} M t) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x t) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (Disjoint.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.completeLattice.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 s) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 t)) -> (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} M (Union.union.{u2} (Set.{u2} M) (Set.instUnionSet.{u2} M) s t)) R M (fun (x : Set.Elem.{u2} M (Union.union.{u2} (Set.{u2} M) (Set.instUnionSet.{u2} M) s t)) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (Union.union.{u2} (Set.{u2} M) (Set.instUnionSet.{u2} M) s t)) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent.union LinearIndependent.unionₓ'. -/
theorem LinearIndependent.union {s t : Set M} (hs : LinearIndependent R (fun x => x : s → M))
    (ht : LinearIndependent R (fun x => x : t → M)) (hst : Disjoint (span R s) (span R t)) :
    LinearIndependent R (fun x => x : s ∪ t → M) :=
  (hs.sum_type ht <| by simpa).to_subtype_range' <| by simp
#align linear_independent.union LinearIndependent.union

/- warning: linear_independent_Union_finite_subtype -> linearIndependent_unionᵢ_finite_subtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {ι : Type.{u3}} {f : ι -> (Set.{u2} M)}, (forall (i : ι), LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (f i)) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (f i)) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (f i)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (f i)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (f i)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (f i)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x (f i)))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (forall (i : ι) (t : Set.{u3} ι), (Set.Finite.{u3} ι t) -> (Not (Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) i t)) -> (Disjoint.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) (Submodule.orderBot.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (f i)) (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.completeLattice.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5))) ι (fun (i : ι) => supᵢ.{u2, 0} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.completeLattice.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5))) (Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) i t) (fun (H : Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) i t) => Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (f i)))))) -> (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.unionᵢ.{u2, succ u3} M ι (fun (i : ι) => f i))) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.unionᵢ.{u2, succ u3} M ι (fun (i : ι) => f i))) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.unionᵢ.{u2, succ u3} M ι (fun (i : ι) => f i))) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.unionᵢ.{u2, succ u3} M ι (fun (i : ι) => f i))) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.unionᵢ.{u2, succ u3} M ι (fun (i : ι) => f i))) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Set.unionᵢ.{u2, succ u3} M ι (fun (i : ι) => f i))) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x (Set.unionᵢ.{u2, succ u3} M ι (fun (i : ι) => f i))))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {ι : Type.{u3}} {f : ι -> (Set.{u2} M)}, (forall (i : ι), LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} M (f i)) R M (fun (x : Set.Elem.{u2} M (f i)) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (f i)) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (forall (i : ι) (t : Set.{u3} ι), (Set.Finite.{u3} ι t) -> (Not (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i t)) -> (Disjoint.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.completeLattice.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (f i)) (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.completeLattice.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5))) ι (fun (i : ι) => supᵢ.{u2, 0} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.completeLattice.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5))) (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i t) (fun (H : Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i t) => Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (f i)))))) -> (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} M (Set.unionᵢ.{u2, succ u3} M ι (fun (i : ι) => f i))) R M (fun (x : Set.Elem.{u2} M (Set.unionᵢ.{u2, succ u3} M ι (fun (i : ι) => f i))) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (Set.unionᵢ.{u2, succ u3} M ι (fun (i : ι) => f i))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent_Union_finite_subtype linearIndependent_unionᵢ_finite_subtypeₓ'. -/
theorem linearIndependent_unionᵢ_finite_subtype {ι : Type _} {f : ι → Set M}
    (hl : ∀ i, LinearIndependent R (fun x => x : f i → M))
    (hd : ∀ i, ∀ t : Set ι, t.Finite → i ∉ t → Disjoint (span R (f i)) (⨆ i ∈ t, span R (f i))) :
    LinearIndependent R (fun x => x : (⋃ i, f i) → M) :=
  by
  rw [Union_eq_Union_finset f]
  apply linearIndependent_unionᵢ_of_directed
  · apply directed_of_sup
    exact fun t₁ t₂ ht => Union_mono fun i => Union_subset_Union_const fun h => ht h
  intro t
  induction' t using Finset.induction_on with i s his ih
  · refine' (linearIndependent_empty _ _).mono _
    simp
  · rw [Finset.set_bunionᵢ_insert]
    refine' (hl _).union ih _
    rw [span_Union₂]
    exact hd i s s.finite_to_set his
#align linear_independent_Union_finite_subtype linearIndependent_unionᵢ_finite_subtype

/- warning: linear_independent_Union_finite -> linearIndependent_unionᵢ_finite is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] {η : Type.{u3}} {ιs : η -> Type.{u4}} {f : forall (j : η), (ιs j) -> M}, (forall (j : η), LinearIndependent.{u4, u1, u2} (ιs j) R M (f j) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (forall (i : η) (t : Set.{u3} η), (Set.Finite.{u3} η t) -> (Not (Membership.Mem.{u3, u3} η (Set.{u3} η) (Set.hasMem.{u3} η) i t)) -> (Disjoint.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) (Submodule.orderBot.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u4} M (ιs i) (f i))) (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.completeLattice.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5))) η (fun (i : η) => supᵢ.{u2, 0} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.completeLattice.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5))) (Membership.Mem.{u3, u3} η (Set.{u3} η) (Set.hasMem.{u3} η) i t) (fun (H : Membership.Mem.{u3, u3} η (Set.{u3} η) (Set.hasMem.{u3} η) i t) => Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u4} M (ιs i) (f i))))))) -> (LinearIndependent.{max u3 u4, u1, u2} (Sigma.{u3, u4} η (fun (j : η) => ιs j)) R M (fun (ji : Sigma.{u3, u4} η (fun (j : η) => ιs j)) => f (Sigma.fst.{u3, u4} η (fun (j : η) => ιs j) ji) (Sigma.snd.{u3, u4} η (fun (j : η) => ιs j) ji)) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {η : Type.{u4}} {ιs : η -> Type.{u3}} {f : forall (j : η), (ιs j) -> M}, (forall (j : η), LinearIndependent.{u3, u2, u1} (ιs j) R M (f j) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (forall (i : η) (t : Set.{u4} η), (Set.Finite.{u4} η t) -> (Not (Membership.mem.{u4, u4} η (Set.{u4} η) (Set.instMembershipSet.{u4} η) i t)) -> (Disjoint.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M (ιs i) (f i))) (supᵢ.{u1, succ u4} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))) η (fun (i : η) => supᵢ.{u1, 0} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))) (Membership.mem.{u4, u4} η (Set.{u4} η) (Set.instMembershipSet.{u4} η) i t) (fun (H : Membership.mem.{u4, u4} η (Set.{u4} η) (Set.instMembershipSet.{u4} η) i t) => Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M (ιs i) (f i))))))) -> (LinearIndependent.{max u4 u3, u2, u1} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R M (fun (ji : Sigma.{u4, u3} η (fun (j : η) => ιs j)) => f (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji) (Sigma.snd.{u4, u3} η (fun (j : η) => ιs j) ji)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent_Union_finite linearIndependent_unionᵢ_finiteₓ'. -/
theorem linearIndependent_unionᵢ_finite {η : Type _} {ιs : η → Type _} {f : ∀ j : η, ιs j → M}
    (hindep : ∀ j, LinearIndependent R (f j))
    (hd :
      ∀ i,
        ∀ t : Set η,
          t.Finite → i ∉ t → Disjoint (span R (range (f i))) (⨆ i ∈ t, span R (range (f i)))) :
    LinearIndependent R fun ji : Σj, ιs j => f ji.1 ji.2 :=
  by
  nontriviality R
  apply LinearIndependent.of_subtype_range
  · rintro ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ hxy
    by_cases h_cases : x₁ = y₁
    subst h_cases
    · apply Sigma.eq
      rw [LinearIndependent.injective (hindep _) hxy]
      rfl
    · have h0 : f x₁ x₂ = 0 :=
        by
        apply
          disjoint_def.1 (hd x₁ {y₁} (finite_singleton y₁) fun h => h_cases (eq_of_mem_singleton h))
            (f x₁ x₂) (subset_span (mem_range_self _))
        rw [supᵢ_singleton]
        simp only at hxy
        rw [hxy]
        exact subset_span (mem_range_self y₂)
      exact False.elim ((hindep x₁).NeZero _ h0)
  rw [range_sigma_eq_Union_range]
  apply linearIndependent_unionᵢ_finite_subtype (fun j => (hindep j).to_subtype_range) hd
#align linear_independent_Union_finite linearIndependent_unionᵢ_finite

end Subtype

section repr

variable (hv : LinearIndependent R v)

/- warning: linear_independent.total_equiv -> LinearIndependent.totalEquiv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)], (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (LinearEquiv.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (LinearIndependent.totalEquiv._proof_1.{u2} R _inst_1) (LinearIndependent.totalEquiv._proof_2.{u2} R _inst_1) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)], (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (LinearEquiv.{u2, u2, max u2 u1, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHomInvPair.ids.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) x (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v)))) (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))))
Case conversion may be inaccurate. Consider using '#align linear_independent.total_equiv LinearIndependent.totalEquivₓ'. -/
/-- Canonical isomorphism between linear combinations and the span of linearly independent vectors.
-/
@[simps (config := { rhsMd := semireducible })]
def LinearIndependent.totalEquiv (hv : LinearIndependent R v) : (ι →₀ R) ≃ₗ[R] span R (range v) :=
  by
  apply LinearEquiv.ofBijective (LinearMap.codRestrict (span R (range v)) (Finsupp.total ι M R v) _)
  constructor
  · rw [← LinearMap.ker_eq_bot, LinearMap.ker_codRestrict]
    apply hv
  · rw [← LinearMap.range_eq_top, LinearMap.range_eq_map, LinearMap.map_codRestrict, ←
      LinearMap.range_le_iff_comap, range_subtype, map_top]
    rw [Finsupp.range_total]
    exact le_rfl
  · intro l
    rw [← Finsupp.range_total]
    rw [LinearMap.mem_range]
    apply mem_range_self l
#align linear_independent.total_equiv LinearIndependent.totalEquiv

/- warning: linear_independent.repr -> LinearIndependent.repr is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)], (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)], (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (LinearMap.{u2, u2, u3, max u2 u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) x (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v)))) (Finsupp.{u1, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align linear_independent.repr LinearIndependent.reprₓ'. -/
/-- Linear combination representing a vector in the span of linearly independent vectors.

Given a family of linearly independent vectors, we can represent any vector in their span as
a linear combination of these vectors. These are provided by this linear map.
It is simply one direction of `linear_independent.total_equiv`. -/
def LinearIndependent.repr (hv : LinearIndependent R v) : span R (range v) →ₗ[R] ι →₀ R :=
  hv.totalEquiv.symm
#align linear_independent.repr LinearIndependent.repr

/- warning: linear_independent.total_repr -> LinearIndependent.total_repr is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (hv : LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (x : coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))), Eq.{succ u3} M (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) (fun (_x : LinearMap.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) => (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Finsupp.total.{u1, u3, u2} ι M R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 v) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) -> (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))))) (LinearMap.hasCoeToFun.{u2, u2, u3, max u1 u2} R R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (LinearIndependent.repr.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5 hv) x)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) x (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))))))) x)
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u1}} {M : Type.{u2}} {v : ι -> M} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (hv : LinearIndependent.{u3, u1, u2} ι R M v (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) => M) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), succ u2, max (succ u3) (succ u1)} (LinearMap.{u1, u1, u2, max u1 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} R _inst_1))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (fun (a : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) => Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u1} R R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearIndependent.repr.{u3, u1, u2} ι R M v _inst_1 _inst_2 _inst_5 hv) x)) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u1), succ u2} (LinearMap.{u1, u1, max u1 u3, u2} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) M (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_5) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (fun (_x : Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u3 u1, u2} R R (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) M (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Finsupp.total.{u3, u2, u1} ι M R (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 v) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), succ u2, max (succ u3) (succ u1)} (LinearMap.{u1, u1, u2, max u1 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} R _inst_1))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (fun (_x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) => Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u1} R R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearIndependent.repr.{u3, u1, u2} ι R M v _inst_1 _inst_2 _inst_5 hv) x)) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) x)
Case conversion may be inaccurate. Consider using '#align linear_independent.total_repr LinearIndependent.total_reprₓ'. -/
@[simp]
theorem LinearIndependent.total_repr (x) : Finsupp.total ι M R v (hv.repr x) = x :=
  Subtype.ext_iff.1 (LinearEquiv.apply_symm_apply hv.totalEquiv x)
#align linear_independent.total_repr LinearIndependent.total_repr

/- warning: linear_independent.total_comp_repr -> LinearIndependent.total_comp_repr is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (hv : LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5), Eq.{succ u3} (LinearMap.{u2, u2, u3, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) _inst_5) (LinearMap.comp.{u2, u2, u2, u3, max u1 u2, u3} R R R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHomCompTriple.right_ids.{u2, u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Finsupp.total.{u1, u3, u2} ι M R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 v) (LinearIndependent.repr.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5 hv)) (Submodule.subtype.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v)))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u1}} {M : Type.{u2}} {v : ι -> M} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (hv : LinearIndependent.{u3, u1, u2} ι R M v (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5), Eq.{succ u2} (LinearMap.{u1, u1, u2, u2} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) M (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) _inst_5) (LinearMap.comp.{u1, u1, u1, u2, max u3 u1, u2} R R R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) M (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Semiring.toModule.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomCompTriple.ids.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Finsupp.total.{u3, u2, u1} ι M R (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 v) (LinearIndependent.repr.{u3, u1, u2} ι R M v _inst_1 _inst_2 _inst_5 hv)) (Submodule.subtype.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))
Case conversion may be inaccurate. Consider using '#align linear_independent.total_comp_repr LinearIndependent.total_comp_reprₓ'. -/
theorem LinearIndependent.total_comp_repr :
    (Finsupp.total ι M R v).comp hv.repr = Submodule.subtype _ :=
  LinearMap.ext <| hv.total_repr
#align linear_independent.total_comp_repr LinearIndependent.total_comp_repr

/- warning: linear_independent.repr_ker -> LinearIndependent.repr_ker is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (hv : LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5), Eq.{succ u3} (Submodule.{u2, u3} R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v)))) (LinearMap.ker.{u2, u2, u3, max u1 u2, max u3 u1 u2} R R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (LinearMap.semilinearMapClass.{u2, u2, u3, max u1 u2} R R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (LinearIndependent.repr.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5 hv)) (Bot.bot.{u3} (Submodule.{u2, u3} R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v)))) (Submodule.hasBot.{u2, u3} R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v)))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u1}} {M : Type.{u2}} {v : ι -> M} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (hv : LinearIndependent.{u3, u1, u2} ι R M v (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5), Eq.{succ u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Ring.toSemiring.{u1} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (LinearMap.ker.{u1, u1, u2, max u3 u1, max (max u3 u1) u2} R R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (LinearMap.{u1, u1, u2, max u1 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} R _inst_1))) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u1} R R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearIndependent.repr.{u3, u1, u2} ι R M v _inst_1 _inst_2 _inst_5 hv)) (Bot.bot.{u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Ring.toSemiring.{u1} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Submodule.instBotSubmodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Ring.toSemiring.{u1} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))))
Case conversion may be inaccurate. Consider using '#align linear_independent.repr_ker LinearIndependent.repr_kerₓ'. -/
theorem LinearIndependent.repr_ker : hv.repr.ker = ⊥ := by
  rw [LinearIndependent.repr, LinearEquiv.ker]
#align linear_independent.repr_ker LinearIndependent.repr_ker

/- warning: linear_independent.repr_range -> LinearIndependent.repr_range is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (hv : LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5), Eq.{succ (max u1 u2)} (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (LinearMap.range.{u2, u2, u3, max u1 u2, max u3 u1 u2} R R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (LinearMap.semilinearMapClass.{u2, u2, u3, max u1 u2} R R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (RingHomSurjective.ids.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (LinearIndependent.repr.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5 hv)) (Top.top.{max u1 u2} (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Submodule.hasTop.{u2, max u1 u2} R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (hv : LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5), Eq.{max (succ u3) (succ u2)} (Submodule.{u2, max u3 u2} R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1))) (LinearMap.range.{u2, u2, u1, max u3 u2, max (max u3 u2) u1} R R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (LinearMap.{u2, u2, u1, max u2 u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1))) (LinearMap.instSemilinearMapClassLinearMap.{u2, u2, u1, max u3 u2} R R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (RingHomSurjective.ids.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (LinearIndependent.repr.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5 hv)) (Top.top.{max u3 u2} (Submodule.{u2, max u3 u2} R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1))) (Submodule.instTopSubmodule.{u2, max u3 u2} R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align linear_independent.repr_range LinearIndependent.repr_rangeₓ'. -/
theorem LinearIndependent.repr_range : hv.repr.range = ⊤ := by
  rw [LinearIndependent.repr, LinearEquiv.range]
#align linear_independent.repr_range LinearIndependent.repr_range

/- warning: linear_independent.repr_eq -> LinearIndependent.repr_eq is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (hv : LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) {l : Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))} {x : coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))}, (Eq.{succ u3} M (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) (fun (_x : LinearMap.{u2, u2, max u1 u2, u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) => (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) M (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u1, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Finsupp.total.{u1, u3, u2} ι M R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 v) l) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) x (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))))))) x)) -> (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) -> (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))))) (LinearMap.hasCoeToFun.{u2, u2, u3, max u1 u2} R R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (LinearIndependent.repr.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5 hv) x) l)
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (hv : LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) {l : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))} {x : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))}, (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => M) l) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (fun (_x : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) M (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) _inst_5 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Finsupp.total.{u3, u1, u2} ι M R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 v) l) (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) x)) -> (Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) => Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) x) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u1, max (succ u3) (succ u2)} (LinearMap.{u2, u2, u1, max u2 u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) (fun (_x : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) => Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, max u3 u2} R R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (LinearIndependent.repr.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5 hv) x) l)
Case conversion may be inaccurate. Consider using '#align linear_independent.repr_eq LinearIndependent.repr_eqₓ'. -/
theorem LinearIndependent.repr_eq {l : ι →₀ R} {x} (eq : Finsupp.total ι M R v l = ↑x) :
    hv.repr x = l :=
  by
  have :
    ↑((LinearIndependent.totalEquiv hv : (ι →₀ R) →ₗ[R] span R (range v)) l) =
      Finsupp.total ι M R v l :=
    rfl
  have : (LinearIndependent.totalEquiv hv : (ι →₀ R) →ₗ[R] span R (range v)) l = x :=
    by
    rw [Eq] at this
    exact Subtype.ext_iff.2 this
  rw [← LinearEquiv.symm_apply_apply hv.total_equiv l]
  rw [← this]
  rfl
#align linear_independent.repr_eq LinearIndependent.repr_eq

/- warning: linear_independent.repr_eq_single -> LinearIndependent.repr_eq_single is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (hv : LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (i : ι) (x : coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))), (Eq.{succ u3} M ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) x (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))))))) x) (v i)) -> (Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) -> (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))))) (LinearMap.hasCoeToFun.{u2, u2, u3, max u1 u2} R R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (LinearIndependent.repr.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5 hv) x) (Finsupp.single.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) i (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u1}} {M : Type.{u2}} {v : ι -> M} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] (hv : LinearIndependent.{u3, u1, u2} ι R M v (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (i : ι) (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))), (Eq.{succ u2} M (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) x) (v i)) -> (Eq.{max (succ u3) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) => Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) x) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), succ u2, max (succ u3) (succ u1)} (LinearMap.{u1, u1, u2, max u1 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} R _inst_1))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (fun (_x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) => Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u1} R R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) x (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v)))) (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u3} M ι v))) (Finsupp.module.{u3, u1, u1} ι R R (Ring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonUnitalRing.{u1} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearIndependent.repr.{u3, u1, u2} ι R M v _inst_1 _inst_2 _inst_5 hv) x) (Finsupp.single.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) i (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align linear_independent.repr_eq_single LinearIndependent.repr_eq_singleₓ'. -/
theorem LinearIndependent.repr_eq_single (i) (x) (hx : ↑x = v i) : hv.repr x = Finsupp.single i 1 :=
  by
  apply hv.repr_eq
  simp [Finsupp.total_single, hx]
#align linear_independent.repr_eq_single LinearIndependent.repr_eq_single

/- warning: linear_independent.span_repr_eq -> LinearIndependent.span_repr_eq is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (hv : LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) [_inst_8 : Nontrivial.{u2} R] (x : coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))), Eq.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) (Set.range.{u3, succ u1} M ι v)) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) (Span.repr.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v) x) (Finsupp.equivMapDomain.{u1, u3, u2} ι (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M) Type.{u3} (Set.hasCoeToSort.{u3} M) (Set.range.{u3, succ u1} M ι v)) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Equiv.ofInjective.{succ u1, u3} ι M v (LinearIndependent.injective.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5 _inst_8 hv)) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ u3) (succ (max u1 u2))} (LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (fun (_x : LinearMap.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) => (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) -> (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))))) (LinearMap.hasCoeToFun.{u2, u2, u3, max u1 u2} R R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.{u1, u2} ι R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.addCommMonoid.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.addCommMonoid.{u1, u2} ι R (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (Submodule.module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.range.{u3, succ u1} M ι v))) (Finsupp.module.{u1, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toAddCommGroup.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1)))) (Semiring.toModule.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (LinearIndependent.repr.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5 hv) x))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (hv : LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) [_inst_8 : Nontrivial.{u2} R] (x : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))), Eq.{max (succ u2) (succ u1)} (Finsupp.{u1, u2} (Set.Elem.{u1} M (Set.range.{u1, succ u3} M ι v)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Span.repr.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v) x) (Finsupp.equivMapDomain.{u3, u1, u2} ι (Set.Elem.{u1} M (Set.range.{u1, succ u3} M ι v)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Equiv.ofInjective.{succ u3, u1} ι M v (LinearIndependent.injective.{u1, u2, u3} ι R M v _inst_1 _inst_2 _inst_5 _inst_8 hv)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u1, max (succ u3) (succ u2)} (LinearMap.{u2, u2, u1, max u2 u3} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) (fun (_x : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) => Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, max u3 u2} R R (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) x (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v)))) (Finsupp.{u3, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.addCommMonoid.{u3, u2} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1))))) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.range.{u1, succ u3} M ι v))) (Finsupp.module.{u3, u2, u2} ι R R (Ring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonUnitalRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonUnitalRing.{u2} R _inst_1)))) (instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) (LinearIndependent.repr.{u3, u2, u1} ι R M v _inst_1 _inst_2 _inst_5 hv) x))
Case conversion may be inaccurate. Consider using '#align linear_independent.span_repr_eq LinearIndependent.span_repr_eqₓ'. -/
theorem LinearIndependent.span_repr_eq [Nontrivial R] (x) :
    Span.repr R (Set.range v) x = (hv.repr x).equivMapDomain (Equiv.ofInjective _ hv.Injective) :=
  by
  have p :
    (Span.repr R (Set.range v) x).equivMapDomain (Equiv.ofInjective _ hv.injective).symm =
      hv.repr x :=
    by
    apply (LinearIndependent.totalEquiv hv).Injective
    ext
    simp only [LinearIndependent.totalEquiv_apply_coe, Equiv.self_comp_ofInjective_symm,
      LinearIndependent.total_repr, Finsupp.total_equivMapDomain, Span.finsupp_total_repr]
  ext ⟨_, ⟨i, rfl⟩⟩
  simp [← p]
#align linear_independent.span_repr_eq LinearIndependent.span_repr_eq

/- warning: linear_independent_iff_not_smul_mem_span -> linearIndependent_iff_not_smul_mem_span is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)], Iff (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (forall (i : ι) (a : R), (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (Module.toMulActionWithZero.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)))) a (v i)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.image.{u1, u3} ι M v (SDiff.sdiff.{u1} (Set.{u1} ι) (BooleanAlgebra.toHasSdiff.{u1} (Set.{u1} ι) (Set.booleanAlgebra.{u1} ι)) (Set.univ.{u1} ι) (Singleton.singleton.{u1, u1} ι (Set.{u1} ι) (Set.hasSingleton.{u1} ι) i))))) -> (Eq.{succ u2} R a (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)], Iff (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (forall (i : ι) (a : R), (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))))) a (v i)) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.image.{u3, u1} ι M v (SDiff.sdiff.{u3} (Set.{u3} ι) (Set.instSDiffSet.{u3} ι) (Set.univ.{u3} ι) (Singleton.singleton.{u3, u3} ι (Set.{u3} ι) (Set.instSingletonSet.{u3} ι) i))))) -> (Eq.{succ u2} R a (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_iff_not_smul_mem_span linearIndependent_iff_not_smul_mem_spanₓ'. -/
-- TODO: why is this so slow?
theorem linearIndependent_iff_not_smul_mem_span :
    LinearIndependent R v ↔ ∀ (i : ι) (a : R), a • v i ∈ span R (v '' (univ \ {i})) → a = 0 :=
  ⟨fun hv i a ha => by
    rw [Finsupp.span_image_eq_map_total, mem_map] at ha
    rcases ha with ⟨l, hl, e⟩
    rw [sub_eq_zero.1 (linearIndependent_iff.1 hv (l - Finsupp.single i a) (by simp [e]))] at hl
    by_contra hn
    exact (not_mem_of_mem_diff (hl <| by simp [hn])) (mem_singleton _), fun H =>
    linearIndependent_iff.2 fun l hl => by
      ext i; simp only [Finsupp.zero_apply]
      by_contra hn
      refine' hn (H i _ _)
      refine' (Finsupp.mem_span_image_iff_total _).2 ⟨Finsupp.single i (l i) - l, _, _⟩
      · rw [Finsupp.mem_supported']
        intro j hj
        have hij : j = i :=
          Classical.not_not.1 fun hij : j ≠ i =>
            hj ((mem_diff _).2 ⟨mem_univ _, fun h => hij (eq_of_mem_singleton h)⟩)
        simp [hij]
      · simp [hl]⟩
#align linear_independent_iff_not_smul_mem_span linearIndependent_iff_not_smul_mem_span

/- warning: linear_independent.independent_span_singleton -> LinearIndependent.independent_span_singleton is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)], (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (CompleteLattice.Independent.{succ u1, u3} ι (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (Submodule.completeLattice.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (fun (i : ι) => Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Singleton.singleton.{u3, u3} M (Set.{u3} M) (Set.hasSingleton.{u3} M) (v i))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} {v : ι -> M} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)], (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (CompleteLattice.Independent.{succ u3, u1} ι (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (fun (i : ι) => Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Singleton.singleton.{u1, u1} M (Set.{u1} M) (Set.instSingletonSet.{u1} M) (v i))))
Case conversion may be inaccurate. Consider using '#align linear_independent.independent_span_singleton LinearIndependent.independent_span_singletonₓ'. -/
/-- See also `complete_lattice.independent_iff_linear_independent_of_ne_zero`. -/
theorem LinearIndependent.independent_span_singleton (hv : LinearIndependent R v) :
    CompleteLattice.Independent fun i => R ∙ v i :=
  by
  refine' complete_lattice.independent_def.mp fun i => _
  rw [disjoint_iff_inf_le]
  intro m hm
  simp only [mem_inf, mem_span_singleton, supᵢ_subtype', ← span_range_eq_supr] at hm
  obtain ⟨⟨r, rfl⟩, hm⟩ := hm
  suffices r = 0 by simp [this]
  apply linear_independent_iff_not_smul_mem_span.mp hv i
  convert hm
  ext
  simp
#align linear_independent.independent_span_singleton LinearIndependent.independent_span_singleton

variable (R)

/- warning: exists_maximal_independent' -> exists_maximal_independent' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (R : Type.{u2}) {M : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (s : ι -> M), Exists.{succ u1} (Set.{u1} ι) (fun (I : Set.{u1} ι) => And (LinearIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) R M (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) => s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x I))))) x)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (forall (J : Set.{u1} ι), (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) I J) -> (LinearIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) J) R M (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) J) => s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) J) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) J) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) J) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) J) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x J))))) x)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (Eq.{succ u1} (Set.{u1} ι) I J)))
but is expected to have type
  forall {ι : Type.{u3}} (R : Type.{u2}) {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (s : ι -> M), Exists.{succ u3} (Set.{u3} ι) (fun (I : Set.{u3} ι) => And (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι I) R M (fun (x : Set.Elem.{u3} ι I) => s (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x I) x)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (forall (J : Set.{u3} ι), (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) I J) -> (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι J) R M (fun (x : Set.Elem.{u3} ι J) => s (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x J) x)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (Eq.{succ u3} (Set.{u3} ι) I J)))
Case conversion may be inaccurate. Consider using '#align exists_maximal_independent' exists_maximal_independent'ₓ'. -/
theorem exists_maximal_independent' (s : ι → M) :
    ∃ I : Set ι,
      (LinearIndependent R fun x : I => s x) ∧
        ∀ J : Set ι, I ⊆ J → (LinearIndependent R fun x : J => s x) → I = J :=
  by
  let indep : Set ι → Prop := fun I => LinearIndependent R (s ∘ coe : I → M)
  let X := { I : Set ι // indep I }
  let r : X → X → Prop := fun I J => I.1 ⊆ J.1
  have key : ∀ c : Set X, IsChain r c → indep (⋃ (I : X) (H : I ∈ c), I) :=
    by
    intro c hc
    dsimp [indep]
    rw [linearIndependent_comp_subtype]
    intro f hsupport hsum
    rcases eq_empty_or_nonempty c with (rfl | hn)
    · simpa using hsupport
    haveI : IsRefl X r := ⟨fun _ => Set.Subset.refl _⟩
    obtain ⟨I, I_mem, hI⟩ : ∃ I ∈ c, (f.support : Set ι) ⊆ I :=
      hc.directed_on.exists_mem_subset_of_finset_subset_bUnion hn hsupport
    exact linear_independent_comp_subtype.mp I.2 f hI hsum
  have trans : Transitive r := fun I J K => Set.Subset.trans
  obtain ⟨⟨I, hli : indep I⟩, hmax : ∀ a, r ⟨I, hli⟩ a → r a ⟨I, hli⟩⟩ :=
    @exists_maximal_of_chains_bounded _ r
      (fun c hc => ⟨⟨⋃ I ∈ c, (I : Set ι), key c hc⟩, fun I => Set.subset_bunionᵢ_of_mem⟩) trans
  exact ⟨I, hli, fun J hsub hli => Set.Subset.antisymm hsub (hmax ⟨J, hli⟩ hsub)⟩
#align exists_maximal_independent' exists_maximal_independent'

/- warning: exists_maximal_independent -> exists_maximal_independent is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (R : Type.{u2}) {M : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (s : ι -> M), Exists.{succ u1} (Set.{u1} ι) (fun (I : Set.{u1} ι) => And (LinearIndependent.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) R M (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) => s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) ι (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) ι (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) ι (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) I) ι (coeSubtype.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x I))))) x)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (forall (i : ι), (Not (Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) i I)) -> (Exists.{succ u2} R (fun (a : R) => And (Ne.{succ u2} R a (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))))))) (Membership.Mem.{u3, u3} M (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) M (Submodule.setLike.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)) (SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)))) (Module.toMulActionWithZero.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5)))) a (s i)) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 (Set.image.{u1, u3} ι M s I)))))))
but is expected to have type
  forall {ι : Type.{u3}} (R : Type.{u2}) {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (s : ι -> M), Exists.{succ u3} (Set.{u3} ι) (fun (I : Set.{u3} ι) => And (LinearIndependent.{u3, u2, u1} (Set.Elem.{u3} ι I) R M (fun (x : Set.Elem.{u3} ι I) => s (Subtype.val.{succ u3} ι (fun (x : ι) => Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) x I) x)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (forall (i : ι), (Not (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i I)) -> (Exists.{succ u2} R (fun (a : R) => And (Ne.{succ u2} R a (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)))))) (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5)) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_2))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))))) a (s i)) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 (Set.image.{u3, u1} ι M s I)))))))
Case conversion may be inaccurate. Consider using '#align exists_maximal_independent exists_maximal_independentₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i «expr ∉ » I) -/
theorem exists_maximal_independent (s : ι → M) :
    ∃ I : Set ι,
      (LinearIndependent R fun x : I => s x) ∧
        ∀ (i) (_ : i ∉ I), ∃ a : R, a ≠ 0 ∧ a • s i ∈ span R (s '' I) :=
  by
  classical
    rcases exists_maximal_independent' R s with ⟨I, hIlinind, hImaximal⟩
    use I, hIlinind
    intro i hi
    specialize hImaximal (I ∪ {i}) (by simp)
    set J := I ∪ {i} with hJ
    have memJ : ∀ {x}, x ∈ J ↔ x = i ∨ x ∈ I := by simp [hJ]
    have hiJ : i ∈ J := by simp
    have h := mt hImaximal _
    swap
    · intro h2
      rw [h2] at hi
      exact absurd hiJ hi
    obtain ⟨f, supp_f, sum_f, f_ne⟩ := linear_dependent_comp_subtype.mp h
    have hfi : f i ≠ 0 := by
      contrapose hIlinind
      refine' linear_dependent_comp_subtype.mpr ⟨f, _, sum_f, f_ne⟩
      simp only [Finsupp.mem_supported, hJ] at supp_f⊢
      rintro x hx
      refine' (memJ.mp (supp_f hx)).resolve_left _
      rintro rfl
      exact hIlinind (finsupp.mem_support_iff.mp hx)
    use f i, hfi
    have hfi' : i ∈ f.support := finsupp.mem_support_iff.mpr hfi
    rw [← Finset.insert_erase hfi', Finset.sum_insert (Finset.not_mem_erase _ _),
      add_eq_zero_iff_eq_neg] at sum_f
    rw [sum_f]
    refine' neg_mem (sum_mem fun c hc => smul_mem _ _ (subset_span ⟨c, _, rfl⟩))
    exact (memJ.mp (supp_f (Finset.erase_subset _ _ hc))).resolve_left (Finset.ne_of_mem_erase hc)
#align exists_maximal_independent exists_maximal_independent

end repr

/- warning: surjective_of_linear_independent_of_span -> surjective_of_linearIndependent_of_span is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {ι' : Type.{u2}} {R : Type.{u3}} {M : Type.{u4}} {v : ι -> M} [_inst_1 : Ring.{u3} R] [_inst_2 : AddCommGroup.{u4} M] [_inst_5 : Module.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2)] [_inst_8 : Nontrivial.{u3} R], (LinearIndependent.{u1, u3, u4} ι R M v (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) -> (forall (f : Function.Embedding.{succ u2, succ u1} ι' ι), (HasSubset.Subset.{u4} (Set.{u4} M) (Set.hasSubset.{u4} M) (Set.range.{u4, succ u1} M ι v) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Submodule.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) (Set.{u4} M) (HasLiftT.mk.{succ u4, succ u4} (Submodule.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) (Set.{u4} M) (CoeTCₓ.coe.{succ u4, succ u4} (Submodule.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) (Set.{u4} M) (SetLike.Set.hasCoeT.{u4, u4} (Submodule.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) M (Submodule.setLike.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5)))) (Submodule.span.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5 (Set.range.{u4, succ u2} M ι' (Function.comp.{succ u2, succ u1, succ u4} ι' ι M v (coeFn.{max 1 (succ u2) (succ u1), max (succ u2) (succ u1)} (Function.Embedding.{succ u2, succ u1} ι' ι) (fun (_x : Function.Embedding.{succ u2, succ u1} ι' ι) => ι' -> ι) (Function.Embedding.hasCoeToFun.{succ u2, succ u1} ι' ι) f)))))) -> (Function.Surjective.{succ u2, succ u1} ι' ι (coeFn.{max 1 (succ u2) (succ u1), max (succ u2) (succ u1)} (Function.Embedding.{succ u2, succ u1} ι' ι) (fun (_x : Function.Embedding.{succ u2, succ u1} ι' ι) => ι' -> ι) (Function.Embedding.hasCoeToFun.{succ u2, succ u1} ι' ι) f)))
but is expected to have type
  forall {ι : Type.{u4}} {ι' : Type.{u1}} {R : Type.{u3}} {M : Type.{u2}} {v : ι -> M} [_inst_1 : Ring.{u3} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_8 : Nontrivial.{u3} R], (LinearIndependent.{u4, u3, u2} ι R M v (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (forall (f : Function.Embedding.{succ u1, succ u4} ι' ι), (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) (Set.range.{u2, succ u4} M ι v) (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.span.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 (Set.range.{u2, succ u1} M ι' (Function.comp.{succ u1, succ u4, succ u2} ι' ι M v (FunLike.coe.{max (succ u4) (succ u1), succ u1, succ u4} (Function.Embedding.{succ u1, succ u4} ι' ι) ι' (fun (_x : ι') => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : ι') => ι) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u1, succ u4} (Function.Embedding.{succ u1, succ u4} ι' ι) ι' ι (Function.instEmbeddingLikeEmbedding.{succ u1, succ u4} ι' ι)) f)))))) -> (Function.Surjective.{succ u1, succ u4} ι' ι (FunLike.coe.{max (succ u4) (succ u1), succ u1, succ u4} (Function.Embedding.{succ u1, succ u4} ι' ι) ι' (fun (_x : ι') => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : ι') => ι) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u1), succ u1, succ u4} (Function.Embedding.{succ u1, succ u4} ι' ι) ι' ι (Function.instEmbeddingLikeEmbedding.{succ u1, succ u4} ι' ι)) f)))
Case conversion may be inaccurate. Consider using '#align surjective_of_linear_independent_of_span surjective_of_linearIndependent_of_spanₓ'. -/
theorem surjective_of_linearIndependent_of_span [Nontrivial R] (hv : LinearIndependent R v)
    (f : ι' ↪ ι) (hss : range v ⊆ span R (range (v ∘ f))) : Surjective f :=
  by
  intro i
  let repr : (span R (range (v ∘ f)) : Type _) → ι' →₀ R := (hv.comp f f.injective).repr
  let l := (repr ⟨v i, hss (mem_range_self i)⟩).mapDomain f
  have h_total_l : Finsupp.total ι M R v l = v i :=
    by
    dsimp only [l]
    rw [Finsupp.total_mapDomain]
    rw [(hv.comp f f.injective).total_repr]
    · rfl
  have h_total_eq : (Finsupp.total ι M R v) l = (Finsupp.total ι M R v) (Finsupp.single i 1) := by
    rw [h_total_l, Finsupp.total_single, one_smul]
  have l_eq : l = _ := LinearMap.ker_eq_bot.1 hv h_total_eq
  dsimp only [l] at l_eq
  rw [← Finsupp.embDomain_eq_mapDomain] at l_eq
  rcases Finsupp.single_of_embDomain_single (repr ⟨v i, _⟩) f i (1 : R) zero_ne_one.symm l_eq with
    ⟨i', hi'⟩
  use i'
  exact hi'.2
#align surjective_of_linear_independent_of_span surjective_of_linearIndependent_of_span

/- warning: eq_of_linear_independent_of_span_subtype -> eq_of_linearIndependent_of_span_subtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_8 : Nontrivial.{u1} R] {s : Set.{u2} M} {t : Set.{u2} M}, (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) t s) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Set.{u2} M) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)))) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 t))) -> (Eq.{succ u2} (Set.{u2} M) s t)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_8 : Nontrivial.{u2} R] {s : Set.{u1} M} {t : Set.{u1} M}, (LinearIndependent.{u1, u2, u1} (Set.Elem.{u1} M s) R M (fun (x : Set.Elem.{u1} M s) => Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x s) x) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) t s) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) s (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) M (Submodule.instSetLikeSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 t))) -> (Eq.{succ u1} (Set.{u1} M) s t)
Case conversion may be inaccurate. Consider using '#align eq_of_linear_independent_of_span_subtype eq_of_linearIndependent_of_span_subtypeₓ'. -/
theorem eq_of_linearIndependent_of_span_subtype [Nontrivial R] {s t : Set M}
    (hs : LinearIndependent R (fun x => x : s → M)) (h : t ⊆ s) (hst : s ⊆ span R t) : s = t :=
  by
  let f : t ↪ s :=
    ⟨fun x => ⟨x.1, h x.2⟩, fun a b hab => Subtype.coe_injective (Subtype.mk.inj hab)⟩
  have h_surj : surjective f :=
    by
    apply surjective_of_linearIndependent_of_span hs f _
    convert hst <;> simp [f, comp]
  show s = t
  · apply subset.antisymm _ h
    intro x hx
    rcases h_surj ⟨x, hx⟩ with ⟨y, hy⟩
    convert y.mem
    rw [← Subtype.mk.inj hy]
    rfl
#align eq_of_linear_independent_of_span_subtype eq_of_linearIndependent_of_span_subtype

open LinearMap

/- warning: linear_independent.image_subtype -> LinearIndependent.image_subtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M' : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : AddCommGroup.{u3} M'] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_6 : Module.{u1, u3} R M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)] {s : Set.{u2} M} {f : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6}, (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (Disjoint.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)) (Submodule.orderBot.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 s) (LinearMap.ker.{u1, u1, u2, u3, max u2 u3} R R M M' (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M' (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f)) -> (LinearIndependent.{u3, u1, u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') (Set.image.{u2, u3} M M' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M' (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f) s)) R M' (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') (Set.image.{u2, u3} M M' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M' (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f) s)) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') (Set.image.{u2, u3} M M' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M' (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f) s)) M' (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') (Set.image.{u2, u3} M M' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M' (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f) s)) M' (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') (Set.image.{u2, u3} M M' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M' (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f) s)) M' (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') (Set.image.{u2, u3} M M' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M' (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f) s)) M' (coeSubtype.{succ u3} M' (fun (x : M') => Membership.Mem.{u3, u3} M' (Set.{u3} M') (Set.hasMem.{u3} M') x (Set.image.{u2, u3} M M' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) => M -> M') (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M' (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f) s)))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_6)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} {M' : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : AddCommGroup.{u1} M'] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] [_inst_6 : Module.{u2, u1} R M' (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3)] {s : Set.{u3} M} {f : LinearMap.{u2, u2, u3, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6}, (LinearIndependent.{u3, u2, u3} (Set.Elem.{u3} M s) R M (fun (x : Set.Elem.{u3} M s) => Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x s) x) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (Disjoint.{u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Submodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (Submodule.completeLattice.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) (Submodule.span.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5 s) (LinearMap.ker.{u2, u2, u3, u1, max u3 u1} R R M M' (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (LinearMap.{u2, u2, u3, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u2, u2, u3, u1} R R M M' (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) f)) -> (LinearIndependent.{u1, u2, u1} (Set.Elem.{u1} M' (Set.image.{u3, u1} M M' (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (LinearMap.{u2, u2, u3, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M') _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u3, u1} R R M M' (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) f) s)) R M' (fun (x : Set.Elem.{u1} M' (Set.image.{u3, u1} M M' (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (LinearMap.{u2, u2, u3, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M') _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u3, u1} R R M M' (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) f) s)) => Subtype.val.{succ u1} M' (fun (x : M') => Membership.mem.{u1, u1} M' (Set.{u1} M') (Set.instMembershipSet.{u1} M') x (Set.image.{u3, u1} M M' (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (LinearMap.{u2, u2, u3, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6) M (fun (a : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M') a) (LinearMap.instFunLikeLinearMap.{u2, u2, u3, u1} R R M M' (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) f) s)) x) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_6)
Case conversion may be inaccurate. Consider using '#align linear_independent.image_subtype LinearIndependent.image_subtypeₓ'. -/
theorem LinearIndependent.image_subtype {s : Set M} {f : M →ₗ[R] M'}
    (hs : LinearIndependent R (fun x => x : s → M)) (hf_inj : Disjoint (span R s) f.ker) :
    LinearIndependent R (fun x => x : f '' s → M') :=
  by
  rw [← @Subtype.range_coe _ s] at hf_inj
  refine' (hs.map hf_inj).to_subtype_range' _
  simp [Set.range_comp f]
#align linear_independent.image_subtype LinearIndependent.image_subtype

/- warning: linear_independent.inl_union_inr -> LinearIndependent.inl_union_inr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M' : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : AddCommGroup.{u3} M'] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_6 : Module.{u1, u3} R M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)] {s : Set.{u2} M} {t : Set.{u3} M'}, (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) R M (fun (x : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) s) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x s))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (LinearIndependent.{u3, u1, u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') t) R M' (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') t) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') t) M' (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') t) M' (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') t) M' (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} M') Type.{u3} (Set.hasCoeToSort.{u3} M') t) M' (coeSubtype.{succ u3} M' (fun (x : M') => Membership.Mem.{u3, u3} M' (Set.{u3} M') (Set.hasMem.{u3} M') x t))))) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_6) -> (LinearIndependent.{max u2 u3, u1, max u2 u3} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Set.{max u2 u3} (Prod.{u2, u3} M M')) Type.{max u2 u3} (Set.hasCoeToSort.{max u2 u3} (Prod.{u2, u3} M M')) (Union.union.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} M M')) (Set.hasUnion.{max u2 u3} (Prod.{u2, u3} M M')) (Set.image.{u2, max u2 u3} M (Prod.{u2, u3} M M') (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inl.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) s) (Set.image.{u3, max u2 u3} M' (Prod.{u2, u3} M M') (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M' -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M' (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inr.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) t))) R (Prod.{u2, u3} M M') (fun (x : coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Set.{max u2 u3} (Prod.{u2, u3} M M')) Type.{max u2 u3} (Set.hasCoeToSort.{max u2 u3} (Prod.{u2, u3} M M')) (Union.union.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} M M')) (Set.hasUnion.{max u2 u3} (Prod.{u2, u3} M M')) (Set.image.{u2, max u2 u3} M (Prod.{u2, u3} M M') (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inl.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) s) (Set.image.{u3, max u2 u3} M' (Prod.{u2, u3} M M') (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M' -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M' (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inr.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) t))) => (fun (a : Type.{max u2 u3}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{succ (max u2 u3), max (succ u2) (succ u3)} a b] => self.0) (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Set.{max u2 u3} (Prod.{u2, u3} M M')) Type.{max u2 u3} (Set.hasCoeToSort.{max u2 u3} (Prod.{u2, u3} M M')) (Union.union.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} M M')) (Set.hasUnion.{max u2 u3} (Prod.{u2, u3} M M')) (Set.image.{u2, max u2 u3} M (Prod.{u2, u3} M M') (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inl.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) s) (Set.image.{u3, max u2 u3} M' (Prod.{u2, u3} M M') (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M' -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M' (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inr.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) t))) (Prod.{u2, u3} M M') (HasLiftT.mk.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Set.{max u2 u3} (Prod.{u2, u3} M M')) Type.{max u2 u3} (Set.hasCoeToSort.{max u2 u3} (Prod.{u2, u3} M M')) (Union.union.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} M M')) (Set.hasUnion.{max u2 u3} (Prod.{u2, u3} M M')) (Set.image.{u2, max u2 u3} M (Prod.{u2, u3} M M') (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inl.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) s) (Set.image.{u3, max u2 u3} M' (Prod.{u2, u3} M M') (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M' -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M' (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inr.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) t))) (Prod.{u2, u3} M M') (CoeTCₓ.coe.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Set.{max u2 u3} (Prod.{u2, u3} M M')) Type.{max u2 u3} (Set.hasCoeToSort.{max u2 u3} (Prod.{u2, u3} M M')) (Union.union.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} M M')) (Set.hasUnion.{max u2 u3} (Prod.{u2, u3} M M')) (Set.image.{u2, max u2 u3} M (Prod.{u2, u3} M M') (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inl.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) s) (Set.image.{u3, max u2 u3} M' (Prod.{u2, u3} M M') (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M' -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M' (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inr.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) t))) (Prod.{u2, u3} M M') (coeBase.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Set.{max u2 u3} (Prod.{u2, u3} M M')) Type.{max u2 u3} (Set.hasCoeToSort.{max u2 u3} (Prod.{u2, u3} M M')) (Union.union.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} M M')) (Set.hasUnion.{max u2 u3} (Prod.{u2, u3} M M')) (Set.image.{u2, max u2 u3} M (Prod.{u2, u3} M M') (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inl.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) s) (Set.image.{u3, max u2 u3} M' (Prod.{u2, u3} M M') (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M' -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M' (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inr.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) t))) (Prod.{u2, u3} M M') (coeSubtype.{max (succ u2) (succ u3)} (Prod.{u2, u3} M M') (fun (x : Prod.{u2, u3} M M') => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} M M') (Set.{max u2 u3} (Prod.{u2, u3} M M')) (Set.hasMem.{max u2 u3} (Prod.{u2, u3} M M')) x (Union.union.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} M M')) (Set.hasUnion.{max u2 u3} (Prod.{u2, u3} M M')) (Set.image.{u2, max u2 u3} M (Prod.{u2, u3} M M') (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_5 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inl.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) s) (Set.image.{u3, max u2 u3} M' (Prod.{u2, u3} M M') (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u2, u3} M M') (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) => M' -> (Prod.{u2, u3} M M')) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M' (Prod.{u2, u3} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) _inst_6 (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inr.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6)) t))))))) x) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} M M' (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3)) (Prod.module.{u1, u2, u3} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} M' _inst_3) _inst_5 _inst_6))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u3}} {M' : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : AddCommGroup.{u2} M'] [_inst_5 : Module.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] [_inst_6 : Module.{u1, u2} R M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)] {s : Set.{u3} M} {t : Set.{u2} M'}, (LinearIndependent.{u3, u1, u3} (Set.Elem.{u3} M s) R M (fun (x : Set.Elem.{u3} M s) => Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x s) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} M' t) R M' (fun (x : Set.Elem.{u2} M' t) => Subtype.val.{succ u2} M' (fun (x : M') => Membership.mem.{u2, u2} M' (Set.{u2} M') (Set.instMembershipSet.{u2} M') x t) x) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_6) -> (LinearIndependent.{max u3 u2, u1, max u3 u2} (Set.Elem.{max u3 u2} (Prod.{u3, u2} M M') (Union.union.{max u3 u2} (Set.{max u3 u2} (Prod.{u3, u2} M M')) (Set.instUnionSet.{max u3 u2} (Prod.{u3, u2} M M')) (Set.image.{u3, max u3 u2} M (Prod.{u3, u2} M M') (FunLike.coe.{max (succ u3) (succ u2), succ u3, max (succ u3) (succ u2)} (LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u3, u2} M M') (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_5 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u3, u2} M M') _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u3 u2} R R M (Prod.{u3, u2} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_5 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inl.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) s) (Set.image.{u2, max u3 u2} M' (Prod.{u3, u2} M M') (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u3, u2} M M') (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_6 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) M' (fun (_x : M') => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M') => Prod.{u3, u2} M M') _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u2} R R M' (Prod.{u3, u2} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_6 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inr.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) t))) R (Prod.{u3, u2} M M') (fun (x : Set.Elem.{max u3 u2} (Prod.{u3, u2} M M') (Union.union.{max u3 u2} (Set.{max u3 u2} (Prod.{u3, u2} M M')) (Set.instUnionSet.{max u3 u2} (Prod.{u3, u2} M M')) (Set.image.{u3, max u3 u2} M (Prod.{u3, u2} M M') (FunLike.coe.{max (succ u3) (succ u2), succ u3, max (succ u3) (succ u2)} (LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u3, u2} M M') (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_5 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u3, u2} M M') _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u3 u2} R R M (Prod.{u3, u2} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_5 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inl.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) s) (Set.image.{u2, max u3 u2} M' (Prod.{u3, u2} M M') (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u3, u2} M M') (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_6 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) M' (fun (_x : M') => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M') => Prod.{u3, u2} M M') _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u2} R R M' (Prod.{u3, u2} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_6 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inr.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) t))) => Subtype.val.{succ (max u3 u2)} (Prod.{u3, u2} M M') (fun (x : Prod.{u3, u2} M M') => Membership.mem.{max u3 u2, max u3 u2} (Prod.{u3, u2} M M') (Set.{max u3 u2} (Prod.{u3, u2} M M')) (Set.instMembershipSet.{max u3 u2} (Prod.{u3, u2} M M')) x (Union.union.{max u3 u2} (Set.{max u3 u2} (Prod.{u3, u2} M M')) (Set.instUnionSet.{max u3 u2} (Prod.{u3, u2} M M')) (Set.image.{u3, max u3 u2} M (Prod.{u3, u2} M M') (FunLike.coe.{max (succ u3) (succ u2), succ u3, max (succ u3) (succ u2)} (LinearMap.{u1, u1, u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M (Prod.{u3, u2} M M') (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_5 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) M (fun (a : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u3, u2} M M') a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u3 u2} R R M (Prod.{u3, u2} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_5 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inl.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) s) (Set.image.{u2, max u3 u2} M' (Prod.{u3, u2} M M') (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (LinearMap.{u1, u1, u2, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) M' (Prod.{u3, u2} M M') (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_6 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) M' (fun (a : M') => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M') => Prod.{u3, u2} M M') a) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u2} R R M' (Prod.{u3, u2} M M') (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) _inst_6 (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.inr.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6)) t))) x) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u3, u2} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3)) (Prod.module.{u1, u3, u2} R M M' (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u2} M' _inst_3) _inst_5 _inst_6))
Case conversion may be inaccurate. Consider using '#align linear_independent.inl_union_inr LinearIndependent.inl_union_inrₓ'. -/
theorem LinearIndependent.inl_union_inr {s : Set M} {t : Set M'}
    (hs : LinearIndependent R (fun x => x : s → M))
    (ht : LinearIndependent R (fun x => x : t → M')) :
    LinearIndependent R (fun x => x : inl R M M' '' s ∪ inr R M M' '' t → M × M') :=
  by
  refine' (hs.image_subtype _).union (ht.image_subtype _) _ <;> [simp, simp, skip]
  simp only [span_image]
  simp [disjoint_iff, prod_inf_prod]
#align linear_independent.inl_union_inr LinearIndependent.inl_union_inr

/- warning: linear_independent_inl_union_inr' -> linearIndependent_inl_union_inr' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {ι' : Type.{u2}} {R : Type.{u3}} {M : Type.{u4}} {M' : Type.{u5}} [_inst_1 : Ring.{u3} R] [_inst_2 : AddCommGroup.{u4} M] [_inst_3 : AddCommGroup.{u5} M'] [_inst_5 : Module.{u3, u4} R M (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2)] [_inst_6 : Module.{u3, u5} R M' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3)] {v : ι -> M} {v' : ι' -> M'}, (LinearIndependent.{u1, u3, u4} ι R M v (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) _inst_5) -> (LinearIndependent.{u2, u3, u5} ι' R M' v' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) _inst_6) -> (LinearIndependent.{max u1 u2, u3, max u4 u5} (Sum.{u1, u2} ι ι') R (Prod.{u4, u5} M M') (Sum.elim.{u1, u2, succ (max u4 u5)} ι ι' (Prod.{u4, u5} M M') (Function.comp.{succ u1, succ u4, succ (max u4 u5)} ι M (Prod.{u4, u5} M M') (coeFn.{max (succ u4) (succ (max u4 u5)), max (succ u4) (succ (max u4 u5))} (LinearMap.{u3, u3, u4, max u4 u5} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) M (Prod.{u4, u5} M M') (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (Prod.addCommMonoid.{u4, u5} M M' (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3)) _inst_5 (Prod.module.{u3, u4, u5} R M M' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u3, u3, u4, max u4 u5} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) M (Prod.{u4, u5} M M') (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (Prod.addCommMonoid.{u4, u5} M M' (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3)) _inst_5 (Prod.module.{u3, u4, u5} R M M' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) _inst_5 _inst_6)) => M -> (Prod.{u4, u5} M M')) (LinearMap.hasCoeToFun.{u3, u3, u4, max u4 u5} R R M (Prod.{u4, u5} M M') (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (Prod.addCommMonoid.{u4, u5} M M' (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3)) _inst_5 (Prod.module.{u3, u4, u5} R M M' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (LinearMap.inl.{u3, u4, u5} R M M' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) _inst_5 _inst_6)) v) (Function.comp.{succ u2, succ u5, max (succ u4) (succ u5)} ι' M' (Prod.{u4, u5} M M') (coeFn.{max (succ u5) (succ (max u4 u5)), max (succ u5) (succ (max u4 u5))} (LinearMap.{u3, u3, u5, max u4 u5} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) M' (Prod.{u4, u5} M M') (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) (Prod.addCommMonoid.{u4, u5} M M' (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3)) _inst_6 (Prod.module.{u3, u4, u5} R M M' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) _inst_5 _inst_6)) (fun (_x : LinearMap.{u3, u3, u5, max u4 u5} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) M' (Prod.{u4, u5} M M') (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) (Prod.addCommMonoid.{u4, u5} M M' (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3)) _inst_6 (Prod.module.{u3, u4, u5} R M M' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) _inst_5 _inst_6)) => M' -> (Prod.{u4, u5} M M')) (LinearMap.hasCoeToFun.{u3, u3, u5, max u4 u5} R R M' (Prod.{u4, u5} M M') (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) (Prod.addCommMonoid.{u4, u5} M M' (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3)) _inst_6 (Prod.module.{u3, u4, u5} R M M' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (LinearMap.inr.{u3, u4, u5} R M M' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) _inst_5 _inst_6)) v')) (Ring.toSemiring.{u3} R _inst_1) (Prod.addCommMonoid.{u4, u5} M M' (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3)) (Prod.module.{u3, u4, u5} R M M' (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} M _inst_2) (AddCommGroup.toAddCommMonoid.{u5} M' _inst_3) _inst_5 _inst_6))
but is expected to have type
  forall {ι : Type.{u5}} {ι' : Type.{u2}} {R : Type.{u4}} {M : Type.{u3}} {M' : Type.{u1}} [_inst_1 : Ring.{u4} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : AddCommGroup.{u1} M'] [_inst_5 : Module.{u4, u3} R M (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] [_inst_6 : Module.{u4, u1} R M' (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3)] {v : ι -> M} {v' : ι' -> M'}, (LinearIndependent.{u5, u4, u3} ι R M v (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_5) -> (LinearIndependent.{u2, u4, u1} ι' R M' v' (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_6) -> (LinearIndependent.{max u2 u5, u4, max u3 u1} (Sum.{u5, u2} ι ι') R (Prod.{u3, u1} M M') (Sum.elim.{u5, u2, succ (max u3 u1)} ι ι' (Prod.{u3, u1} M M') (Function.comp.{succ u5, succ u3, succ (max u3 u1)} ι M (Prod.{u3, u1} M M') (FunLike.coe.{max (succ u3) (succ u1), succ u3, max (succ u3) (succ u1)} (LinearMap.{u4, u4, u3, max u1 u3} R R (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) M (Prod.{u3, u1} M M') (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Prod.instAddCommMonoidSum.{u3, u1} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3)) _inst_5 (Prod.module.{u4, u3, u1} R M M' (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u3, u1} M M') _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, max u3 u1} R R M (Prod.{u3, u1} M M') (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Prod.instAddCommMonoidSum.{u3, u1} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3)) _inst_5 (Prod.module.{u4, u3, u1} R M M' (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1)))) (LinearMap.inl.{u4, u3, u1} R M M' (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6)) v) (Function.comp.{succ u2, succ u1, max (succ u3) (succ u1)} ι' M' (Prod.{u3, u1} M M') (FunLike.coe.{max (succ u3) (succ u1), succ u1, max (succ u3) (succ u1)} (LinearMap.{u4, u4, u1, max u1 u3} R R (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) M' (Prod.{u3, u1} M M') (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) (Prod.instAddCommMonoidSum.{u3, u1} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3)) _inst_6 (Prod.module.{u4, u3, u1} R M M' (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6)) M' (fun (_x : M') => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M') => Prod.{u3, u1} M M') _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u1, max u3 u1} R R M' (Prod.{u3, u1} M M') (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) (Prod.instAddCommMonoidSum.{u3, u1} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3)) _inst_6 (Prod.module.{u4, u3, u1} R M M' (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1)))) (LinearMap.inr.{u4, u3, u1} R M M' (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6)) v')) (Ring.toSemiring.{u4} R _inst_1) (Prod.instAddCommMonoidSum.{u3, u1} M M' (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3)) (Prod.module.{u4, u3, u1} R M M' (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} M' _inst_3) _inst_5 _inst_6))
Case conversion may be inaccurate. Consider using '#align linear_independent_inl_union_inr' linearIndependent_inl_union_inr'ₓ'. -/
theorem linearIndependent_inl_union_inr' {v : ι → M} {v' : ι' → M'} (hv : LinearIndependent R v)
    (hv' : LinearIndependent R v') :
    LinearIndependent R (Sum.elim (inl R M M' ∘ v) (inr R M M' ∘ v')) :=
  (hv.map' (inl R M M') ker_inl).sum_type (hv'.map' (inr R M M') ker_inr) <| by
    refine' is_compl_range_inl_inr.disjoint.mono _ _ <;>
      simp only [span_le, range_coe, range_comp_subset_range]
#align linear_independent_inl_union_inr' linearIndependent_inl_union_inr'

/- warning: linear_independent_monoid_hom -> linearIndependent_monoidHom is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_8 : Monoid.{u1} G] (L : Type.{u2}) [_inst_9 : CommRing.{u2} L] [_inst_10 : NoZeroDivisors.{u2} L (Distrib.toHasMul.{u2} L (Ring.toDistrib.{u2} L (CommRing.toRing.{u2} L _inst_9))) (MulZeroClass.toHasZero.{u2} L (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (CommRing.toRing.{u2} L _inst_9))))))], LinearIndependent.{max u2 u1, u2, max u1 u2} (MonoidHom.{u1, u2} G L (Monoid.toMulOneClass.{u1} G _inst_8) (MulZeroOneClass.toMulOneClass.{u2} L (NonAssocSemiring.toMulZeroOneClass.{u2} L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (CommRing.toRing.{u2} L _inst_9)))))) L (G -> L) (fun (f : MonoidHom.{u1, u2} G L (Monoid.toMulOneClass.{u1} G _inst_8) (MulZeroOneClass.toMulOneClass.{u2} L (NonAssocSemiring.toMulZeroOneClass.{u2} L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (CommRing.toRing.{u2} L _inst_9)))))) => coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} G L (Monoid.toMulOneClass.{u1} G _inst_8) (MulZeroOneClass.toMulOneClass.{u2} L (NonAssocSemiring.toMulZeroOneClass.{u2} L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (CommRing.toRing.{u2} L _inst_9)))))) (fun (_x : MonoidHom.{u1, u2} G L (Monoid.toMulOneClass.{u1} G _inst_8) (MulZeroOneClass.toMulOneClass.{u2} L (NonAssocSemiring.toMulZeroOneClass.{u2} L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (CommRing.toRing.{u2} L _inst_9)))))) => G -> L) (MonoidHom.hasCoeToFun.{u1, u2} G L (Monoid.toMulOneClass.{u1} G _inst_8) (MulZeroOneClass.toMulOneClass.{u2} L (NonAssocSemiring.toMulZeroOneClass.{u2} L (NonAssocRing.toNonAssocSemiring.{u2} L (Ring.toNonAssocRing.{u2} L (CommRing.toRing.{u2} L _inst_9)))))) f) (Ring.toSemiring.{u2} L (CommRing.toRing.{u2} L _inst_9)) (Pi.addCommMonoid.{u1, u2} G (fun (ᾰ : G) => L) (fun (i : G) => AddCommGroup.toAddCommMonoid.{u2} L (NonUnitalNonAssocRing.toAddCommGroup.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (CommRing.toRing.{u2} L _inst_9)))))) (Pi.Function.module.{u1, u2, u2} G L L (Ring.toSemiring.{u2} L (CommRing.toRing.{u2} L _inst_9)) (AddCommGroup.toAddCommMonoid.{u2} L (NonUnitalNonAssocRing.toAddCommGroup.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (CommRing.toRing.{u2} L _inst_9))))) (Semiring.toModule.{u2} L (Ring.toSemiring.{u2} L (CommRing.toRing.{u2} L _inst_9))))
but is expected to have type
  forall (G : Type.{u2}) [_inst_8 : Monoid.{u2} G] (L : Type.{u1}) [_inst_9 : CommRing.{u1} L] [_inst_10 : NoZeroDivisors.{u1} L (NonUnitalNonAssocRing.toMul.{u1} L (NonUnitalRing.toNonUnitalNonAssocRing.{u1} L (NonUnitalCommRing.toNonUnitalRing.{u1} L (CommRing.toNonUnitalCommRing.{u1} L _inst_9)))) (CommMonoidWithZero.toZero.{u1} L (CommSemiring.toCommMonoidWithZero.{u1} L (CommRing.toCommSemiring.{u1} L _inst_9)))], LinearIndependent.{max u2 u1, u1, max u2 u1} (MonoidHom.{u2, u1} G L (Monoid.toMulOneClass.{u2} G _inst_8) (MulZeroOneClass.toMulOneClass.{u1} L (NonAssocSemiring.toMulZeroOneClass.{u1} L (Semiring.toNonAssocSemiring.{u1} L (Ring.toSemiring.{u1} L (CommRing.toRing.{u1} L _inst_9)))))) L (G -> L) (fun (f : MonoidHom.{u2, u1} G L (Monoid.toMulOneClass.{u2} G _inst_8) (MulZeroOneClass.toMulOneClass.{u1} L (NonAssocSemiring.toMulZeroOneClass.{u1} L (Semiring.toNonAssocSemiring.{u1} L (Ring.toSemiring.{u1} L (CommRing.toRing.{u1} L _inst_9)))))) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} G L (Monoid.toMulOneClass.{u2} G _inst_8) (MulZeroOneClass.toMulOneClass.{u1} L (NonAssocSemiring.toMulZeroOneClass.{u1} L (Semiring.toNonAssocSemiring.{u1} L (Ring.toSemiring.{u1} L (CommRing.toRing.{u1} L _inst_9)))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2372 : G) => L) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G L (Monoid.toMulOneClass.{u2} G _inst_8) (MulZeroOneClass.toMulOneClass.{u1} L (NonAssocSemiring.toMulZeroOneClass.{u1} L (Semiring.toNonAssocSemiring.{u1} L (Ring.toSemiring.{u1} L (CommRing.toRing.{u1} L _inst_9)))))) G L (MulOneClass.toMul.{u2} G (Monoid.toMulOneClass.{u2} G _inst_8)) (MulOneClass.toMul.{u1} L (MulZeroOneClass.toMulOneClass.{u1} L (NonAssocSemiring.toMulZeroOneClass.{u1} L (Semiring.toNonAssocSemiring.{u1} L (Ring.toSemiring.{u1} L (CommRing.toRing.{u1} L _inst_9)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} G L (Monoid.toMulOneClass.{u2} G _inst_8) (MulZeroOneClass.toMulOneClass.{u1} L (NonAssocSemiring.toMulZeroOneClass.{u1} L (Semiring.toNonAssocSemiring.{u1} L (Ring.toSemiring.{u1} L (CommRing.toRing.{u1} L _inst_9)))))) G L (Monoid.toMulOneClass.{u2} G _inst_8) (MulZeroOneClass.toMulOneClass.{u1} L (NonAssocSemiring.toMulZeroOneClass.{u1} L (Semiring.toNonAssocSemiring.{u1} L (Ring.toSemiring.{u1} L (CommRing.toRing.{u1} L _inst_9))))) (MonoidHom.monoidHomClass.{u2, u1} G L (Monoid.toMulOneClass.{u2} G _inst_8) (MulZeroOneClass.toMulOneClass.{u1} L (NonAssocSemiring.toMulZeroOneClass.{u1} L (Semiring.toNonAssocSemiring.{u1} L (Ring.toSemiring.{u1} L (CommRing.toRing.{u1} L _inst_9)))))))) f) (Ring.toSemiring.{u1} L (CommRing.toRing.{u1} L _inst_9)) (Pi.addCommMonoid.{u2, u1} G (fun (ᾰ : G) => L) (fun (i : G) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} L (NonUnitalRing.toNonUnitalNonAssocRing.{u1} L (NonUnitalCommRing.toNonUnitalRing.{u1} L (CommRing.toNonUnitalCommRing.{u1} L _inst_9)))))) (Pi.module.{u2, u1, u1} G (fun (a._@.Mathlib.LinearAlgebra.LinearIndependent._hyg.14559 : G) => L) L (Ring.toSemiring.{u1} L (CommRing.toRing.{u1} L _inst_9)) (fun (i : G) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} L (NonUnitalRing.toNonUnitalNonAssocRing.{u1} L (NonUnitalCommRing.toNonUnitalRing.{u1} L (CommRing.toNonUnitalCommRing.{u1} L _inst_9))))) (fun (i : G) => instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} L (CommRing.toRing.{u1} L _inst_9)))
Case conversion may be inaccurate. Consider using '#align linear_independent_monoid_hom linearIndependent_monoidHomₓ'. -/
-- See, for example, Keith Conrad's note
--  <https://kconrad.math.uconn.edu/blurbs/galoistheory/linearchar.pdf>
/-- Dedekind's linear independence of characters -/
theorem linearIndependent_monoidHom (G : Type _) [Monoid G] (L : Type _) [CommRing L]
    [NoZeroDivisors L] : @LinearIndependent _ L (G → L) (fun f => f : (G →* L) → G → L) _ _ _ := by
  letI := Classical.decEq (G →* L) <;>
      letI : MulAction L L :=
        DistribMulAction.toMulAction <;>-- We prove linear independence by showing that only the trivial linear combination vanishes.
    exact
      linearIndependent_iff'.2-- To do this, we use `finset` induction,
      fun s =>
        Finset.induction_on s (fun g hg i => False.elim) fun a s has ih g hg =>
          -- Here
          -- * `a` is a new character we will insert into the `finset` of characters `s`,
          -- * `ih` is the fact that only the trivial linear combination of characters in `s` is zero
          -- * `hg` is the fact that `g` are the coefficients of a linear combination summing to zero
          -- and it remains to prove that `g` vanishes on `insert a s`.
          -- We now make the key calculation:
          -- For any character `i` in the original `finset`, we have `g i • i = g i • a` as functions on the
          -- monoid `G`.
          have h1 : ∀ i ∈ s, (g i • i : G → L) = g i • a := fun i his =>
            funext fun x : G =>
              -- We prove these expressions are equal by showing
                -- the differences of their values on each monoid element `x` is zero
                eq_of_sub_eq_zero <|
                ih (fun j => g j * j x - g j * a x)
                  (funext fun y : G =>
                    calc
                      (-- After that, it's just a chase scene.
                            ∑ i in s, ((g i * i x - g i * a x) • i : G → L))
                            y =
                          ∑ i in s, (g i * i x - g i * a x) * i y :=
                        Finset.sum_apply _ _ _
                      _ = ∑ i in s, g i * i x * i y - g i * a x * i y :=
                        (Finset.sum_congr rfl fun _ _ => sub_mul _ _ _)
                      _ = (∑ i in s, g i * i x * i y) - ∑ i in s, g i * a x * i y :=
                        Finset.sum_sub_distrib
                      _ =
                          (g a * a x * a y + ∑ i in s, g i * i x * i y) -
                            (g a * a x * a y + ∑ i in s, g i * a x * i y) :=
                        by rw [add_sub_add_left_eq_sub]
                      _ =
                          (∑ i in insert a s, g i * i x * i y) -
                            ∑ i in insert a s, g i * a x * i y :=
                        by rw [Finset.sum_insert has, Finset.sum_insert has]
                      _ =
                          (∑ i in insert a s, g i * i (x * y)) -
                            ∑ i in insert a s, a x * (g i * i y) :=
                        (congr
                          (congr_arg Sub.sub
                            (Finset.sum_congr rfl fun i _ => by rw [i.map_mul, mul_assoc]))
                          (Finset.sum_congr rfl fun _ _ => by rw [mul_assoc, mul_left_comm]))
                      _ =
                          (∑ i in insert a s, (g i • i : G → L)) (x * y) -
                            a x * (∑ i in insert a s, (g i • i : G → L)) y :=
                        by rw [Finset.sum_apply, Finset.sum_apply, Finset.mul_sum] <;> rfl
                      _ = 0 - a x * 0 := by rw [hg] <;> rfl
                      _ = 0 := by rw [mul_zero, sub_zero]
                      )
                  i his
          -- On the other hand, since `a` is not already in `s`, for any character `i ∈ s`
          -- there is some element of the monoid on which it differs from `a`.
          have h2 : ∀ i : G →* L, i ∈ s → ∃ y, i y ≠ a y := fun i his =>
            by_contradiction fun h =>
              have hia : i = a := MonoidHom.ext fun y => by_contradiction fun hy => h ⟨y, hy⟩
              has <| hia ▸ his
          -- From these two facts we deduce that `g` actually vanishes on `s`,
          have h3 : ∀ i ∈ s, g i = 0 := fun i his =>
            let ⟨y, hy⟩ := h2 i his
            have h : g i • i y = g i • a y := congr_fun (h1 i his) y
            Or.resolve_right (mul_eq_zero.1 <| by rw [mul_sub, sub_eq_zero] <;> exact h)
              (sub_ne_zero_of_ne hy)
          -- And so, using the fact that the linear combination over `s` and over `insert a s` both vanish,
          -- we deduce that `g a = 0`.
          have h4 : g a = 0 :=
            calc
              g a = g a * 1 := (mul_one _).symm
              _ = (g a • a : G → L) 1 := by rw [← a.map_one] <;> rfl
              _ = (∑ i in insert a s, (g i • i : G → L)) 1 :=
                by
                rw [Finset.sum_eq_single a]
                · intro i his hia
                  rw [Finset.mem_insert] at his
                  rw [h3 i (his.resolve_left hia), zero_smul]
                · intro haas
                  exfalso
                  apply haas
                  exact Finset.mem_insert_self a s
              _ = 0 := by rw [hg] <;> rfl
              
          (-- Now we're done; the last two facts together imply that `g` vanishes on every element
                -- of `insert a s`.
                Finset.forall_mem_insert
                _ _ _).2
            ⟨h4, h3⟩
#align linear_independent_monoid_hom linearIndependent_monoidHom

/- warning: le_of_span_le_span -> le_of_span_le_span is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_8 : Nontrivial.{u1} R] {s : Set.{u2} M} {t : Set.{u2} M} {u : Set.{u2} M}, (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) u) R M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) u) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) u) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) u) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) u) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x u)))))) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s u) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) t u) -> (LE.le.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)))) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 s) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 t)) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s t)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_8 : Nontrivial.{u2} R] {s : Set.{u1} M} {t : Set.{u1} M} {u : Set.{u1} M}, (LinearIndependent.{u1, u2, u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x u)) R M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x u)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) s u) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) t u) -> (LE.le.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))))) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 s) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 t)) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) s t)
Case conversion may be inaccurate. Consider using '#align le_of_span_le_span le_of_span_le_spanₓ'. -/
theorem le_of_span_le_span [Nontrivial R] {s t u : Set M} (hl : LinearIndependent R (coe : u → M))
    (hsu : s ⊆ u) (htu : t ⊆ u) (hst : span R s ≤ span R t) : s ⊆ t :=
  by
  have :=
    eq_of_linearIndependent_of_span_subtype (hl.mono (Set.union_subset hsu htu))
      (Set.subset_union_right _ _) (Set.union_subset (Set.Subset.trans subset_span hst) subset_span)
  rw [← this]; apply Set.subset_union_left
#align le_of_span_le_span le_of_span_le_span

/- warning: span_le_span_iff -> span_le_span_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_8 : Nontrivial.{u1} R] {s : Set.{u2} M} {t : Set.{u2} M} {u : Set.{u2} M}, (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) u) R M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) u) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) u) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) u) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) u) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x u)))))) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s u) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) t u) -> (Iff (LE.le.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5)))) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 s) (Submodule.span.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_5 t)) (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) s t))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] [_inst_8 : Nontrivial.{u2} R] {s : Set.{u1} M} {t : Set.{u1} M} {u : Set.{u1} M}, (LinearIndependent.{u1, u2, u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x u)) R M (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x u)) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) s u) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) t u) -> (Iff (LE.le.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Preorder.toLE.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5))))) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 s) (Submodule.span.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_5 t)) (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) s t))
Case conversion may be inaccurate. Consider using '#align span_le_span_iff span_le_span_iffₓ'. -/
theorem span_le_span_iff [Nontrivial R] {s t u : Set M} (hl : LinearIndependent R (coe : u → M))
    (hsu : s ⊆ u) (htu : t ⊆ u) : span R s ≤ span R t ↔ s ⊆ t :=
  ⟨le_of_span_le_span hl hsu htu, span_mono⟩
#align span_le_span_iff span_le_span_iff

end Module

section Nontrivial

variable [Ring R] [Nontrivial R] [AddCommGroup M] [AddCommGroup M']

variable [Module R M] [NoZeroSMulDivisors R M] [Module R M']

variable {v : ι → M} {s t : Set M} {x y z : M}

/- warning: linear_independent_unique_iff -> linearIndependent_unique_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Nontrivial.{u2} R] [_inst_3 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)] [_inst_6 : NoZeroSMulDivisors.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)))) (Module.toMulActionWithZero.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5))))] (v : ι -> M) [_inst_8 : Unique.{succ u1} ι], Iff (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5) (Ne.{succ u3} M (v (Inhabited.default.{succ u1} ι (Unique.inhabited.{succ u1} ι _inst_8))) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_3)))))))))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Nontrivial.{u2} R] [_inst_3 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3)] [_inst_6 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3) _inst_5))))] (v : ι -> M) [_inst_8 : Unique.{succ u3} ι], Iff (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3) _inst_5) (Ne.{succ u1} M (v (Inhabited.default.{succ u3} ι (Unique.instInhabited.{succ u3} ι _inst_8))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_unique_iff linearIndependent_unique_iffₓ'. -/
theorem linearIndependent_unique_iff (v : ι → M) [Unique ι] :
    LinearIndependent R v ↔ v default ≠ 0 :=
  by
  simp only [linearIndependent_iff, Finsupp.total_unique, smul_eq_zero]
  refine' ⟨fun h hv => _, fun hv l hl => Finsupp.unique_ext <| hl.resolve_right hv⟩
  have := h (Finsupp.single default 1) (Or.inr hv)
  exact one_ne_zero (Finsupp.single_eq_zero.1 this)
#align linear_independent_unique_iff linearIndependent_unique_iff

/- warning: linear_independent_unique -> linearIndependent_unique is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Nontrivial.{u2} R] [_inst_3 : AddCommGroup.{u3} M] [_inst_5 : Module.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)] [_inst_6 : NoZeroSMulDivisors.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_3)))) (Module.toMulActionWithZero.{u2, u3} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5))))] (v : ι -> M) [_inst_8 : Unique.{succ u1} ι], (Ne.{succ u3} M (v (Inhabited.default.{succ u1} ι (Unique.inhabited.{succ u1} ι _inst_8))) (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_3))))))))) -> (LinearIndependent.{u1, u2, u3} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_3) _inst_5)
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Ring.{u2} R] [_inst_2 : Nontrivial.{u2} R] [_inst_3 : AddCommGroup.{u1} M] [_inst_5 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3)] [_inst_6 : NoZeroSMulDivisors.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (SMulZeroClass.toSMul.{u2, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3))))) (Module.toMulActionWithZero.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3) _inst_5))))] (v : ι -> M) [_inst_8 : Unique.{succ u3} ι], (Ne.{succ u1} M (v (Inhabited.default.{succ u3} ι (Unique.instInhabited.{succ u3} ι _inst_8))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_3)))))))) -> (LinearIndependent.{u3, u2, u1} ι R M v (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_3) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent_unique linearIndependent_uniqueₓ'. -/
alias linearIndependent_unique_iff ↔ _ linearIndependent_unique
#align linear_independent_unique linearIndependent_unique

/- warning: linear_independent_singleton -> linearIndependent_singleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Nontrivial.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] [_inst_6 : NoZeroSMulDivisors.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3))))) (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5))))] {x : M}, (Ne.{succ u2} M x (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (SubNegMonoid.toAddMonoid.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_3))))))))) -> (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)) R M (fun (x_1 : coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)) M (coeSubtype.{succ u2} M (fun (x_1 : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x_1 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.hasSingleton.{u2} M) x)))))) x_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Nontrivial.{u1} R] [_inst_3 : AddCommGroup.{u2} M] [_inst_5 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3)] [_inst_6 : NoZeroSMulDivisors.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (SMulZeroClass.toSMul.{u1, u2} R M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5))))] {x : M}, (Ne.{succ u2} M x (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (NegZeroClass.toZero.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_3)))))))) -> (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} M (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) x)) R M (fun (x_1 : Set.Elem.{u2} M (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) x)) => Subtype.val.{succ u2} M (fun (x_1 : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x_1 (Singleton.singleton.{u2, u2} M (Set.{u2} M) (Set.instSingletonSet.{u2} M) x)) x_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} M _inst_3) _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_independent_singleton linearIndependent_singletonₓ'. -/
theorem linearIndependent_singleton {x : M} (hx : x ≠ 0) :
    LinearIndependent R (fun x => x : ({x} : Set M) → M) :=
  linearIndependent_unique coe hx
#align linear_independent_singleton linearIndependent_singleton

end Nontrivial

/-!
### Properties which require `division_ring K`

These can be considered generalizations of properties of linear independence in vector spaces.
-/


section Module

variable [DivisionRing K] [AddCommGroup V] [AddCommGroup V']

variable [Module K V] [Module K V']

variable {v : ι → V} {s t : Set V} {x y z : V}

open Submodule

/- warning: mem_span_insert_exchange -> mem_span_insert_exchange is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {s : Set.{u1} V} {x : V} {y : V}, (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) x (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) y s))) -> (Not (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) x (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 s))) -> (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) y (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} {x : V} {y : V}, (Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)) x (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 (Insert.insert.{u2, u2} V (Set.{u2} V) (Set.instInsertSet.{u2} V) y s))) -> (Not (Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)) x (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 s))) -> (Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)) y (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 (Insert.insert.{u2, u2} V (Set.{u2} V) (Set.instInsertSet.{u2} V) x s)))
Case conversion may be inaccurate. Consider using '#align mem_span_insert_exchange mem_span_insert_exchangeₓ'. -/
/- TODO: some of the following proofs can generalized with a zero_ne_one predicate type class
   (instead of a data containing type class) -/
theorem mem_span_insert_exchange :
    x ∈ span K (insert y s) → x ∉ span K s → y ∈ span K (insert x s) :=
  by
  simp [mem_span_insert]
  rintro a z hz rfl h
  refine' ⟨a⁻¹, -a⁻¹ • z, smul_mem _ _ hz, _⟩
  have a0 : a ≠ 0 := by
    rintro rfl
    simp_all
  simp [a0, smul_add, smul_smul]
#align mem_span_insert_exchange mem_span_insert_exchange

/- warning: linear_independent_iff_not_mem_span -> linearIndependent_iff_not_mem_span is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} {K : Type.{u3}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u3} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {v : ι -> V}, Iff (LinearIndependent.{u2, u3, u1} ι K V v (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (forall (i : ι), Not (Membership.Mem.{u1, u1} V (Submodule.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) (v i) (Submodule.span.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Set.image.{u2, u1} ι V v (SDiff.sdiff.{u2} (Set.{u2} ι) (BooleanAlgebra.toHasSdiff.{u2} (Set.{u2} ι) (Set.booleanAlgebra.{u2} ι)) (Set.univ.{u2} ι) (Singleton.singleton.{u2, u2} ι (Set.{u2} ι) (Set.hasSingleton.{u2} ι) i))))))
but is expected to have type
  forall {ι : Type.{u2}} {K : Type.{u1}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {v : ι -> V}, Iff (LinearIndependent.{u2, u1, u3} ι K V v (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (forall (i : ι), Not (Membership.mem.{u3, u3} V (Submodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4)) (v i) (Submodule.span.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4 (Set.image.{u2, u3} ι V v (SDiff.sdiff.{u2} (Set.{u2} ι) (Set.instSDiffSet.{u2} ι) (Set.univ.{u2} ι) (Singleton.singleton.{u2, u2} ι (Set.{u2} ι) (Set.instSingletonSet.{u2} ι) i))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_iff_not_mem_span linearIndependent_iff_not_mem_spanₓ'. -/
theorem linearIndependent_iff_not_mem_span :
    LinearIndependent K v ↔ ∀ i, v i ∉ span K (v '' (univ \ {i})) :=
  by
  apply linear_independent_iff_not_smul_mem_span.trans
  constructor
  · intro h i h_in_span
    apply one_ne_zero (h i 1 (by simp [h_in_span]))
  · intro h i a ha
    by_contra ha'
    exact False.elim (h _ ((smul_mem_iff _ ha').1 ha))
#align linear_independent_iff_not_mem_span linearIndependent_iff_not_mem_span

/- warning: linear_independent.insert -> LinearIndependent.insert is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {s : Set.{u1} V} {x : V}, (LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) K V (fun (b : coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x s))))) b) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) -> (Not (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) x (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 s))) -> (LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) K V (fun (b : coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) V (coeSubtype.{succ u1} V (fun (x_1 : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x_1 (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)))))) b) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} {x : V}, (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} V s) K V (fun (b : Set.Elem.{u2} V s) => Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s) b) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) -> (Not (Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)) x (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 s))) -> (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} V (Insert.insert.{u2, u2} V (Set.{u2} V) (Set.instInsertSet.{u2} V) x s)) K V (fun (b : Set.Elem.{u2} V (Insert.insert.{u2, u2} V (Set.{u2} V) (Set.instInsertSet.{u2} V) x s)) => Subtype.val.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x_1 (Insert.insert.{u2, u2} V (Set.{u2} V) (Set.instInsertSet.{u2} V) x s)) b) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)
Case conversion may be inaccurate. Consider using '#align linear_independent.insert LinearIndependent.insertₓ'. -/
theorem LinearIndependent.insert (hs : LinearIndependent K (fun b => b : s → V))
    (hx : x ∉ span K s) : LinearIndependent K (fun b => b : insert x s → V) :=
  by
  rw [← union_singleton]
  have x0 : x ≠ 0 := mt (by rintro rfl <;> apply zero_mem (span K s)) hx
  apply hs.union (linearIndependent_singleton x0)
  rwa [disjoint_span_singleton' x0]
#align linear_independent.insert LinearIndependent.insert

/- warning: linear_independent_option' -> linearIndependent_option' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} {K : Type.{u3}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u3} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {v : ι -> V} {x : V}, Iff (LinearIndependent.{u2, u3, u1} (Option.{u2} ι) K V (fun (o : Option.{u2} ι) => Option.casesOn'.{u2, u1} ι V o x v) (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (And (LinearIndependent.{u2, u3, u1} ι K V v (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Not (Membership.Mem.{u1, u1} V (Submodule.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) x (Submodule.span.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Set.range.{u1, succ u2} V ι v)))))
but is expected to have type
  forall {ι : Type.{u2}} {K : Type.{u1}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {v : ι -> V} {x : V}, Iff (LinearIndependent.{u2, u1, u3} (Option.{u2} ι) K V (fun (o : Option.{u2} ι) => Option.casesOn'.{u2, u3} ι V o x v) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (And (LinearIndependent.{u2, u1, u3} ι K V v (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (Not (Membership.mem.{u3, u3} V (Submodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4)) x (Submodule.span.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4 (Set.range.{u3, succ u2} V ι v)))))
Case conversion may be inaccurate. Consider using '#align linear_independent_option' linearIndependent_option'ₓ'. -/
theorem linearIndependent_option' :
    LinearIndependent K (fun o => Option.casesOn' o x v : Option ι → V) ↔
      LinearIndependent K v ∧ x ∉ Submodule.span K (range v) :=
  by
  rw [← linearIndependent_equiv (Equiv.optionEquivSumPUnit ι).symm, linearIndependent_sum,
    @range_unique _ PUnit, @linearIndependent_unique_iff PUnit, disjoint_span_singleton]
  dsimp [(· ∘ ·)]
  refine' ⟨fun h => ⟨h.1, fun hx => h.2.1 <| h.2.2 hx⟩, fun h => ⟨h.1, _, fun hx => (h.2 hx).elim⟩⟩
  rintro rfl
  exact h.2 (zero_mem _)
#align linear_independent_option' linearIndependent_option'

/- warning: linear_independent.option -> LinearIndependent.option is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} {K : Type.{u3}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u3} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {v : ι -> V} {x : V}, (LinearIndependent.{u2, u3, u1} ι K V v (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) -> (Not (Membership.Mem.{u1, u1} V (Submodule.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) x (Submodule.span.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Set.range.{u1, succ u2} V ι v)))) -> (LinearIndependent.{u2, u3, u1} (Option.{u2} ι) K V (fun (o : Option.{u2} ι) => Option.casesOn'.{u2, u1} ι V o x v) (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)
but is expected to have type
  forall {ι : Type.{u2}} {K : Type.{u1}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {v : ι -> V} {x : V}, (LinearIndependent.{u2, u1, u3} ι K V v (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) -> (Not (Membership.mem.{u3, u3} V (Submodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4)) x (Submodule.span.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4 (Set.range.{u3, succ u2} V ι v)))) -> (LinearIndependent.{u2, u1, u3} (Option.{u2} ι) K V (fun (o : Option.{u2} ι) => Option.casesOn'.{u2, u3} ι V o x v) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4)
Case conversion may be inaccurate. Consider using '#align linear_independent.option LinearIndependent.optionₓ'. -/
theorem LinearIndependent.option (hv : LinearIndependent K v)
    (hx : x ∉ Submodule.span K (range v)) :
    LinearIndependent K (fun o => Option.casesOn' o x v : Option ι → V) :=
  linearIndependent_option'.2 ⟨hv, hx⟩
#align linear_independent.option LinearIndependent.option

/- warning: linear_independent_option -> linearIndependent_option is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} {K : Type.{u3}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u3} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {v : (Option.{u2} ι) -> V}, Iff (LinearIndependent.{u2, u3, u1} (Option.{u2} ι) K V v (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (And (LinearIndependent.{u2, u3, u1} ι K V (Function.comp.{succ u2, succ u2, succ u1} ι (Option.{u2} ι) V v ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) ι (Option.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} ι (Option.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} ι (Option.{u2} ι) (coeOption.{u2} ι))))) (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Not (Membership.Mem.{u1, u1} V (Submodule.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) (v (Option.none.{u2} ι)) (Submodule.span.{u3, u1} K V (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Set.range.{u1, succ u2} V ι (Function.comp.{succ u2, succ u2, succ u1} ι (Option.{u2} ι) V v ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) ι (Option.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} ι (Option.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} ι (Option.{u2} ι) (coeOption.{u2} ι))))))))))
but is expected to have type
  forall {ι : Type.{u2}} {K : Type.{u1}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {v : (Option.{u2} ι) -> V}, Iff (LinearIndependent.{u2, u1, u3} (Option.{u2} ι) K V v (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (And (LinearIndependent.{u2, u1, u3} ι K V (Function.comp.{succ u2, succ u2, succ u3} ι (Option.{u2} ι) V v (Option.some.{u2} ι)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (Not (Membership.mem.{u3, u3} V (Submodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4)) (v (Option.none.{u2} ι)) (Submodule.span.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4 (Set.range.{u3, succ u2} V ι (Function.comp.{succ u2, succ u2, succ u3} ι (Option.{u2} ι) V v (Option.some.{u2} ι)))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_option linearIndependent_optionₓ'. -/
theorem linearIndependent_option {v : Option ι → V} :
    LinearIndependent K v ↔
      LinearIndependent K (v ∘ coe : ι → V) ∧ v none ∉ Submodule.span K (range (v ∘ coe : ι → V)) :=
  by simp only [← linearIndependent_option', Option.casesOn'_none_coe]
#align linear_independent_option linearIndependent_option

/- warning: linear_independent_insert' -> linearIndependent_insert' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {ι : Type.{u3}} {s : Set.{u3} ι} {a : ι} {f : ι -> V}, (Not (Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) a s)) -> (Iff (LinearIndependent.{u3, u2, u1} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.hasInsert.{u3} ι) a s)) K V (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.hasInsert.{u3} ι) a s)) => f ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.hasInsert.{u3} ι) a s)) ι (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.hasInsert.{u3} ι) a s)) ι (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.hasInsert.{u3} ι) a s)) ι (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.hasInsert.{u3} ι) a s)) ι (coeSubtype.{succ u3} ι (fun (x : ι) => Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) x (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.hasInsert.{u3} ι) a s)))))) x)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (And (LinearIndependent.{u3, u2, u1} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) K V (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) => f ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} ι) Type.{u3} (Set.hasCoeToSort.{u3} ι) s) ι (coeSubtype.{succ u3} ι (fun (x : ι) => Membership.Mem.{u3, u3} ι (Set.{u3} ι) (Set.hasMem.{u3} ι) x s))))) x)) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Not (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) (f a) (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Set.image.{u3, u1} ι V f s))))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {ι : Type.{u2}} {s : Set.{u2} ι} {a : ι} {f : ι -> V}, (Not (Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) a s)) -> (Iff (LinearIndependent.{u2, u1, u3} (Set.Elem.{u2} ι (Insert.insert.{u2, u2} ι (Set.{u2} ι) (Set.instInsertSet.{u2} ι) a s)) K V (fun (x : Set.Elem.{u2} ι (Insert.insert.{u2, u2} ι (Set.{u2} ι) (Set.instInsertSet.{u2} ι) a s)) => f (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Insert.insert.{u2, u2} ι (Set.{u2} ι) (Set.instInsertSet.{u2} ι) a s)) x)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (And (LinearIndependent.{u2, u1, u3} (Set.Elem.{u2} ι s) K V (fun (x : Set.Elem.{u2} ι s) => f (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x s) x)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (Not (Membership.mem.{u3, u3} V (Submodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4)) (f a) (Submodule.span.{u1, u3} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_4 (Set.image.{u2, u3} ι V f s))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_insert' linearIndependent_insert'ₓ'. -/
theorem linearIndependent_insert' {ι} {s : Set ι} {a : ι} {f : ι → V} (has : a ∉ s) :
    (LinearIndependent K fun x : insert a s => f x) ↔
      (LinearIndependent K fun x : s => f x) ∧ f a ∉ Submodule.span K (f '' s) :=
  by
  rw [← linearIndependent_equiv ((Equiv.optionEquivSumPUnit _).trans (Equiv.Set.insert has).symm),
    linearIndependent_option]
  simp [(· ∘ ·), range_comp f]
#align linear_independent_insert' linearIndependent_insert'

/- warning: linear_independent_insert -> linearIndependent_insert is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {s : Set.{u1} V} {x : V}, (Not (Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x s)) -> (Iff (LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) K V (fun (b : coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)) V (coeSubtype.{succ u1} V (fun (x_1 : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x_1 (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x s)))))) b) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (And (LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) K V (fun (b : coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x s))))) b) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Not (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) x (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 s)))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} {x : V}, (Not (Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s)) -> (Iff (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} V (Insert.insert.{u2, u2} V (Set.{u2} V) (Set.instInsertSet.{u2} V) x s)) K V (fun (b : Set.Elem.{u2} V (Insert.insert.{u2, u2} V (Set.{u2} V) (Set.instInsertSet.{u2} V) x s)) => Subtype.val.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x_1 (Insert.insert.{u2, u2} V (Set.{u2} V) (Set.instInsertSet.{u2} V) x s)) b) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (And (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} V s) K V (fun (b : Set.Elem.{u2} V s) => Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s) b) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (Not (Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)) x (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 s)))))
Case conversion may be inaccurate. Consider using '#align linear_independent_insert linearIndependent_insertₓ'. -/
theorem linearIndependent_insert (hxs : x ∉ s) :
    (LinearIndependent K fun b : insert x s => (b : V)) ↔
      (LinearIndependent K fun b : s => (b : V)) ∧ x ∉ Submodule.span K s :=
  (@linearIndependent_insert' _ _ _ _ _ _ _ _ id hxs).trans <| by simp
#align linear_independent_insert linearIndependent_insert

/- warning: linear_independent_pair -> linearIndependent_pair is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {x : V} {y : V}, (Ne.{succ u1} V x (OfNat.ofNat.{u1} V 0 (OfNat.mk.{u1} V 0 (Zero.zero.{u1} V (AddZeroClass.toHasZero.{u1} V (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))))))))) -> (forall (a : K), Ne.{succ u1} V (SMul.smul.{u2, u1} K V (SMulZeroClass.toHasSmul.{u2, u1} K V (AddZeroClass.toHasZero.{u1} V (AddMonoid.toAddZeroClass.{u1} V (AddCommMonoid.toAddMonoid.{u1} V (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u2, u1} K V (MulZeroClass.toHasZero.{u2} K (MulZeroOneClass.toMulZeroClass.{u2} K (MonoidWithZero.toMulZeroOneClass.{u2} K (Semiring.toMonoidWithZero.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)))))) (AddZeroClass.toHasZero.{u1} V (AddMonoid.toAddZeroClass.{u1} V (AddCommMonoid.toAddMonoid.{u1} V (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u2, u1} K V (Semiring.toMonoidWithZero.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1))) (AddZeroClass.toHasZero.{u1} V (AddMonoid.toAddZeroClass.{u1} V (AddCommMonoid.toAddMonoid.{u1} V (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)))) (Module.toMulActionWithZero.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)))) a x) y) -> (LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x (Singleton.singleton.{u1, u1} V (Set.{u1} V) (Set.hasSingleton.{u1} V) y))) K V ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x (Singleton.singleton.{u1, u1} V (Set.{u1} V) (Set.hasSingleton.{u1} V) y))) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x (Singleton.singleton.{u1, u1} V (Set.{u1} V) (Set.hasSingleton.{u1} V) y))) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x (Singleton.singleton.{u1, u1} V (Set.{u1} V) (Set.hasSingleton.{u1} V) y))) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x (Singleton.singleton.{u1, u1} V (Set.{u1} V) (Set.hasSingleton.{u1} V) y))) V (coeSubtype.{succ u1} V (fun (x_1 : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x_1 (Insert.insert.{u1, u1} V (Set.{u1} V) (Set.hasInsert.{u1} V) x (Singleton.singleton.{u1, u1} V (Set.{u1} V) (Set.hasSingleton.{u1} V) y)))))))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {x : V} {y : V}, (Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) -> (forall (a : K), Ne.{succ u2} V (HSMul.hSMul.{u1, u2, u2} K V V (instHSMul.{u1, u2} K V (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4))))) a x) y) -> (LinearIndependent.{u2, u1, u2} (Subtype.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x_1 (Insert.insert.{u2, u2} V (Set.{u2} V) (Set.instInsertSet.{u2} V) x (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) y)))) K V (Subtype.val.{succ u2} V (fun (x_1 : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x_1 (Insert.insert.{u2, u2} V (Set.{u2} V) (Set.instInsertSet.{u2} V) x (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) y)))) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)
Case conversion may be inaccurate. Consider using '#align linear_independent_pair linearIndependent_pairₓ'. -/
theorem linearIndependent_pair {x y : V} (hx : x ≠ 0) (hy : ∀ a : K, a • x ≠ y) :
    LinearIndependent K (coe : ({x, y} : Set V) → V) :=
  pair_comm y x ▸ (linearIndependent_singleton hx).insert <|
    mt mem_span_singleton.1 (not_exists.2 hy)
#align linear_independent_pair linearIndependent_pair

/- warning: linear_independent_fin_cons -> linearIndependent_fin_cons is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {x : V} {n : Nat} {v : (Fin n) -> V}, Iff (LinearIndependent.{0, u2, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) K V (Fin.cons.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => V) x v) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (And (LinearIndependent.{0, u2, u1} (Fin n) K V v (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Not (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) x (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Set.range.{u1, 1} V (Fin n) v)))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {x : V} {n : Nat} {v : (Fin n) -> V}, Iff (LinearIndependent.{0, u1, u2} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) K V (Fin.cons.{u2} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => V) x v) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (And (LinearIndependent.{0, u1, u2} (Fin n) K V v (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (Not (Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)) x (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 (Set.range.{u2, 1} V (Fin n) v)))))
Case conversion may be inaccurate. Consider using '#align linear_independent_fin_cons linearIndependent_fin_consₓ'. -/
theorem linearIndependent_fin_cons {n} {v : Fin n → V} :
    LinearIndependent K (Fin.cons x v : Fin (n + 1) → V) ↔
      LinearIndependent K v ∧ x ∉ Submodule.span K (range v) :=
  by
  rw [← linearIndependent_equiv (finSuccEquiv n).symm, linearIndependent_option]
  convert Iff.rfl
  · ext
    -- TODO: why doesn't simp use `fin_succ_equiv_symm_coe` here?
    rw [comp_app, comp_app, finSuccEquiv_symm_some, Fin.cons_succ]
  · ext
    rw [comp_app, comp_app, finSuccEquiv_symm_some, Fin.cons_succ]
#align linear_independent_fin_cons linearIndependent_fin_cons

/- warning: linear_independent_fin_snoc -> linearIndependent_fin_snoc is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {x : V} {n : Nat} {v : (Fin n) -> V}, Iff (LinearIndependent.{0, u2, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) K V (Fin.snoc.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => V) v x) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (And (LinearIndependent.{0, u2, u1} (Fin n) K V v (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Not (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) x (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Set.range.{u1, 1} V (Fin n) v)))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {x : V} {n : Nat} {v : (Fin n) -> V}, Iff (LinearIndependent.{0, u1, u2} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) K V (Fin.snoc.{u2} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => V) v x) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (And (LinearIndependent.{0, u1, u2} (Fin n) K V v (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (Not (Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)) x (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 (Set.range.{u2, 1} V (Fin n) v)))))
Case conversion may be inaccurate. Consider using '#align linear_independent_fin_snoc linearIndependent_fin_snocₓ'. -/
theorem linearIndependent_fin_snoc {n} {v : Fin n → V} :
    LinearIndependent K (Fin.snoc v x : Fin (n + 1) → V) ↔
      LinearIndependent K v ∧ x ∉ Submodule.span K (range v) :=
  by rw [Fin.snoc_eq_cons_rotate, linearIndependent_equiv, linearIndependent_fin_cons]
#align linear_independent_fin_snoc linearIndependent_fin_snoc

/- warning: linear_independent.fin_cons -> LinearIndependent.fin_cons is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {x : V} {n : Nat} {v : (Fin n) -> V}, (LinearIndependent.{0, u2, u1} (Fin n) K V v (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) -> (Not (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) x (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Set.range.{u1, 1} V (Fin n) v)))) -> (LinearIndependent.{0, u2, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) K V (Fin.cons.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => V) x v) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {x : V} {n : Nat} {v : (Fin n) -> V}, (LinearIndependent.{0, u1, u2} (Fin n) K V v (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) -> (Not (Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)) x (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 (Set.range.{u2, 1} V (Fin n) v)))) -> (LinearIndependent.{0, u1, u2} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) K V (Fin.cons.{u2} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => V) x v) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)
Case conversion may be inaccurate. Consider using '#align linear_independent.fin_cons LinearIndependent.fin_consₓ'. -/
/-- See `linear_independent.fin_cons'` for an uglier version that works if you
only have a module over a semiring. -/
theorem LinearIndependent.fin_cons {n} {v : Fin n → V} (hv : LinearIndependent K v)
    (hx : x ∉ Submodule.span K (range v)) : LinearIndependent K (Fin.cons x v : Fin (n + 1) → V) :=
  linearIndependent_fin_cons.2 ⟨hv, hx⟩
#align linear_independent.fin_cons LinearIndependent.fin_cons

/- warning: linear_independent_fin_succ -> linearIndependent_fin_succ is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {n : Nat} {v : (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> V}, Iff (LinearIndependent.{0, u2, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) K V v (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (And (LinearIndependent.{0, u2, u1} (Fin n) K V (Fin.tail.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => V) v) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Not (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) (v (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Set.range.{u1, 1} V (Fin n) (Fin.tail.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => V) v))))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat} {v : (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> V}, Iff (LinearIndependent.{0, u1, u2} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) K V v (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (And (LinearIndependent.{0, u1, u2} (Fin n) K V (Fin.tail.{u2} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => V) v) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (Not (Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)) (v (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (NeZero.succ n)))) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 (Set.range.{u2, 1} V (Fin n) (Fin.tail.{u2} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => V) v))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_fin_succ linearIndependent_fin_succₓ'. -/
theorem linearIndependent_fin_succ {n} {v : Fin (n + 1) → V} :
    LinearIndependent K v ↔
      LinearIndependent K (Fin.tail v) ∧ v 0 ∉ Submodule.span K (range <| Fin.tail v) :=
  by rw [← linearIndependent_fin_cons, Fin.cons_self_tail]
#align linear_independent_fin_succ linearIndependent_fin_succ

/- warning: linear_independent_fin_succ' -> linearIndependent_fin_succ' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {n : Nat} {v : (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> V}, Iff (LinearIndependent.{0, u2, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) K V v (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (And (LinearIndependent.{0, u2, u1} (Fin n) K V (Fin.init.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => V) v) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Not (Membership.Mem.{u1, u1} V (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)) (v (Fin.last n)) (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (Set.range.{u1, 1} V (Fin n) (Fin.init.{u1} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => V) v))))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat} {v : (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> V}, Iff (LinearIndependent.{0, u1, u2} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) K V v (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (And (LinearIndependent.{0, u1, u2} (Fin n) K V (Fin.init.{u2} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => V) v) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (Not (Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)) (v (Fin.last n)) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 (Set.range.{u2, 1} V (Fin n) (Fin.init.{u2} n (fun (ᾰ : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => V) v))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_fin_succ' linearIndependent_fin_succ'ₓ'. -/
theorem linearIndependent_fin_succ' {n} {v : Fin (n + 1) → V} :
    LinearIndependent K v ↔
      LinearIndependent K (Fin.init v) ∧ v (Fin.last _) ∉ Submodule.span K (range <| Fin.init v) :=
  by rw [← linearIndependent_fin_snoc, Fin.snoc_init_self]
#align linear_independent_fin_succ' linearIndependent_fin_succ'

/- warning: linear_independent_fin2 -> linearIndependent_fin2 is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {f : (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> V}, Iff (LinearIndependent.{0, u2, u1} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) K V f (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (And (Ne.{succ u1} V (f (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring))))))) (OfNat.ofNat.{u1} V 0 (OfNat.mk.{u1} V 0 (Zero.zero.{u1} V (AddZeroClass.toHasZero.{u1} V (AddMonoid.toAddZeroClass.{u1} V (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))))))))) (forall (a : K), Ne.{succ u1} V (SMul.smul.{u2, u1} K V (SMulZeroClass.toHasSmul.{u2, u1} K V (AddZeroClass.toHasZero.{u1} V (AddMonoid.toAddZeroClass.{u1} V (AddCommMonoid.toAddMonoid.{u1} V (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u2, u1} K V (MulZeroClass.toHasZero.{u2} K (MulZeroOneClass.toMulZeroClass.{u2} K (MonoidWithZero.toMulZeroOneClass.{u2} K (Semiring.toMonoidWithZero.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)))))) (AddZeroClass.toHasZero.{u1} V (AddMonoid.toAddZeroClass.{u1} V (AddCommMonoid.toAddMonoid.{u1} V (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u2, u1} K V (Semiring.toMonoidWithZero.{u2} K (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1))) (AddZeroClass.toHasZero.{u1} V (AddMonoid.toAddZeroClass.{u1} V (AddCommMonoid.toAddMonoid.{u1} V (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)))) (Module.toMulActionWithZero.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)))) a (f (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))))) (f (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {f : (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> V}, Iff (LinearIndependent.{0, u1, u2} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) K V f (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (And (Ne.{succ u2} V (f (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) (forall (a : K), Ne.{succ u2} V (HSMul.hSMul.{u1, u2, u2} K V V (instHSMul.{u1, u2} K V (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4))))) a (f (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))) (f (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))
Case conversion may be inaccurate. Consider using '#align linear_independent_fin2 linearIndependent_fin2ₓ'. -/
theorem linearIndependent_fin2 {f : Fin 2 → V} :
    LinearIndependent K f ↔ f 1 ≠ 0 ∧ ∀ a : K, a • f 1 ≠ f 0 := by
  rw [linearIndependent_fin_succ, linearIndependent_unique_iff, range_unique, mem_span_singleton,
    not_exists, show Fin.tail f default = f 1 by rw [← Fin.succ_zero_eq_one] <;> rfl]
#align linear_independent_fin2 linearIndependent_fin2

/- warning: exists_linear_independent_extension -> exists_linearIndependent_extension is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {s : Set.{u1} V} {t : Set.{u1} V}, (LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) K V ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x s)))))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) -> (HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) s t) -> (Exists.{succ u1} (Set.{u1} V) (fun (b : Set.{u1} V) => Exists.{0} (HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) b t) (fun (H : HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) b t) => And (HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) s b) (And (HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) t ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (HasLiftT.mk.{succ u1, succ u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (CoeTCₓ.coe.{succ u1, succ u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (SetLike.Set.hasCoeT.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)))) (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 b))) (LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) b) K V ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) b) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) b) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) b) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) b) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x b)))))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} {t : Set.{u2} V}, (LinearIndependent.{u2, u1, u2} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s)) K V (Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) -> (HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s t) -> (Exists.{succ u2} (Set.{u2} V) (fun (b : Set.{u2} V) => Exists.{0} (HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) b t) (fun (H : HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) b t) => And (HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s b) (And (HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) t (SetLike.coe.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 b))) (LinearIndependent.{u2, u1, u2} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x b)) K V (Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x b)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)))))
Case conversion may be inaccurate. Consider using '#align exists_linear_independent_extension exists_linearIndependent_extensionₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b «expr ⊆ » t) -/
theorem exists_linearIndependent_extension (hs : LinearIndependent K (coe : s → V)) (hst : s ⊆ t) :
    ∃ (b : _)(_ : b ⊆ t), s ⊆ b ∧ t ⊆ span K b ∧ LinearIndependent K (coe : b → V) :=
  by
  rcases zorn_subset_nonempty { b | b ⊆ t ∧ LinearIndependent K (coe : b → V) } _ _ ⟨hst, hs⟩ with
    ⟨b, ⟨bt, bi⟩, sb, h⟩
  · refine' ⟨b, bt, sb, fun x xt => _, bi⟩
    by_contra hn
    apply hn
    rw [← h _ ⟨insert_subset.2 ⟨xt, bt⟩, bi.insert hn⟩ (subset_insert _ _)]
    exact subset_span (mem_insert _ _)
  · refine' fun c hc cc c0 => ⟨⋃₀ c, ⟨_, _⟩, fun x => _⟩
    · exact sUnion_subset fun x xc => (hc xc).1
    · exact linearIndependent_unionₛ_of_directed cc.directed_on fun x xc => (hc xc).2
    · exact subset_sUnion_of_mem
#align exists_linear_independent_extension exists_linearIndependent_extension

variable (K t)

/- warning: exists_linear_independent -> exists_linearIndependent is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u2}) {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] (t : Set.{u1} V), Exists.{succ u1} (Set.{u1} V) (fun (b : Set.{u1} V) => Exists.{0} (HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) b t) (fun (H : HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) b t) => And (Eq.{succ u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 b) (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 t)) (LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) b) K V ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) b) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) b) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) b) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) b) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x b)))))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)))
but is expected to have type
  forall (K : Type.{u1}) {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (t : Set.{u2} V), Exists.{succ u2} (Set.{u2} V) (fun (b : Set.{u2} V) => Exists.{0} (HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) b t) (fun (H : HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) b t) => And (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 b) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 t)) (LinearIndependent.{u2, u1, u2} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x b)) K V (Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x b)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4)))
Case conversion may be inaccurate. Consider using '#align exists_linear_independent exists_linearIndependentₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b «expr ⊆ » t) -/
theorem exists_linearIndependent :
    ∃ (b : _)(_ : b ⊆ t), span K b = span K t ∧ LinearIndependent K (coe : b → V) :=
  by
  obtain ⟨b, hb₁, -, hb₂, hb₃⟩ :=
    exists_linearIndependent_extension (linearIndependent_empty K V) (Set.empty_subset t)
  exact ⟨b, hb₁, (span_eq_of_le _ hb₂ (Submodule.span_mono hb₁)).symm, hb₃⟩
#align exists_linear_independent exists_linearIndependent

variable {K t}

#print LinearIndependent.extend /-
/-- `linear_independent.extend` adds vectors to a linear independent set `s ⊆ t` until it spans
all elements of `t`. -/
noncomputable def LinearIndependent.extend (hs : LinearIndependent K (fun x => x : s → V))
    (hst : s ⊆ t) : Set V :=
  Classical.choose (exists_linearIndependent_extension hs hst)
#align linear_independent.extend LinearIndependent.extend
-/

/- warning: linear_independent.extend_subset -> LinearIndependent.extend_subset is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {s : Set.{u1} V} {t : Set.{u1} V} (hs : LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) K V (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x s))))) x) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (hst : HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) s t), HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) (LinearIndependent.extend.{u1, u2} K V _inst_1 _inst_2 _inst_4 s t hs hst) t
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} {t : Set.{u2} V} (hs : LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} V s) K V (fun (x : Set.Elem.{u2} V s) => Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s) x) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (hst : HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s t), HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) (LinearIndependent.extend.{u2, u1} K V _inst_1 _inst_2 _inst_4 s t hs hst) t
Case conversion may be inaccurate. Consider using '#align linear_independent.extend_subset LinearIndependent.extend_subsetₓ'. -/
theorem LinearIndependent.extend_subset (hs : LinearIndependent K (fun x => x : s → V))
    (hst : s ⊆ t) : hs.extend hst ⊆ t :=
  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)
  hbt
#align linear_independent.extend_subset LinearIndependent.extend_subset

/- warning: linear_independent.subset_extend -> LinearIndependent.subset_extend is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {s : Set.{u1} V} {t : Set.{u1} V} (hs : LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) K V (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x s))))) x) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (hst : HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) s t), HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) s (LinearIndependent.extend.{u1, u2} K V _inst_1 _inst_2 _inst_4 s t hs hst)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} {t : Set.{u2} V} (hs : LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} V s) K V (fun (x : Set.Elem.{u2} V s) => Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s) x) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (hst : HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s t), HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s (LinearIndependent.extend.{u2, u1} K V _inst_1 _inst_2 _inst_4 s t hs hst)
Case conversion may be inaccurate. Consider using '#align linear_independent.subset_extend LinearIndependent.subset_extendₓ'. -/
theorem LinearIndependent.subset_extend (hs : LinearIndependent K (fun x => x : s → V))
    (hst : s ⊆ t) : s ⊆ hs.extend hst :=
  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)
  hsb
#align linear_independent.subset_extend LinearIndependent.subset_extend

/- warning: linear_independent.subset_span_extend -> LinearIndependent.subset_span_extend is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {s : Set.{u1} V} {t : Set.{u1} V} (hs : LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) K V (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x s))))) x) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (hst : HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) s t), HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) t ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (HasLiftT.mk.{succ u1, succ u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (CoeTCₓ.coe.{succ u1, succ u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (SetLike.Set.hasCoeT.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)))) (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 (LinearIndependent.extend.{u1, u2} K V _inst_1 _inst_2 _inst_4 s t hs hst)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} {t : Set.{u2} V} (hs : LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} V s) K V (fun (x : Set.Elem.{u2} V s) => Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s) x) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (hst : HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s t), HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) t (SetLike.coe.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 (LinearIndependent.extend.{u2, u1} K V _inst_1 _inst_2 _inst_4 s t hs hst)))
Case conversion may be inaccurate. Consider using '#align linear_independent.subset_span_extend LinearIndependent.subset_span_extendₓ'. -/
theorem LinearIndependent.subset_span_extend (hs : LinearIndependent K (fun x => x : s → V))
    (hst : s ⊆ t) : t ⊆ span K (hs.extend hst) :=
  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)
  htb
#align linear_independent.subset_span_extend LinearIndependent.subset_span_extend

/- warning: linear_independent.linear_independent_extend -> LinearIndependent.linearIndependent_extend is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {s : Set.{u1} V} {t : Set.{u1} V} (hs : LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) K V (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x s))))) x) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (hst : HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) s t), LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (LinearIndependent.extend.{u1, u2} K V _inst_1 _inst_2 _inst_4 s t hs hst)) K V ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (LinearIndependent.extend.{u1, u2} K V _inst_1 _inst_2 _inst_4 s t hs hst)) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (LinearIndependent.extend.{u1, u2} K V _inst_1 _inst_2 _inst_4 s t hs hst)) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (LinearIndependent.extend.{u1, u2} K V _inst_1 _inst_2 _inst_4 s t hs hst)) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) (LinearIndependent.extend.{u1, u2} K V _inst_1 _inst_2 _inst_4 s t hs hst)) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x (LinearIndependent.extend.{u1, u2} K V _inst_1 _inst_2 _inst_4 s t hs hst))))))) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} {t : Set.{u2} V} (hs : LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} V s) K V (fun (x : Set.Elem.{u2} V s) => Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s) x) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (hst : HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s t), LinearIndependent.{u2, u1, u2} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x (LinearIndependent.extend.{u2, u1} K V _inst_1 _inst_2 _inst_4 s t hs hst))) K V (Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x (LinearIndependent.extend.{u2, u1} K V _inst_1 _inst_2 _inst_4 s t hs hst))) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4
Case conversion may be inaccurate. Consider using '#align linear_independent.linear_independent_extend LinearIndependent.linearIndependent_extendₓ'. -/
theorem LinearIndependent.linearIndependent_extend (hs : LinearIndependent K (fun x => x : s → V))
    (hst : s ⊆ t) : LinearIndependent K (coe : hs.extend hst → V) :=
  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)
  hli
#align linear_independent.linear_independent_extend LinearIndependent.linearIndependent_extend

variable {K V}

/- warning: exists_of_linear_independent_of_finite_span -> exists_of_linearIndependent_of_finite_span is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {s : Set.{u1} V} {t : Finset.{u1} V}, (LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) K V (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x s))))) x) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) -> (HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (HasLiftT.mk.{succ u1, succ u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (CoeTCₓ.coe.{succ u1, succ u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (SetLike.Set.hasCoeT.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)))) (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} V) (Set.{u1} V) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} V) (Set.{u1} V) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} V) (Set.{u1} V) (Finset.Set.hasCoeT.{u1} V))) t)))) -> (Exists.{succ u1} (Finset.{u1} V) (fun (t' : Finset.{u1} V) => And (HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} V) (Set.{u1} V) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} V) (Set.{u1} V) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} V) (Set.{u1} V) (Finset.Set.hasCoeT.{u1} V))) t') (Union.union.{u1} (Set.{u1} V) (Set.hasUnion.{u1} V) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} V) (Set.{u1} V) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} V) (Set.{u1} V) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} V) (Set.{u1} V) (Finset.Set.hasCoeT.{u1} V))) t))) (And (HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} V) (Set.{u1} V) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} V) (Set.{u1} V) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} V) (Set.{u1} V) (Finset.Set.hasCoeT.{u1} V))) t')) (Eq.{1} Nat (Finset.card.{u1} V t') (Finset.card.{u1} V t)))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} {t : Finset.{u2} V}, (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} V s) K V (fun (x : Set.Elem.{u2} V s) => Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s) x) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) -> (HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 (Finset.toSet.{u2} V t)))) -> (Exists.{succ u2} (Finset.{u2} V) (fun (t' : Finset.{u2} V) => And (HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) (Finset.toSet.{u2} V t') (Union.union.{u2} (Set.{u2} V) (Set.instUnionSet.{u2} V) s (Finset.toSet.{u2} V t))) (And (HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s (Finset.toSet.{u2} V t')) (Eq.{1} Nat (Finset.card.{u2} V t') (Finset.card.{u2} V t)))))
Case conversion may be inaccurate. Consider using '#align exists_of_linear_independent_of_finite_span exists_of_linearIndependent_of_finite_spanₓ'. -/
-- TODO(Mario): rewrite?
theorem exists_of_linearIndependent_of_finite_span {t : Finset V}
    (hs : LinearIndependent K (fun x => x : s → V)) (hst : s ⊆ (span K ↑t : Submodule K V)) :
    ∃ t' : Finset V, ↑t' ⊆ s ∪ ↑t ∧ s ⊆ ↑t' ∧ t'.card = t.card :=
  by
  have :
    ∀ t,
      ∀ s' : Finset V,
        ↑s' ⊆ s →
          s ∩ ↑t = ∅ →
            s ⊆ (span K ↑(s' ∪ t) : Submodule K V) →
              ∃ t' : Finset V, ↑t' ⊆ s ∪ ↑t ∧ s ⊆ ↑t' ∧ t'.card = (s' ∪ t).card :=
    fun t =>
    Finset.induction_on t
      (fun s' hs' _ hss' =>
        have : s = ↑s' := eq_of_linearIndependent_of_span_subtype hs hs' <| by simpa using hss'
        ⟨s', by simp [this]⟩)
      fun b₁ t hb₁t ih s' hs' hst hss' =>
      have hb₁s : b₁ ∉ s := fun h =>
        by
        have : b₁ ∈ s ∩ ↑(insert b₁ t) := ⟨h, Finset.mem_insert_self _ _⟩
        rwa [hst] at this
      have hb₁s' : b₁ ∉ s' := fun h => hb₁s <| hs' h
      have hst : s ∩ ↑t = ∅ :=
        eq_empty_of_subset_empty <|
          Subset.trans (by simp [inter_subset_inter, subset.refl]) (le_of_eq hst)
      by_cases
        (fun this : s ⊆ (span K ↑(s' ∪ t) : Submodule K V) =>
          let ⟨u, hust, hsu, Eq⟩ := ih _ hs' hst this
          have hb₁u : b₁ ∉ u := fun h => (hust h).elim hb₁s hb₁t
          ⟨insert b₁ u, by simp [insert_subset_insert hust], Subset.trans hsu (by simp), by
            simp [Eq, hb₁t, hb₁s', hb₁u]⟩)
        fun this : ¬s ⊆ (span K ↑(s' ∪ t) : Submodule K V) =>
        let ⟨b₂, hb₂s, hb₂t⟩ := not_subset.mp this
        have hb₂t' : b₂ ∉ s' ∪ t := fun h => hb₂t <| subset_span h
        have : s ⊆ (span K ↑(insert b₂ s' ∪ t) : Submodule K V) := fun b₃ hb₃ =>
          by
          have : ↑(s' ∪ insert b₁ t) ⊆ insert b₁ (insert b₂ ↑(s' ∪ t) : Set V) := by
            simp [insert_eq, -singleton_union, -union_singleton, union_subset_union, subset.refl,
              subset_union_right]
          have hb₃ : b₃ ∈ span K (insert b₁ (insert b₂ ↑(s' ∪ t) : Set V)) :=
            span_mono this (hss' hb₃)
          have : s ⊆ (span K (insert b₁ ↑(s' ∪ t)) : Submodule K V) := by
            simpa [insert_eq, -singleton_union, -union_singleton] using hss'
          have hb₁ : b₁ ∈ span K (insert b₂ ↑(s' ∪ t)) := mem_span_insert_exchange (this hb₂s) hb₂t
          rw [span_insert_eq_span hb₁] at hb₃ <;> simpa using hb₃
        let ⟨u, hust, hsu, Eq⟩ := ih _ (by simp [insert_subset, hb₂s, hs']) hst this
        ⟨u, Subset.trans hust <| union_subset_union (Subset.refl _) (by simp [subset_insert]), hsu,
          by simp [Eq, hb₂t', hb₁t, hb₁s']⟩
  have eq : ((t.filter fun x => x ∈ s) ∪ t.filter fun x => x ∉ s) = t :=
    by
    ext1 x
    by_cases x ∈ s <;> simp [*]
  apply
    Exists.elim
      (this (t.filter fun x => x ∉ s) (t.filter fun x => x ∈ s) (by simp [Set.subset_def])
        (by simp (config := { contextual := true }) [Set.ext_iff]) (by rwa [Eq]))
  intro u h
  exact
    ⟨u, subset.trans h.1 (by simp (config := { contextual := true }) [subset_def, and_imp, or_imp]),
      h.2.1, by simp only [h.2.2, Eq]⟩
#align exists_of_linear_independent_of_finite_span exists_of_linearIndependent_of_finite_span

/- warning: exists_finite_card_le_of_finite_of_linear_independent_of_span -> exists_finite_card_le_of_finite_of_linearIndependent_of_span is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {s : Set.{u1} V} {t : Set.{u1} V} (ht : Set.Finite.{u1} V t), (LinearIndependent.{u1, u2, u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) K V (fun (x : coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) => (fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} V) Type.{u1} (Set.hasCoeToSort.{u1} V) s) V (coeSubtype.{succ u1} V (fun (x : V) => Membership.Mem.{u1, u1} V (Set.{u1} V) (Set.hasMem.{u1} V) x s))))) x) (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) -> (HasSubset.Subset.{u1} (Set.{u1} V) (Set.hasSubset.{u1} V) s ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (HasLiftT.mk.{succ u1, succ u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (CoeTCₓ.coe.{succ u1, succ u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) (Set.{u1} V) (SetLike.Set.hasCoeT.{u1, u1} (Submodule.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4) V (Submodule.setLike.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4)))) (Submodule.span.{u2, u1} K V (Ring.toSemiring.{u2} K (DivisionRing.toRing.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_4 t))) -> (Exists.{0} (Set.Finite.{u1} V s) (fun (h : Set.Finite.{u1} V s) => LE.le.{0} Nat Nat.hasLe (Finset.card.{u1} V (Set.Finite.toFinset.{u1} V s h)) (Finset.card.{u1} V (Set.Finite.toFinset.{u1} V t ht))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} {t : Set.{u2} V} (ht : Set.Finite.{u2} V t), (LinearIndependent.{u2, u1, u2} (Set.Elem.{u2} V s) K V (fun (x : Set.Elem.{u2} V s) => Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x s) x) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) -> (HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) V (Submodule.instSetLikeSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_4 t))) -> (Exists.{0} (Set.Finite.{u2} V s) (fun (h : Set.Finite.{u2} V s) => LE.le.{0} Nat instLENat (Finset.card.{u2} V (Set.Finite.toFinset.{u2} V s h)) (Finset.card.{u2} V (Set.Finite.toFinset.{u2} V t ht))))
Case conversion may be inaccurate. Consider using '#align exists_finite_card_le_of_finite_of_linear_independent_of_span exists_finite_card_le_of_finite_of_linearIndependent_of_spanₓ'. -/
theorem exists_finite_card_le_of_finite_of_linearIndependent_of_span (ht : t.Finite)
    (hs : LinearIndependent K (fun x => x : s → V)) (hst : s ⊆ span K t) :
    ∃ h : s.Finite, h.toFinset.card ≤ ht.toFinset.card :=
  have : s ⊆ (span K ↑ht.toFinset : Submodule K V) := by simp <;> assumption
  let ⟨u, hust, hsu, Eq⟩ := exists_of_linearIndependent_of_finite_span hs this
  have : s.Finite := u.finite_toSet.Subset hsu
  ⟨this, by rw [← Eq] <;> exact Finset.card_le_of_subset <| finset.coe_subset.mp <| by simp [hsu]⟩
#align exists_finite_card_le_of_finite_of_linear_independent_of_span exists_finite_card_le_of_finite_of_linearIndependent_of_span

end Module

